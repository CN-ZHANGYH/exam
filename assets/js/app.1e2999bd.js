(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,s,o=e[0],l=e[1],c=e[2],u=0,p=[];u<o.length;u++)s=o[u],Object.prototype.hasOwnProperty.call(r,s)&&r[s]&&p.push(r[s][0]),r[s]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(d&&d(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,o=1;o<t.length;o++){var l=t[o];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=s(s.s=t[0]))}return n}var a={},r={1:0},i=[];function s(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,o=document.createElement("script");o.charset="utf-8",o.timeout=120,s.nc&&o.setAttribute("nonce",s.nc),o.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"d32ca216",3:"d4e4ad20",4:"e0a9a322",5:"8fbef9e7",6:"a2544676",7:"a3bbed7a",8:"813850a9",9:"f7c583ac",10:"5265ff2b",11:"c4c5207e",12:"31cb3d76",13:"a47857df",14:"72c28a89",15:"ad243f17",16:"97612ac7",17:"3bbe13d7",18:"d9d73fe7",19:"34a4f0df",20:"c88c1497",21:"e8d03c9a",22:"184ebafa",23:"12e5d7bb",24:"75c21041",25:"b16f0127",26:"6eb9f6b7",27:"67156c7f",28:"283d5b83",29:"6c223534",30:"3ab6b5f1",31:"f6351d7c",32:"c00850fd",33:"8b737bc5",34:"7be2aaf1",35:"5a82d7a0",36:"4c249e67",37:"c174f7fd",38:"646d4869",39:"8dd73816",40:"31d7e137",41:"4ad90edf",42:"2add84ff",43:"1dbdb1b5",44:"24c08607",45:"5c60b648",46:"b064deb5",47:"2d070dc3",48:"dc471c3e",49:"b4b24af2",50:"3fb90a34",51:"f2bdb144",52:"dd18e9d0",53:"f4632fce",54:"5017f6c8",55:"ba8e398b",56:"a325fb91",57:"b5197f62",58:"84caf0c9",59:"74de2f49",60:"ffc6d104"}[n]+".js"}(n);var l=new Error;i=function(e){o.onerror=o.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:o})}),12e4);o.onerror=o.onload=i,document.head.appendChild(o)}return Promise.all(e)},s.m=n,s.c=a,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)s.d(t,a,function(e){return n[e]}.bind(null,a));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/exam/",s.oe=function(n){throw console.error(n),n};var o=window.webpackJsonp=window.webpackJsonp||[],l=o.push.bind(o);o.push=e,o=o.slice();for(var c=0;c<o.length;c++)e(o[c]);var d=l;i.push([95,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(25),r=Function.prototype,i=r.bind,s=r.call,o=a&&i.bind(s,s);n.exports=a?function(n){return n&&o(n)}:function(n){return n&&function(){return s.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(67),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,s,o){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):r&&(l=o?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(2),r=t(58),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(0),r="object"==typeof document&&document.all,i=void 0===r&&void 0!==r;n.exports=i?function(n){return"object"==typeof n?null!==n:a(n)||n===r}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(156),r=t(159);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return _}));const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,s=/^[a-z]+:/i;function o(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=o(n);return i.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return o(n.path)===o(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=o(e);for(let e=0;e<n.length;e++)if(o(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:r,themeConfig:i}=t,s=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||s.sidebar||i.sidebar))return f(n);const o=s.sidebar||i.sidebar;if(o){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,o);return"auto"===a?f(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function _(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(14),r=t(141),i=t(142),s=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(5).Symbol;n.exports=a},function(n,e,t){var a=t(1),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(7),r=t(17),i=t(26);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(7),r=t(60),i=t(104),s=t(32),o=t(49),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(s(n),e=o(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=o(e),s(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(146),r=t(147),i=t(148),s=t(149),o=t(150);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(69);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(168);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(40);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),d=a.speed,u=a.easing;return l.offsetWidth,s((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),o(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,u)),1===n?(o(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){o(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,s=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),d=document.querySelector(a.parent);return o(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),o=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=u(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(25),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(46),r=t(47);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(2),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(1),r=t(56),i=t(8),s=t(59),o=t(53),l=t(52),c=r("wks"),d=a.Symbol,u=d&&d.for,p=l?d:d&&d.withoutSetter||s;n.exports=function(n){if(!i(c,n)||!o&&"string"!=typeof c[n]){var e="Symbol."+n;o&&i(d,n)?c[n]=d[n]:c[n]=l&&u?u(e):p(e)}return c[n]}},function(n,e,t){var a=t(1),r=t(31),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(140),r=t(12),i=Object.prototype,s=i.hasOwnProperty,o=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&s.call(n,"callee")&&!o.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(5),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(160),r=t(167),i=t(169),s=t(170),o=t(171);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(4),r=t(40),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(s.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,s=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=o||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var o=r.test(n);return o||i.test(n)?s(n.slice(2),o?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,s,o,l,c=0,d=!1,g=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=a,i=r;return a=r=void 0,c=e,s=n.apply(i,t)}function y(n){return c=n,o=setTimeout(x,e),d?v(n):s}function _(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=i}function x(){var n=m();if(_(n))return w(n);o=setTimeout(x,function(n){var t=e-(n-l);return g?p(t,i-(n-c)):t}(n))}function w(n){return o=void 0,b&&a?v(n):(a=r=void 0,s)}function E(){var n=m(),t=_(n);if(a=arguments,r=this,l=n,t){if(void 0===o)return y(l);if(g)return o=setTimeout(x,e),v(l)}return void 0===o&&(o=setTimeout(x,e)),s}return e=f(e)||0,h(t)&&(d=!!t.leading,i=(g="maxWait"in t)?u(f(t.maxWait)||0,e):i,b="trailing"in t?!!t.trailing:b),E.cancel=function(){void 0!==o&&clearTimeout(o),c=0,a=l=r=o=void 0},E.flush=function(){return void 0===o?s:w(m())},E}},function(n,e,t){var a=t(1),r=t(45).f,i=t(16),s=t(105),o=t(31),l=t(62),c=t(121);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?a:g?a[h]||o(h,{}):(a[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=r(t,d))&&m.value:t[d],!c(f?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&i(p,"sham",!0),s(t,d,p,n)}}},function(n,e,t){var a=t(7),r=t(24),i=t(97),s=t(26),o=t(27),l=t(49),c=t(8),d=t(60),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=o(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return s(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(2),r=t(3),i=t(28),s=Object,o=a("".split);n.exports=r((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?o(n,""):s(n)}:s},function(n,e,t){var a=t(48),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(98),r=t(50);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){var a=t(15),r=t(0),i=t(51),s=t(52),o=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,o(n))}},function(n,e,t){var a=t(2);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(53);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(54),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(1),s=t(99),o=i.process,l=i.Deno,c=o&&o.versions||l&&l.version,d=c&&c.v8;d&&(r=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&s&&(!(a=s.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=s.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(0),r=t(101),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e,t){var a=t(57),r=t(30);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.25.0",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.25.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(47),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(2),r=0,i=Math.random(),s=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++r+i,36)}},function(n,e,t){var a=t(7),r=t(3),i=t(103);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e){n.exports={}},function(n,e,t){var a=t(8),r=t(112),i=t(45),s=t(17);n.exports=function(n,e,t){for(var o=r(e),l=s.f,c=i.f,d=0;d<o.length;d++){var u=o[d];a(n,u)||t&&a(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var a=t(117);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(118);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(2),r=t(32),i=t(128);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(18),r=t(151),i=t(152),s=t(153),o=t(154),l=t(155);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=s,c.prototype.has=o,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),r=t(35);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(172),r=t(12);n.exports=function n(e,t,i,s,o){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,s,n,o))}},function(n,e,t){var a=t(74),r=t(175),i=t(75);n.exports=function(n,e,t,s,o,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var b=n[h],v=e[h];if(s)var y=c?s(v,b,h,e,n,l):s(b,v,h,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!i(g,e)&&(b===n||o(b,n,t,s,l)))return g.push(e)}))){f=!1;break}}else if(b!==v&&!o(b,v,t,s,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var a=t(36),r=t(173),i=t(174);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=r,s.prototype.has=i,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(185),r=t(191),i=t(80);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(5),r=t(187),i=e&&!e.nodeType&&e,s=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===i?a.Buffer:void 0,l=(o?o.isBuffer:void 0)||r;n.exports=l}).call(this,t(42)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(188),r=t(189),i=t(190),s=i&&i.isTypedArray,o=s?r(s):a;n.exports=o},function(n,e,t){var a=t(70),r=t(38);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(5),"Set");n.exports=a},function(n,e,t){var a=t(35);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(85),r=t(22);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(4),r=t(39),i=t(202),s=t(205);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(138),r=t(143),i=t(214),s=t(222),o=t(231),l=t(94),c=i((function(n){var e=l(n);return o(e)&&(e=void 0),s(a(n,1,o,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",s=0,o=0;for(s=r.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}o!==s&&(i+=t.substring(o,s)),o=s+1,i+=e}return o!==s?i+t.substring(o,s):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(234),t(6)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(235),t(6)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(240)},function(n,e,t){"use strict";var a=t(44),r=t(122).left,i=t(123),s=t(54),o=t(124);a({target:"Array",proto:!0,forced:!i("reduce")||!o&&s>79&&s<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(24),r=t(9),i=t(50),s=t(100),o=t(102),l=t(29),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=s(n,d);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),o(n,e)}},function(n,e,t){var a=t(15);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(55),r=t(48);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(24),r=t(0),i=t(9),s=TypeError;n.exports=function(n,e){var t,o;if("string"===e&&r(t=n.toString)&&!i(o=a(t,n)))return o;if(r(t=n.valueOf)&&!i(o=a(t,n)))return o;if("string"!==e&&r(t=n.toString)&&!i(o=a(t,n)))return o;throw s("Can't convert object to primitive value")}},function(n,e,t){var a=t(1),r=t(9),i=a.document,s=r(i)&&r(i.createElement);n.exports=function(n){return s?i.createElement(n):{}}},function(n,e,t){var a=t(7),r=t(3);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(0),r=t(17),i=t(106),s=t(31);n.exports=function(n,e,t,o){o||(o={});var l=o.enumerable,c=void 0!==o.name?o.name:e;if(a(t)&&i(t,c,o),o.global)l?n[e]=t:s(e,t);else{try{o.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return n}},function(n,e,t){var a=t(3),r=t(0),i=t(8),s=t(7),o=t(107).CONFIGURABLE,l=t(108),c=t(109),d=c.enforce,u=c.get,p=Object.defineProperty,m=s&&!a((function(){return 8!==p((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||o&&n.name!==e)&&(s?p(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&i(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&p(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return i(a,"source")||(a.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return r(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var a=t(7),r=t(8),i=Function.prototype,s=a&&Object.getOwnPropertyDescriptor,o=r(i,"name"),l=o&&"something"===function(){}.name,c=o&&(!a||a&&s(i,"name").configurable);n.exports={EXISTS:o,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(2),r=t(0),i=t(30),s=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return s(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,s=t(110),o=t(1),l=t(2),c=t(9),d=t(16),u=t(8),p=t(30),m=t(111),h=t(61),f=o.TypeError,g=o.WeakMap;if(s||p.state){var b=p.state||(p.state=new g),v=l(b.get),y=l(b.has),_=l(b.set);a=function(n,e){if(y(b,n))throw f("Object already initialized");return e.facade=n,_(b,n,e),e},r=function(n){return v(b,n)||{}},i=function(n){return y(b,n)}}else{var x=m("state");h[x]=!0,a=function(n,e){if(u(n,x))throw f("Object already initialized");return e.facade=n,d(n,x,e),e},r=function(n){return u(n,x)?n[x]:{}},i=function(n){return u(n,x)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(1),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(56),r=t(59),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(15),r=t(2),i=t(113),s=t(120),o=t(32),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(o(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(114),r=t(119).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(2),r=t(8),i=t(27),s=t(115).indexOf,o=t(61),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,d=[];for(t in a)!r(o,t)&&r(a,t)&&l(d,t);for(;e.length>c;)r(a,t=e[c++])&&(~s(d,t)||l(d,t));return d}},function(n,e,t){var a=t(27),r=t(116),i=t(64),s=function(n){return function(e,t,s){var o,l=a(e),c=i(l),d=r(s,c);if(n&&t!=t){for(;c>d;)if((o=l[d++])!=o)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var a=t(63),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(63),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(3),r=t(0),i=/#|\.prototype\./,s=function(n,e){var t=l[o(n)];return t==d||t!=c&&(r(e)?a(e):!!e)},o=s.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",d=s.POLYFILL="P";n.exports=s},function(n,e,t){var a=t(55),r=t(58),i=t(46),s=t(64),o=TypeError,l=function(n){return function(e,t,l,c){a(t);var d=r(e),u=i(d),p=s(d),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw o("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(28),r=t(1);n.exports="process"==a(r.process)},function(n,e,t){var a=t(44),r=t(1),i=t(126),s=t(127),o=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(o&&o[n]){var t={};t[n]=s("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(25),r=Function.prototype,i=r.apply,s=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?s.bind(i):function(){return s.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(15),r=t(8),i=t(16),s=t(51),o=t(65),l=t(62),c=t(129),d=t(130),u=t(131),p=t(135),m=t(136),h=t(137),f=t(7),g=t(57);n.exports=function(n,e,t,b){var v=b?2:1,y=n.split("."),_=y[y.length-1],x=a.apply(null,y);if(x){var w=x.prototype;if(!g&&r(w,"cause")&&delete w.cause,!t)return x;var E=a("Error"),k=e((function(n,e){var t=u(b?e:n,void 0),a=b?new x(n):new x;return void 0!==t&&i(a,"message",t),h&&i(a,"stack",m(a.stack,2)),this&&s(w,this)&&d(a,this,k),arguments.length>v&&p(a,arguments[v]),a}));if(k.prototype=w,"Error"!==_?o?o(k,E):l(k,E,{name:!0}):f&&"stackTraceLimit"in x&&(c(k,x,"stackTraceLimit"),c(k,x,"prepareStackTrace")),l(k,x),!g)try{w.name!==_&&i(w,"name",_),w.constructor=k}catch(n){}return k}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(65);n.exports=function(n,e,t){var s,o;return i&&a(s=e.constructor)&&s!==t&&r(o=s.prototype)&&o!==t.prototype&&i(n,o),n}},function(n,e,t){var a=t(132);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(133),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(134),r=t(0),i=t(28),s=t(29)("toStringTag"),o=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=o(n),s))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(29)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(16);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(2),r=Error,i=a("".replace),s=String(r("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,o,"");return n}},function(n,e,t){var a=t(3),r=t(26);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(66),r=t(139);n.exports=function n(e,t,i,s,o){var l=-1,c=e.length;for(i||(i=r),o||(o=[]);++l<c;){var d=e[l];t>0&&i(d)?t>1?n(d,t-1,i,s,o):a(o,d):s||(o[o.length]=d)}return o}},function(n,e,t){var a=t(14),r=t(33),i=t(4),s=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(s&&n&&n[s])}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(14),r=Object.prototype,i=r.hasOwnProperty,s=r.toString,o=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,o),t=n[o];try{n[o]=void 0;var a=!0}catch(n){}var r=s.call(n);return a&&(e?n[o]=t:delete n[o]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(144),r=t(200),i=t(41),s=t(4),o=t(211);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?s(n)?r(n[0],n[1]):a(n):o(n)}},function(n,e,t){var a=t(145),r=t(199),i=t(83);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(68),r=t(72);n.exports=function(n,e,t,i){var s=t.length,o=s,l=!i;if(null==n)return!o;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<o;){var d=(c=t[s])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new a;if(i)var h=i(u,p,d,n,e,m);if(!(void 0===h?r(p,u,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(19),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(19);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(19);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(19);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(18);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(18),r=t(34),i=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var s=t.__data__;if(!r||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(70),r=t(157),i=t(35),s=t(71),o=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:o).test(s(n))}},function(n,e,t){var a,r=t(158),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(5)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(161),r=t(18),i=t(34);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(162),r=t(163),i=t(164),s=t(165),o=t(166);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(20);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(20),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(20),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(21);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(21);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(21);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(68),r=t(73),i=t(176),s=t(179),o=t(195),l=t(4),c=t(77),d=t(79),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),b=l(e),v=g?"[object Array]":o(n),y=b?"[object Array]":o(e),_=(v="[object Arguments]"==v?u:v)==u,x=(y="[object Arguments]"==y?u:y)==u,w=v==y;if(w&&c(n)){if(!c(e))return!1;g=!0,_=!1}if(w&&!_)return f||(f=new a),g||d(n)?r(n,e,t,m,h,f):i(n,e,v,t,m,h,f);if(!(1&t)){var E=_&&p.call(n,"__wrapped__"),k=x&&p.call(e,"__wrapped__");if(E||k){var S=E?n.value():n,T=k?e.value():e;return f||(f=new a),h(S,T,t,m,f)}}return!!w&&(f||(f=new a),s(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(14),r=t(177),i=t(69),s=t(73),o=t(178),l=t(37),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=o;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;a|=2,p.set(n,e);var g=s(m(n),m(e),a,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(5).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(180),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,s,o){var l=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:r.call(e,p)))return!1}var m=o.get(n),h=o.get(e);if(m&&h)return m==e&&h==n;var f=!0;o.set(n,e),o.set(e,n);for(var g=l;++u<d;){var b=n[p=c[u]],v=e[p];if(i)var y=l?i(v,b,p,e,n,o):i(b,v,p,n,e,o);if(!(void 0===y?b===v||s(b,v,t,i,o):y)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var _=n.constructor,x=e.constructor;_==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof _&&_ instanceof _&&"function"==typeof x&&x instanceof x||(f=!1)}return o.delete(n),o.delete(e),f}},function(n,e,t){var a=t(181),r=t(182),i=t(76);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(66),r=t(4);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(183),r=t(184),i=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,o=s?function(n){return null==n?[]:(n=Object(n),a(s(n),(function(e){return i.call(n,e)})))}:r;n.exports=o},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var s=n[t];e(s,t,n)&&(i[r++]=s)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(186),r=t(33),i=t(4),s=t(77),o=t(78),l=t(79),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&r(n),u=!t&&!d&&s(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?a(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||o(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),r=t(38),i=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!s[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(67),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===r&&a.process,o=function(){try{var n=i&&i.require&&i.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=o}).call(this,t(42)(n))},function(n,e,t){var a=t(192),r=t(193),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(194)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(196),r=t(34),i=t(197),s=t(81),o=t(198),l=t(13),c=t(71),d=c(a),u=c(r),p=c(i),m=c(s),h=c(o),f=l;(a&&"[object DataView]"!=f(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||i&&"[object Promise]"!=f(i.resolve())||s&&"[object Set]"!=f(new s)||o&&"[object WeakMap]"!=f(new o))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var a=t(10)(t(5),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(5),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(5),"WeakMap");n.exports=a},function(n,e,t){var a=t(82),r=t(76);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],s=n[i];e[t]=[i,s,a(s)]}return e}},function(n,e,t){var a=t(72),r=t(201),i=t(208),s=t(39),o=t(82),l=t(83),c=t(22);n.exports=function(n,e){return s(n)&&o(e)?l(c(n),e):function(t){var s=r(t,n);return void 0===s&&s===e?i(t,n):a(e,s,3)}}},function(n,e,t){var a=t(84);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(203),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,s=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var a=t(204);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(36);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var s=n.apply(this,a);return t.cache=i.set(r,s)||i,s};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(206);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(14),r=t(207),i=t(4),s=t(40),o=a?a.prototype:void 0,l=o?o.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(209),r=t(210);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(85),r=t(33),i=t(4),s=t(78),o=t(38),l=t(22);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&o(d)&&s(p,d)&&(i(n)||r(n))}},function(n,e,t){var a=t(212),r=t(213),i=t(39),s=t(22);n.exports=function(n){return i(n)?a(s(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(84);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(41),r=t(215),i=t(217);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(216),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,s=-1,o=r(i.length-e,0),l=Array(o);++s<o;)l[s]=i[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=i[s];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(218),r=t(221)(a);n.exports=r},function(n,e,t){var a=t(219),r=t(220),i=t(41),s=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(74),r=t(223),i=t(228),s=t(75),o=t(229),l=t(37);n.exports=function(n,e,t){var c=-1,d=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=i;else if(u>=200){var f=e?null:o(n);if(f)return l(f);p=!1,d=s,h=new a}else h=e?[]:m;n:for(;++c<u;){var g=n[c],b=e?e(g):g;if(g=t||0!==g?g:0,p&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(g)}else d(h,b,t)||(h!==m&&h.push(b),m.push(g))}return m}},function(n,e,t){var a=t(224);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(225),r=t(226),i=t(227);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(81),r=t(230),i=t(37),s=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(80),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t(87)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.10
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function _(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var k=/-(\w)/g,S=E((function(n){return n.replace(k,(function(n,e){return e?e.toUpperCase():""}))})),T=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,L=E((function(n){return n.replace(I,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function B(n,e){for(var t in e)n[t]=e[t];return n}function D(n){for(var e={},t=0;t<n.length;t++)n[t]&&B(e,n[t]);return e}function M(n,e,t){}var z=function(n,e,t){return!1},O=function(n){return n};function N(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return N(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var s=Object.keys(n),o=Object.keys(e);return s.length===o.length&&s.every((function(t){return N(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(N(n[t],e))return t;return-1}function j(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],R=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:z,isReservedAttr:z,isUnknownElement:z,getTagNamespace:M,parsePlatformTagName:O,mustUseProp:z,async:!0,_lifecycleHooks:R},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function Q(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function $(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(H.source,".$_\\d]"));var Y="__proto__"in{},G="undefined"!=typeof window,J=G&&window.navigator.userAgent.toLowerCase(),K=J&&/msie|trident/.test(J),W=J&&J.indexOf("msie 9.0")>0,X=J&&J.indexOf("edge/")>0;J&&J.indexOf("android");var Z=J&&/iphone|ipad|ipod|ios/.test(J);J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J);var nn,en=J&&J.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(G)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var sn=function(){return void 0===nn&&(nn=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},on=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,s,o){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=function(){function n(){this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){_(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,a=e.length;t<a;t++){e[t].update()}},n}();vn.target=null;var yn=[];function _n(n){yn.push(n),vn.target=n}function xn(){yn.pop(),vn.target=yn[yn.length-1]}var wn=Array.prototype,En=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];$(En,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&s.observeArray(r),s.dep.notify(),i}))}));var kn=Object.getOwnPropertyNames(En),Sn={},Tn=!0;function In(n){Tn=n}var Ln={notify:M,depend:M,addSub:M,removeSub:M},Cn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Ln:new vn,this.vmCount=0,$(n,"__ob__",this),r(n)){if(!t)if(Y)n.__proto__=En;else for(var a=0,i=kn.length;a<i;a++){$(n,o=kn[a],En[o])}e||this.observeArray(n)}else{var s=Object.keys(n);for(a=0;a<s.length;a++){var o;Bn(n,o=s[a],Sn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)An(n[e],!1,this.mock)},n}();function An(n,e,t){var a;if(!(!d(n)||jn(n)||n instanceof mn))return w(n,"__ob__")&&n.__ob__ instanceof Cn?a=n.__ob__:!Tn||!t&&sn()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||(a=new Cn(n,e,t)),a}function Bn(n,e,t,a,i,s){var o=new vn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==Sn&&2!==arguments.length||(t=n[e]);var u=!i&&An(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return vn.target&&(o.depend(),u&&(u.dep.depend(),r(e)&&zn(e))),jn(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(q(a,e)){if(d)d.call(n,e);else{if(c)return;if(!i&&jn(a)&&!jn(e))return void(a.value=e);t=e}u=!i&&An(e,!1,s),o.notify()}}}),o}}function Dn(n,e,t){if(!Pn(n)){var a=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&An(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Bn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Mn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Pn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function zn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&zn(e)}function On(n){return Nn(n,!0),$(n,"__v_isShallow",!0),n}function Nn(n,e){if(!Pn(n)){An(n,e,sn());0}}function Pn(n){return!(!n||!n.__v_isReadonly)}function jn(n){return!(!n||!0!==n.__v_isRef)}function qn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(jn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];jn(a)&&!jn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Rn=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Un&&(this.parent=Un,this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.active=!1}},n}();function Fn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Qn(n,e){function t(){var n=t.fns;if(!r(n))return Te(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Te(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function $n(n,e,t,a,r,s){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Hn(l),i(c)||(i(d)?(i(c.fns)&&(c=n[l]=Qn(c,s)),o(u.once)&&(c=n[l]=r(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)i(n[l])&&a((u=Hn(l)).name,e[l],u.capture)}function Vn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),_(a.fns,l)}i(r)?a=Qn([l]):s(r.fns)&&o(r.merged)?(a=r).fns.push(l):a=Qn([r,l]),a.merged=!0,n[e]=a}function Yn(n,e,t,a,r){if(s(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Gn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var a,c,d,u,p=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Jn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Jn(u)&&(p[d]=fn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Jn(u)?p[d]=fn(u.text+c):""!==c&&p.push(fn(c)):Jn(c)&&Jn(u)?p[d]=fn(u.text+c.text):(o(e._isVList)&&s(c.tag)&&i(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function Jn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Kn(n,e){var t,a,i,o,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)o=i[t],l[t]=e(n[o],o,t);return s(l)||(l=[]),l._isVList=!0,l}function Wn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=B(B({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},r):r}function Xn(n){return Ct(this.$options,"filters",n,!0)||O}function Zn(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,a,r){var i=F.keyCodes[e]||t;return r&&a&&!F.keyCodes[e]?Zn(r,a):i?Zn(i,n):a?L(a)!==e:void 0===n}function ee(n,e,t,a,i){if(t)if(d(t)){r(t)&&(t=D(t));var s=void 0,o=function(r){if("class"===r||"style"===r||y(r))s=n;else{var o=n.attrs&&n.attrs.type;s=a||F.mustUseProp(e,o,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(r),c=L(r);l in s||c in s||(s[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)o(l)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||re(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ae(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&ie(n[a],"".concat(e,"_").concat(a),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?B({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function oe(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var s=n[i];r(s)?oe(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ce(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ae,n._n=b,n._s=g,n._l=Kn,n._t=Wn,n._q=N,n._i=P,n._m=te,n._f=Xn,n._k=ne,n._b=ee,n._v=fn,n._e=hn,n._u=oe,n._g=se,n._d=le,n._p=ce}function ue(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],s=i.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,i.context!==e&&i.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(i);else{var o=s.slot,l=t[o]||(t[o]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(pe)&&delete t[c];return t}function pe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function he(n,e,t,r){var i,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&r&&r!==a&&l===r.$key&&!s&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=fe(n,t,c,e[c]))}else i={};for(var d in t)d in i||(i[d]=ge(t,d));return e&&Object.isExtensible(e)&&(e._normalized=i),$(i,"$stable",o),$(i,"$key",l),$(i,"$hasNormal",s),i}function fe(n,e,t,a){var i=function(){var e=un;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Gn(t))&&t[0];return pn(e),t&&(!i||1===t.length&&i.isComment&&!me(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ge(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};$(e,"_v_attr_proxy",!0),ve(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ve(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||_e(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return qn(n,e,t)}))}}}function ve(n,e,t,a,r){var i=!1;for(var s in e)s in n?e[s]!==t[s]&&(i=!0):(i=!0,ye(n,s,a,r));for(var s in n)s in e||(i=!0,delete n[s]);return i}function ye(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function _e(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var xe=null;function we(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Ee(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||me(t)))return t}}function ke(n,e,t,a,u,p){return(r(t)||l(t))&&(u=a,a=t,t=void 0),o(p)&&(u=2),function(n,e,t,a,l){if(s(t)&&s(t.__ob__))return hn();s(t)&&s(t.is)&&(e=t.is);if(!e)return hn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Gn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),u=F.isReservedTag(e)?new mn(F.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!s(m=Ct(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):yt(m,t,n,a,e)}else u=yt(e,t,n,a);return r(u)?u:s(u)?(s(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(s(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];s(c.tag)&&(i(c.ns)||o(a)&&"svg"!==c.tag)&&n(c,t,a)}}(u,p),s(t)&&function(n){d(n.style)&&Re(n.style);d(n.class)&&Re(n.class)}(t),u):hn()}(n,e,t,a,u)}function Se(n,e,t){_n();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Ie(n,a,"errorCaptured hook")}}Ie(n,e,t)}finally{xn()}}function Te(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(n){return Se(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Se(n,a,r)}return i}function Ie(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Le(e,null,"config.errorHandler")}Le(n,e,t)}function Le(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var Ce,Ae=!1,Be=[],De=!1;function Me(){De=!1;var n=Be.slice(0);Be.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ze=Promise.resolve();Ce=function(){ze.then(Me),Z&&setTimeout(M)},Ae=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ce="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Me)}:function(){setTimeout(Me,0)};else{var Oe=1,Ne=new MutationObserver(Me),Pe=document.createTextNode(String(Oe));Ne.observe(Pe,{characterData:!0}),Ce=function(){Oe=(Oe+1)%2,Pe.data=String(Oe)},Ae=!0}function je(n,e){var t;if(Be.push((function(){if(n)try{n.call(e)}catch(n){Se(n,e,"nextTick")}else t&&t(e)})),De||(De=!0,Ce()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function qe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=St(a[e],t)}(t,n,e)}}qe("beforeMount"),qe("mounted"),qe("beforeUpdate"),qe("updated"),qe("beforeDestroy"),qe("destroyed"),qe("activated"),qe("deactivated"),qe("serverPrefetch"),qe("renderTracked"),qe("renderTriggered"),qe("errorCaptured");var Ue=new cn;function Re(n){return function n(e,t){var a,i,s=r(e);if(!s&&!d(e)||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(a=e.length;a--;)n(e[a],t);else if(jn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var Fe,He=0,Qe=function(){function n(n,e,t,a,r){var i,s;i=this,void 0===(s=Un&&!Un._vm?Un:n?n._scope:void 0)&&(s=Un),s&&s.active&&s.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=M)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;_n(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Se(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Re(n),xn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ut(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Te(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&_(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function $e(n,e){Fe.$on(n,e)}function Ve(n,e){Fe.$off(n,e)}function Ye(n,e){var t=Fe;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Ge(n,e,t){Fe=n,$n(e,t||{},$e,Ve,Ye,n),Fe=void 0}var Je=null;function Ke(n){var e=Je;return Je=n,function(){Je=e}}function We(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Xe(n,e){if(e){if(n._directInactive=!1,We(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Xe(n.$children[t]);Ze(n,"activated")}}function Ze(n,e,t,a){void 0===a&&(a=!0),_n();var r=un;a&&pn(n);var i=n.$options[e],s="".concat(e," hook");if(i)for(var o=0,l=i.length;o<l;o++)Te(i[o],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),a&&pn(r),xn()}var nt=[],et=[],tt={},at=!1,rt=!1,it=0;var st=0,ot=Date.now;if(G&&!K){var lt=window.performance;lt&&"function"==typeof lt.now&&ot()>document.createEvent("Event").timeStamp&&(ot=function(){return lt.now()})}var ct=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(st=ot(),rt=!0,nt.sort(ct),it=0;it<nt.length;it++)(n=nt[it]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),a=nt.slice();it=nt.length=et.length=0,tt={},at=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Xe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&Ze(a,"updated")}}(a),on&&F.devtools&&on.emit("flush")}function ut(n){var e=n.id;if(null==tt[e]&&(n!==vn.target||!n.noRecurse)){if(tt[e]=!0,rt){for(var t=nt.length-1;t>it&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);at||(at=!0,je(dt))}}function pt(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var s=n[i].from;if(s in e._provided)t[i]=e._provided[s];else if("default"in n[i]){var o=n[i].default;t[i]=c(o)?o.call(e):o}else 0}}return t}}function mt(n,e,t,i,s){var l,c=this,d=s.options;w(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var u=o(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=pt(d.inject,i),this.slots=function(){return c.$slots||he(i,n.scopedSlots,c.$slots=ue(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return he(i,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=he(i,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var s=ke(l,n,e,t,a,p);return s&&!r(s)&&(s.fnScopeId=d._scopeId,s.fnContext=i),s}:this._c=function(n,e,t,a){return ke(l,n,e,t,a,p)}}function ht(n,e,t,a,r){var i=gn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[S(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}de(mt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;s(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Je)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var s=r.data.scopedSlots,o=n.$scopedSlots,l=!!(s&&!s.$stable||o!==a&&!o.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var u=r.data.attrs||a;n._attrsProxy&&ve(n._attrsProxy,u,d.data&&d.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ve(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ge(n,t,p),e&&n.$options.props){In(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],b=n.$options.props;m[g]=At(g,b,e,n)}In(!0),n.$options.propsData=e}c&&(n.$slots=ue(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,Ze(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,et.push(e)):Xe(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,We(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);Ze(e,"deactivated")}}(e,!0):e.$destroy())}},vt=Object.keys(bt);function yt(n,e,t,l,c){if(!i(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=xe;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return _(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=j((function(t){n.resolved=we(t,e),r?a.length=0:u(!0)})),m=j((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(f(h)?i(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=we(h.error,e)),s(h.loading)&&(n.loadingComp=we(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),s(h.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,a,r){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(p,e,t,l,c);e=e||{},Qt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),o=i[a],l=e.model.callback;s(o)?(r(o)?-1===o.indexOf(l):o!==l)&&(i[a]=[l].concat(o)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var c in a){var d=L(c);Yn(r,l,c,d,!0)||Yn(r,o,c,d,!1)}return r}}(e,n);if(o(n.options.functional))return function(n,e,t,i,o){var l=n.options,c={},d=l.props;if(s(d))for(var u in d)c[u]=At(u,d,e||a);else s(t.attrs)&&ft(c,t.attrs),s(t.props)&&ft(c,t.props);var p=new mt(t,c,o,i,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return ht(m,t,p.parent,l,p);if(r(m)){for(var h=Gn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ht(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<vt.length;t++){var a=vt[t],r=e[a],i=bt[a];r===i||r&&r._merged||(e[a]=r?_t(i,r):i)}}(e);var b=gt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function _t(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var xt=M,wt=F.optionMergeStrategies;function Et(n,e){if(!e)return n;for(var t,a,r,i=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(t=i[s])&&(a=n[t],r=e[t],w(n,t)?a!==r&&p(a)&&p(r)&&Et(a,r):Dn(n,t,r));return n}function kt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?Et(a,r):r}:e?n?function(){return Et(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function St(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Tt(n,e,t,a){var r=Object.create(n||null);return e?B(r,e):r}wt.data=function(n,e,t){return t?kt(n,e,t):e&&"function"!=typeof e?n:kt(n,e)},R.forEach((function(n){wt[n]=St})),U.forEach((function(n){wt[n+"s"]=Tt})),wt.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var s in B(i,n),e){var o=i[s],l=e[s];o&&!r(o)&&(o=[o]),i[s]=o?o.concat(l):r(l)?l:[l]}return i},wt.props=wt.methods=wt.inject=wt.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return B(r,n),e&&B(r,e),r},wt.provide=kt;var It=function(n,e){return void 0===e?n:e};function Lt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,s={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(s[S(i)]={type:null});else if(p(t))for(var o in t)i=t[o],s[S(o)]=p(i)?i:{type:i};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(p(t))for(var s in t){var o=t[s];a[s]=p(o)?B({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Lt(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Lt(n,e.mixins[a],t);var s,o={};for(s in n)l(s);for(s in e)w(n,s)||l(s);function l(a){var r=wt[a]||It;o[a]=r(n[a],e[a],t,a)}return o}function Ct(n,e,t,a){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var i=S(t);if(w(r,i))return r[i];var s=T(i);return w(r,s)?r[s]:r[t]||r[i]||r[s]}}function At(n,e,t,a){var r=e[n],i=!w(t,n),s=t[n],o=zt(Boolean,r.type);if(o>-1)if(i&&!w(r,"default"))s=!1;else if(""===s||s===L(n)){var l=zt(String,r.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Dt(e.type)?a.call(n):a}(a,r,n);var d=Tn;In(!0),An(s),In(d)}return s}var Bt=/^\s*function (\w+)/;function Dt(n){var e=n&&n.toString().match(Bt);return e?e[1]:""}function Mt(n,e){return Dt(n)===Dt(e)}function zt(n,e){if(!r(e))return Mt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Mt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:M,set:M};function Nt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Pt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=On({}),r=n.$options._propKeys=[];n.$parent&&In(!1);var i=function(i){r.push(i);var s=At(i,e,t,n);Bn(a,i,s),i in n||Nt(n,"_props",i)};for(var s in e)i(s);In(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);pn(n),_n();var r=Te(t,null,[n._props||On({}),a],n,"setup");if(xn(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var s in r)"__sfc"!==s&&qn(i,r,s)}else for(var s in r)Q(s)||qn(n,r,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?M:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){_n();try{return n.call(e,e)}catch(n){return Se(n,e,"data()"),{}}finally{xn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&w(a,i)||Q(i)||Nt(n,"_data",i)}var s=An(e);s&&s.vmCount++}(n);else{var t=An(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var r in e){var i=e[r],s=c(i)?i:i.get;0,a||(t[r]=new Qe(n,s||M,M,jt)),r in n||qt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Ft(n,t,a[i]);else Ft(n,t,a)}}(n,e.watch)}var jt={lazy:!0};function qt(n,e,t){var a=!sn();c(t)?(Ot.get=a?Ut(e):Rt(t),Ot.set=M):(Ot.get=t.get?a&&!1!==t.cache?Ut(e):Rt(t.get):M,Ot.set=t.set||M),Object.defineProperty(n,e,Ot)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),vn.target&&e.depend(),e.value}}function Rt(n){return function(){return n.call(this,this)}}function Ft(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Ht=0;function Qt(n){var e=n.options;if(n.super){var t=Qt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&B(n.extendOptions,a),(e=n.options=Lt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function $t(n){this._init(n)}function Vt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=gt(n)||gt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=Lt(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Nt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)qt(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,U.forEach((function(n){s[n]=t[n]})),i&&(s.options.components[i]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=B({},s.options),r[a]=s,s}}function Yt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Gt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Jt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var s=t[i];if(s){var o=s.name;o&&!e(o)&&Kt(t,i,a,r)}}}function Kt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,_(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new Rn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Lt(Qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ge(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=ue(e._renderChildren,r),n.$scopedSlots=t?he(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return ke(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return ke(n,e,t,a,r,!0)};var i=t&&t.data;Bn(n,"$attrs",i&&i.attrs||a,null,!0),Bn(n,"$listeners",e._parentListeners||a,null,!0)}(e),Ze(e,"beforeCreate",void 0,!1),function(n){var e=pt(n.$options.inject,n);e&&(In(!1),Object.keys(e).forEach((function(t){Bn(n,t,e[t])})),In(!0))}(e),Pt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var a=Fn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var s=r[i];Object.defineProperty(a,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),Ze(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}($t),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Dn,n.prototype.$delete=Mn,n.prototype.$watch=function(n,e,t){if(p(e))return Ft(this,n,e,t);(t=t||{}).user=!0;var a=new Qe(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');_n(),Te(e,this,[a.value],this,r),xn()}return function(){a.teardown()}}}($t),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,s=n.length;i<s;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((s=o[l])===e||s.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var a=A(arguments,1),r='event handler for "'.concat(n,'"'),i=0,s=t.length;i<s;i++)Te(t[i],e,a,e,r)}return e}}($t),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ke(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Ze(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||_(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Ze(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}($t),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return je(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=he(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&_e(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{pn(e),xe=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Se(t,e,"render"),n=e._vnode}finally{xe=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=i,n}}($t);var Wt=[String,RegExp,Array],Xt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Wt,exclude:Wt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,s=t.componentOptions;n[a]={name:Yt(s),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Kt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Kt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Jt(n,(function(n){return Gt(e,n)}))})),this.$watch("exclude",(function(e){Jt(n,(function(n){return!Gt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ee(n),t=e&&e.componentOptions;if(t){var a=Yt(t),r=this.include,i=this.exclude;if(r&&(!a||!Gt(r,a))||i&&a&&Gt(i,a))return e;var s=this.cache,o=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,_(o,l),o.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:xt,extend:B,mergeOptions:Lt,defineReactive:Bn},n.set=Dn,n.delete=Mn,n.nextTick=je,n.observable=function(n){return An(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,B(n.options.components,Xt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Lt(this.options,n),this}}(n),Vt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}($t),Object.defineProperty($t.prototype,"$isServer",{get:sn}),Object.defineProperty($t.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty($t,"FunctionalRenderContext",{value:mt}),$t.version="2.7.10";var Zt=v("style,class"),na=v("input,textarea,option,select,progress"),ea=v("contenteditable,draggable,spellcheck"),ta=v("events,caret,typing,plaintext-only"),aa=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",ia=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return ia(n)?n.slice(6,n.length):""},oa=function(n){return null==n||!1===n};function la(n){for(var e=n.data,t=n,a=n;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ca(a.data,e));for(;s(t=t.parent);)t&&t.data&&(e=ca(e,t.data));return function(n,e){if(s(n)||s(e))return da(n,ua(e));return""}(e.staticClass,e.class)}function ca(n,e){return{staticClass:da(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function da(n,e){return n?e?n+" "+e:n:e||""}function ua(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)s(e=ua(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var pa={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ma=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ha=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(n){return ma(n)||ha(n)};var ga=Object.create(null);var ba=v("text,number,password,search,email,tel,url");var va=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(pa[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ya={create:function(n,e){_a(e)},update:function(n,e){n.data.ref!==e.data.ref&&(_a(n,!0),_a(e))},destroy:function(n){_a(n,!0)}};function _a(n,e){var t=n.data.ref;if(s(t)){var a=n.context,i=n.componentInstance||n.elm,o=e?null:i,l=e?void 0:i;if(c(t))Te(t,a,[o],a,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=jn(t),m=a.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?r(h)&&_(h,i):r(h)?h.includes(i)||h.push(i):u?(m[t]=[i],xa(a,t,m[t])):t.value=[i]}else if(u){if(e&&m[t]!==i)return;m[t]=l,xa(a,t,o)}else if(p){if(e&&t.value!==i)return;t.value=o}else 0}}}function xa(n,e,t){var a=n._setupState;a&&w(a,e)&&(jn(a[e])?a[e].value=t:a[e]=t)}var wa=new mn("",{},[]),Ea=["create","activate","update","remove","destroy"];function ka(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=s(t=n.data)&&s(t=t.attrs)&&t.type,r=s(t=e.data)&&s(t=t.attrs)&&t.type;return a===r||ba(a)&&ba(r)}(n,e)||o(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Sa(n,e,t){var a,r,i={};for(a=e;a<=t;++a)s(r=n[a].key)&&(i[r]=a);return i}var Ta={create:Ia,update:Ia,destroy:function(n){Ia(n,wa)}};function Ia(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===wa,s=e===wa,o=Ca(n.data.directives,n.context),l=Ca(e.data.directives,e.context),c=[],d=[];for(t in l)a=o[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,Ba(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(Ba(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Ba(c[t],"inserted",e,n)};i?Vn(e,"insert",u):u()}d.length&&Vn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ba(d[t],"componentUpdated",e,n)}));if(!i)for(t in o)l[t]||Ba(o[t],"unbind",n,n,s)}(n,e)}var La=Object.create(null);function Ca(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=La),r[Aa(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||Ct(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Ct(e.$options,"directives",a.name)}return r}function Aa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ba(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Se(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Da=[ya,Ta];function Ma(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(a in(s(d.__ob__)||o(d._v_attr_proxy))&&(d=e.data.attrs=B({},d)),d)r=d[a],c[a]!==r&&za(l,a,r,e.data.pre);for(a in(K||X)&&d.value!==c.value&&za(l,"value",d.value),c)i(d[a])&&(ia(a)?l.removeAttributeNS(ra,sa(a)):ea(a)||l.removeAttribute(a))}}function za(n,e,t,a){a||n.tagName.indexOf("-")>-1?Oa(n,e,t):aa(e)?oa(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ea(e)?n.setAttribute(e,function(n,e){return oa(e)||"false"===e?"false":"contenteditable"===n&&ta(e)?e:"true"}(e,t)):ia(e)?oa(t)?n.removeAttributeNS(ra,sa(e)):n.setAttributeNS(ra,e,t):Oa(n,e,t)}function Oa(n,e,t){if(oa(t))n.removeAttribute(e);else{if(K&&!W&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Na={create:Ma,update:Ma};function Pa(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var o=la(e),l=t._transitionClasses;s(l)&&(o=da(o,ua(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var ja,qa={create:Pa,update:Pa};function Ua(n,e,t){var a=ja;return function r(){var i=e.apply(null,arguments);null!==i&&Ha(n,r,t,a)}}var Ra=Ae&&!(en&&Number(en[1])<=53);function Fa(n,e,t,a){if(Ra){var r=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}ja.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Ha(n,e,t,a){(a||ja).removeEventListener(n,e._wrapper||e,t)}function Qa(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};ja=e.elm||n.elm,function(n){if(s(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),$n(t,a,Fa,Ha,Ua,e.context),ja=void 0}}var $a,Va={create:Qa,update:Qa,destroy:function(n){return Qa(n,wa)}};function Ya(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||o(c._v_attr_proxy))&&(c=e.data.domProps=B({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var d=i(a)?"":String(a);Ga(r,d)&&(r.value=d)}else if("innerHTML"===t&&ha(r.tagName)&&i(r.innerHTML)){($a=$a||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=$a.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Ga(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(s(a)){if(a.number)return b(t)!==b(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ja={create:Ya,update:Ya},Ka=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Wa(n){var e=Xa(n.style);return n.staticStyle?B(n.staticStyle,e):e}function Xa(n){return Array.isArray(n)?D(n):"string"==typeof n?Ka(n):n}var Za,nr=/^--/,er=/\s*!important$/,tr=function(n,e,t){if(nr.test(e))n.style.setProperty(e,t);else if(er.test(t))n.style.setProperty(L(e),t.replace(er,""),"important");else{var a=rr(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},ar=["Webkit","Moz","ms"],rr=E((function(n){if(Za=Za||document.createElement("div").style,"filter"!==(n=S(n))&&n in Za)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ar.length;t++){var a=ar[t]+e;if(a in Za)return a}}));function ir(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,o,l=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},u=c||d,p=Xa(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?B({},p):p;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Wa(r.data))&&B(a,t);(t=Wa(n.data))&&B(a,t);for(var i=n;i=i.parent;)i.data&&(t=Wa(i.data))&&B(a,t);return a}(e,!0);for(o in u)i(m[o])&&tr(l,o,"");for(o in m)(r=m[o])!==u[o]&&tr(l,o,null==r?"":r)}}var sr={create:ir,update:ir},or=/\s+/;function lr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(or).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(or).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function dr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&B(e,ur(n.name||"v")),B(e,n),e}return"string"==typeof n?ur(n):void 0}}var ur=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),pr=G&&!W,mr="transition",hr="transitionend",fr="animation",gr="animationend";pr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mr="WebkitTransition",hr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fr="WebkitAnimation",gr="webkitAnimationEnd"));var br=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function vr(n){br((function(){br(n)}))}function yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),lr(n,e))}function _r(n,e){n._transitionClasses&&_(n._transitionClasses,e),cr(n,e)}function xr(n,e,t){var a=Er(n,e),r=a.type,i=a.timeout,s=a.propCount;if(!r)return t();var o="transition"===r?hr:gr,l=0,c=function(){n.removeEventListener(o,d),t()},d=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),i+1),n.addEventListener(o,d)}var wr=/\b(transform|all)(,|$)/;function Er(n,e){var t,a=window.getComputedStyle(n),r=(a[mr+"Delay"]||"").split(", "),i=(a[mr+"Duration"]||"").split(", "),s=kr(r,i),o=(a[fr+"Delay"]||"").split(", "),l=(a[fr+"Duration"]||"").split(", "),c=kr(o,l),d=0,u=0;return"transition"===e?s>0&&(t="transition",d=s,u=i.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&wr.test(a[mr+"Property"])}}function kr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Sr(e)+Sr(n[t])})))}function Sr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Tr(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=dr(n.data.transition);if(!i(a)&&!s(t._enterCb)&&1===t.nodeType){for(var r=a.css,o=a.type,l=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,f=a.appearActiveClass,g=a.beforeEnter,v=a.enter,y=a.afterEnter,_=a.enterCancelled,x=a.beforeAppear,w=a.appear,E=a.afterAppear,k=a.appearCancelled,S=a.duration,T=Je,I=Je.$vnode;I&&I.parent;)T=I.context,I=I.parent;var L=!T._isMounted||!n.isRootInsert;if(!L||w||""===w){var C=L&&m?m:l,A=L&&f?f:p,B=L&&h?h:u,D=L&&x||g,M=L&&c(w)?w:v,z=L&&E||y,O=L&&k||_,N=b(d(S)?S.enter:S);0;var P=!1!==r&&!W,q=Cr(M),U=t._enterCb=j((function(){P&&(_r(t,B),_r(t,A)),U.cancelled?(P&&_r(t,C),O&&O(t)):z&&z(t),t._enterCb=null}));n.data.show||Vn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),M&&M(t,U)})),D&&D(t),P&&(yr(t,C),yr(t,A),vr((function(){_r(t,C),U.cancelled||(yr(t,B),q||(Lr(N)?setTimeout(U,N):xr(t,o,U)))}))),n.data.show&&(e&&e(),M&&M(t,U)),P||q||U()}}}function Ir(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=dr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var r=a.css,o=a.type,l=a.leaveClass,c=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,f=a.leaveCancelled,g=a.delayLeave,v=a.duration,y=!1!==r&&!W,_=Cr(m),x=b(d(v)?v.leave:v);0;var w=t._leaveCb=j((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(_r(t,c),_r(t,u)),w.cancelled?(y&&_r(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(E):E()}function E(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(yr(t,l),yr(t,u),vr((function(){_r(t,l),w.cancelled||(yr(t,c),_||(Lr(x)?setTimeout(w,x):xr(t,o,w)))}))),m&&m(t,w),y||_||w())}}function Lr(n){return"number"==typeof n&&!isNaN(n)}function Cr(n){if(i(n))return!1;var e=n.fns;return s(e)?Cr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ar(n,e){!0!==e.data.show&&Tr(e)}var Br=function(n){var e,t,a={},c=n.modules,d=n.nodeOps;for(e=0;e<Ea.length;++e)for(a[Ea[e]]=[],t=0;t<c.length;++t)s(c[t][Ea[e]])&&a[Ea[e]].push(c[t][Ea[e]]);function u(n){var e=d.parentNode(n);s(e)&&d.removeChild(e,n)}function p(n,e,t,r,i,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=gn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(s(i)){var l=s(n.componentInstance)&&i.keepAlive;if(s(i=i.hook)&&s(i=i.init)&&i(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,r),o(l)&&function(n,e,t,r){var i,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(i=o.data)&&s(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](wa,o);e.push(o);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;s(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),y(n),f(n,p,e),s(u)&&b(n,e),h(t,n.elm,r)):o(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,r)):(n.elm=d.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(b(n,e),y(n)):(_a(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function b(n,t){for(var r=0;r<a.create.length;++r)a.create[r](wa,n);s(e=n.data.hook)&&(s(e.create)&&e.create(wa,n),s(e.insert)&&t.push(n))}function y(n){var e;if(s(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;s(e=Je)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function _(n,e,t,a,r,i){for(;a<=r;++a)p(t[a],i,n,e,!1,t,a)}function x(n){var e,t,r=n.data;if(s(r))for(s(e=r.hook)&&s(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];s(a)&&(s(a.tag)?(E(a),x(a)):u(a.elm))}}function E(n,e){if(s(e)||s(n.data)){var t,r=a.remove.length+1;for(s(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&E(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else u(n.elm)}function k(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(s(i)&&ka(n,i))return r}}function S(n,e,t,r,l,c){if(n!==e){s(e.elm)&&s(r)&&(e=r[l]=gn(e));var u=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?L(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var f=n.children,b=e.children;if(s(h)&&g(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}i(e.text)?s(f)&&s(b)?f!==b&&function(n,e,t,a,r){var o,l,c,u=0,m=0,h=e.length-1,f=e[0],g=e[h],b=t.length-1,v=t[0],y=t[b],x=!r;for(0;u<=h&&m<=b;)i(f)?f=e[++u]:i(g)?g=e[--h]:ka(f,v)?(S(f,v,a,t,m),f=e[++u],v=t[++m]):ka(g,y)?(S(g,y,a,t,b),g=e[--h],y=t[--b]):ka(f,y)?(S(f,y,a,t,b),x&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++u],y=t[--b]):ka(g,v)?(S(g,v,a,t,m),x&&d.insertBefore(n,g.elm,f.elm),g=e[--h],v=t[++m]):(i(o)&&(o=Sa(e,u,h)),i(l=s(v.key)?o[v.key]:k(v,e,u,h))?p(v,a,n,f.elm,!1,t,m):ka(c=e[l],v)?(S(c,v,a,t,m),e[l]=void 0,x&&d.insertBefore(n,c.elm,f.elm)):p(v,a,n,f.elm,!1,t,m),v=t[++m]);u>h?_(n,i(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&w(e,u,h)}(u,f,b,t,c):s(b)?(s(n.text)&&d.setTextContent(u,""),_(u,null,b,0,b.length-1,t)):s(f)?w(f,0,f.length-1):s(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var I=v("attrs,class,staticClass,staticStyle,key");function L(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(r=l.hook)&&s(r=r.init)&&r(e,!0),s(r=e.componentInstance)))return m(e,t),!0;if(s(i)){if(s(c))if(n.hasChildNodes())if(s(r=l)&&s(r=r.domProps)&&s(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!L(u,c[p],t,a)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(s(l)){var h=!1;for(var g in l)if(!I(g)){h=!0,b(e,t);break}!h&&l.class&&Re(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,u=[];if(i(n))c=!0,p(e,u);else{var m=s(n.nodeType);if(!m&&ka(n,e))S(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&L(n,e,u))return T(e,u,!0),n;l=n,n=new mn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=d.parentNode(h);if(p(e,u,h._leaveCb?null:f,d.nextSibling(h)),s(e.parent))for(var b=e.parent,v=g(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,v){for(var _=0;_<a.create.length;++_)a.create[_](wa,b);var E=b.data.hook.insert;if(E.merged)for(var k=1;k<E.fns.length;k++)E.fns[k]()}else _a(b);b=b.parent}s(f)?w([n],0,0):s(n.tag)&&x(n)}}return T(e,u,c),e.elm}s(n)&&x(n)}}({nodeOps:va,modules:[Na,qa,Va,Ja,sr,G?{create:Ar,activate:Ar,remove:function(n,e){!0!==n.data.show?Ir(n,e):e()}}:{}].concat(Da)});W&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qr(n,"input")}));var Dr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Vn(t,"postpatch",(function(){Dr.componentUpdated(n,e,t)})):Mr(n,e,t.context),n._vOptions=[].map.call(n.options,Nr)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Pr),n.addEventListener("compositionend",jr),n.addEventListener("change",jr),W&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Mr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Nr);if(r.some((function(n,e){return!N(n,a[e])})))(n.multiple?e.value.some((function(n){return Or(n,r)})):e.value!==e.oldValue&&Or(e.value,r))&&qr(n,"change")}}};function Mr(n,e,t){zr(n,e,t),(K||X)&&setTimeout((function(){zr(n,e,t)}),0)}function zr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,s,o=0,l=n.options.length;o<l;o++)if(s=n.options[o],r)i=P(a,Nr(s))>-1,s.selected!==i&&(s.selected=i);else if(N(Nr(s),a))return void(n.selectedIndex!==o&&(n.selectedIndex=o));r||(n.selectedIndex=-1)}}function Or(n,e){return e.every((function(e){return!N(e,n)}))}function Nr(n){return"_value"in n?n._value:n.value}function Pr(n){n.target.composing=!0}function jr(n){n.target.composing&&(n.target.composing=!1,qr(n.target,"input"))}function qr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var Rr={model:Dr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Tr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Tr(t,(function(){n.style.display=n.__vOriginalDisplay})):Ir(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Fr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Hr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Hr(Ee(e.children)):n}function Qr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[S(a)]=r[a];return e}function $r(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Vr=function(n){return n.tag||me(n)},Yr=function(n){return"show"===n.name},Gr={name:"transition",props:Fr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Vr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=Hr(r);if(!i)return r;if(this._leaving)return $r(n,r);var s="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?s+"comment":s+i.tag:l(i.key)?0===String(i.key).indexOf(s)?i.key:s+i.key:i.key;var o=(i.data||(i.data={})).transition=Qr(this),c=this._vnode,d=Hr(c);if(i.data.directives&&i.data.directives.some(Yr)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!me(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=B({},o);if("out-in"===a)return this._leaving=!0,Vn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),$r(n,r);if("in-out"===a){if(me(i))return c;var p,m=function(){p()};Vn(o,"afterEnter",m),Vn(o,"enterCancelled",m),Vn(u,"delayLeave",(function(n){p=n}))}}return r}}},Jr=B({tag:String,moveClass:String},Fr);function Kr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Wr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Xr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Jr.mode;var Zr={Transition:Gr,TransitionGroup:{props:Jr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],s=Qr(this),o=0;o<r.length;o++){if((d=r[o]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))i.push(d),t[d.key]=d,(d.data||(d.data={})).transition=s;else;}if(a){var l=[],c=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=s,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Kr),n.forEach(Wr),n.forEach(Xr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;yr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(hr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(hr,n),t._moveCb=null,_r(t,e))})}})))},methods:{hasMove:function(n,e){if(!pr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){cr(t,n)})),lr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Er(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ni(n,e){for(var t in e)n[t]=e[t];return n}$t.config.mustUseProp=function(n,e,t){return"value"===t&&na(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},$t.config.isReservedTag=fa,$t.config.isReservedAttr=Zt,$t.config.getTagNamespace=function(n){return ha(n)?"svg":"math"===n?"math":void 0},$t.config.isUnknownElement=function(n){if(!G)return!0;if(fa(n))return!1;if(n=n.toLowerCase(),null!=ga[n])return ga[n];var e=document.createElement(n);return n.indexOf("-")>-1?ga[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ga[n]=/HTMLUnknownElement/.test(e.toString())},B($t.options.directives,Rr),B($t.options.components,Zr),$t.prototype.__patch__=G?Br:M,$t.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),Ze(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Qe(n,a,M,{before:function(){n._isMounted&&!n._isDestroyed&&Ze(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,Ze(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){F.devtools&&on&&on.emit("init",$t)}),0);var ei=/[!'()*]/g,ti=function(n){return"%"+n.charCodeAt(0).toString(16)},ai=/%2C/g,ri=function(n){return encodeURIComponent(n).replace(ei,ti).replace(ai,",")};function ii(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function oi(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=ii(t.shift()),r=t.length>0?ii(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function li(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ri(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ri(e)):a.push(ri(e)+"="+ri(n)))})),a.join("&")}return ri(e)+"="+ri(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ci=/\/?$/;function di(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=ui(i)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:hi(e,r),matched:n?mi(n):[]};return t&&(s.redirectedFrom=hi(t,r)),Object.freeze(s)}function ui(n){if(Array.isArray(n))return n.map(ui);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ui(n[t]);return e}return n}var pi=di(null,{path:"/"});function mi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function hi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||li)(a)+r}function fi(n,e,t){return e===pi?n===e:!!e&&(n.path&&e.path?n.path.replace(ci,"")===e.path.replace(ci,"")&&(t||n.hash===e.hash&&gi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&gi(n.query,e.query)&&gi(n.params,e.params))))}function gi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var s=e[t];return null==i||null==s?i===s:"object"==typeof i&&"object"==typeof s?gi(i,s):String(i)===String(s)}))}function bi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var s=0;s<i.length;s++)r._isBeingDestroyed||i[s](r)}}}}var vi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var s=r.$createElement,o=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(i.routerViewDepth=d,u){var m=c[o],h=m&&m.component;return h?(m.configProps&&yi(h,i,m.route,m.configProps),s(h,i,a)):s()}var f=l.matched[d],g=f&&f.components[o];if(!f||!g)return c[o]=null,s();c[o]={component:g},i.registerRouteInstance=function(n,e){var t=f.instances[o];(e&&t!==n||!e&&t===n)&&(f.instances[o]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){f.instances[o]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[o]&&(f.instances[o]=n.componentInstance),bi(l)};var b=f.props&&f.props[o];return b&&(ni(c[o],{route:l,configProps:b}),yi(g,i,l,b)),s(g,i,a)}};function yi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ni({},r);var i=e.attrs=e.attrs||{};for(var s in r)n.props&&s in n.props||(i[s]=r[s],delete r[s])}}function _i(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),s=0;s<i.length;s++){var o=i[s];".."===o?r.pop():"."!==o&&r.push(o)}return""!==r[0]&&r.unshift(""),r.join("/")}function xi(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var wi=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ei=Pi,ki=Ci,Si=function(n,e){return Bi(Ci(n,e),e)},Ti=Bi,Ii=Ni,Li=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ci(n,e){for(var t,a=[],r=0,i=0,s="",o=e&&e.delimiter||"/";null!=(t=Li.exec(n));){var l=t[0],c=t[1],d=t.index;if(s+=n.slice(i,d),i=d+l.length,c)s+=c[1];else{var u=n[i],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],b=t[7];s&&(a.push(s),s="");var v=null!=p&&null!=u&&u!==p,y="+"===g||"*"===g,_="?"===g||"*"===g,x=t[2]||o,w=h||f;a.push({name:m||r++,prefix:p||"",delimiter:x,optional:_,repeat:y,partial:v,asterisk:!!b,pattern:w?Mi(w):b?".*":"[^"+Di(x)+"]+?"})}}return i<n.length&&(s+=n.substr(i)),s&&a.push(s),a}function Ai(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Bi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Oi(e)));return function(e,a){for(var r="",i=e||{},s=(a||{}).pretty?Ai:encodeURIComponent,o=0;o<n.length;o++){var l=n[o];if("string"!=typeof l){var c,d=i[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(wi(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=s(d[u]),!t[o].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(d),!t[o].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Di(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Mi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function zi(n,e){return n.keys=e,n}function Oi(n){return n&&n.sensitive?"":"i"}function Ni(n,e,t){wi(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",s=0;s<n.length;s++){var o=n[s];if("string"==typeof o)i+=Di(o);else{var l=Di(o.prefix),c="(?:"+o.pattern+")";e.push(o),o.repeat&&(c+="(?:"+l+c+")*"),i+=c=o.optional?o.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Di(t.delimiter||"/"),u=i.slice(-d.length)===d;return a||(i=(u?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=r?"$":a&&u?"":"(?="+d+"|$)",zi(new RegExp("^"+i,Oi(t)),e)}function Pi(n,e,t){return wi(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return zi(n,e)}(n,e):wi(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Pi(n[r],e,t).source);return zi(new RegExp("(?:"+a.join("|")+")",Oi(t)),e)}(n,e,t):function(n,e,t){return Ni(Ci(n,t),e,t)}(n,e,t)}Ei.parse=ki,Ei.compile=Si,Ei.tokensToFunction=Ti,Ei.tokensToRegExp=Ii;var ji=Object.create(null);function qi(n,e,t){e=e||{};try{var a=ji[n]||(ji[n]=Ei.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ni({},n)).params;return i&&"object"==typeof i&&(r.params=ni({},i)),r}if(!r.path&&r.params&&e){(r=ni({},r))._normalized=!0;var s=ni(ni({},e.params),r.params);if(e.name)r.name=e.name,r.params=s;else if(e.matched.length){var o=e.matched[e.matched.length-1].path;r.path=qi(o,s,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?_i(l.path,c,t||r.append):c,u=function(n,e,t){void 0===e&&(e={});var a,r=t||oi;try{a=r(n||"")}catch(n){a={}}for(var i in e){var s=e[i];a[i]=Array.isArray(s)?s.map(si):si(s)}return a}(l.query,r.query,a&&a.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Ri,Fi=function(){},Hi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,s=r.route,o=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=s.redirectedFrom?di(null,Ui(s.redirectedFrom),null,t):s;l[h]=fi(a,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ci,"/").indexOf(e.path.replace(ci,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,f);var g=l[h]?this.ariaCurrentValue:null,b=function(n){Qi(n)&&(e.replace?t.replace(i,Fi):t.push(i,Fi))},v={click:Qi};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var y={class:l},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:b,isActive:l[m],isExactActive:l[h]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?n():n("span",{},_)}if("a"===this.tag)y.on=v,y.attrs={href:o,"aria-current":g};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=ni({},x.data);for(var E in w.on=w.on||{},w.on){var k=w.on[E];E in v&&(w.on[E]=Array.isArray(k)?k:[k])}for(var S in v)S in w.on?w.on[S].push(v[S]):w.on[S]=b;var T=x.data.attrs=ni({},x.data.attrs);T.href=o,T["aria-current"]=g}else y.on=v}return n(this.tag,y,this.$slots.default)}};function Qi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var $i="undefined"!=typeof window;function Vi(n,e,t,a,r){var i=e||[],s=t||Object.create(null),o=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,s){var o=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return xi(e.path+"/"+n)}(o,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:Yi(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:s,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=s?xi(s+"/"+r.path):void 0;n(e,t,a,r,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,a,h,i,u.path||"/")}l&&(a[l]||(a[l]=u))}(i,s,o,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:s,nameMap:o}}function Yi(n,e){return Ei(n,[],e)}function Gi(n,e){var t=Vi(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function s(n,t,s){var o=Ui(n,t,!1,e),c=o.name;if(c){var d=i[c];if(!d)return l(null,o);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof o.params&&(o.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in o.params)&&u.indexOf(p)>-1&&(o.params[p]=t.params[p]);return o.path=qi(d.path,o.params),l(d,o,s)}if(o.path){o.params={};for(var m=0;m<a.length;m++){var h=a[m],f=r[h];if(Ji(f.regex,o.path,o.params))return l(f,o,s)}}return l(null,o)}function o(n,t){var a=n.redirect,r="function"==typeof a?a(di(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var o=r,c=o.name,d=o.path,u=t.query,p=t.hash,m=t.params;if(u=o.hasOwnProperty("query")?o.query:u,p=o.hasOwnProperty("hash")?o.hash:p,m=o.hasOwnProperty("params")?o.params:m,c){i[c];return s({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return _i(n,e.parent?e.parent.path:"/",!0)}(d,n);return s({_normalized:!0,path:qi(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?o(n,a||t):n&&n.matchAs?function(n,e,t){var a=s({_normalized:!0,path:qi(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):di(n,t,a,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Vi([e||n],a,r,i,t),t&&t.alias.length&&Vi(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Vi(n,a,r,i)}}}function Ji(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var s=n.keys[r-1];s&&(t[s.name||"pathMatch"]="string"==typeof a[r]?ii(a[r]):a[r])}return!0}var Ki=$i&&window.performance&&window.performance.now?window.performance:Date;function Wi(){return Ki.now().toFixed(3)}var Xi=Wi();function Zi(){return Xi}function ns(n){return Xi=n}var es=Object.create(null);function ts(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ni({},window.history.state);return t.key=Zi(),window.history.replaceState(t,"",e),window.addEventListener("popstate",is),function(){window.removeEventListener("popstate",is)}}function as(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=Zi();if(n)return es[n]}(),s=r.call(n,e,t,a?i:null);s&&("function"==typeof s.then?s.then((function(n){ds(n,i)})).catch((function(n){0})):ds(s,i))}))}}function rs(){var n=Zi();n&&(es[n]={x:window.pageXOffset,y:window.pageYOffset})}function is(n){rs(),n.state&&n.state.key&&ns(n.state.key)}function ss(n){return ls(n.x)||ls(n.y)}function os(n){return{x:ls(n.x)?n.x:window.pageXOffset,y:ls(n.y)?n.y:window.pageYOffset}}function ls(n){return"number"==typeof n}var cs=/^#\d/;function ds(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=cs.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:ls((t=i).x)?t.x:0,y:ls(t.y)?t.y:0})}else ss(n)&&(e=os(n))}else a&&ss(n)&&(e=os(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var us,ps=$i&&((-1===(us=window.navigator.userAgent).indexOf("Android 2.")&&-1===us.indexOf("Android 4.0")||-1===us.indexOf("Mobile Safari")||-1!==us.indexOf("Chrome")||-1!==us.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ms(n,e){rs();var t=window.history;try{if(e){var a=ni({},t.state);a.key=Zi(),t.replaceState(a,"",n)}else t.pushState({key:ns(Wi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function hs(n){ms(n,!0)}var fs={redirected:2,aborted:4,cancelled:8,duplicated:16};function gs(n,e){return vs(n,e,fs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ys.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function bs(n,e){return vs(n,e,fs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function vs(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ys=["params","query","hash"];function _s(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function xs(n,e){return _s(n)&&n._isRouter&&(null==e||n.type===e)}function ws(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function Es(n){return function(e,t,a){var r=!1,i=0,s=null;ks(n,(function(n,e,t,o){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=Is((function(e){var r;((r=e).__esModule||Ts&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ri.extend(e),t.components[o]=e,--i<=0&&a()})),d=Is((function(n){var e="Failed to resolve async component "+o+": "+n;s||(s=_s(n)?n:new Error(e),a(s))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||a()}}function ks(n,e){return Ss(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ss(n){return Array.prototype.concat.apply([],n)}var Ts="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Is(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Ls=function(n,e){this.router=n,this.base=function(n){if(!n)if($i){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=pi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Cs(n,e,t,a){var r=ks(n,(function(n,a,r,i){var s=function(n,e){"function"!=typeof n&&(n=Ri.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,a,r,i)})):t(s,a,r,i)}));return Ss(a?r.reverse():r)}function As(n,e){if(e)return function(){return n.apply(e,arguments)}}Ls.prototype.listen=function(n){this.cb=n},Ls.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ls.prototype.onError=function(n){this.errorCbs.push(n)},Ls.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(xs(n,fs.redirected)&&i===pi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ls.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,s,o=function(n){!xs(n)&&_s(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(fi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&as(this.router,r,n,!1),o(((s=vs(i=r,n,fs.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",s));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Cs(n,"beforeRouteLeave",As,!0)}(p),this.router.beforeHooks,function(n){return Cs(n,"beforeRouteUpdate",As)}(u),m.map((function(n){return n.beforeEnter})),Es(m)),f=function(e,t){if(a.pending!==n)return o(bs(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),o(function(n,e){return vs(n,e,fs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):_s(e)?(a.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(gs(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){o(n)}};ws(h,f,(function(){ws(function(n){return Cs(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),f,(function(){if(a.pending!==n)return o(bs(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){bi(n)}))}))}))},Ls.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ls.prototype.setupListeners=function(){},Ls.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=pi,this.pending=null};var Bs=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ds(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ps&&t;a&&this.listeners.push(ts());var r=function(){var t=n.current,r=Ds(n.base);n.current===pi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&as(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){ms(xi(a.base+n.fullPath)),as(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){hs(xi(a.base+n.fullPath)),as(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ds(this.base)!==this.current.fullPath){var e=xi(this.base+this.current.fullPath);n?ms(e):hs(e)}},e.prototype.getCurrentLocation=function(){return Ds(this.base)},e}(Ls);function Ds(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(xi(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ms=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Ds(n);if(!/^\/#/.test(e))return window.location.replace(xi(n+"/#"+e)),!0}(this.base)||zs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ps&&e;t&&this.listeners.push(ts());var a=function(){var e=n.current;zs()&&n.transitionTo(Os(),(function(a){t&&as(n.router,a,e,!0),ps||js(a.fullPath)}))},r=ps?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Ps(n.fullPath),as(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){js(n.fullPath),as(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Os()!==e&&(n?Ps(e):js(e))},e.prototype.getCurrentLocation=function(){return Os()},e}(Ls);function zs(){var n=Os();return"/"===n.charAt(0)||(js("/"+n),!1)}function Os(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ns(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ps(n){ps?ms(Ns(n)):window.location.hash=n}function js(n){ps?hs(Ns(n)):window.location.replace(Ns(n))}var qs=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){xs(n,fs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ls),Us=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Gi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ps&&!1!==n.fallback,this.fallback&&(e="hash"),$i||(e="abstract"),this.mode=e,e){case"history":this.history=new Bs(this,n.base);break;case"hash":this.history=new Ms(this,n.base,this.fallback);break;case"abstract":this.history=new qs(this,n.base);break;default:0}},Rs={currentRoute:{configurable:!0}};Us.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Rs.currentRoute.get=function(){return this.history&&this.history.current},Us.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Bs||t instanceof Ms){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;ps&&r&&"fullPath"in n&&as(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Us.prototype.beforeEach=function(n){return Hs(this.beforeHooks,n)},Us.prototype.beforeResolve=function(n){return Hs(this.resolveHooks,n)},Us.prototype.afterEach=function(n){return Hs(this.afterHooks,n)},Us.prototype.onReady=function(n,e){this.history.onReady(n,e)},Us.prototype.onError=function(n){this.history.onError(n)},Us.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Us.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Us.prototype.go=function(n){this.history.go(n)},Us.prototype.back=function(){this.go(-1)},Us.prototype.forward=function(){this.go(1)},Us.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Us.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?xi(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Us.prototype.getRoutes=function(){return this.matcher.getRoutes()},Us.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==pi&&this.history.transitionTo(this.history.getCurrentLocation())},Us.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==pi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Us.prototype,Rs);var Fs=Us;function Hs(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Us.install=function n(e){if(!n.installed||Ri!==e){n.installed=!0,Ri=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",vi),e.component("RouterLink",Hi);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Us.version="3.6.4",Us.isNavigationFailure=xs,Us.NavigationFailureType=fs,Us.START_LOCATION=pi,$i&&window.Vue&&window.Vue.use(Us);t(96);t(125);var Qs={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,311)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,310))},$s={"v-5b01debe":()=>t.e(5).then(t.bind(null,312)),"v-36afde32":()=>t.e(6).then(t.bind(null,313)),"v-e990cafe":()=>t.e(8).then(t.bind(null,314)),"v-cb672f88":()=>t.e(10).then(t.bind(null,315)),"v-2780ee7f":()=>t.e(12).then(t.bind(null,316)),"v-70dd68cc":()=>t.e(7).then(t.bind(null,317)),"v-47ed6a43":()=>t.e(13).then(t.bind(null,318)),"v-faf15f2e":()=>t.e(11).then(t.bind(null,319)),"v-02970178":()=>t.e(15).then(t.bind(null,320)),"v-6a3757ac":()=>t.e(9).then(t.bind(null,321)),"v-3a027d70":()=>t.e(14).then(t.bind(null,322)),"v-782af799":()=>t.e(16).then(t.bind(null,323)),"v-2ec934f2":()=>t.e(17).then(t.bind(null,324)),"v-1a40dcf1":()=>t.e(19).then(t.bind(null,325)),"v-6f629324":()=>t.e(18).then(t.bind(null,326)),"v-0d5c43ac":()=>t.e(20).then(t.bind(null,327)),"v-4cffe8e0":()=>t.e(22).then(t.bind(null,328)),"v-120c6a65":()=>t.e(21).then(t.bind(null,329)),"v-fe401634":()=>t.e(23).then(t.bind(null,330)),"v-13cb7718":()=>t.e(24).then(t.bind(null,331)),"v-665fe5c9":()=>t.e(26).then(t.bind(null,332)),"v-3c3508ee":()=>t.e(27).then(t.bind(null,333)),"v-0185fa5e":()=>t.e(29).then(t.bind(null,334)),"v-86be2110":()=>t.e(28).then(t.bind(null,335)),"v-e8336c5e":()=>t.e(30).then(t.bind(null,336)),"v-24edf572":()=>t.e(31).then(t.bind(null,337)),"v-9abc4948":()=>t.e(32).then(t.bind(null,338)),"v-28e2e596":()=>t.e(33).then(t.bind(null,339)),"v-5f4b4e88":()=>t.e(25).then(t.bind(null,340)),"v-db48104a":()=>t.e(34).then(t.bind(null,341)),"v-4ba6b42a":()=>t.e(35).then(t.bind(null,342)),"v-fba7452c":()=>t.e(36).then(t.bind(null,343)),"v-6faa9299":()=>t.e(37).then(t.bind(null,344)),"v-c1e4cbf0":()=>t.e(38).then(t.bind(null,345)),"v-41b1c054":()=>t.e(40).then(t.bind(null,346)),"v-1283332c":()=>t.e(39).then(t.bind(null,347)),"v-2f070f9c":()=>t.e(41).then(t.bind(null,348)),"v-90759344":()=>t.e(42).then(t.bind(null,349)),"v-74942003":()=>t.e(44).then(t.bind(null,350)),"v-7e0c0407":()=>t.e(45).then(t.bind(null,351)),"v-4455e40b":()=>t.e(46).then(t.bind(null,352)),"v-fb50d35c":()=>t.e(47).then(t.bind(null,353)),"v-c40dde22":()=>t.e(43).then(t.bind(null,354)),"v-3bf4c9cb":()=>t.e(49).then(t.bind(null,355)),"v-359c0910":()=>t.e(48).then(t.bind(null,356)),"v-f34049fe":()=>t.e(50).then(t.bind(null,357)),"v-41672a42":()=>t.e(52).then(t.bind(null,358)),"v-7bd90c00":()=>t.e(51).then(t.bind(null,359)),"v-5bf6b476":()=>t.e(53).then(t.bind(null,360)),"v-0fa0e03a":()=>t.e(54).then(t.bind(null,361)),"v-0a2e96d0":()=>t.e(55).then(t.bind(null,362)),"v-6c624ce1":()=>t.e(56).then(t.bind(null,363)),"v-218f15ef":()=>t.e(57).then(t.bind(null,364)),"v-5617b67f":()=>t.e(58).then(t.bind(null,365)),"v-504fe09d":()=>t.e(59).then(t.bind(null,366)),"v-0d6c806e":()=>t.e(60).then(t.bind(null,367))};function Vs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ys=/-(\w)/g,Gs=Vs(n=>n.replace(Ys,(n,e)=>e?e.toUpperCase():"")),Js=/\B([A-Z])/g,Ks=Vs(n=>n.replace(Js,"-$1").toLowerCase()),Ws=Vs(n=>n.charAt(0).toUpperCase()+n.slice(1));function Xs(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ws(Gs(e))):n(Ws(e))||n(Ks(e))}const Zs=Object.assign({},Qs,$s),no=n=>Zs[n],eo=n=>$s[n],to=n=>Qs[n],ao=n=>$t.component(n);function ro(n){return Xs(eo,n)}function io(n){return Xs(to,n)}function so(n){return Xs(no,n)}function oo(n){return Xs(ao,n)}function lo(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!oo(n)&&so(n)){const e=await so(n)();$t.component(n,e.default)}}))}function co(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var uo=t(90),po=t.n(uo),mo=t(91),ho=t.n(mo),fo={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ho()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=vo(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return po()([{name:"description",content:this.$description}],n,this.siteMeta,yo)},updateCanonicalLink(){go(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){vo(null,this.currentMetaTags),go()}};function go(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function vo(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function yo(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var _o=t(43),xo={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(_o)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],s=e[n+1],o=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(o&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},wo=t(23),Eo=t.n(wo),ko={mounted(){Eo.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||$t.component(n.name)||Eo.a.start(),t()}),this.$router.afterEach(()=>{Eo.a.done(),this.isSidebarOpen=!1})}};t(232),t(233);class So{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var To={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new So).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Io={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Lo={},Co=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ao=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Io[n]},Bo=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Do=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Mo=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};o.htmlTpl=Co(o.html),o.jsTpl=(t=o.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),o.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(o.js,o.html);var l=Ao("vue");return o.jsLib.unshift(l),o},zo=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},Oo=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function No(){var n=Do(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Do(n,"vuepress-plugin-demo-block__code"),t=Do(n,"vuepress-plugin-demo-block__display"),a=Do(n,"vuepress-plugin-demo-block__footer"),r=Do(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),o=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var l=e.querySelector("div").clientHeight,c="react"===o?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Oo(n),htmlTpl:Co("")},s=Ao("react"),o=Ao("reactDOM");return i.jsLib.unshift(s,o),i}(i,s):"vanilla"===o?zo(i,s):Mo(i,s),d=Bo("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Po.bind(null,d,l,e,a)),Ao("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,s=r.concat(i).concat(Ao("cssLib")).concat(Ao("jsLib")).join(",");return Bo("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ao("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,s=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ao("jsLib")).join(";"),css_external:i.concat(Ao("cssLib")).join(";"),layout:Ao("codepenLayout"),js_pre_processor:Ao("codepenJsProcessor"),editors:Ao("codepenEditors")});return Bo("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==s.horizontal?s.horizontal:Ao("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Lo[n]){var e=Bo("style",{innerHTML:n});document.body.appendChild(e),Lo[n]=!0}}(c.css),"react"===o)ReactDOM.render(React.createElement(c.js),r);else if("vue"===o){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===o&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){No()}),300)}function Po(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var jo={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!0,codepen:!0,horizontal:!1},No()},updated:function(){No()}},qo="auto",Uo="zoom-in",Ro="zoom-out",Fo="grab",Ho="move";function Qo(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function $o(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Vo(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Yo(n,e,t){!function(n){var e=Go,t=Jo;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Go="transition",Jo="transform",Ko="transform",Wo="transitionend";var Xo=function(){},Zo={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Xo,onClose:Xo,onGrab:Xo,onMove:Xo,onRelease:Xo,onBeforeOpen:Xo,onBeforeClose:Xo,onBeforeGrab:Xo,onBeforeRelease:Xo,onImageLoading:Xo,onImageLoaded:Xo},nl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),tl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(el(n)&&!tl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){el(n)&&!tl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function el(n){return 0===n.button}function tl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Yo(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Qo(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Yo(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},rl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},il=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ol={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Vo(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Fo:Ro,transition:Ko+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Yo(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Yo(this.el,{transform:"none"})},grab:function(n,e,t){var a=ll(),r=a.x-n,i=a.y-e;Yo(this.el,{cursor:Ho,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=ll(),r=a.x-n,i=a.y-e;Yo(this.el,{transition:Ko,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Yo(this.el,this.styleClose)},restoreOpenStyle:function(){Yo(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=ll(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":rl(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var s=this.rect.width/2,o=this.rect.height/2,l=ll(),c={x:l.x-s,y:l.y-o},d=c.x/s,u=c.y/o,p=i+Math.min(d,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function ll(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function cl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Qo(n,a,e[a],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ol),this.overlay=Object.create(al),this.handler=Object.create(nl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},Zo,e),this.overlay.init(this),this.handler.init(this)}return il(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Uo,Qo(n,"click",this.handler.click),this.options.preloadImage&&$o(Vo(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),$o(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Qo(document,"scroll",this.handler.scroll),Qo(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Qo(window,"resize",this.handler.resizeWindow);var i=function n(){Qo(a,Wo,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&cl(document,e.handler,!0),t(a)};return Qo(a,Wo,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=qo,this.overlay.fadeOut(),this.target.zoomOut(),Qo(document,"scroll",this.handler.scroll,!1),Qo(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Qo(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Qo(t,Wo,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&cl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Qo(t,Wo,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Qo(r,Wo,n,!1),a(r)};return Qo(r,Wo,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ho,this.target.move(n,e,t);var r=this.target.el,i=function n(){Qo(r,Wo,n,!1),a(r)};return Qo(r,Wo,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=qo,this.target.restoreOpenStyle();var a=function a(){Qo(t,Wo,a,!1),n.lock=!1,n.released=!0,e(t)};return Qo(t,Wo,a),this}}}]),n}();const ul=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),pl=Number("500");class ml{constructor(){this.instance=new dl(ul)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=pl){setTimeout(()=>this.update(n),e)}}var hl=[fo,xo,ko,To,jo,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new ml,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return co("layout",n),$t.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},gl=t(6),bl=Object(gl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",hl);const vl=[{name:"v-5b01debe",path:"/pages/8d7d6e/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-5b01debe").then(t)}},{path:"/pages/8d7d6e/index.html",redirect:"/pages/8d7d6e/"},{path:"/01.指南/01.开篇介绍/01.文档介绍.html",redirect:"/pages/8d7d6e/"},{name:"v-36afde32",path:"/pages/f015b6/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-36afde32").then(t)}},{path:"/pages/f015b6/index.html",redirect:"/pages/f015b6/"},{path:"/01.指南/02.学习路线规划/01.学习路线规划.html",redirect:"/pages/f015b6/"},{name:"v-e990cafe",path:"/pages/1581f4/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-e990cafe").then(t)}},{path:"/pages/1581f4/index.html",redirect:"/pages/1581f4/"},{path:"/01.指南/03.计算机系统与网络/02.操作系统基本原理.html",redirect:"/pages/1581f4/"},{name:"v-cb672f88",path:"/pages/b49e95/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-cb672f88").then(t)}},{path:"/pages/b49e95/index.html",redirect:"/pages/b49e95/"},{path:"/01.指南/03.计算机系统与网络/04.网络信息安全.html",redirect:"/pages/b49e95/"},{name:"v-2780ee7f",path:"/pages/b3d4fe/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-2780ee7f").then(t)}},{path:"/pages/b3d4fe/index.html",redirect:"/pages/b3d4fe/"},{path:"/01.指南/04.数据库/02.MySQL概述.html",redirect:"/pages/b3d4fe/"},{name:"v-70dd68cc",path:"/pages/0ca117/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-70dd68cc").then(t)}},{path:"/pages/0ca117/index.html",redirect:"/pages/0ca117/"},{path:"/01.指南/03.计算机系统与网络/01.计算机组成与体系结构.html",redirect:"/pages/0ca117/"},{name:"v-47ed6a43",path:"/pages/4d8727/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-47ed6a43").then(t)}},{path:"/pages/4d8727/index.html",redirect:"/pages/4d8727/"},{path:"/01.指南/04.数据库/03.MySQL安装.html",redirect:"/pages/4d8727/"},{name:"v-faf15f2e",path:"/pages/454a1c/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-faf15f2e").then(t)}},{path:"/pages/454a1c/index.html",redirect:"/pages/454a1c/"},{path:"/01.指南/04.数据库/01.数据库系统.html",redirect:"/pages/454a1c/"},{name:"v-02970178",path:"/pages/7bb5a9/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-02970178").then(t)}},{path:"/pages/7bb5a9/index.html",redirect:"/pages/7bb5a9/"},{path:"/01.指南/04.数据库/05.MySQL的函数.html",redirect:"/pages/7bb5a9/"},{name:"v-6a3757ac",path:"/pages/fd02ba/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-6a3757ac").then(t)}},{path:"/pages/fd02ba/index.html",redirect:"/pages/fd02ba/"},{path:"/01.指南/03.计算机系统与网络/03.计算机网络.html",redirect:"/pages/fd02ba/"},{name:"v-3a027d70",path:"/pages/972c8f/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-3a027d70").then(t)}},{path:"/pages/972c8f/index.html",redirect:"/pages/972c8f/"},{path:"/01.指南/04.数据库/04.MySQL的SQL详解.html",redirect:"/pages/972c8f/"},{name:"v-782af799",path:"/pages/c2207f/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-782af799").then(t)}},{path:"/pages/c2207f/index.html",redirect:"/pages/c2207f/"},{path:"/01.指南/04.数据库/06.MySQL的约束.html",redirect:"/pages/c2207f/"},{name:"v-2ec934f2",path:"/pages/7cdfba/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-2ec934f2").then(t)}},{path:"/pages/7cdfba/index.html",redirect:"/pages/7cdfba/"},{path:"/01.指南/04.数据库/07.MySQL多表查询.html",redirect:"/pages/7cdfba/"},{name:"v-1a40dcf1",path:"/pages/751d08/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-1a40dcf1").then(t)}},{path:"/pages/751d08/index.html",redirect:"/pages/751d08/"},{path:"/01.指南/04.数据库/09.MySQL索引.html",redirect:"/pages/751d08/"},{name:"v-6f629324",path:"/pages/904c55/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-6f629324").then(t)}},{path:"/pages/904c55/index.html",redirect:"/pages/904c55/"},{path:"/01.指南/04.数据库/08.MySQL的事务.html",redirect:"/pages/904c55/"},{name:"v-0d5c43ac",path:"/pages/f5abb7/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-0d5c43ac").then(t)}},{path:"/pages/f5abb7/index.html",redirect:"/pages/f5abb7/"},{path:"/01.指南/05.面向对象/01.Java面向对象(上).html",redirect:"/pages/f5abb7/"},{name:"v-4cffe8e0",path:"/pages/d7dcc5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-4cffe8e0").then(t)}},{path:"/pages/d7dcc5/index.html",redirect:"/pages/d7dcc5/"},{path:"/01.指南/05.面向对象/03.面向对象设计总结.html",redirect:"/pages/d7dcc5/"},{name:"v-120c6a65",path:"/pages/a5fd33/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-120c6a65").then(t)}},{path:"/pages/a5fd33/index.html",redirect:"/pages/a5fd33/"},{path:"/01.指南/05.面向对象/02.Java面对对象(下).html",redirect:"/pages/a5fd33/"},{name:"v-fe401634",path:"/pages/2bb75b/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-fe401634").then(t)}},{path:"/pages/2bb75b/index.html",redirect:"/pages/2bb75b/"},{path:"/01.指南/06.数据结构/01.数据结构基本概念.html",redirect:"/pages/2bb75b/"},{name:"v-13cb7718",path:"/pages/a46aa1/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-13cb7718").then(t)}},{path:"/pages/a46aa1/index.html",redirect:"/pages/a46aa1/"},{path:"/01.指南/06.数据结构/02.线性表.html",redirect:"/pages/a46aa1/"},{name:"v-665fe5c9",path:"/pages/3e284b/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-665fe5c9").then(t)}},{path:"/pages/3e284b/index.html",redirect:"/pages/3e284b/"},{path:"/01.指南/06.数据结构/04.队列.html",redirect:"/pages/3e284b/"},{name:"v-3c3508ee",path:"/pages/925cd5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-3c3508ee").then(t)}},{path:"/pages/925cd5/index.html",redirect:"/pages/925cd5/"},{path:"/01.指南/06.数据结构/05.树的定义.html",redirect:"/pages/925cd5/"},{name:"v-0185fa5e",path:"/pages/a7d8d3/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-0185fa5e").then(t)}},{path:"/pages/a7d8d3/index.html",redirect:"/pages/a7d8d3/"},{path:"/01.指南/06.数据结构/07.二叉查找树.html",redirect:"/pages/a7d8d3/"},{name:"v-86be2110",path:"/pages/75c23c/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-86be2110").then(t)}},{path:"/pages/75c23c/index.html",redirect:"/pages/75c23c/"},{path:"/01.指南/06.数据结构/06.二叉树的遍历.html",redirect:"/pages/75c23c/"},{name:"v-e8336c5e",path:"/pages/bf255e/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-e8336c5e").then(t)}},{path:"/pages/bf255e/index.html",redirect:"/pages/bf255e/"},{path:"/01.指南/06.数据结构/08.平衡平衡树.html",redirect:"/pages/bf255e/"},{name:"v-24edf572",path:"/pages/830399/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-24edf572").then(t)}},{path:"/pages/830399/index.html",redirect:"/pages/830399/"},{path:"/01.指南/06.数据结构/09.堆.html",redirect:"/pages/830399/"},{name:"v-9abc4948",path:"/pages/41b93a/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-9abc4948").then(t)}},{path:"/pages/41b93a/index.html",redirect:"/pages/41b93a/"},{path:"/01.指南/06.数据结构/10.哈夫曼树.html",redirect:"/pages/41b93a/"},{name:"v-28e2e596",path:"/pages/9640b5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-28e2e596").then(t)}},{path:"/pages/9640b5/index.html",redirect:"/pages/9640b5/"},{path:"/01.指南/06.数据结构/11.图.html",redirect:"/pages/9640b5/"},{name:"v-5f4b4e88",path:"/pages/6e4306/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-5f4b4e88").then(t)}},{path:"/pages/6e4306/index.html",redirect:"/pages/6e4306/"},{path:"/01.指南/06.数据结构/03.堆栈.html",redirect:"/pages/6e4306/"},{name:"v-db48104a",path:"/pages/9e10e0/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-db48104a").then(t)}},{path:"/pages/9e10e0/index.html",redirect:"/pages/9e10e0/"},{path:"/01.指南/07.知识产权/01.知识产权标准化.html",redirect:"/pages/9e10e0/"},{name:"v-4ba6b42a",path:"/pages/beda9a/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-4ba6b42a").then(t)}},{path:"/pages/beda9a/index.html",redirect:"/pages/beda9a/"},{path:"/01.指南/08.程序语言设计/01.程序语言设计(上).html",redirect:"/pages/beda9a/"},{name:"v-fba7452c",path:"/pages/76f52a/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-fba7452c").then(t)}},{path:"/pages/76f52a/index.html",redirect:"/pages/76f52a/"},{path:"/01.指南/08.程序语言设计/02.程序语言设计(下).html",redirect:"/pages/76f52a/"},{name:"v-6faa9299",path:"/pages/52aecc/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-6faa9299").then(t)}},{path:"/pages/52aecc/index.html",redirect:"/pages/52aecc/"},{path:"/01.指南/09.软件工程/01.软件工程基础知识.html",redirect:"/pages/52aecc/"},{name:"v-c1e4cbf0",path:"/pages/4e3563/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-c1e4cbf0").then(t)}},{path:"/pages/4e3563/index.html",redirect:"/pages/4e3563/"},{path:"/01.指南/09.软件工程/02.软件工程题目.html",redirect:"/pages/4e3563/"},{name:"v-41b1c054",path:"/pages/3cb6ac/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-41b1c054").then(t)}},{path:"/pages/3cb6ac/index.html",redirect:"/pages/3cb6ac/"},{path:"/01.指南/10.UML/02.UML详解.html",redirect:"/pages/3cb6ac/"},{name:"v-1283332c",path:"/pages/f43aaa/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-1283332c").then(t)}},{path:"/pages/f43aaa/index.html",redirect:"/pages/f43aaa/"},{path:"/01.指南/10.UML/01.UML概述.html",redirect:"/pages/f43aaa/"},{name:"v-2f070f9c",path:"/pages/9bf5f0/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-2f070f9c").then(t)}},{path:"/pages/9bf5f0/index.html",redirect:"/pages/9bf5f0/"},{path:"/01.指南/10.UML/03.14种UML图.html",redirect:"/pages/9bf5f0/"},{name:"v-90759344",path:"/pages/fb9639/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-90759344").then(t)}},{path:"/pages/fb9639/index.html",redirect:"/pages/fb9639/"},{path:"/01.指南/11.数据流图/01.数据流图详解.html",redirect:"/pages/fb9639/"},{name:"v-74942003",path:"/pages/91b2e7/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-74942003").then(t)}},{path:"/pages/91b2e7/index.html",redirect:"/pages/91b2e7/"},{path:"/01.指南/12.数据库设计/01.数据库设计.html",redirect:"/pages/91b2e7/"},{name:"v-7e0c0407",path:"/pages/1575d1/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-7e0c0407").then(t)}},{path:"/pages/1575d1/index.html",redirect:"/pages/1575d1/"},{path:"/01.指南/12.数据库设计/03.数据流设计答题技巧.html",redirect:"/pages/1575d1/"},{name:"v-4455e40b",path:"/pages/55dfda/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-4455e40b").then(t)}},{path:"/pages/55dfda/index.html",redirect:"/pages/55dfda/"},{path:"/01.指南/13.Java设计模式/01.Java设计模式图解.html",redirect:"/pages/55dfda/"},{name:"v-fb50d35c",path:"/pages/5aa53b/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-fb50d35c").then(t)}},{path:"/pages/5aa53b/index.html",redirect:"/pages/5aa53b/"},{path:"/01.指南/13.Java设计模式/02.Java设计模式下午题目.html",redirect:"/pages/5aa53b/"},{name:"v-c40dde22",path:"/pages/70e421/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-c40dde22").then(t)}},{path:"/pages/70e421/index.html",redirect:"/pages/70e421/"},{path:"/01.指南/11.数据流图/02.数据流图答题技巧.html",redirect:"/pages/70e421/"},{name:"v-3bf4c9cb",path:"/pages/fb6ad7/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-3bf4c9cb").then(t)}},{path:"/pages/fb6ad7/index.html",redirect:"/pages/fb6ad7/"},{path:"/02.配置/02.思维导图复习/01.计算机结构思维导图.html",redirect:"/pages/fb6ad7/"},{name:"v-359c0910",path:"/pages/64d804/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-359c0910").then(t)}},{path:"/pages/64d804/index.html",redirect:"/pages/64d804/"},{path:"/02.配置/01.思维导图/01.思维导图学习导航.html",redirect:"/pages/64d804/"},{name:"v-f34049fe",path:"/pages/ac51c5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-f34049fe").then(t)}},{path:"/pages/ac51c5/index.html",redirect:"/pages/ac51c5/"},{path:"/02.配置/02.思维导图复习/02.程序设计语言思维导图.html",redirect:"/pages/ac51c5/"},{name:"v-41672a42",path:"/pages/0c2de5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-41672a42").then(t)}},{path:"/pages/0c2de5/index.html",redirect:"/pages/0c2de5/"},{path:"/02.配置/02.思维导图复习/04.面向对象思维导图.html",redirect:"/pages/0c2de5/"},{name:"v-7bd90c00",path:"/pages/57d5f6/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-7bd90c00").then(t)}},{path:"/pages/57d5f6/index.html",redirect:"/pages/57d5f6/"},{path:"/02.配置/02.思维导图复习/03.知识产权思维导图.html",redirect:"/pages/57d5f6/"},{name:"v-5bf6b476",path:"/pages/47a2c3/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-5bf6b476").then(t)}},{path:"/pages/47a2c3/index.html",redirect:"/pages/47a2c3/"},{path:"/02.配置/02.思维导图复习/06.数据结构思维导图.html",redirect:"/pages/47a2c3/"},{name:"v-0fa0e03a",path:"/pages/99cb22/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-0fa0e03a").then(t)}},{path:"/pages/99cb22/index.html",redirect:"/pages/99cb22/"},{path:"/02.配置/02.思维导图复习/07.排序算法思维导图.html",redirect:"/pages/99cb22/"},{name:"v-0a2e96d0",path:"/pages/0751c5/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-0a2e96d0").then(t)}},{path:"/pages/0751c5/index.html",redirect:"/pages/0751c5/"},{path:"/02.配置/03.复习笔记/01.软件设计师复习大纲.html",redirect:"/pages/0751c5/"},{name:"v-6c624ce1",path:"/pages/db78e2/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-6c624ce1").then(t)}},{path:"/pages/db78e2/index.html",redirect:"/pages/db78e2/"},{path:"/03.资源/01.资源.html",redirect:"/pages/db78e2/"},{name:"v-218f15ef",path:"/pages/9cc27d/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-218f15ef").then(t)}},{path:"/pages/9cc27d/index.html",redirect:"/pages/9cc27d/"},{path:"/04.问答/01.问答.html",redirect:"/pages/9cc27d/"},{name:"v-5617b67f",path:"/pages/1b12ed/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-5617b67f").then(t)}},{path:"/pages/1b12ed/index.html",redirect:"/pages/1b12ed/"},{path:"/05.支持/01.支持.html",redirect:"/pages/1b12ed/"},{name:"v-504fe09d",path:"/blog/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-504fe09d").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-0d6c806e",path:"/",component:bl,beforeEnter:(n,e,t)=>{lo("Layout","v-0d6c806e").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bl}],yl={title:"软件设计师",description:"一分耕耘一分收获",base:"/exam/",headTags:[["link",{rel:"icon",href:"/exam/img/lu.png"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"6c4b761a28b734fe93831e3fb400ce87"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}]],pages:[{title:"文档系统介绍",frontmatter:{title:"文档系统介绍",date:"2022-08-30T21:47:09.000Z",categories:["指南"],tags:["指南"],permalink:"/pages/8d7d6e"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D/01.%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D.html",relativePath:"01.指南/01.开篇介绍/01.文档介绍.md",key:"v-5b01debe",path:"/pages/8d7d6e/",headers:[{level:2,title:"1.本仓库说明",slug:"_1-本仓库说明",normalizedTitle:"1.本仓库说明",charIndex:20},{level:2,title:"2.是否长期更新",slug:"_2-是否长期更新",normalizedTitle:"2.是否长期更新",charIndex:131},{level:2,title:"3.报考软考方式",slug:"_3-报考软考方式",normalizedTitle:"3.报考软考方式",charIndex:232},{level:2,title:"4.文档的目的",slug:"_4-文档的目的",normalizedTitle:"4.文档的目的",charIndex:463}],headersStr:"1.本仓库说明 2.是否长期更新 3.报考软考方式 4.文档的目的",content:"VuePress-Docs\n\n\n\n\n# 1.本仓库说明\n\n * 😶‍🌫️ 仓库开源，支持随时Fork和下载\n * 😶‍🌫️该文档知识库是用来记录软件设计师考试的复习内容\n * 😶‍🌫️无任何利益牵扯\n * 😶‍🌫️免费查看所有的文档笔记\n\n\n# 2.是否长期更新\n\n * ✨因为某些原因所以不能长期更新\n * ✨如需更新上传文件或者笔记的小伙伴可以联系我\n * ✨本文档知识库暂时只支持静，不支持评论功能\n * ✨博主会不定时更新一些笔记\n\n\n# 3.报考软考方式\n\n * 🎉全国计算机软件技术考试报名官网： https://bm.ruankao.org.cn/sign/welcome\n * 🎉B站学习链接： https://space.bilibili.com/91286799\n * 🎉本网站学习链接：https://kryust.github.io/exam/\n\n\n\n微信号 有问题扫码添加   本知识文档开源\n              \n              😶‍🌫️\n\n\n\n\n# 4.文档的目的\n\n构建本文档做软考复习是我一开始就想到的，可以通过本网站的复习和学习路线的规划，再加上刷视频学习，可以轻松过软考。我也会结合小绿龙的规划整理给大家。\n\n 1. 😶‍🌫️为广大的软设考生提供免费的复习\n 2. 😶‍🌫️找到一个总和整理的文档笔记很难\n 3. 😶‍🌫️需要整理一些笔记放在一起方便复习\n 4. 😶‍🌫️并没有提供太多的做题详解\n\n\n祝每届考生顺利通过软设考试",normalizedContent:"vuepress-docs\n\n\n\n\n# 1.本仓库说明\n\n * 😶‍🌫️ 仓库开源，支持随时fork和下载\n * 😶‍🌫️该文档知识库是用来记录软件设计师考试的复习内容\n * 😶‍🌫️无任何利益牵扯\n * 😶‍🌫️免费查看所有的文档笔记\n\n\n# 2.是否长期更新\n\n * ✨因为某些原因所以不能长期更新\n * ✨如需更新上传文件或者笔记的小伙伴可以联系我\n * ✨本文档知识库暂时只支持静，不支持评论功能\n * ✨博主会不定时更新一些笔记\n\n\n# 3.报考软考方式\n\n * 🎉全国计算机软件技术考试报名官网： https://bm.ruankao.org.cn/sign/welcome\n * 🎉b站学习链接： https://space.bilibili.com/91286799\n * 🎉本网站学习链接：https://kryust.github.io/exam/\n\n\n\n微信号 有问题扫码添加   本知识文档开源\n              \n              😶‍🌫️\n\n\n\n\n# 4.文档的目的\n\n构建本文档做软考复习是我一开始就想到的，可以通过本网站的复习和学习路线的规划，再加上刷视频学习，可以轻松过软考。我也会结合小绿龙的规划整理给大家。\n\n 1. 😶‍🌫️为广大的软设考生提供免费的复习\n 2. 😶‍🌫️找到一个总和整理的文档笔记很难\n 3. 😶‍🌫️需要整理一些笔记放在一起方便复习\n 4. 😶‍🌫️并没有提供太多的做题详解\n\n\n祝每届考生顺利通过软设考试",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"软考学习路线规划",frontmatter:{title:"软考学习路线规划",date:"2022-12-18T12:06:08.000Z",permalink:"/pages/f015b6/"},regularPath:"/01.%E6%8C%87%E5%8D%97/02.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/01.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92.html",relativePath:"01.指南/02.学习路线规划/01.学习路线规划.md",key:"v-36afde32",path:"/pages/f015b6/",headers:[{level:2,title:"软考复习路线",slug:"软考复习路线",normalizedTitle:"软考复习路线",charIndex:2},{level:3,title:"上午题",slug:"上午题",normalizedTitle:"上午题",charIndex:19},{level:3,title:"下午题",slug:"下午题",normalizedTitle:"下午题",charIndex:24},{level:2,title:'如何准备资料复习 "一切的开端"',slug:"如何准备资料复习-一切的开端",normalizedTitle:"如何准备资料复习 &quot;一切的开端&quot;",charIndex:null},{level:2,title:'如何准备资料复习 "正式开始"',slug:"如何准备资料复习-正式开始",normalizedTitle:"如何准备资料复习 &quot;正式开始&quot;",charIndex:null},{level:3,title:"软考通APP",slug:"软考通app",normalizedTitle:"软考通app",charIndex:992},{level:3,title:"软件设计师真题练习",slug:"软件设计师真题练习",normalizedTitle:"软件设计师真题练习",charIndex:1106},{level:3,title:"复习总结",slug:"复习总结",normalizedTitle:"复习总结",charIndex:1220},{level:2,title:"如何入门第一篇 “计算机系统结构”",slug:"如何入门第一篇-计算机系统结构",normalizedTitle:"如何入门第一篇 “计算机系统结构”",charIndex:1570},{level:2,title:"如何掌握难点 ”数据结构与算法“",slug:"如何掌握难点-数据结构与算法",normalizedTitle:"如何掌握难点 ”数据结构与算法“",charIndex:1705},{level:2,title:"学好设计模式 ”23中设计模式“",slug:"学好设计模式-23中设计模式",normalizedTitle:"学好设计模式 ”23中设计模式“",charIndex:2172}],headersStr:'软考复习路线 上午题 下午题 如何准备资料复习 "一切的开端" 如何准备资料复习 "正式开始" 软考通APP 软件设计师真题练习 复习总结 如何入门第一篇 “计算机系统结构” 如何掌握难点 ”数据结构与算法“ 学好设计模式 ”23中设计模式“',content:'# 软考复习路线\n\n软件设计师总共分为上午题目和下午题目，上午为选择题，下午为是实操题。都是75分满分，45分是及格。\n\n\n# 上午题\n\n 1.  计算机硬件基础\n 2.  操作系统\n 3.  多媒体基础\n 4.  知识产权与标准化\n 5.  计算机网络\n 6.  数据库系统\n 7.  程序设计语言\n 8.  面向对象\n 9.  软件工程基础知识(难点)\n 10. 数据结构与算法(难点)\n\n\n\n\n# 下午题\n\n> 注意: C语言算法是必须的, 5和6的设计模式需要二选一。\n\n 1. 数据流图\n 2. 数据库设计\n 3. UML建模\n 4. C语言算法\n 5. C++语言程序设计 (设计模式)\n 6. Java语言程序设计 (设计模式)\n\n\n\n\n# 如何准备资料复习 "一切的开端"\n\n首先你需要找到正确的方式去学习或者去复习，所以资料就非常的关键，如果你要花长时间去备考，可以看那三本巨厚的书，当然看下去也是需要很长的时间去消化各种知识，如果你需要短时间备考或者说你是一个零基础的小伙伴，可以选择较稳妥的时间去备考，2-3个月适合零基础的同学备考，这里力顶一个适合零基础的B站UP主， ”小绿龙“。\n\nUP的主页地址： https://space.bilibili.com/91286799\n\n\n\n介绍一下：\n\n * 小绿龙： 专注软考设计师的优质讲师\n * 视频推荐的目的： 免费、讲的好、细心、分好了章节、分好了学习路线、按着视频学习路线学习即可。\n * 资料： 资料齐全，进群就是VIP用户。\n\n----------------------------------------\n\n有人就会问了： 怎么播放量这么少？\n\n你见过考前复习，一排的人手机都是打开的B站看小绿龙的视频和资料复习下午题吗？\n\n有人就会问了：希赛的不比这个好？\n\n希赛是收费的，讲的确实不错，但是考前也会公布免费的复习资料，确实很不错，但是本人喜欢白嫖。\n\n有人就会问了：这么多视频刷不完怎么办？\n\n你要考试你就认真的去看视频做笔记，不要想着一遍过脑，多做题。刷不完就是你的问题。\n\n有人就会问了： UP帅吗？\n\n我可以很明确的告诉你，UP有时候很帅，有时候帅爆了。\n\n----------------------------------------\n\n\n# 如何准备资料复习 "正式开始"\n\n\n# 软考通APP\n\n首选你需要手机下载一个APP，软考通。软考通的目的是： 你学完一章节的理论，进行软考通选择软件设计师刷题，选择学习的章节进行刷题，对知识的复习和巩固，做错的题目一定要看解析，一定要看解析。解析非常重要。\n\n\n# 软件设计师真题练习\n\n我的建议是，你能手写就不要对着电脑去做，你手写的效果会比对着电脑去做效果更高，用笔推理出来的答案会让你脑子更加深刻印象。\n\n就是一本软件设计师历年真题的总和，我练习的是2018-2022年的。\n\n\n\n\n# 复习总结\n\n可以使用电脑的笔记软件把软件设计师的上午题和下午题考点的详细知识点进行总结，就当写笔记一样，也可以用几张空白的纸写一遍，让脑子过一遍记住有什么需要考，哪些是重点，哪些是需要记的知识点，查缺补漏。\n\n我的时间规划是：\n\n我不是零基础，只会一点数据库和计算机网络以及计算机结构和Java\n\n 1. 3-4天的时间去看需要掌握哪些考点，寻找资料，挑选高质量的资料进行浏览一遍。\n 2. 1个月的时间对上午题的理论进行学习，然后交叉使用软考通APP做题，或者跟着电子档做题。\n 3. 10天的时间学习下午题目的理论 （把历年真题写完）\n 4. 5天的时间琢磨下午题的技巧和方法，对题目的理解做分析。\n 5. 1天的时间打印准考、复习上午题理论，过一遍真题。我的下午题是考前2小时复习的。\n\n\n# 如何入门第一篇 “计算机系统结构”\n\n我的笔记并不是很详细，但是推荐小林的图解计算机基础\n\n小林的文档系统地址: https://xiaolincoding.com/\n\n * 😍个人认为讲解的超级好\n * 😍通俗易懂\n * 😍印象深刻\n * 😍建议收藏\n\n\n# 如何掌握难点 ”数据结构与算法“\n\n这里推荐一个图解数据结构和算法的网站，很适合学习：\n\nVISUUALGO网站： https://visualgo.net/zh\n\n * ✨适合新手\n * ✨适合不喜欢枯燥的理论的小伙伴\n * ✨可以按照步骤进行观察\n * ✨动态图解+解析\n\n推荐一个GitHub的学习数据结构和算法的项目\n\nlabuladong的开源项目： https://github.com/labuladong/fucking-algorithm\n\n * ✨偏理论和代码实践\n * ✨需要有C或者Java基础的小伙伴\n * ✨有很好的图解和解析\n * ✨记得给Star\n\n推荐一个GitHub的记录浙江大学的数据结构与算法的教程项目\n\n叫我皮卡丘： https://github.com/callmePicacho/Data-Structres\n\n * ✨偏理论和代码实践\n * ✨需要有C或者Java基础的小伙伴\n * ✨有很好的图解和解析\n * ✨记得给Star\n\n> 当然，还可以参考B站UP的数据结构教程。\n\n\n# 学好设计模式 ”23中设计模式“\n\n设计模式暂且只针对Java的设计模式，因为我不会c++的设计模式。\n\n这里推荐一个非常棒的Java设计模式学习网站\n\n设计模式：https://refactoringguru.cn/design-patterns/java\n\n * 🏅图解+文字解析+代码示例+Java的应用\n * 🏅整个网站界面非常简洁优雅\n * 🏅有非常详细的介绍每一个设计模式\n * 🏅初学Java设计模式很推荐\n\n推荐一个Java全栈知识体系网站：\n\nJava全栈知识体系： https://pdai.tech/md/dev-spec/pattern/1_overview.html\n\n * 🏅这里主要看一下设计模式的概念和理论\n * 🏅也有非常好的图解+代码实现讲解\n * 🏅写的非常的详细\n * 🏅记得多理解+练习',normalizedContent:'# 软考复习路线\n\n软件设计师总共分为上午题目和下午题目，上午为选择题，下午为是实操题。都是75分满分，45分是及格。\n\n\n# 上午题\n\n 1.  计算机硬件基础\n 2.  操作系统\n 3.  多媒体基础\n 4.  知识产权与标准化\n 5.  计算机网络\n 6.  数据库系统\n 7.  程序设计语言\n 8.  面向对象\n 9.  软件工程基础知识(难点)\n 10. 数据结构与算法(难点)\n\n\n\n\n# 下午题\n\n> 注意: c语言算法是必须的, 5和6的设计模式需要二选一。\n\n 1. 数据流图\n 2. 数据库设计\n 3. uml建模\n 4. c语言算法\n 5. c++语言程序设计 (设计模式)\n 6. java语言程序设计 (设计模式)\n\n\n\n\n# 如何准备资料复习 "一切的开端"\n\n首先你需要找到正确的方式去学习或者去复习，所以资料就非常的关键，如果你要花长时间去备考，可以看那三本巨厚的书，当然看下去也是需要很长的时间去消化各种知识，如果你需要短时间备考或者说你是一个零基础的小伙伴，可以选择较稳妥的时间去备考，2-3个月适合零基础的同学备考，这里力顶一个适合零基础的b站up主， ”小绿龙“。\n\nup的主页地址： https://space.bilibili.com/91286799\n\n\n\n介绍一下：\n\n * 小绿龙： 专注软考设计师的优质讲师\n * 视频推荐的目的： 免费、讲的好、细心、分好了章节、分好了学习路线、按着视频学习路线学习即可。\n * 资料： 资料齐全，进群就是vip用户。\n\n----------------------------------------\n\n有人就会问了： 怎么播放量这么少？\n\n你见过考前复习，一排的人手机都是打开的b站看小绿龙的视频和资料复习下午题吗？\n\n有人就会问了：希赛的不比这个好？\n\n希赛是收费的，讲的确实不错，但是考前也会公布免费的复习资料，确实很不错，但是本人喜欢白嫖。\n\n有人就会问了：这么多视频刷不完怎么办？\n\n你要考试你就认真的去看视频做笔记，不要想着一遍过脑，多做题。刷不完就是你的问题。\n\n有人就会问了： up帅吗？\n\n我可以很明确的告诉你，up有时候很帅，有时候帅爆了。\n\n----------------------------------------\n\n\n# 如何准备资料复习 "正式开始"\n\n\n# 软考通app\n\n首选你需要手机下载一个app，软考通。软考通的目的是： 你学完一章节的理论，进行软考通选择软件设计师刷题，选择学习的章节进行刷题，对知识的复习和巩固，做错的题目一定要看解析，一定要看解析。解析非常重要。\n\n\n# 软件设计师真题练习\n\n我的建议是，你能手写就不要对着电脑去做，你手写的效果会比对着电脑去做效果更高，用笔推理出来的答案会让你脑子更加深刻印象。\n\n就是一本软件设计师历年真题的总和，我练习的是2018-2022年的。\n\n\n\n\n# 复习总结\n\n可以使用电脑的笔记软件把软件设计师的上午题和下午题考点的详细知识点进行总结，就当写笔记一样，也可以用几张空白的纸写一遍，让脑子过一遍记住有什么需要考，哪些是重点，哪些是需要记的知识点，查缺补漏。\n\n我的时间规划是：\n\n我不是零基础，只会一点数据库和计算机网络以及计算机结构和java\n\n 1. 3-4天的时间去看需要掌握哪些考点，寻找资料，挑选高质量的资料进行浏览一遍。\n 2. 1个月的时间对上午题的理论进行学习，然后交叉使用软考通app做题，或者跟着电子档做题。\n 3. 10天的时间学习下午题目的理论 （把历年真题写完）\n 4. 5天的时间琢磨下午题的技巧和方法，对题目的理解做分析。\n 5. 1天的时间打印准考、复习上午题理论，过一遍真题。我的下午题是考前2小时复习的。\n\n\n# 如何入门第一篇 “计算机系统结构”\n\n我的笔记并不是很详细，但是推荐小林的图解计算机基础\n\n小林的文档系统地址: https://xiaolincoding.com/\n\n * 😍个人认为讲解的超级好\n * 😍通俗易懂\n * 😍印象深刻\n * 😍建议收藏\n\n\n# 如何掌握难点 ”数据结构与算法“\n\n这里推荐一个图解数据结构和算法的网站，很适合学习：\n\nvisuualgo网站： https://visualgo.net/zh\n\n * ✨适合新手\n * ✨适合不喜欢枯燥的理论的小伙伴\n * ✨可以按照步骤进行观察\n * ✨动态图解+解析\n\n推荐一个github的学习数据结构和算法的项目\n\nlabuladong的开源项目： https://github.com/labuladong/fucking-algorithm\n\n * ✨偏理论和代码实践\n * ✨需要有c或者java基础的小伙伴\n * ✨有很好的图解和解析\n * ✨记得给star\n\n推荐一个github的记录浙江大学的数据结构与算法的教程项目\n\n叫我皮卡丘： https://github.com/callmepicacho/data-structres\n\n * ✨偏理论和代码实践\n * ✨需要有c或者java基础的小伙伴\n * ✨有很好的图解和解析\n * ✨记得给star\n\n> 当然，还可以参考b站up的数据结构教程。\n\n\n# 学好设计模式 ”23中设计模式“\n\n设计模式暂且只针对java的设计模式，因为我不会c++的设计模式。\n\n这里推荐一个非常棒的java设计模式学习网站\n\n设计模式：https://refactoringguru.cn/design-patterns/java\n\n * 🏅图解+文字解析+代码示例+java的应用\n * 🏅整个网站界面非常简洁优雅\n * 🏅有非常详细的介绍每一个设计模式\n * 🏅初学java设计模式很推荐\n\n推荐一个java全栈知识体系网站：\n\njava全栈知识体系： https://pdai.tech/md/dev-spec/pattern/1_overview.html\n\n * 🏅这里主要看一下设计模式的概念和理论\n * 🏅也有非常好的图解+代码实现讲解\n * 🏅写的非常的详细\n * 🏅记得多理解+练习',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"操作系统基本原理",frontmatter:{title:"操作系统基本原理",date:"2022-09-05T00:04:20.000Z",permalink:"/pages/1581f4/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BD%91%E7%BB%9C/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"01.指南/03.计算机系统与网络/02.操作系统基本原理.md",key:"v-e990cafe",path:"/pages/1581f4/",headers:[{level:2,title:"操作系统基本原理",slug:"操作系统基本原理",normalizedTitle:"操作系统基本原理",charIndex:2},{level:2,title:"1. 操作系统概述",slug:"_1-操作系统概述",normalizedTitle:"1. 操作系统概述",charIndex:15},{level:3,title:"1.1 操作系统概述",slug:"_1-1-操作系统概述",normalizedTitle:"1.1 操作系统概述",charIndex:29},{level:3,title:"1.2 内容大纲",slug:"_1-2-内容大纲",normalizedTitle:"1.2 内容大纲",charIndex:189},{level:2,title:"2. 操作系统原理",slug:"_2-操作系统原理",normalizedTitle:"2. 操作系统原理",charIndex:204},{level:3,title:"2.1 进程",slug:"_2-1-进程",normalizedTitle:"2.1 进程",charIndex:218},{level:3,title:"2.1.1 进程的概念",slug:"_2-1-1-进程的概念",normalizedTitle:"2.1.1 进程的概念",charIndex:229},{level:3,title:"2.1.2 进程的管理状态",slug:"_2-1-2-进程的管理状态",normalizedTitle:"2.1.2 进程的管理状态",charIndex:341},{level:3,title:"2.1.3 前趋图",slug:"_2-1-3-前趋图",normalizedTitle:"2.1.3 前趋图",charIndex:392},{level:3,title:"2.1.4 进程的PV操作",slug:"_2-1-4-进程的pv操作",normalizedTitle:"2.1.4 进程的pv操作",charIndex:676},{level:3,title:"2.1.5 死锁",slug:"_2-1-5-死锁",normalizedTitle:"2.1.5 死锁",charIndex:1237},{level:3,title:"2.1.6 存储管理",slug:"_2-1-6-存储管理",normalizedTitle:"2.1.6 存储管理",charIndex:1524},{level:3,title:"2.1.7 快表",slug:"_2-1-7-快表",normalizedTitle:"2.1.7 快表",charIndex:2692},{level:3,title:"2.1.8 文件管理",slug:"_2-1-8-文件管理",normalizedTitle:"2.1.8 文件管理",charIndex:2846},{level:3,title:"2.1.9 特殊操作系统",slug:"_2-1-9-特殊操作系统",normalizedTitle:"2.1.9 特殊操作系统",charIndex:3238},{level:3,title:"2.1.10 微内核操作系统",slug:"_2-1-10-微内核操作系统",normalizedTitle:"2.1.10 微内核操作系统",charIndex:4419}],headersStr:"操作系统基本原理 1. 操作系统概述 1.1 操作系统概述 1.2 内容大纲 2. 操作系统原理 2.1 进程 2.1.1 进程的概念 2.1.2 进程的管理状态 2.1.3 前趋图 2.1.4 进程的PV操作 2.1.5 死锁 2.1.6 存储管理 2.1.7 快表 2.1.8 文件管理 2.1.9 特殊操作系统 2.1.10 微内核操作系统",content:"# 操作系统基本原理\n\n\n# 1. 操作系统概述\n\n\n# 1.1 操作系统概述\n\n操作系统 （英语：Operating System，缩写：OS） 是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。根据运行的环境，操作系统可以分为桌面操作系统，手机操作系统，服务器操作系统，嵌入式操作系统等。\n\n基本的概述图\n\n\n\n\n# 1.2 内容大纲\n\n\n\n\n# 2. 操作系统原理\n\n\n# 2.1 进程\n\n\n# 2.1.1 进程的概念\n\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，通常一个进程中包含多个线程。有就绪、运行、阻塞三种基本状态。\n\n\n# 2.1.2 进程的管理状态\n\n进程的状态分为三种：\n\n * 运行\n * 就绪\n * 等待\n\n\n\n\n# 2.1.3 前趋图\n\n\n\n进程的同步和互斥\n\n * 互斥：在同一时刻，只允许某一个进程使用资源。即同一资源不能同时服务多个资源。反义词是共享。\n * 同步：快的进程等待速度慢的进程。反义词是异步。\n\n生产者 --\x3e         /资源/         --\x3e  消费者      //单缓冲区情况\n生产者 --\x3e  /资源/ /资源/ /资源/  --\x3e   消费者     //多缓冲区情况\n\n\n> 注意：单缓冲区只允许消费者或生产者其中之一操作（互斥），多缓冲区不影响生产者往里塞，资源满了生产者才会停下等待，资源空了消费者才会停下来等待（同步）。\n\n\n# 2.1.4 进程的PV操作\n\nP表示通过的意思，V表示释放的意思，V操作是不具备阻塞的能力的。\n\n * 临界资源： 各个进程中需要抢着使用（互斥）的资源。\n * 临界区： 每个进程中访问临界资源的那段代码成为临界区\n * 信号量： 是一中特殊的变量\n\n\n\n * P操作会将信号量S减1，如果S<0则会阻塞进入等待队列，否则继续执行。\n * V操作会将信号量S加1，如果S≤0则会将进程取出队列，否则继续执行。\n\n🌰：假如S1初值为1，S2初值为0 按时间顺序看如下表格，注意上图是PV操作，不是生产者和消费者别搞蒙了。\n\n生产者             信号量               状态\n生产一个产品 P(S1)    S1 = 1 - 1 = 0    继续执行\n送产品到缓冲区 V(S2)   S2 = 0 + 1 = 1    继续执行\n生产一个产品 P(S1)    S1 = 0 - 1 = -1   阻塞进入等待队\n\n消费者              信号量               状态\nP(S2) 从缓冲区取出产品   S2 = -1 + 1 = 0   继续执行\nV(S1) 消费产品       S1 = -1 +1 = 0    唤醒生产者继续执行\n\n进程的PV结合前趋图\n\n\n\n\n# 2.1.5 死锁\n\n如果一个进程在等待一件不可能发生的事情，则进程进入死锁状态。而如果一个或多个进程产生死锁，就会造成系统死锁。\n\n造成死锁的四大条件\n\n 1. 互斥：所需资源通过互斥方式对其进行共享\n\n 2. 保持等待：进程会对资源进行锁定等待，不会释放资源\n\n 3. 不剥夺：进程在对资源进行调用时候，不会根据优先级进行资源掠夺，抢夺其他进程的资源\n\n 4. 环路等待：进程之间相互等待资源，即A进程等待B进程完成，B进程等待C进程完成，C进程等待A进程完成，形成等待环路\n\n死锁的预防：打破上述的死锁四大条件之一。\n\n死锁的避免：有序资源分配法，银行家算法。\n\n\n# 2.1.6 存储管理\n\n🥩逻辑地址与物理地址\n\n * 逻辑地址在计算机体系结构中是指应用程序角度看到的内存单元、存储单元、网络主机的地址。\n * 物理地址是指主存的某个可以让数据总线访问的特定存储单元地址。\n\n🥩地址重定向\n\n程序和数据装入内存时，需对目标程序中的地址进行修改。这种把逻辑地址转变为内存物理地址的过程称作为地址重向。\n\n地址重定向又分两种：\n\n * 静态重定向\n * 动态重定向\n\n🥩静态重定位\n\n目标程序装入内存时进行地址转换，在程序执行期间将不会再发生变化。\n\n 1. 优点：无须硬件地址变化机构（寄存器）的支持，只需要程序本身是可重定位的。\n 2. 缺点：位置固定，不便共享。\n\n🥩动态重定位\n\n程序运行期间完成逻辑地址到物理地址的转变，其实现机制依赖硬件地址变化机构（基地址寄存器）。\n\n 1. 优点：位置可变，不必连续；易于共享。\n 2. 缺点：需要附加硬件支持。\n\n1）分区存储组织\n\n例子：某计算机系统的内存大小为128k,采用可变分区分配方式进行内存分配，当前系统的内 存分块情况如下图所示，现有作业4申请内存9k,几种不同的存储分配算法在分配中，会产生什么样的结果呢？\n\n\n\n2）页式存储组织\n\n将程序与内存均划分为相同大小的块，以页为单位将程序调入内存。\n\n * 优点：利用率高，碎片小，分配及管理简单\n * 缺点：增加了系统的开销；可能产生抖动现象\n\n1.地址结构\n\n * 页式存储地址由两部分组成：页号和页内地址（偏移量）。页的大小一般为512B~8KB。\n\n * 假设页地址长度为32位，操作系统页大小为 4K，即通过短除法，对十进制字节大小转换成二进制，计算出十进制数码4096的二进制数表示为：从右到左数，最多存在12个连续的0位数码，得到页内偏移量为12。\n\n2.地址映射\n\n3.淘汰机制\n\n 1. 优先淘汰访问位置为0（最近未被访问）数据\n 2. 其次淘汰修改位置为0（最近未被修改）数据\n 3. 最后淘汰状态位置为0（不在内存中）数据\n\n\n\n3）段式存储组织\n\n按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。\n\n 1. 优点：多道程序共享内存，各段程序修改互不影响。\n 2. 缺点：内存利用率低，内存碎片浪费大。\n\n\n\n地址映射\n\n4）段页式存储\n\n段式与页式的综合体。先分段，再分页。1个程序有若干段，每个段中可以有若干项，每个页的大小相同，但每个段的大小不同。\n\n 1. 优点：空间浪费小，存储共享容易，存储保护容易，能动态连接。\n 2. 缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降。\n\n地址结构\n\n段页式存储地址由三部分组成：段号、页号和页内地址。\n\n\n\n动态地址转换\n\n\n\n\n# 2.1.7 快表\n\n快表是一块容量小的相联存储器(AssociativeMemory)，由高速缓存器组成，速度快，并且可以从硬件上保证内按容并行查找，一用般来存放当前访问最频繁少数的活动页面的页号。\n\n * 快表: 将 页 表 存 Cache 于 上;\n * 慢表 : 将 表页 存 于 内 存上。\n\n\n# 2.1.8 文件管理\n\n1.索引文件结构\n\n文件索引结构是指一个文件的信息存放在若干不连续的物理块中，系统为每个文件建立一个专用的数据结构——索引表，并将这些块号存放在索引表中。\n\n文件在逻辑上一定是连续的，在物理上是可以分散的。\n\n\n\n2.位示图\n\n位示图是利用二进制的一位（0或1）来表示磁盘中的一个盘块（物理块）的使用情况，当其值为0时表示空闲，当值为1时表示占用。\n\n\n\n3.树形目录结构\n\n文件属性\n\n * R 只读文件属性\n * A 存档属性\n * S 系统文件\n * H 隐藏文件\n\n文件名组成\n\n * 驱动器号\n * 路径\n * 主文件名\n * 扩展名\n\n绝对路径与相对路径\n\n * 绝对路径：是从盘符开始的路径。\n * 相对路径：是从当前目录开始的路径。\n * 若当前目录为：D1，要求F2路径，则：绝对路径：/D1/W2/F2，相对路径：W2/F2。\n\n\n\n\n# 2.1.9 特殊操作系统\n\n1.嵌入式操作系统 EOS\n\n嵌入式系统主要由嵌入式硬件平台、相关支撑硬件、嵌入式操作系统、支撑软件和应用软件组成。其中，嵌入性、专用性和计算机系统是嵌入式系统的三个核心要素。\n\n典型的嵌入式系统具有以下特点\n\n * 系统专用性强\n\n * 系统实时性强\n\n * 软硬件依赖性强\n\n * 处理器专用\n\n * 多种技术紧密结合\n\n * 系统透明性\n\n * 系统资源受限\n\n嵌入式操作系统特点\n\n * 微型化\n\n * 代码质量高\n\n * 专业化\n\n * 实时性强\n\n * 可裁剪可配置\n\n针对不同的硬件平台，操作系统通常建立在一个硬件抽象层（HAL）上，该层位于底层硬件和内核之间，为内核提供各种方便移植的宏定义接口，在不同的平台间移植时，只需要修改宏定义即可。与硬件相关，与操作系统相关。\n\n交叉开发环境\n\n由于嵌入式单板的资源有限，不能在单板上运行开发和调试工具，通常需要交叉编译调试的方式进行开发调试，即“宿主机+目标机”的形式，宿主机一般采用串口连接，也可同时通过网口或者JTAG连接。\n\n\n\n低功耗设计\n\n基于硬件的低功耗设计：板级电路低功耗设计；选择低功耗处理器；总线的低功耗设计；接口驱动电路的设计；分区分时供电技术。\n\n基于软件的低功耗设计：编译优化技术（指令开销）；软件与硬件的系统设计（硬件功能交由软件完成）；算法优化（低时间复杂度）。\n\n2.实时操作系统（RTOS）\n\n实时性能指标\n\n * 任务切换时间\n\n * 系统响应时间（对用户的输入或请求作出反应的时间）\n\n * 信号量混洗时间（指从一个任务释放信号量到另一个等待该信号量的任务被激活的时间延迟）\n\n * 中断处理相关的时间指标\n   \n   * 中断延迟时间\n   \n   * 中断响应时间\n\n多任务调度算法\n\n 1. 优先级调度算法：分配一个相对固定的优先顺序，然后调度程序根据优先级的高低排序，按时间顺序进行高优先级任务优先调度。（非抢占式）\n\n 2. 抢占式调度算法：是在优先级调度算法的基础上，允许高优先级任务抢占低优先级任务而运行。\n\n 3. 时间轮转调度算法：调度程序会依次调度每个任务运行一个小的时间片，然后再调度另一个任务。每个任务运行完一个时间片，无论是否结束都会释放CPU让下一个任务运行。（纯粹的时间轮转调度无法满足实时系统的要求，取而代之的是给予优先级的抢占式时间轮转调度）\n\n 4. 最晚截止期调度算法：指调度程序按每个任务的最接近其截至期末端的时间进行调度。\n\n 5. 最早截至期调度算法：指调度程序按每个任务的截至时间，选择最早到截止期头端时间的任务进行调度。\n\n在RTOS中，大多数RTOS调度算法都是抢占式的。\n\n实时操作系统比较\n\n常见的嵌入式RTOS有：VxWorks、RT-Linux、QNX、pSOS。\n\n\n\n\n# 2.1.10 微内核操作系统\n\n现代操作系统大多拥有两种工作状态，分别是核心态和用户态。一般应用程序工作在用户态，而内核模块和最基本的操作系统核心在核心态。\n\n\n\n将传统的操作系统代码放置到更高层，从操作系统中去掉尽可能多的东西，而只留下最小的核心，称之为微内核（C/S结构）。\n\n操作系统的内核服务：异常和中断、计时器、I/O管理等。\n\n",normalizedContent:"# 操作系统基本原理\n\n\n# 1. 操作系统概述\n\n\n# 1.1 操作系统概述\n\n操作系统 （英语：operating system，缩写：os） 是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。根据运行的环境，操作系统可以分为桌面操作系统，手机操作系统，服务器操作系统，嵌入式操作系统等。\n\n基本的概述图\n\n\n\n\n# 1.2 内容大纲\n\n\n\n\n# 2. 操作系统原理\n\n\n# 2.1 进程\n\n\n# 2.1.1 进程的概念\n\n进程（process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，通常一个进程中包含多个线程。有就绪、运行、阻塞三种基本状态。\n\n\n# 2.1.2 进程的管理状态\n\n进程的状态分为三种：\n\n * 运行\n * 就绪\n * 等待\n\n\n\n\n# 2.1.3 前趋图\n\n\n\n进程的同步和互斥\n\n * 互斥：在同一时刻，只允许某一个进程使用资源。即同一资源不能同时服务多个资源。反义词是共享。\n * 同步：快的进程等待速度慢的进程。反义词是异步。\n\n生产者 --\x3e         /资源/         --\x3e  消费者      //单缓冲区情况\n生产者 --\x3e  /资源/ /资源/ /资源/  --\x3e   消费者     //多缓冲区情况\n\n\n> 注意：单缓冲区只允许消费者或生产者其中之一操作（互斥），多缓冲区不影响生产者往里塞，资源满了生产者才会停下等待，资源空了消费者才会停下来等待（同步）。\n\n\n# 2.1.4 进程的pv操作\n\np表示通过的意思，v表示释放的意思，v操作是不具备阻塞的能力的。\n\n * 临界资源： 各个进程中需要抢着使用（互斥）的资源。\n * 临界区： 每个进程中访问临界资源的那段代码成为临界区\n * 信号量： 是一中特殊的变量\n\n\n\n * p操作会将信号量s减1，如果s<0则会阻塞进入等待队列，否则继续执行。\n * v操作会将信号量s加1，如果s≤0则会将进程取出队列，否则继续执行。\n\n🌰：假如s1初值为1，s2初值为0 按时间顺序看如下表格，注意上图是pv操作，不是生产者和消费者别搞蒙了。\n\n生产者             信号量               状态\n生产一个产品 p(s1)    s1 = 1 - 1 = 0    继续执行\n送产品到缓冲区 v(s2)   s2 = 0 + 1 = 1    继续执行\n生产一个产品 p(s1)    s1 = 0 - 1 = -1   阻塞进入等待队\n\n消费者              信号量               状态\np(s2) 从缓冲区取出产品   s2 = -1 + 1 = 0   继续执行\nv(s1) 消费产品       s1 = -1 +1 = 0    唤醒生产者继续执行\n\n进程的pv结合前趋图\n\n\n\n\n# 2.1.5 死锁\n\n如果一个进程在等待一件不可能发生的事情，则进程进入死锁状态。而如果一个或多个进程产生死锁，就会造成系统死锁。\n\n造成死锁的四大条件\n\n 1. 互斥：所需资源通过互斥方式对其进行共享\n\n 2. 保持等待：进程会对资源进行锁定等待，不会释放资源\n\n 3. 不剥夺：进程在对资源进行调用时候，不会根据优先级进行资源掠夺，抢夺其他进程的资源\n\n 4. 环路等待：进程之间相互等待资源，即a进程等待b进程完成，b进程等待c进程完成，c进程等待a进程完成，形成等待环路\n\n死锁的预防：打破上述的死锁四大条件之一。\n\n死锁的避免：有序资源分配法，银行家算法。\n\n\n# 2.1.6 存储管理\n\n🥩逻辑地址与物理地址\n\n * 逻辑地址在计算机体系结构中是指应用程序角度看到的内存单元、存储单元、网络主机的地址。\n * 物理地址是指主存的某个可以让数据总线访问的特定存储单元地址。\n\n🥩地址重定向\n\n程序和数据装入内存时，需对目标程序中的地址进行修改。这种把逻辑地址转变为内存物理地址的过程称作为地址重向。\n\n地址重定向又分两种：\n\n * 静态重定向\n * 动态重定向\n\n🥩静态重定位\n\n目标程序装入内存时进行地址转换，在程序执行期间将不会再发生变化。\n\n 1. 优点：无须硬件地址变化机构（寄存器）的支持，只需要程序本身是可重定位的。\n 2. 缺点：位置固定，不便共享。\n\n🥩动态重定位\n\n程序运行期间完成逻辑地址到物理地址的转变，其实现机制依赖硬件地址变化机构（基地址寄存器）。\n\n 1. 优点：位置可变，不必连续；易于共享。\n 2. 缺点：需要附加硬件支持。\n\n1）分区存储组织\n\n例子：某计算机系统的内存大小为128k,采用可变分区分配方式进行内存分配，当前系统的内 存分块情况如下图所示，现有作业4申请内存9k,几种不同的存储分配算法在分配中，会产生什么样的结果呢？\n\n\n\n2）页式存储组织\n\n将程序与内存均划分为相同大小的块，以页为单位将程序调入内存。\n\n * 优点：利用率高，碎片小，分配及管理简单\n * 缺点：增加了系统的开销；可能产生抖动现象\n\n1.地址结构\n\n * 页式存储地址由两部分组成：页号和页内地址（偏移量）。页的大小一般为512b~8kb。\n\n * 假设页地址长度为32位，操作系统页大小为 4k，即通过短除法，对十进制字节大小转换成二进制，计算出十进制数码4096的二进制数表示为：从右到左数，最多存在12个连续的0位数码，得到页内偏移量为12。\n\n2.地址映射\n\n3.淘汰机制\n\n 1. 优先淘汰访问位置为0（最近未被访问）数据\n 2. 其次淘汰修改位置为0（最近未被修改）数据\n 3. 最后淘汰状态位置为0（不在内存中）数据\n\n\n\n3）段式存储组织\n\n按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。\n\n 1. 优点：多道程序共享内存，各段程序修改互不影响。\n 2. 缺点：内存利用率低，内存碎片浪费大。\n\n\n\n地址映射\n\n4）段页式存储\n\n段式与页式的综合体。先分段，再分页。1个程序有若干段，每个段中可以有若干项，每个页的大小相同，但每个段的大小不同。\n\n 1. 优点：空间浪费小，存储共享容易，存储保护容易，能动态连接。\n 2. 缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降。\n\n地址结构\n\n段页式存储地址由三部分组成：段号、页号和页内地址。\n\n\n\n动态地址转换\n\n\n\n\n# 2.1.7 快表\n\n快表是一块容量小的相联存储器(associativememory)，由高速缓存器组成，速度快，并且可以从硬件上保证内按容并行查找，一用般来存放当前访问最频繁少数的活动页面的页号。\n\n * 快表: 将 页 表 存 cache 于 上;\n * 慢表 : 将 表页 存 于 内 存上。\n\n\n# 2.1.8 文件管理\n\n1.索引文件结构\n\n文件索引结构是指一个文件的信息存放在若干不连续的物理块中，系统为每个文件建立一个专用的数据结构——索引表，并将这些块号存放在索引表中。\n\n文件在逻辑上一定是连续的，在物理上是可以分散的。\n\n\n\n2.位示图\n\n位示图是利用二进制的一位（0或1）来表示磁盘中的一个盘块（物理块）的使用情况，当其值为0时表示空闲，当值为1时表示占用。\n\n\n\n3.树形目录结构\n\n文件属性\n\n * r 只读文件属性\n * a 存档属性\n * s 系统文件\n * h 隐藏文件\n\n文件名组成\n\n * 驱动器号\n * 路径\n * 主文件名\n * 扩展名\n\n绝对路径与相对路径\n\n * 绝对路径：是从盘符开始的路径。\n * 相对路径：是从当前目录开始的路径。\n * 若当前目录为：d1，要求f2路径，则：绝对路径：/d1/w2/f2，相对路径：w2/f2。\n\n\n\n\n# 2.1.9 特殊操作系统\n\n1.嵌入式操作系统 eos\n\n嵌入式系统主要由嵌入式硬件平台、相关支撑硬件、嵌入式操作系统、支撑软件和应用软件组成。其中，嵌入性、专用性和计算机系统是嵌入式系统的三个核心要素。\n\n典型的嵌入式系统具有以下特点\n\n * 系统专用性强\n\n * 系统实时性强\n\n * 软硬件依赖性强\n\n * 处理器专用\n\n * 多种技术紧密结合\n\n * 系统透明性\n\n * 系统资源受限\n\n嵌入式操作系统特点\n\n * 微型化\n\n * 代码质量高\n\n * 专业化\n\n * 实时性强\n\n * 可裁剪可配置\n\n针对不同的硬件平台，操作系统通常建立在一个硬件抽象层（hal）上，该层位于底层硬件和内核之间，为内核提供各种方便移植的宏定义接口，在不同的平台间移植时，只需要修改宏定义即可。与硬件相关，与操作系统相关。\n\n交叉开发环境\n\n由于嵌入式单板的资源有限，不能在单板上运行开发和调试工具，通常需要交叉编译调试的方式进行开发调试，即“宿主机+目标机”的形式，宿主机一般采用串口连接，也可同时通过网口或者jtag连接。\n\n\n\n低功耗设计\n\n基于硬件的低功耗设计：板级电路低功耗设计；选择低功耗处理器；总线的低功耗设计；接口驱动电路的设计；分区分时供电技术。\n\n基于软件的低功耗设计：编译优化技术（指令开销）；软件与硬件的系统设计（硬件功能交由软件完成）；算法优化（低时间复杂度）。\n\n2.实时操作系统（rtos）\n\n实时性能指标\n\n * 任务切换时间\n\n * 系统响应时间（对用户的输入或请求作出反应的时间）\n\n * 信号量混洗时间（指从一个任务释放信号量到另一个等待该信号量的任务被激活的时间延迟）\n\n * 中断处理相关的时间指标\n   \n   * 中断延迟时间\n   \n   * 中断响应时间\n\n多任务调度算法\n\n 1. 优先级调度算法：分配一个相对固定的优先顺序，然后调度程序根据优先级的高低排序，按时间顺序进行高优先级任务优先调度。（非抢占式）\n\n 2. 抢占式调度算法：是在优先级调度算法的基础上，允许高优先级任务抢占低优先级任务而运行。\n\n 3. 时间轮转调度算法：调度程序会依次调度每个任务运行一个小的时间片，然后再调度另一个任务。每个任务运行完一个时间片，无论是否结束都会释放cpu让下一个任务运行。（纯粹的时间轮转调度无法满足实时系统的要求，取而代之的是给予优先级的抢占式时间轮转调度）\n\n 4. 最晚截止期调度算法：指调度程序按每个任务的最接近其截至期末端的时间进行调度。\n\n 5. 最早截至期调度算法：指调度程序按每个任务的截至时间，选择最早到截止期头端时间的任务进行调度。\n\n在rtos中，大多数rtos调度算法都是抢占式的。\n\n实时操作系统比较\n\n常见的嵌入式rtos有：vxworks、rt-linux、qnx、psos。\n\n\n\n\n# 2.1.10 微内核操作系统\n\n现代操作系统大多拥有两种工作状态，分别是核心态和用户态。一般应用程序工作在用户态，而内核模块和最基本的操作系统核心在核心态。\n\n\n\n将传统的操作系统代码放置到更高层，从操作系统中去掉尽可能多的东西，而只留下最小的核心，称之为微内核（c/s结构）。\n\n操作系统的内核服务：异常和中断、计时器、i/o管理等。\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"网络信息安全",frontmatter:{title:"网络信息安全",date:"2022-09-06T03:29:32.000Z",permalink:"/pages/b49e95/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BD%91%E7%BB%9C/04.%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8.html",relativePath:"01.指南/03.计算机系统与网络/04.网络信息安全.md",key:"v-cb672f88",path:"/pages/b49e95/",headers:[{level:2,title:"1.信息安全技术",slug:"_1-信息安全技术",normalizedTitle:"1.信息安全技术",charIndex:13},{level:3,title:"1.1 信息安全属性",slug:"_1-1-信息安全属性",normalizedTitle:"1.1 信息安全属性",charIndex:26},{level:2,title:"2. 加密",slug:"_2-加密",normalizedTitle:"2. 加密",charIndex:158},{level:3,title:"2.1 非对称加密介绍",slug:"_2-1-非对称加密介绍",normalizedTitle:"2.1 非对称加密介绍",charIndex:168},{level:3,title:"2.2 常见非对称加密算法",slug:"_2-2-常见非对称加密算法",normalizedTitle:"2.2 常见非对称加密算法",charIndex:529},{level:3,title:"2.3 常见对称加密算法",slug:"_2-3-常见对称加密算法",normalizedTitle:"2.3 常见对称加密算法",charIndex:663},{level:3,title:"2.4 信息摘要",slug:"_2-4-信息摘要",normalizedTitle:"2.4 信息摘要",charIndex:964},{level:3,title:"2.5 数字签名",slug:"_2-5-数字签名",normalizedTitle:"2.5 数字签名",charIndex:1899},{level:3,title:"2.6 数字信封与PGP",slug:"_2-6-数字信封与pgp",normalizedTitle:"2.6 数字信封与pgp",charIndex:3078},{level:3,title:"2.7 设计邮件加密系统",slug:"_2-7-设计邮件加密系统",normalizedTitle:"2.7 设计邮件加密系统",charIndex:3402},{level:3,title:"3. 网络安全",slug:"_3-网络安全",normalizedTitle:"3. 网络安全",charIndex:3478},{level:3,title:"3.1 网络层次的安全保障",slug:"_3-1-网络层次的安全保障",normalizedTitle:"3.1 网络层次的安全保障",charIndex:3490},{level:3,title:"3.2 网络威胁与攻击",slug:"_3-2-网络威胁与攻击",normalizedTitle:"3.2 网络威胁与攻击",charIndex:3510},{level:3,title:"3.3 防火墙技术",slug:"_3-3-防火墙技术",normalizedTitle:"3.3 防火墙技术",charIndex:3528}],headersStr:"1.信息安全技术 1.1 信息安全属性 2. 加密 2.1 非对称加密介绍 2.2 常见非对称加密算法 2.3 常见对称加密算法 2.4 信息摘要 2.5 数字签名 2.6 数字信封与PGP 2.7 设计邮件加密系统 3. 网络安全 3.1 网络层次的安全保障 3.2 网络威胁与攻击 3.3 防火墙技术",content:'# 网络信息安全\n\n\n# 1.信息安全技术\n\n\n# 1.1 信息安全属性\n\n安全属性：\n\n * 保密性： 最小授权原则、防暴露、信息加密、物理保密\n * 完整性：安全协议、校验码、密码校验、数字签名、公证\n * 可用性：结合保障（IP过滤、业务流控制、路由选择控制、审计跟踪）\n * 不可抵赖性： 数字签名\n\n\n# 2. 加密\n\n\n# 2.1 非对称加密介绍\n\n什么是非对称加密？\n\n“非对称加密也叫公钥密码：使用公钥加密，使用私钥解密”\n\n\n\n在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用非对称加密，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送的问题。\n\n非对称加密中，密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。需理解公钥密码，清楚地分加密密钥和解密密钥是非常重要的。加密密钥是发送者加密时使用的，而解密密钥则是接收者解密时使用的。\n\n加密密钥和解密密钥的区别\n\n * 发送者只需要加密密钥\n * 接收者只需要解密密钥\n * 解密密钥不可以被窃听者获取\n * 加密密钥被窃听者获取也没关系\n\n\n# 2.2 常见非对称加密算法\n\n * RSA： 512位（或者1024位）密钥、计算量极大、难破解\n * Elgamal： 其基础是Diffie-Hellman密钥交换算法\n * ECC： 椭圆曲线算法\n * 其他非对称算法包括： 背包算法、Rabin、D-H\n\n\n# 2.3 常见对称加密算法\n\n * DES： 替换+移位、56位密钥、64位数据块、速度快、密钥易产生\n * 3DES(三重DES)： 两个56位的密钥K1、K2\n   * 加密： K1加密--K2解密--K1加密\n   * 解密： K1解密--K2加密--K1解密\n * AES: 高级加密标准RijnDael加密算法，是美国联邦政府采用的一种区块加密标准技术，这个标准用来替代原先的DES。对其要求是“至少与3DES一样安全”。\n * RC-5： RSA数据安全公司很多产品都使用RC-5\n * IDEA算法： 128位密钥、64位数据块、比DES的加密好、对计算机功能要求比较低、PGP。\n\n\n# 2.4 信息摘要\n\n数据摘要算法是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用做敏感信息的加密。\n\n> 数据摘要算法也被称为哈希（Hash）算法、散列算法；\n\n特点\n\n消息摘要算法（杂凑算法，哈希算法）的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。\n\n * 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的；\n * 消息摘要看起来是“随机的”，一般随机都是伪随机；\n * 一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同（潜在意思是可以相同）；但相同的输入必会产生相同的输出；\n * 消息摘要函数是无陷门的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息；\n * 好的摘要算法，没有人能从中找到“碰撞”，但是“碰撞”是肯定存在的。\n\n算法家族\n\n信息摘要算法来源于CRC算法，最初CRC算法是用来验证数据完整性的，即我们常见的奇偶校验码、循环冗余校验，在CRC基础上发展处了MD和SHA量大算法家族，CRC比这些算法都要早，MD算法比SHA算法早，SHA算法是对MD算法的改进。再后来则发展出了可以带有密码的信息摘要算法-MAC算法。\n\n信息摘要算法包括三大类，MD、SHA和MAC算法，MD的分类是按照版本规定的，SHA则是按照适用的消息长度分类的：\n\n * MD算法： Message Digest Algorithm ，目前主流的是MD5算法，为第五版算法，之前有MD2、MD3、MD4算法。\n * SHA算法：安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）；\n * MAC算法：带有密码信息的信息摘要算法，是对MD和SHA算法的演变和改进，包括HmacMD2、HmacMD4、HmacMD5、HmacSHA-256等。\n\n\n# 2.5 数字签名\n\n数字签名是基于公钥密码体制（非对称密钥密码体制）的。\n\n基本特征\n\n数字签名必须保证以下三点：\n\n * 报文鉴别——接收者能够核实发送者对报文的签名；\n * 报文的完整性——接收者不能伪造对报文的签名或更改报文内容。\n * 不可否认——发送者事后不能抵赖对报文的签名；\n\n1.数字签名的验证过程\n\n\n\n上图位用户A使用数字签名向用户B传输一份文件的过程：\n\n * 首先，文件经过单向散列函数的处理得到一份占128位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是128位），这份摘要相当于该文件的"指纹"，能够唯一地识别文件。**注意：**只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。所以，文件和文件的摘要具有很强的对应关系。\n * 随后，用户A使用自己地私钥对这份128位地摘要进行加密，得到一份加密地摘要。\n * 然后，用户A把文件、加密的摘要和公钥打包一起发给用户B。传输的过程中并没有对文件进行加密处理。\n * 用户B将收到的文件经过单向散列函数处理得出一份128位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用A提供的公钥对收到的"加密的摘要"进行解密得到另一份128位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将两份摘要进行比较。\n * 如果两份摘要相等，说明文件经过用户A签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户A的签名失效。\n\n2.数字签名三个特征的验证\n\n * 不可否认——只有用户A拥有私钥A，并能使用私钥A产生"加密的摘要"，这样用户A就不能否认给用户B发送了经过签名的密文。\n * 报文的完整性——用户B通过比较得出的两份摘要是否相等，可以判断签名或文件内容是否发生改变。\n * 报文鉴别——用户B可以使用收到的公钥对"加密的摘要"进行解密，从而核实用户A对文件的签名。\n\n3.数字签名使用的场合\n\n什么时候使用这种不对文件加密，而对文件的摘要加密（对文件进行签名）的技术呢？\n\n * 数字签名解决的核心问题是：确保收到的文件没有被更改。\n * 比如：公司的领导给员工下发放假通知，这时候就需要对邮件进行数字签名来证明这个通知是领导发的。员工收到通知，看到上面有领导的签名，于是就可以放心休假了。如果有人冒充领导发通知，上面没有领导的签名，员工休假回来就要扣工资。同样的，通知有了领导的签名，领导想抵赖也不行。\n\n> 需要强调\n\n * 用户A使用私钥对由文件生成的128位摘要进行加密的过程称为数字签名的过程，得到的**"加密的摘要"，称为该文件的数据签名**。\n * 用户A使用私钥加密的是摘要而不是文件。\n * 用户B验证签名实际上是比较得出的两份摘要是否相等。\n\n\n# 2.6 数字信封与PGP\n\n发送方将原文用对称密钥加密传输，而将对称密钥用接收方公钥加密发送给对方。\n\n接收放收到电子信封，用自己的私钥解密信封，取出对称密钥解密得到原文。\n\n * PGP可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括IDEA、RS A. MD5、ZIP数据压缩算法\n * PGP承认两种不同的证书格式: PGP证书和X.509证书.\n * PGP证书包含PGP版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的 数字签名、证书的有效期、密钥首选的对称加密算法.\n * X.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据：证书发行商名字、证书主体名、主体公钥信息、发布者的数字签名\n\n\n# 2.7 设计邮件加密系统\n\n要求邮件以加密的方式传输，邮件最大附件内容可达500MB，发送者不可抵赖，若邮件被第三方截获，第三方无法篡改。\n\n\n\n\n# 3. 网络安全\n\n\n# 3.1 网络层次的安全保障\n\n\n\n\n# 3.2 网络威胁与攻击\n\n\n\n\n# 3.3 防火墙技术\n\n防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。\n\n通俗的说它是一个连接两个或者多个网络区域，并且基于策略限制区域间流量的设备。\n\n防火墙技术的主要功能功能在于及时发现并处理计算机网络运行时候可能存在的安全风险，数据输出等问题。\n\n防火墙技术分为两个级别：\n\n * 网络级\n   * 包过滤\n   * 状态检测\n * 应用级\n   * 双穴主机\n   * 屏蔽主机\n   * 屏蔽子网\n\n防火墙的分类\n\n防火墙的分类方法，主要有以下6种：\n\n 1. 软、硬件形式分类：软件防火墙、硬件防火墙、芯片级防火墙。\n 2. 防火墙技术分类：包过滤型防火墙、应用代理型防火墙 。\n 3. 防火墙结构分类：单一主机防火墙、路由器集成式防火墙、分布式防火墙。\n 4. 防火墙的应用部署位置分类：边界防火墙、个人防火墙、混合防火墙。\n 5. 防火墙性能分类：百兆级防火墙、千兆级防火墙。\n 6. 防火墙使用方法分类：网络层防火墙、物理层防火墙、链路层防火墙。\n\n防火墙技术有很多种，其中以下三类比较常见:\n\n1.包过滤防火墙\n\n基本原理: 通过配置ACL实现数据包的过滤。\n\n实现过滤主要是基于数据包中IP层所承载上层协议的协议号、源/目的IP地址、源/目的端口号和报文传递的方向等信息。\n\n> 优缺点： 这种技术实现起来最为简单，但是要求管理员定义大量的规则，而当规则定义多了之后，往往会影响设备的转发性能。\n\n2.代理服务器防火墙\n\n基本原理：当代理服务器收到一个客户的连接请求时，先核实该请求，然后将处理后的请求转发给真实服务器，在接受真实服务器应答并做进一步处理后，再将回复交给发出请求的客户。代理服务器在外部网络和内部网络之间，发挥了中间转接的作用。\n\n> 优缺点：\n> \n> 使用代理服务器防火墙的好处是可以提供用户级的身份认证、日志记录和账号管理，彻底分开外部与内部网络，但是所有内部网络的主机均需通过代理服务器主机才能获得互联网上的资源，因此会造成使用上的不便，而且代理服务器很有可能会成为系统的“瓶颈”\n\n3.状态检测防火墙\n\n状态检测防火墙是最好的防火墙\n\n基本原理：状态检测防火墙是包过滤防火墙的扩展**，它不仅把**数据包作为独立单元进行ACL检查和过滤，同时也考虑前后数据包的应用层关联性。\n\n状态检测防火墙使用各种状态表来监控 TCP/UDP会话，由ACL表决定哪些会话允许建立，只有与被允许会话相关联的数据包才被转发。同时状态防火墙针对TCP/UDP会话，分析数据包的应用层状态信息，过滤不符合当前应用层状态的数据包。\n\n> 优点：\n> \n> 状态检测防火墙结合了包过滤防火墙和代理防火墙的优点，不仅速度快，而且安全性高。\n\n在防火墙上保留四个安全区域，如下：\n\n● 非受信区(Untrust):低级的安全区域，其安全优先级为5\n\n● 非军事化区(DMZ):中度级别的安全区域，其安全优先级为50\n\n● 受信区(Trust):较高级别的安全区域，其安全优先级为85\n\n● 本地区域(Local);最高级别的安全区域，其安全优先级为100\n\n如有必要，还可以自定义安全区域并制定优先级',normalizedContent:'# 网络信息安全\n\n\n# 1.信息安全技术\n\n\n# 1.1 信息安全属性\n\n安全属性：\n\n * 保密性： 最小授权原则、防暴露、信息加密、物理保密\n * 完整性：安全协议、校验码、密码校验、数字签名、公证\n * 可用性：结合保障（ip过滤、业务流控制、路由选择控制、审计跟踪）\n * 不可抵赖性： 数字签名\n\n\n# 2. 加密\n\n\n# 2.1 非对称加密介绍\n\n什么是非对称加密？\n\n“非对称加密也叫公钥密码：使用公钥加密，使用私钥解密”\n\n\n\n在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用非对称加密，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送的问题。\n\n非对称加密中，密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。需理解公钥密码，清楚地分加密密钥和解密密钥是非常重要的。加密密钥是发送者加密时使用的，而解密密钥则是接收者解密时使用的。\n\n加密密钥和解密密钥的区别\n\n * 发送者只需要加密密钥\n * 接收者只需要解密密钥\n * 解密密钥不可以被窃听者获取\n * 加密密钥被窃听者获取也没关系\n\n\n# 2.2 常见非对称加密算法\n\n * rsa： 512位（或者1024位）密钥、计算量极大、难破解\n * elgamal： 其基础是diffie-hellman密钥交换算法\n * ecc： 椭圆曲线算法\n * 其他非对称算法包括： 背包算法、rabin、d-h\n\n\n# 2.3 常见对称加密算法\n\n * des： 替换+移位、56位密钥、64位数据块、速度快、密钥易产生\n * 3des(三重des)： 两个56位的密钥k1、k2\n   * 加密： k1加密--k2解密--k1加密\n   * 解密： k1解密--k2加密--k1解密\n * aes: 高级加密标准rijndael加密算法，是美国联邦政府采用的一种区块加密标准技术，这个标准用来替代原先的des。对其要求是“至少与3des一样安全”。\n * rc-5： rsa数据安全公司很多产品都使用rc-5\n * idea算法： 128位密钥、64位数据块、比des的加密好、对计算机功能要求比较低、pgp。\n\n\n# 2.4 信息摘要\n\n数据摘要算法是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用做敏感信息的加密。\n\n> 数据摘要算法也被称为哈希（hash）算法、散列算法；\n\n特点\n\n消息摘要算法（杂凑算法，哈希算法）的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。\n\n * 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的；\n * 消息摘要看起来是“随机的”，一般随机都是伪随机；\n * 一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同（潜在意思是可以相同）；但相同的输入必会产生相同的输出；\n * 消息摘要函数是无陷门的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息；\n * 好的摘要算法，没有人能从中找到“碰撞”，但是“碰撞”是肯定存在的。\n\n算法家族\n\n信息摘要算法来源于crc算法，最初crc算法是用来验证数据完整性的，即我们常见的奇偶校验码、循环冗余校验，在crc基础上发展处了md和sha量大算法家族，crc比这些算法都要早，md算法比sha算法早，sha算法是对md算法的改进。再后来则发展出了可以带有密码的信息摘要算法-mac算法。\n\n信息摘要算法包括三大类，md、sha和mac算法，md的分类是按照版本规定的，sha则是按照适用的消息长度分类的：\n\n * md算法： message digest algorithm ，目前主流的是md5算法，为第五版算法，之前有md2、md3、md4算法。\n * sha算法：安全哈希算法（secure hash algorithm）主要适用于数字签名标准（digital signature standard dss）里面定义的数字签名算法（digital signature algorithm dsa）；\n * mac算法：带有密码信息的信息摘要算法，是对md和sha算法的演变和改进，包括hmacmd2、hmacmd4、hmacmd5、hmacsha-256等。\n\n\n# 2.5 数字签名\n\n数字签名是基于公钥密码体制（非对称密钥密码体制）的。\n\n基本特征\n\n数字签名必须保证以下三点：\n\n * 报文鉴别——接收者能够核实发送者对报文的签名；\n * 报文的完整性——接收者不能伪造对报文的签名或更改报文内容。\n * 不可否认——发送者事后不能抵赖对报文的签名；\n\n1.数字签名的验证过程\n\n\n\n上图位用户a使用数字签名向用户b传输一份文件的过程：\n\n * 首先，文件经过单向散列函数的处理得到一份占128位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是128位），这份摘要相当于该文件的"指纹"，能够唯一地识别文件。**注意：**只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。所以，文件和文件的摘要具有很强的对应关系。\n * 随后，用户a使用自己地私钥对这份128位地摘要进行加密，得到一份加密地摘要。\n * 然后，用户a把文件、加密的摘要和公钥打包一起发给用户b。传输的过程中并没有对文件进行加密处理。\n * 用户b将收到的文件经过单向散列函数处理得出一份128位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用a提供的公钥对收到的"加密的摘要"进行解密得到另一份128位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将两份摘要进行比较。\n * 如果两份摘要相等，说明文件经过用户a签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户a的签名失效。\n\n2.数字签名三个特征的验证\n\n * 不可否认——只有用户a拥有私钥a，并能使用私钥a产生"加密的摘要"，这样用户a就不能否认给用户b发送了经过签名的密文。\n * 报文的完整性——用户b通过比较得出的两份摘要是否相等，可以判断签名或文件内容是否发生改变。\n * 报文鉴别——用户b可以使用收到的公钥对"加密的摘要"进行解密，从而核实用户a对文件的签名。\n\n3.数字签名使用的场合\n\n什么时候使用这种不对文件加密，而对文件的摘要加密（对文件进行签名）的技术呢？\n\n * 数字签名解决的核心问题是：确保收到的文件没有被更改。\n * 比如：公司的领导给员工下发放假通知，这时候就需要对邮件进行数字签名来证明这个通知是领导发的。员工收到通知，看到上面有领导的签名，于是就可以放心休假了。如果有人冒充领导发通知，上面没有领导的签名，员工休假回来就要扣工资。同样的，通知有了领导的签名，领导想抵赖也不行。\n\n> 需要强调\n\n * 用户a使用私钥对由文件生成的128位摘要进行加密的过程称为数字签名的过程，得到的**"加密的摘要"，称为该文件的数据签名**。\n * 用户a使用私钥加密的是摘要而不是文件。\n * 用户b验证签名实际上是比较得出的两份摘要是否相等。\n\n\n# 2.6 数字信封与pgp\n\n发送方将原文用对称密钥加密传输，而将对称密钥用接收方公钥加密发送给对方。\n\n接收放收到电子信封，用自己的私钥解密信封，取出对称密钥解密得到原文。\n\n * pgp可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括idea、rs a. md5、zip数据压缩算法\n * pgp承认两种不同的证书格式: pgp证书和x.509证书.\n * pgp证书包含pgp版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的 数字签名、证书的有效期、密钥首选的对称加密算法.\n * x.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据：证书发行商名字、证书主体名、主体公钥信息、发布者的数字签名\n\n\n# 2.7 设计邮件加密系统\n\n要求邮件以加密的方式传输，邮件最大附件内容可达500mb，发送者不可抵赖，若邮件被第三方截获，第三方无法篡改。\n\n\n\n\n# 3. 网络安全\n\n\n# 3.1 网络层次的安全保障\n\n\n\n\n# 3.2 网络威胁与攻击\n\n\n\n\n# 3.3 防火墙技术\n\n防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。\n\n通俗的说它是一个连接两个或者多个网络区域，并且基于策略限制区域间流量的设备。\n\n防火墙技术的主要功能功能在于及时发现并处理计算机网络运行时候可能存在的安全风险，数据输出等问题。\n\n防火墙技术分为两个级别：\n\n * 网络级\n   * 包过滤\n   * 状态检测\n * 应用级\n   * 双穴主机\n   * 屏蔽主机\n   * 屏蔽子网\n\n防火墙的分类\n\n防火墙的分类方法，主要有以下6种：\n\n 1. 软、硬件形式分类：软件防火墙、硬件防火墙、芯片级防火墙。\n 2. 防火墙技术分类：包过滤型防火墙、应用代理型防火墙 。\n 3. 防火墙结构分类：单一主机防火墙、路由器集成式防火墙、分布式防火墙。\n 4. 防火墙的应用部署位置分类：边界防火墙、个人防火墙、混合防火墙。\n 5. 防火墙性能分类：百兆级防火墙、千兆级防火墙。\n 6. 防火墙使用方法分类：网络层防火墙、物理层防火墙、链路层防火墙。\n\n防火墙技术有很多种，其中以下三类比较常见:\n\n1.包过滤防火墙\n\n基本原理: 通过配置acl实现数据包的过滤。\n\n实现过滤主要是基于数据包中ip层所承载上层协议的协议号、源/目的ip地址、源/目的端口号和报文传递的方向等信息。\n\n> 优缺点： 这种技术实现起来最为简单，但是要求管理员定义大量的规则，而当规则定义多了之后，往往会影响设备的转发性能。\n\n2.代理服务器防火墙\n\n基本原理：当代理服务器收到一个客户的连接请求时，先核实该请求，然后将处理后的请求转发给真实服务器，在接受真实服务器应答并做进一步处理后，再将回复交给发出请求的客户。代理服务器在外部网络和内部网络之间，发挥了中间转接的作用。\n\n> 优缺点：\n> \n> 使用代理服务器防火墙的好处是可以提供用户级的身份认证、日志记录和账号管理，彻底分开外部与内部网络，但是所有内部网络的主机均需通过代理服务器主机才能获得互联网上的资源，因此会造成使用上的不便，而且代理服务器很有可能会成为系统的“瓶颈”\n\n3.状态检测防火墙\n\n状态检测防火墙是最好的防火墙\n\n基本原理：状态检测防火墙是包过滤防火墙的扩展**，它不仅把**数据包作为独立单元进行acl检查和过滤，同时也考虑前后数据包的应用层关联性。\n\n状态检测防火墙使用各种状态表来监控 tcp/udp会话，由acl表决定哪些会话允许建立，只有与被允许会话相关联的数据包才被转发。同时状态防火墙针对tcp/udp会话，分析数据包的应用层状态信息，过滤不符合当前应用层状态的数据包。\n\n> 优点：\n> \n> 状态检测防火墙结合了包过滤防火墙和代理防火墙的优点，不仅速度快，而且安全性高。\n\n在防火墙上保留四个安全区域，如下：\n\n● 非受信区(untrust):低级的安全区域，其安全优先级为5\n\n● 非军事化区(dmz):中度级别的安全区域，其安全优先级为50\n\n● 受信区(trust):较高级别的安全区域，其安全优先级为85\n\n● 本地区域(local);最高级别的安全区域，其安全优先级为100\n\n如有必要，还可以自定义安全区域并制定优先级',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL概述",frontmatter:{title:"MySQL概述",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/b3d4fe/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/04.数据库/02.MySQL概述.md",key:"v-2780ee7f",path:"/pages/b3d4fe/",headers:[{level:2,title:"数据库相关概念",slug:"数据库相关概念",normalizedTitle:"数据库相关概念",charIndex:28},{level:2,title:"MySQL数据库",slug:"mysql数据库",normalizedTitle:"mysql数据库",charIndex:36},{level:3,title:"版本",slug:"版本",normalizedTitle:"版本",charIndex:796},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:48},{level:3,title:"启动停止",slug:"启动停止",normalizedTitle:"启动停止",charIndex:1101},{level:3,title:"客户端连接",slug:"客户端连接",normalizedTitle:"客户端连接",charIndex:1237},{level:3,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:1549}],headersStr:"数据库相关概念 MySQL数据库 版本 下载 启动停止 客户端连接 数据模型",content:"# MySQL概述\n\n在这一章节，我们主要介绍两个部分，数据库相关概念及MySQL数据库的介绍、下载、安装、启动及连接。\n\n\n# 数据库相关概念\n\n在这一部分，我们先来讲解三个概念：数据库、数据库管理系统、SQL。\n\n名称        全称                                简称\n数据库       存储数据的仓库，数据是有组织的进行存储               DataBase（DB）\n数据库管理系统   操纵和管理数据库的大型软件                     DataBase Management System (DBMS)\nSQL       操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准   Structured Query Language (SQL)\n\n\n\n而目前主流的关系型数据库管理系统的市场占有率排名如下：\n\n\n\n * SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。\n * PostgreSQL：开源免费的中小型数据库。\n * DB2：IBM公司的大型收费数据库产品。\n * SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。\n * MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。\n\n而不论我们使用的是上面的哪一个关系型数据库， 终在操作时，都是使用SQL语言来进行统一操作，因为我们前面讲到SQL语言，是操作关系型数据库的统一标准。所以即使我们现在学习的是MySQL，假如我们以后到了公司，使用的是别的关系型数据库，如：Oracle、DB2、SQLServer，也完全不用担心，因为操作的方式都是一致的。\n\n\n# MySQL数据库\n\n\n# 版本\n\n官方： https://www.mysql.com/\n\nMySQL官方提供了两种不同的版本：\n\n> 社区版本（MySQL Community Server）免费， MySQL不提供任何技术支持\n> \n> 商业版本（MySQL Enterprise Edition）\n> \n> 收费，可以使用30天，官方提供技术支持\n\n本课程采用的是MySQL新的社区版-MySQL Community Server 8.0.26\n\n\n# 下载\n\n下载地址：https://downloads.mysql.com/archives/installer/\n\n\n\n也可以使用课程资料中提供的MySQL的安装包：\n\n\n\n\n# 启动停止\n\nMySQL安装完成之后，在系统启动时，会自动启动MySQL服务，我们无需手动启动了。\n\n当然，也可以手动的通过指令启动停止，以管理员身份运行cmd，进入命令行执行如下指令：\n\nnet start mysql80 \nnet stop  mysql80\n\n\n\n# 客户端连接\n\n1). 方式一：使用MySQL提供的客户端命令行工具\n\n\n\n2). 方式二：使用系统自带的命令行工具执行指令\n\n[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果连接本地的MySQL，则无需指定这两个参数。\n\nmysql  [-h 127.0.0.1]  [-P 3306]  -u root -p\n\n参数：\n\t-h: MySQL服务所在的主机IP\n\t-P: MySQL服务端口号，默认3306\n\t-u: MySQL数据库用户名\n\t-p: MySQL数据库用户名对应的密码\n\n\n\n\n> 注意： 使用这种方式进行连接时，需要安装完毕后配置PATH环境变量。\n\n\n# 数据模型\n\n1). 关系型数据库（RDBMS）\n\n概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n\n而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据）。我们之前提到的MySQL、Oracle、DB2、\n\nSQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。\n\n\n\n特点：\n\nA. 使用表存储数据，格式统一，便于维护。\n\nB. 使用SQL语言操作，标准统一，使用方便。\n\n2). 数据模型\n\nMySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:\n\n\n\n * 我们可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。\n * 可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。\n * 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。",normalizedContent:"# mysql概述\n\n在这一章节，我们主要介绍两个部分，数据库相关概念及mysql数据库的介绍、下载、安装、启动及连接。\n\n\n# 数据库相关概念\n\n在这一部分，我们先来讲解三个概念：数据库、数据库管理系统、sql。\n\n名称        全称                                简称\n数据库       存储数据的仓库，数据是有组织的进行存储               database（db）\n数据库管理系统   操纵和管理数据库的大型软件                     database management system (dbms)\nsql       操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准   structured query language (sql)\n\n\n\n而目前主流的关系型数据库管理系统的市场占有率排名如下：\n\n\n\n * sql server：microsoft 公司推出的收费的中型数据库，c#、.net等语言常用。\n * postgresql：开源免费的中小型数据库。\n * db2：ibm公司的大型收费数据库产品。\n * sqllite：嵌入式的微型数据库。android内置的数据库采用的就是该数据库。\n * mariadb：开源免费的中小型数据库。是mysql数据库的另外一个分支、另外一个衍生产品，与mysql数据库有很好的兼容性。\n\n而不论我们使用的是上面的哪一个关系型数据库， 终在操作时，都是使用sql语言来进行统一操作，因为我们前面讲到sql语言，是操作关系型数据库的统一标准。所以即使我们现在学习的是mysql，假如我们以后到了公司，使用的是别的关系型数据库，如：oracle、db2、sqlserver，也完全不用担心，因为操作的方式都是一致的。\n\n\n# mysql数据库\n\n\n# 版本\n\n官方： https://www.mysql.com/\n\nmysql官方提供了两种不同的版本：\n\n> 社区版本（mysql community server）免费， mysql不提供任何技术支持\n> \n> 商业版本（mysql enterprise edition）\n> \n> 收费，可以使用30天，官方提供技术支持\n\n本课程采用的是mysql新的社区版-mysql community server 8.0.26\n\n\n# 下载\n\n下载地址：https://downloads.mysql.com/archives/installer/\n\n\n\n也可以使用课程资料中提供的mysql的安装包：\n\n\n\n\n# 启动停止\n\nmysql安装完成之后，在系统启动时，会自动启动mysql服务，我们无需手动启动了。\n\n当然，也可以手动的通过指令启动停止，以管理员身份运行cmd，进入命令行执行如下指令：\n\nnet start mysql80 \nnet stop  mysql80\n\n\n\n# 客户端连接\n\n1). 方式一：使用mysql提供的客户端命令行工具\n\n\n\n2). 方式二：使用系统自带的命令行工具执行指令\n\n[]内为可选参数，如果需要连接远程的mysql，需要加上这两个参数来指定远程主机ip、端口，如果连接本地的mysql，则无需指定这两个参数。\n\nmysql  [-h 127.0.0.1]  [-p 3306]  -u root -p\n\n参数：\n\t-h: mysql服务所在的主机ip\n\t-p: mysql服务端口号，默认3306\n\t-u: mysql数据库用户名\n\t-p: mysql数据库用户名对应的密码\n\n\n\n\n> 注意： 使用这种方式进行连接时，需要安装完毕后配置path环境变量。\n\n\n# 数据模型\n\n1). 关系型数据库（rdbms）\n\n概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n\n而所谓二维表，指的是由行和列组成的表，如下图（就类似于excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据）。我们之前提到的mysql、oracle、db2、\n\nsqlserver这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。\n\n\n\n特点：\n\na. 使用表存储数据，格式统一，便于维护。\n\nb. 使用sql语言操作，标准统一，使用方便。\n\n2). 数据模型\n\nmysql是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:\n\n\n\n * 我们可以通过mysql客户端连接数据库管理系统dbms，然后通过dbms操作数据库。\n * 可以使用sql语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。\n * 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"计算机组成与体系结构",frontmatter:{title:"计算机组成与体系结构",date:"2022-08-30T21:47:09.000Z",permalink:"/pages/0ca117/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BD%91%E7%BB%9C/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",relativePath:"01.指南/03.计算机系统与网络/01.计算机组成与体系结构.md",key:"v-70dd68cc",path:"/pages/0ca117/",headers:[{level:2,title:"1.计算机基础知识",slug:"_1-计算机基础知识",normalizedTitle:"1.计算机基础知识",charIndex:17},{level:3,title:"1.1 数据的表示",slug:"_1-1-数据的表示",normalizedTitle:"1.1 数据的表示",charIndex:31},{level:4,title:"1.1.1 进制转换",slug:"_1-1-1-进制转换",normalizedTitle:"1.1.1 进制转换",charIndex:78},{level:4,title:"1.1.2 码制",slug:"_1-1-2-码制",normalizedTitle:"1.1.2 码制",charIndex:340},{level:4,title:"1.1.3 浮点数的表示",slug:"_1-1-3-浮点数的表示",normalizedTitle:"1.1.3 浮点数的表示",charIndex:624},{level:4,title:"1.1.4 逻辑数运算",slug:"_1-1-4-逻辑数运算",normalizedTitle:"1.1.4 逻辑数运算",charIndex:993},{level:3,title:"1.2 校验码",slug:"_1-2-校验码",normalizedTitle:"1.2 校验码",charIndex:1530},{level:4,title:"1.2.1 奇偶校验(Parity Codes)",slug:"_1-2-1-奇偶校验-parity-codes",normalizedTitle:"1.2.1 奇偶校验(parity codes)",charIndex:1622},{level:4,title:"1.2.2  循环校验码CRC",slug:"_1-2-2-循环校验码crc",normalizedTitle:"1.2.2  循环校验码crc",charIndex:null},{level:4,title:"1.2.3 海明校验码",slug:"_1-2-3-海明校验码",normalizedTitle:"1.2.3 海明校验码",charIndex:1907},{level:4,title:"1.2.4 校验码对比",slug:"_1-2-4-校验码对比",normalizedTitle:"1.2.4 校验码对比",charIndex:2019},{level:2,title:"2.计算机的组成",slug:"_2-计算机的组成",normalizedTitle:"2.计算机的组成",charIndex:2037},{level:3,title:"2.1 CPU结构",slug:"_2-1-cpu结构",normalizedTitle:"2.1 cpu结构",charIndex:2050},{level:3,title:"2.2 计算机体系结构分类",slug:"_2-2-计算机体系结构分类",normalizedTitle:"2.2 计算机体系结构分类",charIndex:2502},{level:3,title:"2.3 指令系统",slug:"_2-3-指令系统",normalizedTitle:"2.3 指令系统",charIndex:2712},{level:3,title:"2.4 CPU架构",slug:"_2-4-cpu架构",normalizedTitle:"2.4 cpu架构",charIndex:2878},{level:3,title:"2.5 流水线",slug:"_2-5-流水线",normalizedTitle:"2.5 流水线",charIndex:3492},{level:4,title:"2.5.1 流水线的周期和执行时间",slug:"_2-5-1-流水线的周期和执行时间",normalizedTitle:"2.5.1 流水线的周期和执行时间",charIndex:3558},{level:4,title:"2.5.2 流水线吞吐率",slug:"_2-5-2-流水线吞吐率",normalizedTitle:"2.5.2 流水线吞吐率",charIndex:3959},{level:4,title:"2.5.3 流水线加速比",slug:"_2-5-3-流水线加速比",normalizedTitle:"2.5.3 流水线加速比",charIndex:4116},{level:4,title:"2.5.4 流水线的效率",slug:"_2-5-4-流水线的效率",normalizedTitle:"2.5.4 流水线的效率",charIndex:4243},{level:3,title:"2.6 缓存",slug:"_2-6-缓存",normalizedTitle:"2.6 缓存",charIndex:4387},{level:3,title:"2.7 局部性原理",slug:"_2-7-局部性原理",normalizedTitle:"2.7 局部性原理",charIndex:4646},{level:3,title:"2.8 主存储器",slug:"_2-8-主存储器",normalizedTitle:"2.8 主存储器",charIndex:4805},{level:3,title:"2.9 磁盘",slug:"_2-9-磁盘",normalizedTitle:"2.9 磁盘",charIndex:5034},{level:3,title:"2.10 总线",slug:"_2-10-总线",normalizedTitle:"2.10 总线",charIndex:5692},{level:3,title:"2.11 串联系统与并联系统",slug:"_2-11-串联系统与并联系统",normalizedTitle:"2.11 串联系统与并联系统",charIndex:5905},{level:3,title:"2.12 校验码",slug:"_2-12-校验码",normalizedTitle:"2.12 校验码",charIndex:6020}],headersStr:"1.计算机基础知识 1.1 数据的表示 1.1.1 进制转换 1.1.2 码制 1.1.3 浮点数的表示 1.1.4 逻辑数运算 1.2 校验码 1.2.1 奇偶校验(Parity Codes) 1.2.2  循环校验码CRC 1.2.3 海明校验码 1.2.4 校验码对比 2.计算机的组成 2.1 CPU结构 2.2 计算机体系结构分类 2.3 指令系统 2.4 CPU架构 2.5 流水线 2.5.1 流水线的周期和执行时间 2.5.2 流水线吞吐率 2.5.3 流水线加速比 2.5.4 流水线的效率 2.6 缓存 2.7 局部性原理 2.8 主存储器 2.9 磁盘 2.10 总线 2.11 串联系统与并联系统 2.12 校验码",content:"# 计算机组成与体系结构\n\n\n# 1.计算机基础知识\n\n\n# 1.1 数据的表示\n\n * 进制转换\n * 码制\n * 浮点数的表示\n * 逻辑数运算\n\n# 1.1.1 进制转换\n\n一般为一些基础的进制转换，二进制(B)，八进制（O），十进制（D），十六进制（H）这里是后缀表示法\n\n易混淆的为（计算机常见的数据计量单位）：\n\n 1. 比特(bit/位)： 最小的单位\n 2. 字节(bytes/Byte)： 比位大一些，1字节=8位(bit)即1B=8b\n 3. KB：1KB=1024B\n 4. MB：1MB=1024KB\n 5. GB：1GB=1024MB\n\n常用的进制缩写\n\n进制     简写\n十进制    D\n二进制    B\n八进制    Q\n十六进制   H\n\n# 1.1.2 码制\n\n原码：符号位+数值位绝对值。\n\n反码：正数的反码是原码本身，负数的反码是符号位不变数值位按位取反。\n\n补码：正数的补码是原码本身，负数的补码是符号位不变数值位在反码基础上加1。\n\n移码：正数和负数的移码都是在补码基础上符号位取反。\n\n原码无法直接在计算机中进行运算，即原码的负值与原码相加和实际情况不一致。\n\n数值的表示范围\n\n * 原码： -127至127\n * 反码： -127至127\n * 补码： -128至127\n\n补码比原码和反码的取值范围要大1个，因为在原码和反码中0需要有正0和负0两个，而在补码和移码中0不存在正负0；\n\n\n\n# 1.1.3 浮点数的表示\n\n浮点数的表示格式：\n\n阶符   阶码   数符   尾数\n\n要点注意：\n\n * 浮点数各部分表示意义：N = 尾数*基数的指数次幂\n * 一般尾数用补码，阶码用移码；\n * 阶码的位数决定数的表示范围，位数越多范围越大；\n * 尾数的位数决定数的有效精度，位数越多精度越高。\n * 浮点数运算规则：对阶>尾数计算>结果格式化\n * 对阶时，小数向大数看齐；\n * 对阶是通过较小数的尾数右移实现的。\n\n浮点数表示：\n\n\n\n其中M为尾数，e为指数，R为基数。 当计算机在进行浮点数运算时，需要经过 对阶 → 尾数计算 → 结果格式化 三个步骤 例：\n\n\n\n在这两个浮点数进行运算时，把阶数小的往高的对(小阶对大阶)，即0.119 * 10 ^ 3，然后进行同阶的尾数计算，最后格式化成d.dddd的结果。\n\n# 1.1.4 逻辑数运算\n\n1、运算符\n\n * 较高优先级（关系运算符）：<（小于）<=（小于或等于） >（大于）>=（大于或等于）。\n\n * 较低优先级（关系运算符）：==等于 !=不等于。逻辑运算符。\n\n * 逻辑或（ ||、+ 、∪、∨、OR）：连接的两个逻辑值全 0 时才取 0。\n\n * 逻辑与（&&、*、・、∩、∧、AND ）：连接的两个逻辑值全 1 时才取 1。\n\n * 逻辑异或（⊕、XOR ）：连接的两个逻辑值不相同时才取 1，相同则取 0。\n\n * 逻辑非（！、﹃ 、～ 、NOT，—）：将原逻辑值取反即可。\n\n2、优先级\n\n！（非）->&&（与）->||（或）\n\n逻辑运算符中的“&&”和 “||”低于关系运算符，“!”高于算术运算符\n\n因此运算符的优先顺序为：！>算术运算符>关系运算符> && > || >赋值运算符\n\n3、短路原则\n\n在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行。\n\n（1）a && b && c 只有 a 为真时，才需要判断 b 的值，只有 a 和 b 都为真时，才需要判断 c 的值。\n\n（2）a || b || c 只要a 为真，就不必判断b和c的值，只有 a 为假，才判断 b,a 和b 都为假才判断c。\n\n\n# 1.2 校验码\n\n * 奇偶校验(Parity Codes)\n * 循环校验码CRC(Cyclic Redundancy Check,CRC)\n * 海明校验\n * 校验码对比\n\n# 1.2.1 奇偶校验(Parity Codes)\n\n是一种简单有效的校验方法。它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中的奇数位发生了错误时，即编码中的1变成0或0变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。因而奇偶校验码只有检错的功能，不能进行纠错。\n\n# 1.2.2 循环校验码CRC\n\n广泛应用于数据通信领域和磁介质存储系统校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。也是只能检错，不能进行纠错。\n\n# 1.2.3 海明校验码\n\n是一种利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的特定位置上插入 k 个校验位，通过扩大码距来实现检错和纠错。\n\n设数据位是n位，校验位是k位海明校验码校验位计算：\n\n\n\n# 1.2.4 校验码对比\n\n\n\n\n# 2.计算机的组成\n\n\n# 2.1 CPU结构\n\n主机分为CPU和主存储器（又称内存储器、内存）\n\n\n\n> 运算器部件：\n\n 1. 算数逻辑单元ALU ：是能实现多组算术运算和逻辑运算的组合逻辑电路。\n 2. 累加寄存器AC ： 是一个通用寄存器，虽然叫累加器，但还支持减法、读出、移位、循环移位、求补等操作。它为ALU提供一个工作区，暂时存放ALU运算的结果信息。\n 3. 数据缓冲寄存器DR，在内存储器（内存）进行读写操作时，将数据放入其。\n 4. 状态条件寄存器PSW，存储在运算过程中的标志位（进位、溢出、为零、为负、终端、方向、单步等）\n\n> 控制部件：\n\n1.控制器部件：\n\n 1. 地址寄存器AR ：用来保存当前CPU所访问的内存单元的地址信息。\n 2. 程序计数器PC ：存放指令地址，将指令由内存取到指令寄存器中，且程序计数器更新为下一指令的地址\n\n2.指令部件：\n\n 1. 指令寄存器IR :用于暂存当前正在执行的指令\n 2. 指令译码器ID :译码呗。\n\n3.时序部件：为指令的执行产生时序信号。\n\n\n\n\n# 2.2 计算机体系结构分类\n\n 1. 单指令流单数据流SISD：单控制部分，单处理器，单主存模块；常见于单片机\n 2. 单指令流多数据流SIMD：单控制部分，多处理器，多主存模块；阵列处理器，各处理以异步执行同一条指令，像GPU做矩阵处理时那样。\n 3. 多指令流单数据流MISD：多控制部分，单处理器，多主存模块；没得这种东西。\n 4. 多指令流多数据流MIMD：多控制部分，多处理器，多主存模块；家用计算机\n\n\n# 2.3 指令系统\n\n复杂指令集计算机CISC，Complex 复杂的。上世纪用的东西，定制的、占地面积巨大的计算机。 精简指令集计算机RISC，Reduced 减少，缩小。 在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。\n\n\n\n\n# 2.4 CPU架构\n\nCPU的分类：\n\n * x86架构\n * ARM架构\n * MIPS架构\n\nx86架构，因Intel的处理器型号早期以数字86结尾，因此其架构被称为x86架构，常用与家用计算机中。其早期是16位的，后来AMD与1999年抢先推出了64位元、x86架构的处理器，命名为AMD 64。Intel于2001年紧随其后推出IA-64，是和惠普合作的英特尔安腾处理器，是一种和x86完全不同的架构。后来统称为x86-64或x64。那么x86架构是用的是前文说到的复杂指令集（CISC），windows8以前的操作系统都是仅支持x86架构的。在较为新的微架构中，x86处理器会把x86指令更换为更像RISC那样的微指令再进行执行，提升性能。\n\nARM架构，英文是AdvancedRISC Machine进阶精简指令集机器。 起初叫AcornRISC Machine，Acorn是公司名字。显而易见是用的RISC复杂指令集，是32位元的处理器。因其节能低耗的特点，常用与嵌入式系统与移动通讯领域（手机芯片）。\n\nMIPS架构，英文是Microprocessorwithout Interlocked Pipeline Stages，无内部互锁流水级微处理器，也是采用RISC的处理器架构。机制是尽量利用软件办法避免流水线中的数据相关问题，强调硬件协同提高性能，同时简化硬件设计。是64位元处理器，支持除法指令。\n\n\n# 2.5 流水线\n\n流水线是指在程序执行时，多条指令重叠进行操作的一种准并行处理技术，提高各部件的利用率和指令单平均执行速率。\n\n# 2.5.1 流水线的周期和执行时间\n\n\n\n * 流水线周期：是流水线步骤中最长的一段时间。是执行多条指令时，一条指令的开始到下一条指令的最晚开始时间的总称。私以为可以看图中间的一竖列。\n * 流水线执行时间计算公式：1条指令执行时间 + 剩下的指令数 * 流水线周期\n\n🌰：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别是2ns、2ns、1ns，流水线的周期是：2ns 。\n\n理论上：\n\n * 1条指令的执行时间是：2ns + 2ns + 1ns = 5ns\n * 100令的执行时间是：5ns + 99 * 2ns = 203ns\n\n但是！执行时间比周期要小，这就很麻烦，不如统一一下。\n\n实际上：\n\n * 1条指令的执行时间是：2ns + 2ns + 2ns = 6ns\n * 100令的执行时间是：6ns + 99 * 2ns = 204ns\n\n但是！两种都算对。\n\n# 2.5.2 流水线吞吐率\n\n流水线吞吐率：是指在单位时间内流水线所完成的任务数量或输出结果的数量。 流水线吞吐率计算公式： 指令条数 / 流水线执行时间 流水线最大吞吐率计算公式： 1条 / 流水线周期，是一个理想状态 流水线的吞吐率为： 100条 / 203ns 流水线的最大吞吐率为： 1条 / 2ns\n\n# 2.5.3 流水线加速比\n\n流水线加速比公式： 不使用流水线的执行时间 / 使用流水线的执行时间 不使用流水线时间：( 2ns + 2ns + 1ns ) * 100条 = 500ns 使用流水线时间： 203ns 流水线加速比：2.463054\n\n# 2.5.4 流水线的效率\n\n流水线效率：是指流水线设备的利用率。在时空图上，流水线的效率定义为那个任务占用的时空区与k个流水段总的时空区之比。\n\n\n\n率公式： 任务占用的时空区（灰的） / 总的时空区（白的） 已上图为例即 （1+1+1+3）* 4 / 15 * 4 = 0.4\n\n\n# 2.6 缓存\n\n缓存（cache）：缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此速率很快。CPU一般有多层缓存，在计算机存储系统体系中，缓存是访问速度最快的层次。\n\n如果以h代表对Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为t3，则\n\n\n\n其中（1-h）称为失效率或未命中率\n\n\n\n首先，CPU去Cache中取数据，如果Cache里面有则称为命中，没有称为未命中，去内存（主存）中去取。\n\n\n# 2.7 局部性原理\n\n在CPU访问寄存器时，无论是存取数据或指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。\n\n时间局部性：（循环中）被引用过一次的储存器位置未来会被多次引用\n\n空间局部性：如果一个储存器的位置被引用，那么将来他附近的位置也不会被引用。\n\n工作集理论：程序运行时被频繁访问的页面集合\n\n\n# 2.8 主存储器\n\n主存储器类别         简写\n随机存取存储器（RAM）   DRAM动态、SRAM静态\n只读存储器（ROM）     MROM掩模式、PROM一次可编程、EPROM可擦除、Flash Memory闪存储器（闪存）\n\n🌰：内存地址从AC000H到C7FFFH，共有112K个地址单元，如果该内存地址按字（16bit）编址，由28片存储芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每个存储单元存储4bit。\n\n\n# 2.9 磁盘\n\n\n\n左侧是多叠的磁盘\n\n存取时间 = 寻道时间 + 等待时间（平均定位时间 + 转动延迟）\n\n寻道时间是指磁头移动到磁道所需的时间；\n\n等待时间为等待读写的扇区转到磁头下方所用的实践\n\n🌰：假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0…R10存放到同一个磁道上，记录的存放顺序如下表所示。\n\n物理块    1    2    3    4    5    6    7    8    9    10   11\n逻辑记录   R0   R1   R2   R3   R4   R5   R6   R7   R8   R9   R10\n\n如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处。若系统是用的单缓冲区顺序处理这些记录，每个记录处理时间为3ms。\n\n> Ps:单缓存区意味着只能存放一块逻辑记录，如果没处理完，磁盘可是会接着旋转的。\n\n\n\n读取 + 处理R0，定位到R1所消耗时间为：3ms + 33ms = 36ms 那处理到R9，且定位到R10所消耗的时间为：10 * 36ms = 360ms 读取 + 处理R10所消耗的实践为：3ms + 3ms = 6ms 则处理这11个记录的最长（常规）时间为：360ms + 6ms = 366ms\n\n\n\n理想态是读取且处理完R0后，磁盘正好转动到R1那里。 即对信息存储进行优化分布后，处理11个记录的最少时间为：66ms\n\n> 即：[ 3ms（读取）+ 3ms （处理）] * 11 = 66ms\n\n\n# 2.10 总线\n\n根据总线所处位置不同，总线通常分为三种：内部总线、系统总线、外部总线。\n\n * 内部总线：计算机内部各个芯片与处理器之间的总线，类似于CPU与南北桥的线路连接，是芯片级别。\n * 系统总线：计算机主板和各个拆线版之间的总线，类似PCIE线，VGA接口线等，是插线板级别，常说的总线就是系统总线。\n * 外部总线：计算机和外设、计算机之间的总线，又称通信总线。\n\n总线分为数据总线、地址总线和控制总线\n\n\n# 2.11 串联系统与并联系统\n\n串联系统是组成系统的所有单元中任一单元失效就会导致整个系统失效的系统。 可靠度R:\n\n\n\n失效率λ:\n\n\n\n并联系统只有当所有子系统失效时，系统才会失效。 可靠度R:\n\n\n\n失效率λ:\n\n\n\n\n# 2.12 校验码\n\n海明码校验码/汉明码Hamming Code\n\n 1. 注意：海明码的校验位在2的次方位上，例如1，2，4，8，16位\n 2. 定义：海明码是一个有多个校验位，拥有检错纠错能力的编码。\n 3. 基本思想：将有效信息按照某种规律分为若干组，每组安排一个校验位进行就行测试，后产生多位检测信息，并从中得到具体出错位置，将其取反来纠正。\n 4. 步骤：计算校验位数 → 确定校验码位置 → 确定校验码 → 计算\n\n🌰：求1011的海明码。\n\n1.计算校验位数\n\n假设用 N 表示添加了校验码后整个编码信息的二进制位数长度，用 I 代表其中有效信息位， r 表示添加的校验码位，他们之间的关系应满足：\n\n\n\n即 4+ r ≤ 2r - 1\n\n2.确定校验码位置\n\n求得校验码位至少为3位，分别放在第20，21，22位。即第1位，第2位和第4位。\n\n位数    7       6       5       4    3       2    1\n信息位   1（I4）   0（I3）   1（I2）        1（I1）        \n校验位                           r2           r1   r0\n\n3.确定校验码\n\n【I4】 7 = 0111 第2,1,0位；即第7位的信息为会影响到 r2 r1 r0 【I3】6 = 0110 第2,1位； 即第6位的信息为会影响到 r2 r1 【I2】5 = 0101 第3,1位；即第5位的信息为会影响到 r2 r0 【I1】3 = 0011 第2,1位；即第3位的信息为会影响到 r1 r0\n\n4.计算\n\nr2 = I4 ⊕ I3 ⊕ I2 = 1 ⊕ 0 ⊕ 1 = 0 r1 = I4 ⊕ I3 ⊕ I1 = 1 ⊕ 0 ⊕ 1 = 0 r0 = I4 ⊕ I2 ⊕ I1 = 1 ⊕ 1 ⊕ 1 = 1\n\n故1011的海明码为1010101\n\n> ps:异或运算，同为0，异为1\n\nA   B   A ⊕ B\n0   0   0\n0   1   1\n1   0   1\n1   1   0\n\n🌰：纠正海明码1011101的错误。\n\n计算得到的校验码为 100 ，给出的校验码为101，按位异或 得到 001，即第一位错误，将其取反即可，即1011100。",normalizedContent:"# 计算机组成与体系结构\n\n\n# 1.计算机基础知识\n\n\n# 1.1 数据的表示\n\n * 进制转换\n * 码制\n * 浮点数的表示\n * 逻辑数运算\n\n# 1.1.1 进制转换\n\n一般为一些基础的进制转换，二进制(b)，八进制（o），十进制（d），十六进制（h）这里是后缀表示法\n\n易混淆的为（计算机常见的数据计量单位）：\n\n 1. 比特(bit/位)： 最小的单位\n 2. 字节(bytes/byte)： 比位大一些，1字节=8位(bit)即1b=8b\n 3. kb：1kb=1024b\n 4. mb：1mb=1024kb\n 5. gb：1gb=1024mb\n\n常用的进制缩写\n\n进制     简写\n十进制    d\n二进制    b\n八进制    q\n十六进制   h\n\n# 1.1.2 码制\n\n原码：符号位+数值位绝对值。\n\n反码：正数的反码是原码本身，负数的反码是符号位不变数值位按位取反。\n\n补码：正数的补码是原码本身，负数的补码是符号位不变数值位在反码基础上加1。\n\n移码：正数和负数的移码都是在补码基础上符号位取反。\n\n原码无法直接在计算机中进行运算，即原码的负值与原码相加和实际情况不一致。\n\n数值的表示范围\n\n * 原码： -127至127\n * 反码： -127至127\n * 补码： -128至127\n\n补码比原码和反码的取值范围要大1个，因为在原码和反码中0需要有正0和负0两个，而在补码和移码中0不存在正负0；\n\n\n\n# 1.1.3 浮点数的表示\n\n浮点数的表示格式：\n\n阶符   阶码   数符   尾数\n\n要点注意：\n\n * 浮点数各部分表示意义：n = 尾数*基数的指数次幂\n * 一般尾数用补码，阶码用移码；\n * 阶码的位数决定数的表示范围，位数越多范围越大；\n * 尾数的位数决定数的有效精度，位数越多精度越高。\n * 浮点数运算规则：对阶>尾数计算>结果格式化\n * 对阶时，小数向大数看齐；\n * 对阶是通过较小数的尾数右移实现的。\n\n浮点数表示：\n\n\n\n其中m为尾数，e为指数，r为基数。 当计算机在进行浮点数运算时，需要经过 对阶 → 尾数计算 → 结果格式化 三个步骤 例：\n\n\n\n在这两个浮点数进行运算时，把阶数小的往高的对(小阶对大阶)，即0.119 * 10 ^ 3，然后进行同阶的尾数计算，最后格式化成d.dddd的结果。\n\n# 1.1.4 逻辑数运算\n\n1、运算符\n\n * 较高优先级（关系运算符）：<（小于）<=（小于或等于） >（大于）>=（大于或等于）。\n\n * 较低优先级（关系运算符）：==等于 !=不等于。逻辑运算符。\n\n * 逻辑或（ ||、+ 、∪、∨、or）：连接的两个逻辑值全 0 时才取 0。\n\n * 逻辑与（&&、*、・、∩、∧、and ）：连接的两个逻辑值全 1 时才取 1。\n\n * 逻辑异或（⊕、xor ）：连接的两个逻辑值不相同时才取 1，相同则取 0。\n\n * 逻辑非（！、﹃ 、～ 、not，—）：将原逻辑值取反即可。\n\n2、优先级\n\n！（非）->&&（与）->||（或）\n\n逻辑运算符中的“&&”和 “||”低于关系运算符，“!”高于算术运算符\n\n因此运算符的优先顺序为：！>算术运算符>关系运算符> && > || >赋值运算符\n\n3、短路原则\n\n在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行。\n\n（1）a && b && c 只有 a 为真时，才需要判断 b 的值，只有 a 和 b 都为真时，才需要判断 c 的值。\n\n（2）a || b || c 只要a 为真，就不必判断b和c的值，只有 a 为假，才判断 b,a 和b 都为假才判断c。\n\n\n# 1.2 校验码\n\n * 奇偶校验(parity codes)\n * 循环校验码crc(cyclic redundancy check,crc)\n * 海明校验\n * 校验码对比\n\n# 1.2.1 奇偶校验(parity codes)\n\n是一种简单有效的校验方法。它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中的奇数位发生了错误时，即编码中的1变成0或0变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。因而奇偶校验码只有检错的功能，不能进行纠错。\n\n# 1.2.2 循环校验码crc\n\n广泛应用于数据通信领域和磁介质存储系统校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。在求crc编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。也是只能检错，不能进行纠错。\n\n# 1.2.3 海明校验码\n\n是一种利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的特定位置上插入 k 个校验位，通过扩大码距来实现检错和纠错。\n\n设数据位是n位，校验位是k位海明校验码校验位计算：\n\n\n\n# 1.2.4 校验码对比\n\n\n\n\n# 2.计算机的组成\n\n\n# 2.1 cpu结构\n\n主机分为cpu和主存储器（又称内存储器、内存）\n\n\n\n> 运算器部件：\n\n 1. 算数逻辑单元alu ：是能实现多组算术运算和逻辑运算的组合逻辑电路。\n 2. 累加寄存器ac ： 是一个通用寄存器，虽然叫累加器，但还支持减法、读出、移位、循环移位、求补等操作。它为alu提供一个工作区，暂时存放alu运算的结果信息。\n 3. 数据缓冲寄存器dr，在内存储器（内存）进行读写操作时，将数据放入其。\n 4. 状态条件寄存器psw，存储在运算过程中的标志位（进位、溢出、为零、为负、终端、方向、单步等）\n\n> 控制部件：\n\n1.控制器部件：\n\n 1. 地址寄存器ar ：用来保存当前cpu所访问的内存单元的地址信息。\n 2. 程序计数器pc ：存放指令地址，将指令由内存取到指令寄存器中，且程序计数器更新为下一指令的地址\n\n2.指令部件：\n\n 1. 指令寄存器ir :用于暂存当前正在执行的指令\n 2. 指令译码器id :译码呗。\n\n3.时序部件：为指令的执行产生时序信号。\n\n\n\n\n# 2.2 计算机体系结构分类\n\n 1. 单指令流单数据流sisd：单控制部分，单处理器，单主存模块；常见于单片机\n 2. 单指令流多数据流simd：单控制部分，多处理器，多主存模块；阵列处理器，各处理以异步执行同一条指令，像gpu做矩阵处理时那样。\n 3. 多指令流单数据流misd：多控制部分，单处理器，多主存模块；没得这种东西。\n 4. 多指令流多数据流mimd：多控制部分，多处理器，多主存模块；家用计算机\n\n\n# 2.3 指令系统\n\n复杂指令集计算机cisc，complex 复杂的。上世纪用的东西，定制的、占地面积巨大的计算机。 精简指令集计算机risc，reduced 减少，缩小。 在cisc指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。\n\n\n\n\n# 2.4 cpu架构\n\ncpu的分类：\n\n * x86架构\n * arm架构\n * mips架构\n\nx86架构，因intel的处理器型号早期以数字86结尾，因此其架构被称为x86架构，常用与家用计算机中。其早期是16位的，后来amd与1999年抢先推出了64位元、x86架构的处理器，命名为amd 64。intel于2001年紧随其后推出ia-64，是和惠普合作的英特尔安腾处理器，是一种和x86完全不同的架构。后来统称为x86-64或x64。那么x86架构是用的是前文说到的复杂指令集（cisc），windows8以前的操作系统都是仅支持x86架构的。在较为新的微架构中，x86处理器会把x86指令更换为更像risc那样的微指令再进行执行，提升性能。\n\narm架构，英文是advancedrisc machine进阶精简指令集机器。 起初叫acornrisc machine，acorn是公司名字。显而易见是用的risc复杂指令集，是32位元的处理器。因其节能低耗的特点，常用与嵌入式系统与移动通讯领域（手机芯片）。\n\nmips架构，英文是microprocessorwithout interlocked pipeline stages，无内部互锁流水级微处理器，也是采用risc的处理器架构。机制是尽量利用软件办法避免流水线中的数据相关问题，强调硬件协同提高性能，同时简化硬件设计。是64位元处理器，支持除法指令。\n\n\n# 2.5 流水线\n\n流水线是指在程序执行时，多条指令重叠进行操作的一种准并行处理技术，提高各部件的利用率和指令单平均执行速率。\n\n# 2.5.1 流水线的周期和执行时间\n\n\n\n * 流水线周期：是流水线步骤中最长的一段时间。是执行多条指令时，一条指令的开始到下一条指令的最晚开始时间的总称。私以为可以看图中间的一竖列。\n * 流水线执行时间计算公式：1条指令执行时间 + 剩下的指令数 * 流水线周期\n\n🌰：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别是2ns、2ns、1ns，流水线的周期是：2ns 。\n\n理论上：\n\n * 1条指令的执行时间是：2ns + 2ns + 1ns = 5ns\n * 100令的执行时间是：5ns + 99 * 2ns = 203ns\n\n但是！执行时间比周期要小，这就很麻烦，不如统一一下。\n\n实际上：\n\n * 1条指令的执行时间是：2ns + 2ns + 2ns = 6ns\n * 100令的执行时间是：6ns + 99 * 2ns = 204ns\n\n但是！两种都算对。\n\n# 2.5.2 流水线吞吐率\n\n流水线吞吐率：是指在单位时间内流水线所完成的任务数量或输出结果的数量。 流水线吞吐率计算公式： 指令条数 / 流水线执行时间 流水线最大吞吐率计算公式： 1条 / 流水线周期，是一个理想状态 流水线的吞吐率为： 100条 / 203ns 流水线的最大吞吐率为： 1条 / 2ns\n\n# 2.5.3 流水线加速比\n\n流水线加速比公式： 不使用流水线的执行时间 / 使用流水线的执行时间 不使用流水线时间：( 2ns + 2ns + 1ns ) * 100条 = 500ns 使用流水线时间： 203ns 流水线加速比：2.463054\n\n# 2.5.4 流水线的效率\n\n流水线效率：是指流水线设备的利用率。在时空图上，流水线的效率定义为那个任务占用的时空区与k个流水段总的时空区之比。\n\n\n\n率公式： 任务占用的时空区（灰的） / 总的时空区（白的） 已上图为例即 （1+1+1+3）* 4 / 15 * 4 = 0.4\n\n\n# 2.6 缓存\n\n缓存（cache）：缓存是指可以进行高速数据交换的存储器，它先于内存与cpu交换数据，因此速率很快。cpu一般有多层缓存，在计算机存储系统体系中，缓存是访问速度最快的层次。\n\n如果以h代表对cache的访问命中率，t1表示cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“cache+主存储器”的系统的平均周期为t3，则\n\n\n\n其中（1-h）称为失效率或未命中率\n\n\n\n首先，cpu去cache中取数据，如果cache里面有则称为命中，没有称为未命中，去内存（主存）中去取。\n\n\n# 2.7 局部性原理\n\n在cpu访问寄存器时，无论是存取数据或指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。\n\n时间局部性：（循环中）被引用过一次的储存器位置未来会被多次引用\n\n空间局部性：如果一个储存器的位置被引用，那么将来他附近的位置也不会被引用。\n\n工作集理论：程序运行时被频繁访问的页面集合\n\n\n# 2.8 主存储器\n\n主存储器类别         简写\n随机存取存储器（ram）   dram动态、sram静态\n只读存储器（rom）     mrom掩模式、prom一次可编程、eprom可擦除、flash memory闪存储器（闪存）\n\n🌰：内存地址从ac000h到c7fffh，共有112k个地址单元，如果该内存地址按字（16bit）编址，由28片存储芯片构成。已知构成此内存的芯片每片有16k个存储单元，则该芯片每个存储单元存储4bit。\n\n\n# 2.9 磁盘\n\n\n\n左侧是多叠的磁盘\n\n存取时间 = 寻道时间 + 等待时间（平均定位时间 + 转动延迟）\n\n寻道时间是指磁头移动到磁道所需的时间；\n\n等待时间为等待读写的扇区转到磁头下方所用的实践\n\n🌰：假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录r0…r10存放到同一个磁道上，记录的存放顺序如下表所示。\n\n物理块    1    2    3    4    5    6    7    8    9    10   11\n逻辑记录   r0   r1   r2   r3   r4   r5   r6   r7   r8   r9   r10\n\n如果磁盘的旋转周期为33ms，磁头当前处在r0的开始处。若系统是用的单缓冲区顺序处理这些记录，每个记录处理时间为3ms。\n\n> ps:单缓存区意味着只能存放一块逻辑记录，如果没处理完，磁盘可是会接着旋转的。\n\n\n\n读取 + 处理r0，定位到r1所消耗时间为：3ms + 33ms = 36ms 那处理到r9，且定位到r10所消耗的时间为：10 * 36ms = 360ms 读取 + 处理r10所消耗的实践为：3ms + 3ms = 6ms 则处理这11个记录的最长（常规）时间为：360ms + 6ms = 366ms\n\n\n\n理想态是读取且处理完r0后，磁盘正好转动到r1那里。 即对信息存储进行优化分布后，处理11个记录的最少时间为：66ms\n\n> 即：[ 3ms（读取）+ 3ms （处理）] * 11 = 66ms\n\n\n# 2.10 总线\n\n根据总线所处位置不同，总线通常分为三种：内部总线、系统总线、外部总线。\n\n * 内部总线：计算机内部各个芯片与处理器之间的总线，类似于cpu与南北桥的线路连接，是芯片级别。\n * 系统总线：计算机主板和各个拆线版之间的总线，类似pcie线，vga接口线等，是插线板级别，常说的总线就是系统总线。\n * 外部总线：计算机和外设、计算机之间的总线，又称通信总线。\n\n总线分为数据总线、地址总线和控制总线\n\n\n# 2.11 串联系统与并联系统\n\n串联系统是组成系统的所有单元中任一单元失效就会导致整个系统失效的系统。 可靠度r:\n\n\n\n失效率λ:\n\n\n\n并联系统只有当所有子系统失效时，系统才会失效。 可靠度r:\n\n\n\n失效率λ:\n\n\n\n\n# 2.12 校验码\n\n海明码校验码/汉明码hamming code\n\n 1. 注意：海明码的校验位在2的次方位上，例如1，2，4，8，16位\n 2. 定义：海明码是一个有多个校验位，拥有检错纠错能力的编码。\n 3. 基本思想：将有效信息按照某种规律分为若干组，每组安排一个校验位进行就行测试，后产生多位检测信息，并从中得到具体出错位置，将其取反来纠正。\n 4. 步骤：计算校验位数 → 确定校验码位置 → 确定校验码 → 计算\n\n🌰：求1011的海明码。\n\n1.计算校验位数\n\n假设用 n 表示添加了校验码后整个编码信息的二进制位数长度，用 i 代表其中有效信息位， r 表示添加的校验码位，他们之间的关系应满足：\n\n\n\n即 4+ r ≤ 2r - 1\n\n2.确定校验码位置\n\n求得校验码位至少为3位，分别放在第20，21，22位。即第1位，第2位和第4位。\n\n位数    7       6       5       4    3       2    1\n信息位   1（i4）   0（i3）   1（i2）        1（i1）        \n校验位                           r2           r1   r0\n\n3.确定校验码\n\n【i4】 7 = 0111 第2,1,0位；即第7位的信息为会影响到 r2 r1 r0 【i3】6 = 0110 第2,1位； 即第6位的信息为会影响到 r2 r1 【i2】5 = 0101 第3,1位；即第5位的信息为会影响到 r2 r0 【i1】3 = 0011 第2,1位；即第3位的信息为会影响到 r1 r0\n\n4.计算\n\nr2 = i4 ⊕ i3 ⊕ i2 = 1 ⊕ 0 ⊕ 1 = 0 r1 = i4 ⊕ i3 ⊕ i1 = 1 ⊕ 0 ⊕ 1 = 0 r0 = i4 ⊕ i2 ⊕ i1 = 1 ⊕ 1 ⊕ 1 = 1\n\n故1011的海明码为1010101\n\n> ps:异或运算，同为0，异为1\n\na   b   a ⊕ b\n0   0   0\n0   1   1\n1   0   1\n1   1   0\n\n🌰：纠正海明码1011101的错误。\n\n计算得到的校验码为 100 ，给出的校验码为101，按位异或 得到 001，即第一位错误，将其取反即可，即1011100。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL安装",frontmatter:{title:"MySQL安装",date:"2022-02-10T12:16:00.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/4d8727/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/03.MySQL%E5%AE%89%E8%A3%85.html",relativePath:"01.指南/04.数据库/03.MySQL安装.md",key:"v-47ed6a43",path:"/pages/4d8727/",headers:[{level:2,title:"MySQL安装",slug:"mysql安装",normalizedTitle:"mysql安装",charIndex:2},{level:3,title:"1. 安装",slug:"_1-安装",normalizedTitle:"1. 安装",charIndex:14},{level:3,title:"2. 配置",slug:"_2-配置",normalizedTitle:"2. 配置",charIndex:129}],headersStr:"MySQL安装 1. 安装 2. 配置",content:'# MySQL安装\n\n\n# 1. 安装\n\n1). 双击官方下来的安装包文件\n\n\n\n2). 根据安装提示进行安装\n\n安装MySQL的相关组件，这个过程可能需要耗时几分钟，耐心等待。\n\n\n\n==输入MySQL中root用户的密码,一定记得记住该密码==\n\n\n# 2. 配置\n\n安装好MySQL之后，还需要配置环境变量，这样才可以在任何目录下连接MySQL。\n\n1). 在此电脑上，右键选择属性\n\n\n\n2). 点击左侧的 "高级系统设置"，选择环境变量\n\n3). 找到 Path 系统变量, 点击 "编辑"\n\n4). 选择 "新建" , 将MySQL Server的安装目录下的bin目录添加到环境变量',normalizedContent:'# mysql安装\n\n\n# 1. 安装\n\n1). 双击官方下来的安装包文件\n\n\n\n2). 根据安装提示进行安装\n\n安装mysql的相关组件，这个过程可能需要耗时几分钟，耐心等待。\n\n\n\n==输入mysql中root用户的密码,一定记得记住该密码==\n\n\n# 2. 配置\n\n安装好mysql之后，还需要配置环境变量，这样才可以在任何目录下连接mysql。\n\n1). 在此电脑上，右键选择属性\n\n\n\n2). 点击左侧的 "高级系统设置"，选择环境变量\n\n3). 找到 path 系统变量, 点击 "编辑"\n\n4). 选择 "新建" , 将mysql server的安装目录下的bin目录添加到环境变量',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据库系统",frontmatter:{title:"数据库系统",date:"2022-12-18T12:01:00.000Z",permalink:"/pages/454a1c/",categories:["MySQL"],tags:["MySQL"]},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.html",relativePath:"01.指南/04.数据库/01.数据库系统.md",key:"v-faf15f2e",path:"/pages/454a1c/",headers:[{level:2,title:"1.数据库系统设计",slug:"_1-数据库系统设计",normalizedTitle:"1.数据库系统设计",charIndex:12},{level:3,title:"1.1 学习导航",slug:"_1-1-学习导航",normalizedTitle:"1.1 学习导航",charIndex:26},{level:3,title:"1.2 三级模式两级映射",slug:"_1-2-三级模式两级映射",normalizedTitle:"1.2 三级模式两级映射",charIndex:134},{level:3,title:"1.3 数据库的设计过程",slug:"_1-3-数据库的设计过程",normalizedTitle:"1.3 数据库的设计过程",charIndex:982},{level:3,title:"1.4 ER模型",slug:"_1-4-er模型",normalizedTitle:"1.4 er模型",charIndex:1118},{level:3,title:"1.5 ER模型转关系模式",slug:"_1-5-er模型转关系模式",normalizedTitle:"1.5 er模型转关系模式",charIndex:1361},{level:3,title:"1.6 关系代数",slug:"_1-6-关系代数",normalizedTitle:"1.6 关系代数",charIndex:1822},{level:2,title:"2.规范化理论",slug:"_2-规范化理论",normalizedTitle:"2.规范化理论",charIndex:2775},{level:3,title:"2.1 函数依赖",slug:"_2-1-函数依赖",normalizedTitle:"2.1 函数依赖",charIndex:2787},{level:3,title:"2.2 价值与用途",slug:"_2-2-价值与用途",normalizedTitle:"2.2 价值与用途",charIndex:3101},{level:3,title:"2.3 键",slug:"_2-3-键",normalizedTitle:"2.3 键",charIndex:3159},{level:3,title:"2.4 范式",slug:"_2-4-范式",normalizedTitle:"2.4 范式",charIndex:3793},{level:3,title:"2.5 第一范式",slug:"_2-5-第一范式",normalizedTitle:"2.5 第一范式",charIndex:4381},{level:3,title:"2.6 第二范式",slug:"_2-6-第二范式",normalizedTitle:"2.6 第二范式",charIndex:4496},{level:3,title:"2.7 第三范式",slug:"_2-7-第三范式",normalizedTitle:"2.7 第三范式",charIndex:5092},{level:3,title:"2.8 BC范式",slug:"_2-8-bc范式",normalizedTitle:"2.8 bc范式",charIndex:5363},{level:3,title:"2.9 模式分解",slug:"_2-9-模式分解",normalizedTitle:"2.9 模式分解",charIndex:5766},{level:3,title:"2.10 保持函数依赖分解",slug:"_2-10-保持函数依赖分解",normalizedTitle:"2.10 保持函数依赖分解",charIndex:5878},{level:3,title:"2.11 无损分解",slug:"_2-11-无损分解",normalizedTitle:"2.11 无损分解",charIndex:6353},{level:2,title:"3. 数据库并发控制",slug:"_3-数据库并发控制",normalizedTitle:"3. 数据库并发控制",charIndex:6475},{level:3,title:"3.1 并发基本概念",slug:"_3-1-并发基本概念",normalizedTitle:"3.1 并发基本概念",charIndex:6490},{level:3,title:"3.2 存在的问题实例",slug:"_3-2-存在的问题实例",normalizedTitle:"3.2 存在的问题实例",charIndex:6781},{level:3,title:"3.3 封锁协议",slug:"_3-3-封锁协议",normalizedTitle:"3.3 封锁协议",charIndex:7152},{level:2,title:"4. 数据库的完整性约束",slug:"_4-数据库的完整性约束",normalizedTitle:"4. 数据库的完整性约束",charIndex:7328},{level:3,title:"4.1 数据库的完整约束",slug:"_4-1-数据库的完整约束",normalizedTitle:"4.1 数据库的完整约束",charIndex:7345},{level:3,title:"4.2 数据库安全",slug:"_4-2-数据库安全",normalizedTitle:"4.2 数据库安全",charIndex:7732},{level:3,title:"4.3 数据库的备份",slug:"_4-3-数据库的备份",normalizedTitle:"4.3 数据库的备份",charIndex:7748},{level:3,title:"4.4 数据库故障与恢复",slug:"_4-4-数据库故障与恢复",normalizedTitle:"4.4 数据库故障与恢复",charIndex:8292},{level:3,title:"4.5 数据仓库与数据挖掘",slug:"_4-5-数据仓库与数据挖掘",normalizedTitle:"4.5 数据仓库与数据挖掘",charIndex:8311},{level:3,title:"4.6 反规范化技术",slug:"_4-6-反规范化技术",normalizedTitle:"4.6 反规范化技术",charIndex:8635},{level:2,title:"5. 大数据的基本概念",slug:"_5-大数据的基本概念",normalizedTitle:"5. 大数据的基本概念",charIndex:8741},{level:3,title:"5.1 基本了解",slug:"_5-1-基本了解",normalizedTitle:"5.1 基本了解",charIndex:8757},{level:3,title:"5.2 大数据",slug:"_5-2-大数据",normalizedTitle:"5.2 大数据",charIndex:8844}],headersStr:"1.数据库系统设计 1.1 学习导航 1.2 三级模式两级映射 1.3 数据库的设计过程 1.4 ER模型 1.5 ER模型转关系模式 1.6 关系代数 2.规范化理论 2.1 函数依赖 2.2 价值与用途 2.3 键 2.4 范式 2.5 第一范式 2.6 第二范式 2.7 第三范式 2.8 BC范式 2.9 模式分解 2.10 保持函数依赖分解 2.11 无损分解 3. 数据库并发控制 3.1 并发基本概念 3.2 存在的问题实例 3.3 封锁协议 4. 数据库的完整性约束 4.1 数据库的完整约束 4.2 数据库安全 4.3 数据库的备份 4.4 数据库故障与恢复 4.5 数据仓库与数据挖掘 4.6 反规范化技术 5. 大数据的基本概念 5.1 基本了解 5.2 大数据",content:"# 数据库系统\n\n\n# 1.数据库系统设计\n\n\n# 1.1 学习导航\n\n需要学习的内容如下：\n\n * 数据库模式\n * ER模型\n * 关系代数与元组演算\n * 规范化理论\n * 并发控制\n * 数据库完整性约束\n * 分布式数据库\n * 数据仓库与数据挖掘\n\n\n# 1.2 三级模式两级映射\n\n数据库三级模式两级映射是（常考）题\n\n三级模式两级映射这种设计属于层次型的架构设计，这种层次型设计为我们应用数据库提供了很多方面的便利，同时，让整个系统的可维护性和应变能力变得更好。\n\n\n\n物理数据库：在计算机上面表现形式是一个文件。SQLServer、MySQL等。\n\n三级模式详细如下：\n\n * 内模式：又叫物理数据库层次，和物理层的数据库直接关联，管的是如何去存储这一系列的数据，数据要存到物理文件上面，按什么格式来存储，如何去优化；它主要的关注点是数据的存放。\n * 概念模式：平常用数据库时，表这一级别，数据库中会有很多表，这些表对应的就是概念模式，这一级模式中将数据分成若干张表，这些表是根据我们的业务，根据我们的应用来划分出来的。表之间会有相应的关联。\n * 外模式：它所对应的是数据库中的视图，外模式的应用让我们对数据的控制有了更进一步的手段，更加灵活的一些处置方式。如：在概念模式中用户信息表，该表包含多种用户信息，用户名，密码等，在应用过程中，如果任何一个功能模块都能直接去调用用户的所有信息，这不是很安全；并且如果概念模式中的表发生了变化，应用程序如果直接去调用这些表，那么应用程序也会跟着变。但是如果加了一层外模式之后，会将原来的数据表进行一定的处理之后形成相应的数据表。登录时候只需要用户名，密码调出来，形成一个视图，给登录模块用，在内部调用时候，只需要用户信息，不需要用户密码，则可以建一个视图，不包含密码，增加了安全性。也增加了灵活性。\n\n两级映射详细如下：\n\n * 外模式-概念模式映射：表通过相应的操作得到视图，其实表和视图之间是有一种映射关系的，这种映射关系被称之为外模式-概念模式映射。有了这一级映射，当表发生变化，我们只需要改映射，而不需要改应用程序。\n * 概念模式-内模式映射：主要管内部的存储形式和表的情况的一种映射关系；当存储结构进行改变时，只需调整这种映射关系，而不需要修改用户的应用程序，就能应对这种变化。\n\n\n# 1.3 数据库的设计过程\n\n主要分为三个阶段：\n\n * 需求分析\n * 概念结构设计\n * 逻辑结构设计\n * 物理设计\n\n需求分析：整个系统对数据有什么样的要求，有从用户收集过来的，同时有转换的过程中产生的需求。\n\n概念结构设计：主要表达形式就是ER模型。\n\n\n\n\n# 1.4 ER模型\n\n集成的方法：\n\n✔ 多个局部E-R图一次集成\n\n✔ 逐步集成，用累加的方式一次集成两个局部E-R\n\n集成产生的冲突及解决办法\n\n✔ 属性冲突： 包括属性域冲突和属性取值冲突\n\n✔ 命名冲突： 包括同名异义和异名同义\n\n✔ 结构冲突： 包括同一 对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。\n\n\n\n学生和课程是多对多的关系：一个学生记录可以对应多个课程的记录，反之，一个课程可以供多个学生来选择。\n\n\n# 1.5 ER模型转关系模式\n\n一个实体转为一个关系模式：\n\n * 1：1联系：两个实体各转成一个关系模式，中间的联系可以转成单独的一个关系模式，也可以把联系合并到与之关联的两端的任意一端的实体上。一对一联系最少转成两个关系模式。一个实体转成一个关系模式，把联系记录到任一实体上记录下来。\n * 1：n联系：每一个实体转成单独的一个关系模式；可以将单独将联系转成一个关系模式，这种做法可以，但不是必须的。也可以把这种联系记录到n，也就是多的一端； 如：员工和部门的关系就是一对多，把这种联系只能记录在员工端，即在员工表中加上一个部门号。一对多的联系中，最少要转成两个关系模式，联系可以合并到多的一端。\n * m：n联系：学生和课程多对多的联系，学生表转成一个单独的实体，课程表转成一个单独的实体，选课的联系也必须转成一个单独的实体。多对多的联系，至少要转成3个关系模式。\n\n> 熟记：\n> \n>  1. 一个实体型转为一个关系模式 ： 1：1联系 、1：n联系、m：n联系\n>  2. 三个以上实体间的一个多元联系\n\n\n# 1.6 关系代数\n\n并：将两个集合的内容并到一起，两个集合当中都有的数据只显示一次。\n\n交：将公共部分找出来，形成新的关系。\n\n差：我有的你没有；S1-S2，结果集是S1有但S2没有。将S1中公共部分去掉。\n\n\n\n笛卡尔积：笛卡尔积的符号是一个乘号，笛卡尔的结果是：前三个字段来自于S1，后三个字段来自于S2，在笛卡尔积中会把两个参与笛卡尔积操作的集合的属性一一的列出来，成为笛卡尔积最终的结果，这是包含那些数据列的问题。（笛卡尔积不会将相同的字段给去掉） 包含那些记录：记录是这样原则产生的，S1的第一条记录要跟S2的一、二、三的每一条记录要做一次组合，形成一条新的记录。S1的第二第三条记录也是依次和S2的第一、第二、第三条记录做拼接。这样就得到了笛卡尔积。 笛卡尔积结果的属性的个数是参与操作的两个属性树之和； 而记录数是两个记录数之积。\n\n投影：对S1做投影，结果就是只有投影下来的哪几列数据了，没有投影的那部分数据就丢弃了；所以投影是选列的一种操作，选出哪些我需要的列； 如图：对S1的 Sno和Sname做了投影，所以结果集就只有Sno和Sname；\n\n选择：选择选的记录，选的是行。对S1做选择操作，Sno=No0003，这一条记录就被选出来了，在投影和选择操作过程中，值得我们注意的一点是：在选择列也好，选择行也好，有的时候在写它的选择和投影操作的属性的时候，有时用的是属性名，有时用的是数字编码代号，以第一个投影操作来看，我们可以写出它的等价形式：π 1,2 (S1)； 在选择操作中也可以有同样的写法。\n\n\n\n联接：一般联接操作下面会写联接的条件，如：S1.Sno = S2.Sno。\n\n\n\n联接和笛卡尔积有啥区别：最大的区别：联接会把S1，S2都有的字段只保留一个。有时在联接过程中没有写条件，被称为自然连接，自然连接的条件是：这两个关系当中，相同的字段做等值。在S1、S2中，相同的字段只有Sno，所以不写条件默认就是S1的S1.Sno = S2.Sno。\n\n> 细节注意：\n> \n> 在做自然联接之后，要对某些字段做选择，只需要Sno、Sname、Age。可以写 π Sno,Sname,Age；也可以写成 π 1,2,4。值得特别注意的地方是：Sno我们只会保留一个。\n\n\n# 2.规范化理论\n\n\n# 2.1 函数依赖\n\n函数：f(x) = x^2；对于确定的x的值，都有唯一的f(x)的值与之对应。 此时我们就说x能够确定f(x)，这就是一种函数依赖。 如：学号能够函数确定姓名。反之则不行，因为姓名可能重名。\n\n\n\n部分函数依赖理论：A、B的组合键确定C，并且A确定C\n\n主键是两个属性的组合键，主键当中的一部分可以确定某一个属性，就是部分函数依赖。 如：学号，课程号，姓名；学号和课程号的组合键可以确定姓名，于此同时，学号也可以确定姓名。\n\n传递函数依赖：A可以确定B，B又可以确定C，这时可以得到一个推论：A确定C。 强调了一点：B不能确定A，因为如果B能够反过来确定A，说明A和B等价，就不存在传递性的讲法了。\n\n\n# 2.2 价值与用途\n\n非规范化的关系模式，肯能存在的问题包括：数据冗余、更新异常、插入异常、删除异常。\n\n\n\n\n# 2.3 键\n\n 1. 超键：唯一标识元组，可以是单个属性，也可以是属性的组合。 超键和候选键的唯一区别区别：超键可能存在冗余属性，而候选键不存在冗余属性。 所以，在超键的基础上消除多余的属性，就成为了候选键，候选键也是能够唯一标识元组。\n\n 2. 主键：候选键和主键的区别：候选键可以有多个，主键只能有一个。\n\n（选总统时候选人可以有多个，但是选出来的总统只能有一个）。在数据库中，几个字段都可以设置为主键，但是只能挑选其中的一个设置为主键。\n\n 3. 外键：别的关系的主键，因为很多时候我们要对表做关联。\n\n（比如：员工表中一般会设置部门号，部门号用来和部门表进行关联，那么部门号对于员工表就是一个外键。）外键的提出就是关联查询的时候用到的。\n\n\n\n求候选键：（常考）\n\n * 将关系模式的函数依赖关系用到“有向图”的方式表示\n * 找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有的结点，则该属性即为关系模式的候选键。\n * 若入度为0的属性集不能遍历图中所有的结点，则需要尝试性将一些中间结点（既有入度，也有出度的结点）并入入度为0的属性集中，直至该集合能遍历所有的结点，集合为候选键。\n\n\n\n例1：选A，入度：对于一个节点，指向该节点的为入度，从该节点指出的为出度。 例2：候选键是ABCD的组合键，ABCD的任何一个字母都不能遍历全图，只有将他们组合起来才能遍历全图。 例3：选B。A和B作为中间节点，都能遍历所有节点。\n\n\n# 2.4 范式\n\n> 范式是必考，要求掌握。\n\n范式会分为第一范式，第二范式，第三范式， BC范式以及更高级别的第四范式。\n\n范式在级别不断提高的时候，规范化程度是越来越高了。也就更有可能去解决插入异常，删除异常，数据冗余的问题。\n\n与此同时也带来了问题，即规范化程度越高，往往数据的粒度越小。\n\n要将范式提高级别，基本上走的方式都是数据表的拆分，越到高级别的范式，拆分的越细。 将数据一步步拆分的细的时候，往往又带来性能方面的问题。所以一般采取比较平衡、折中的方式。即将范式做到第三范式左右即可。\n\n要达到第二范式必先达到第一范式；以此类推，范式可以跨越。\n\n范式的级别：\n\n * 第一范式：属性值都是不可分的原子值，所谓原子值就是该属性无法再拆分为几个属性。\n * 第二范式：第一范式消除了非主属性对候选键的部分依赖，就到第二范式。\n * 第三范式：第二范式消除非主属性对候选键的传递依赖，就到第三范式。\n * BC范式：第三范式消除主属性对候选键的传递依赖。就到BC范式。\n\n\n\n主属性和非主属性的意思：所谓主属性，就是该属性属于候选键的一部分，（以第二范式的图为例，主属性有SNO，CNO都是主属性。而GRADE、CREDIT是非主属性）。所以判断主属性和非主属性，核心就在于那些是候选关键字。（将候选关键字列出来，在任何候选关键字中出现过的属性都是主属性）。\n\n\n# 2.5 第一范式\n\n\n\n以上关系不满足第一范式，因为该表中分为系名称和高级职称人数。而高级职称人数又可以分为教授和副教授，这就不满足第一范式的要求。 如果要改成第一范式，将高级职称人数去掉，直接就是系名称，教授，副教授。\n\n\n# 2.6 第二范式\n\n\n\n以上表SNO（学号）CNO（课程号）GRADE（成绩）CREDIT（学分）\n\n在以上关系中主键是SNO和CNO的组合键，SNO和CNO组合起来才能确定成绩；因为一个学生可以选多门课程（S01就选了C01，C02，C03上面课程），我们仅仅用课程号或者学号都不能确定成绩，必须是两者的组合键才能确定成绩，而学分是可以通过课程号来确定的，所以我们要求这一个关系模式的主键（候选键），候选键就是SNO和CNO的组合键。\n\n部分函数依赖带来的问题？\n\n * 数据冗余：学分存了很多次，这是不必要的，因为每一门学科都有固定的学分。学分好课程号的对应关 系存一个就可以了。\n\n * 更新异常：要更新学分的时候只更新了两条记录肯定不行。更新部分不更新部分导致更新异常。\n\n * 插入遗产：比如有一门新的课程C08，学分是6分，现在该课程还没人选，要想先将C08，6学分的信息录入到该表中，会无法录入，因为没有学号，系统不让录入，因为学号是主键。主键必须有值，不能为空。\n\n * 删除异常：比如学生毕业将他们的成绩信息全部清除，则学分信息也一并被删除掉了。（学分信息下届学生同样适用，应当予以保留）。\n\n * 解决方案：将CNO（课程号）和CREDIT（学分）两个字段提取出来，做一个新的关系模式。在原来的关系模式中将学分列去掉，注意：不能去掉课程号字段，因为数据会不完整。\n\n\n# 2.7 第三范式\n\n\n\n以上表显然已达到第二范式的要求，因为已标识出SNO是主键，知道这一点，不用再细致去分析，也知道，它已经属于第二范式了，因为它的主键只有单属性，单属性是不可能有部分函数依赖存在的，所以如果说我们求出来是单属性的关键字，那就不存在部分函数依赖的可能。 该表虽然已经达到第二范式，单仍然有数据冗余等一系列的问题（更新，插入，删除异常）。\n\n解决方案：将DNO，DNAME，LOCATION独立出来，成为一个关系模式。这样就打破现有的这种传递依赖了，原来的关系模式就只剩下前三个字段了（SNO、SName、DNO）。\n\n\n# 2.8 BC范式\n\n\n\nSJ是一个候选键，ST也是一个候选键（因为ST中T可确定J）。 STJ都是主属性，在这个关系模式中没有非主属性。既然没有非主属性，所以肯定满足第二范式和第三范式的。因为第二范式是消除非主属性对候选键的部分函数依赖，而第三范式是消除非主属性对候选键的传递依赖。现在连非主属性都没有了，自然这些依赖也就不存在了。\n\n任何判断是否是BC范式？ R属于BCNF当且仅当其F中每个依赖的决定因素必定包含R的某个候选码、（通俗讲就是：我们将所有的函数依赖写出来，函数依赖的左边部分必须是候选键，因为函数依赖里面，左边部分，就是它所谓的决定因素）。\n\n上图有哪些函数依赖，函数依赖包括 “SJ确定T”，还有“T确定J”，对于第一个函数依赖，明显左边部分是一个候选键，而对于第二个函数依赖左边部分不是一个候选键，所以我们判断，这不是BCNF，或者说该关系模式还没有达到BCNF的级别要求。\n\n\n# 2.9 模式分解\n\n\n\n在之前讲范式的过程中，当范式级别不够时候，是将模式进行拆分，拆分下来后级别就上去了，在拆分过程中，需要考虑到一些因素，拆分时有不同的拆分的机制，原则需要注意，模式的分解拆分，主要讲两个方面。\n\n\n# 2.10 保持函数依赖分解\n\n分解之前有哪些函数依赖，分解之后这些函数依赖仍然存在。\n\n例子：有一个关系模式，总共有A、B、C三个属性，R（A、B、C），然后有函数依赖，A确定B，B确定C，将其分成两个关系模式，R1（A、B），R2（B、C），这种分发就保持了函数依赖。因为，A和B都在R1中，所以R1保持了A到B的函数依赖，R2有B和C两个属性，所以B到C的函数依赖，被R2保存下来，所以两个函数依赖都被保存下来了，这就代表保持了函数依赖。\n\n * 假设将其拆分成R1（A、B）和R3（A、C），就没有保持函依赖，因为A确定B保存下来了，B确定C没有保存下来，所以这种形式没有保持函数依赖。\n\n * 能够将原关系模式当中的所有函数依赖关系，都将它写到新的拆分出来的这些关系当中来，代表函数一来就保持下来了。如果有缺失就不行。（对于冗余性质的函数依赖不要求保留。）\n\n * 假设R1（A、B），R2（B、C），R3（A、C），R3就是冗余的函数依赖，因为R1、R2的分解保持了函数依赖，因为A确定B，B确定C，就已经能将A确定C推导出来了。\n\n\n# 2.11 无损分解\n\n什么是无损分解和有损分解：\n\n * 有损：不能还原。将原关系模式R拆分之后，无法再还原成为R。\n * 无损：可以还原。如果可以通过链接操作将拆分后的关系模式，又可以组合起来，链接起来形成原来的关系模式，就是无损。\n\n\n# 3. 数据库并发控制\n\n\n# 3.1 并发基本概念\n\n事务：将多个操作封装起来，把它看做一个整体来进行操作（要么全做，要么全不做）。为什么要有事务机制呢？ 因为很多的操作有关联性，本身就是一个整体，如果不一次性执行完，会产生一系列的问题。\n\n事务的几大特性\n\n * 原子性：要么全做，要么全不做。事务操作是一个原子性操作，即不可再拆分来做。\n * 一致性：指事务在执行之前，数据是保持一致的状态，执行之后也是一致的状态。如：银行转账前后两个账号的钱的总和始终是一致的（类比能量守恒的状态）。\n * 隔离性：事务之间是独立进行的，隔离的，互不影响。\n * 持续性：事务执行之后，它的结果影响是持续的。\n\n\n\n\n# 3.2 存在的问题实例\n\n * 丢失更新：T1、T2两个事务，各司其职的运行，T1读取A并进行自减5写回的操作。T2读取A自减8写回操作。逻辑上来讲，T1、T2都执行完，A应该减13，但真正的结果是只减掉了8，即A=2，因为T2写回时会把T1的结果覆盖掉，即丢失更新。\n * 不可重复读：T1在读A、B求和，并二次求和做验算，但是在T1第二次求和过程中，T2对A进行了更新，导致T1的两次运算结果不同，验算不对。即重复读第二次时候，值以及不一样了——不可重复读。\n * 读“脏”数据：不是真正的数据，只是一个临时值，T1读取了A的值20，加50写回70，此时T2读取了A=70的值去进行它自己的操作，但是T1最后进行ROLLBACK操作（回滚，之间的所有操作将被复原），A的值回复为20。此时T2读到的A的值就是一个“脏”数据。\n\n\n\n\n# 3.3 封锁协议\n\n为了解决以上问题，提出了封锁协议：\n\n 1. S 锁是读锁，X锁是写锁。读锁加上之后，别人还可以对这个数据加读锁，但是不能加写锁，而写锁加上之后不能在之上加任何的锁。\n 2. 三级封锁协议和二级封锁协议，释放时间不一样，二级封锁协议，读完后即可释放，三级封锁协议是直到事务结束才释放。三级封锁协议以上三种情况都可应对。\n\n\n\n\n# 4. 数据库的完整性约束\n\n\n# 4.1 数据库的完整约束\n\n数据库的完整性约束：\n\n * 实体完整性约束\n * 参照完整性约束\n * 用户自定义完整性约束\n * 触发器\n\n数据库的完整性约束主要有三种：\n\n * 实体完整性约束：使用数据库的时候通过给数据表定义主键。实体完整性约束，约束的是主键，它的值不能为空，不能重复。\n * 参照完整性约束：外键的完整性约束。\n * 用户自定义完整性约束：用户可以设置该属性值的情况要求；比如：输入的是年龄，就不允许输入负数，也不允许输入200以上的值。就可以设置自定义完整性约束。\n\n以上三种完整性约束都是一种提高数据可靠性的一种机制，数据有问题，就不应该让它录入进数据库。\n\n但这三种完整性约束都只能应对简单的情况，复杂情况不能应对，所以此时又有一种新的机制---触发器：触发器可以写脚本来约束数据库数据的一些要求。所以更加复杂的要求使用触发器来完成的。\n\n\n# 4.2 数据库安全\n\n\n\n\n# 4.3 数据库的备份\n\n数据库的备份恢复分为： 静态备份和动态备份。\n\n 1. 冷备份也称为静态备份，是将数据库正常关闭，在停止状态下，将数据库的文件全部备份（复制）下来。\n 2. 热备份也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来。\n\n\n\n备份的另外一种分类方式：依据数据备份的量来进行区分的。\n\n * 完全备份： 备份所有的数据\n * 差量备份： 仅备份上一次完全备份之后变化的数据\n * 增量备份： 备份上一次备份之后变化的数据\n\n制定一个备份策略：\n\n\n\n周一的增量备份针对周日的完全备份的版本，在完全版本的基础上删除了哪些东西，增加了哪些东西，修改了什么东西等都在增量备份中体现。假设周一备份完发生故障，恢复数据先恢复周日的完全版，再在周日完全版的基础上恢复周一的增量版。\n\n同理：周二的增量是针对周一的，周三的增量是针对周二的，周三数据出故障：先恢复周日，在恢复周一，在恢复周二，最后恢复周三的。周四的差量备份是直接针对周日的完全备份来记录的。这种变化量跨度大，恢复时候方便。增量和差量有机的结合，是有利用备份和恢复的。\n\n\n\n转储就是备份：海量指所有数据，增量指上一次转储之后的。 静态就是不运行状态，动态是运行状态。\n\n\n\n\n# 4.4 数据库故障与恢复\n\n\n\n\n# 4.5 数据仓库与数据挖掘\n\n数据仓库\n\n * 面向主题\n * 集成的\n * 相对稳定的（非易失的）\n * 反映历史变化（随着时间变化）\n\n\n\n数据库和数据仓库的差异：\n\n 1. 数据库： 数据库是根据业务的需求看需要记录那些数据，就将其记录下来。（面向应用）\n 2. 数据集市：部门级的数据仓库。\n\n数据挖掘\n\n数据挖掘的方法分类：\n\n 1. 决策树\n 2. 神经网络\n 3. 遗传算法\n 4. 关联规则挖掘算法\n\n分类：\n\n 1. 关联分析： 挖掘出隐藏在数据间的相互关系\n 2. 序列模式分析： 侧重点是分析数据间的前后关系（因果关系）\n 3. 分类分析： 为每一个记录赋予一个标记再按标记分类\n 4. 聚类分析：分类分析法的逆过程\n\n\n# 4.6 反规范化技术\n\n\n\n反规范化的技术手段：就是规范化的逆过程，以牺牲空间和规范化程度来换取时间。\n\n技术手段有如下及几种：\n\n * 增加派生性冗余列\n * 增加冗余列\n * 重新组表\n * 分割表\n\n\n# 5. 大数据的基本概念\n\n\n# 5.1 基本了解\n\n大数据技术：对海量数据进行处理的相关技术； 这些数据具备什么特点？ 数据量极大，要求处理的速度极快，数据具有多样性，并且数据具备一定的价值。\n\n\n\n\n# 5.2 大数据\n\n\n\n大数据处理系统应该具有的重要特征\n\n * 高度可扩展性\n * 高性能\n * 高度容错\n * 支持异构环境\n * 较短的分析延迟\n * 易用且开放的接口\n * 较低成本\n * 向下兼容性\n\n现在大数据往往和云计算，虚拟化等技术结合起来来分析；云计算可以将一些闲置资源利用起来，成本较低。",normalizedContent:"# 数据库系统\n\n\n# 1.数据库系统设计\n\n\n# 1.1 学习导航\n\n需要学习的内容如下：\n\n * 数据库模式\n * er模型\n * 关系代数与元组演算\n * 规范化理论\n * 并发控制\n * 数据库完整性约束\n * 分布式数据库\n * 数据仓库与数据挖掘\n\n\n# 1.2 三级模式两级映射\n\n数据库三级模式两级映射是（常考）题\n\n三级模式两级映射这种设计属于层次型的架构设计，这种层次型设计为我们应用数据库提供了很多方面的便利，同时，让整个系统的可维护性和应变能力变得更好。\n\n\n\n物理数据库：在计算机上面表现形式是一个文件。sqlserver、mysql等。\n\n三级模式详细如下：\n\n * 内模式：又叫物理数据库层次，和物理层的数据库直接关联，管的是如何去存储这一系列的数据，数据要存到物理文件上面，按什么格式来存储，如何去优化；它主要的关注点是数据的存放。\n * 概念模式：平常用数据库时，表这一级别，数据库中会有很多表，这些表对应的就是概念模式，这一级模式中将数据分成若干张表，这些表是根据我们的业务，根据我们的应用来划分出来的。表之间会有相应的关联。\n * 外模式：它所对应的是数据库中的视图，外模式的应用让我们对数据的控制有了更进一步的手段，更加灵活的一些处置方式。如：在概念模式中用户信息表，该表包含多种用户信息，用户名，密码等，在应用过程中，如果任何一个功能模块都能直接去调用用户的所有信息，这不是很安全；并且如果概念模式中的表发生了变化，应用程序如果直接去调用这些表，那么应用程序也会跟着变。但是如果加了一层外模式之后，会将原来的数据表进行一定的处理之后形成相应的数据表。登录时候只需要用户名，密码调出来，形成一个视图，给登录模块用，在内部调用时候，只需要用户信息，不需要用户密码，则可以建一个视图，不包含密码，增加了安全性。也增加了灵活性。\n\n两级映射详细如下：\n\n * 外模式-概念模式映射：表通过相应的操作得到视图，其实表和视图之间是有一种映射关系的，这种映射关系被称之为外模式-概念模式映射。有了这一级映射，当表发生变化，我们只需要改映射，而不需要改应用程序。\n * 概念模式-内模式映射：主要管内部的存储形式和表的情况的一种映射关系；当存储结构进行改变时，只需调整这种映射关系，而不需要修改用户的应用程序，就能应对这种变化。\n\n\n# 1.3 数据库的设计过程\n\n主要分为三个阶段：\n\n * 需求分析\n * 概念结构设计\n * 逻辑结构设计\n * 物理设计\n\n需求分析：整个系统对数据有什么样的要求，有从用户收集过来的，同时有转换的过程中产生的需求。\n\n概念结构设计：主要表达形式就是er模型。\n\n\n\n\n# 1.4 er模型\n\n集成的方法：\n\n✔ 多个局部e-r图一次集成\n\n✔ 逐步集成，用累加的方式一次集成两个局部e-r\n\n集成产生的冲突及解决办法\n\n✔ 属性冲突： 包括属性域冲突和属性取值冲突\n\n✔ 命名冲突： 包括同名异义和异名同义\n\n✔ 结构冲突： 包括同一 对象在不同应用中具有不同的抽象，以及同一实体在不同局部e-r图中所包含的属性个数和属性排列次序不完全相同。\n\n\n\n学生和课程是多对多的关系：一个学生记录可以对应多个课程的记录，反之，一个课程可以供多个学生来选择。\n\n\n# 1.5 er模型转关系模式\n\n一个实体转为一个关系模式：\n\n * 1：1联系：两个实体各转成一个关系模式，中间的联系可以转成单独的一个关系模式，也可以把联系合并到与之关联的两端的任意一端的实体上。一对一联系最少转成两个关系模式。一个实体转成一个关系模式，把联系记录到任一实体上记录下来。\n * 1：n联系：每一个实体转成单独的一个关系模式；可以将单独将联系转成一个关系模式，这种做法可以，但不是必须的。也可以把这种联系记录到n，也就是多的一端； 如：员工和部门的关系就是一对多，把这种联系只能记录在员工端，即在员工表中加上一个部门号。一对多的联系中，最少要转成两个关系模式，联系可以合并到多的一端。\n * m：n联系：学生和课程多对多的联系，学生表转成一个单独的实体，课程表转成一个单独的实体，选课的联系也必须转成一个单独的实体。多对多的联系，至少要转成3个关系模式。\n\n> 熟记：\n> \n>  1. 一个实体型转为一个关系模式 ： 1：1联系 、1：n联系、m：n联系\n>  2. 三个以上实体间的一个多元联系\n\n\n# 1.6 关系代数\n\n并：将两个集合的内容并到一起，两个集合当中都有的数据只显示一次。\n\n交：将公共部分找出来，形成新的关系。\n\n差：我有的你没有；s1-s2，结果集是s1有但s2没有。将s1中公共部分去掉。\n\n\n\n笛卡尔积：笛卡尔积的符号是一个乘号，笛卡尔的结果是：前三个字段来自于s1，后三个字段来自于s2，在笛卡尔积中会把两个参与笛卡尔积操作的集合的属性一一的列出来，成为笛卡尔积最终的结果，这是包含那些数据列的问题。（笛卡尔积不会将相同的字段给去掉） 包含那些记录：记录是这样原则产生的，s1的第一条记录要跟s2的一、二、三的每一条记录要做一次组合，形成一条新的记录。s1的第二第三条记录也是依次和s2的第一、第二、第三条记录做拼接。这样就得到了笛卡尔积。 笛卡尔积结果的属性的个数是参与操作的两个属性树之和； 而记录数是两个记录数之积。\n\n投影：对s1做投影，结果就是只有投影下来的哪几列数据了，没有投影的那部分数据就丢弃了；所以投影是选列的一种操作，选出哪些我需要的列； 如图：对s1的 sno和sname做了投影，所以结果集就只有sno和sname；\n\n选择：选择选的记录，选的是行。对s1做选择操作，sno=no0003，这一条记录就被选出来了，在投影和选择操作过程中，值得我们注意的一点是：在选择列也好，选择行也好，有的时候在写它的选择和投影操作的属性的时候，有时用的是属性名，有时用的是数字编码代号，以第一个投影操作来看，我们可以写出它的等价形式：π 1,2 (s1)； 在选择操作中也可以有同样的写法。\n\n\n\n联接：一般联接操作下面会写联接的条件，如：s1.sno = s2.sno。\n\n\n\n联接和笛卡尔积有啥区别：最大的区别：联接会把s1，s2都有的字段只保留一个。有时在联接过程中没有写条件，被称为自然连接，自然连接的条件是：这两个关系当中，相同的字段做等值。在s1、s2中，相同的字段只有sno，所以不写条件默认就是s1的s1.sno = s2.sno。\n\n> 细节注意：\n> \n> 在做自然联接之后，要对某些字段做选择，只需要sno、sname、age。可以写 π sno,sname,age；也可以写成 π 1,2,4。值得特别注意的地方是：sno我们只会保留一个。\n\n\n# 2.规范化理论\n\n\n# 2.1 函数依赖\n\n函数：f(x) = x^2；对于确定的x的值，都有唯一的f(x)的值与之对应。 此时我们就说x能够确定f(x)，这就是一种函数依赖。 如：学号能够函数确定姓名。反之则不行，因为姓名可能重名。\n\n\n\n部分函数依赖理论：a、b的组合键确定c，并且a确定c\n\n主键是两个属性的组合键，主键当中的一部分可以确定某一个属性，就是部分函数依赖。 如：学号，课程号，姓名；学号和课程号的组合键可以确定姓名，于此同时，学号也可以确定姓名。\n\n传递函数依赖：a可以确定b，b又可以确定c，这时可以得到一个推论：a确定c。 强调了一点：b不能确定a，因为如果b能够反过来确定a，说明a和b等价，就不存在传递性的讲法了。\n\n\n# 2.2 价值与用途\n\n非规范化的关系模式，肯能存在的问题包括：数据冗余、更新异常、插入异常、删除异常。\n\n\n\n\n# 2.3 键\n\n 1. 超键：唯一标识元组，可以是单个属性，也可以是属性的组合。 超键和候选键的唯一区别区别：超键可能存在冗余属性，而候选键不存在冗余属性。 所以，在超键的基础上消除多余的属性，就成为了候选键，候选键也是能够唯一标识元组。\n\n 2. 主键：候选键和主键的区别：候选键可以有多个，主键只能有一个。\n\n（选总统时候选人可以有多个，但是选出来的总统只能有一个）。在数据库中，几个字段都可以设置为主键，但是只能挑选其中的一个设置为主键。\n\n 3. 外键：别的关系的主键，因为很多时候我们要对表做关联。\n\n（比如：员工表中一般会设置部门号，部门号用来和部门表进行关联，那么部门号对于员工表就是一个外键。）外键的提出就是关联查询的时候用到的。\n\n\n\n求候选键：（常考）\n\n * 将关系模式的函数依赖关系用到“有向图”的方式表示\n * 找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有的结点，则该属性即为关系模式的候选键。\n * 若入度为0的属性集不能遍历图中所有的结点，则需要尝试性将一些中间结点（既有入度，也有出度的结点）并入入度为0的属性集中，直至该集合能遍历所有的结点，集合为候选键。\n\n\n\n例1：选a，入度：对于一个节点，指向该节点的为入度，从该节点指出的为出度。 例2：候选键是abcd的组合键，abcd的任何一个字母都不能遍历全图，只有将他们组合起来才能遍历全图。 例3：选b。a和b作为中间节点，都能遍历所有节点。\n\n\n# 2.4 范式\n\n> 范式是必考，要求掌握。\n\n范式会分为第一范式，第二范式，第三范式， bc范式以及更高级别的第四范式。\n\n范式在级别不断提高的时候，规范化程度是越来越高了。也就更有可能去解决插入异常，删除异常，数据冗余的问题。\n\n与此同时也带来了问题，即规范化程度越高，往往数据的粒度越小。\n\n要将范式提高级别，基本上走的方式都是数据表的拆分，越到高级别的范式，拆分的越细。 将数据一步步拆分的细的时候，往往又带来性能方面的问题。所以一般采取比较平衡、折中的方式。即将范式做到第三范式左右即可。\n\n要达到第二范式必先达到第一范式；以此类推，范式可以跨越。\n\n范式的级别：\n\n * 第一范式：属性值都是不可分的原子值，所谓原子值就是该属性无法再拆分为几个属性。\n * 第二范式：第一范式消除了非主属性对候选键的部分依赖，就到第二范式。\n * 第三范式：第二范式消除非主属性对候选键的传递依赖，就到第三范式。\n * bc范式：第三范式消除主属性对候选键的传递依赖。就到bc范式。\n\n\n\n主属性和非主属性的意思：所谓主属性，就是该属性属于候选键的一部分，（以第二范式的图为例，主属性有sno，cno都是主属性。而grade、credit是非主属性）。所以判断主属性和非主属性，核心就在于那些是候选关键字。（将候选关键字列出来，在任何候选关键字中出现过的属性都是主属性）。\n\n\n# 2.5 第一范式\n\n\n\n以上关系不满足第一范式，因为该表中分为系名称和高级职称人数。而高级职称人数又可以分为教授和副教授，这就不满足第一范式的要求。 如果要改成第一范式，将高级职称人数去掉，直接就是系名称，教授，副教授。\n\n\n# 2.6 第二范式\n\n\n\n以上表sno（学号）cno（课程号）grade（成绩）credit（学分）\n\n在以上关系中主键是sno和cno的组合键，sno和cno组合起来才能确定成绩；因为一个学生可以选多门课程（s01就选了c01，c02，c03上面课程），我们仅仅用课程号或者学号都不能确定成绩，必须是两者的组合键才能确定成绩，而学分是可以通过课程号来确定的，所以我们要求这一个关系模式的主键（候选键），候选键就是sno和cno的组合键。\n\n部分函数依赖带来的问题？\n\n * 数据冗余：学分存了很多次，这是不必要的，因为每一门学科都有固定的学分。学分好课程号的对应关 系存一个就可以了。\n\n * 更新异常：要更新学分的时候只更新了两条记录肯定不行。更新部分不更新部分导致更新异常。\n\n * 插入遗产：比如有一门新的课程c08，学分是6分，现在该课程还没人选，要想先将c08，6学分的信息录入到该表中，会无法录入，因为没有学号，系统不让录入，因为学号是主键。主键必须有值，不能为空。\n\n * 删除异常：比如学生毕业将他们的成绩信息全部清除，则学分信息也一并被删除掉了。（学分信息下届学生同样适用，应当予以保留）。\n\n * 解决方案：将cno（课程号）和credit（学分）两个字段提取出来，做一个新的关系模式。在原来的关系模式中将学分列去掉，注意：不能去掉课程号字段，因为数据会不完整。\n\n\n# 2.7 第三范式\n\n\n\n以上表显然已达到第二范式的要求，因为已标识出sno是主键，知道这一点，不用再细致去分析，也知道，它已经属于第二范式了，因为它的主键只有单属性，单属性是不可能有部分函数依赖存在的，所以如果说我们求出来是单属性的关键字，那就不存在部分函数依赖的可能。 该表虽然已经达到第二范式，单仍然有数据冗余等一系列的问题（更新，插入，删除异常）。\n\n解决方案：将dno，dname，location独立出来，成为一个关系模式。这样就打破现有的这种传递依赖了，原来的关系模式就只剩下前三个字段了（sno、sname、dno）。\n\n\n# 2.8 bc范式\n\n\n\nsj是一个候选键，st也是一个候选键（因为st中t可确定j）。 stj都是主属性，在这个关系模式中没有非主属性。既然没有非主属性，所以肯定满足第二范式和第三范式的。因为第二范式是消除非主属性对候选键的部分函数依赖，而第三范式是消除非主属性对候选键的传递依赖。现在连非主属性都没有了，自然这些依赖也就不存在了。\n\n任何判断是否是bc范式？ r属于bcnf当且仅当其f中每个依赖的决定因素必定包含r的某个候选码、（通俗讲就是：我们将所有的函数依赖写出来，函数依赖的左边部分必须是候选键，因为函数依赖里面，左边部分，就是它所谓的决定因素）。\n\n上图有哪些函数依赖，函数依赖包括 “sj确定t”，还有“t确定j”，对于第一个函数依赖，明显左边部分是一个候选键，而对于第二个函数依赖左边部分不是一个候选键，所以我们判断，这不是bcnf，或者说该关系模式还没有达到bcnf的级别要求。\n\n\n# 2.9 模式分解\n\n\n\n在之前讲范式的过程中，当范式级别不够时候，是将模式进行拆分，拆分下来后级别就上去了，在拆分过程中，需要考虑到一些因素，拆分时有不同的拆分的机制，原则需要注意，模式的分解拆分，主要讲两个方面。\n\n\n# 2.10 保持函数依赖分解\n\n分解之前有哪些函数依赖，分解之后这些函数依赖仍然存在。\n\n例子：有一个关系模式，总共有a、b、c三个属性，r（a、b、c），然后有函数依赖，a确定b，b确定c，将其分成两个关系模式，r1（a、b），r2（b、c），这种分发就保持了函数依赖。因为，a和b都在r1中，所以r1保持了a到b的函数依赖，r2有b和c两个属性，所以b到c的函数依赖，被r2保存下来，所以两个函数依赖都被保存下来了，这就代表保持了函数依赖。\n\n * 假设将其拆分成r1（a、b）和r3（a、c），就没有保持函依赖，因为a确定b保存下来了，b确定c没有保存下来，所以这种形式没有保持函数依赖。\n\n * 能够将原关系模式当中的所有函数依赖关系，都将它写到新的拆分出来的这些关系当中来，代表函数一来就保持下来了。如果有缺失就不行。（对于冗余性质的函数依赖不要求保留。）\n\n * 假设r1（a、b），r2（b、c），r3（a、c），r3就是冗余的函数依赖，因为r1、r2的分解保持了函数依赖，因为a确定b，b确定c，就已经能将a确定c推导出来了。\n\n\n# 2.11 无损分解\n\n什么是无损分解和有损分解：\n\n * 有损：不能还原。将原关系模式r拆分之后，无法再还原成为r。\n * 无损：可以还原。如果可以通过链接操作将拆分后的关系模式，又可以组合起来，链接起来形成原来的关系模式，就是无损。\n\n\n# 3. 数据库并发控制\n\n\n# 3.1 并发基本概念\n\n事务：将多个操作封装起来，把它看做一个整体来进行操作（要么全做，要么全不做）。为什么要有事务机制呢？ 因为很多的操作有关联性，本身就是一个整体，如果不一次性执行完，会产生一系列的问题。\n\n事务的几大特性\n\n * 原子性：要么全做，要么全不做。事务操作是一个原子性操作，即不可再拆分来做。\n * 一致性：指事务在执行之前，数据是保持一致的状态，执行之后也是一致的状态。如：银行转账前后两个账号的钱的总和始终是一致的（类比能量守恒的状态）。\n * 隔离性：事务之间是独立进行的，隔离的，互不影响。\n * 持续性：事务执行之后，它的结果影响是持续的。\n\n\n\n\n# 3.2 存在的问题实例\n\n * 丢失更新：t1、t2两个事务，各司其职的运行，t1读取a并进行自减5写回的操作。t2读取a自减8写回操作。逻辑上来讲，t1、t2都执行完，a应该减13，但真正的结果是只减掉了8，即a=2，因为t2写回时会把t1的结果覆盖掉，即丢失更新。\n * 不可重复读：t1在读a、b求和，并二次求和做验算，但是在t1第二次求和过程中，t2对a进行了更新，导致t1的两次运算结果不同，验算不对。即重复读第二次时候，值以及不一样了——不可重复读。\n * 读“脏”数据：不是真正的数据，只是一个临时值，t1读取了a的值20，加50写回70，此时t2读取了a=70的值去进行它自己的操作，但是t1最后进行rollback操作（回滚，之间的所有操作将被复原），a的值回复为20。此时t2读到的a的值就是一个“脏”数据。\n\n\n\n\n# 3.3 封锁协议\n\n为了解决以上问题，提出了封锁协议：\n\n 1. s 锁是读锁，x锁是写锁。读锁加上之后，别人还可以对这个数据加读锁，但是不能加写锁，而写锁加上之后不能在之上加任何的锁。\n 2. 三级封锁协议和二级封锁协议，释放时间不一样，二级封锁协议，读完后即可释放，三级封锁协议是直到事务结束才释放。三级封锁协议以上三种情况都可应对。\n\n\n\n\n# 4. 数据库的完整性约束\n\n\n# 4.1 数据库的完整约束\n\n数据库的完整性约束：\n\n * 实体完整性约束\n * 参照完整性约束\n * 用户自定义完整性约束\n * 触发器\n\n数据库的完整性约束主要有三种：\n\n * 实体完整性约束：使用数据库的时候通过给数据表定义主键。实体完整性约束，约束的是主键，它的值不能为空，不能重复。\n * 参照完整性约束：外键的完整性约束。\n * 用户自定义完整性约束：用户可以设置该属性值的情况要求；比如：输入的是年龄，就不允许输入负数，也不允许输入200以上的值。就可以设置自定义完整性约束。\n\n以上三种完整性约束都是一种提高数据可靠性的一种机制，数据有问题，就不应该让它录入进数据库。\n\n但这三种完整性约束都只能应对简单的情况，复杂情况不能应对，所以此时又有一种新的机制---触发器：触发器可以写脚本来约束数据库数据的一些要求。所以更加复杂的要求使用触发器来完成的。\n\n\n# 4.2 数据库安全\n\n\n\n\n# 4.3 数据库的备份\n\n数据库的备份恢复分为： 静态备份和动态备份。\n\n 1. 冷备份也称为静态备份，是将数据库正常关闭，在停止状态下，将数据库的文件全部备份（复制）下来。\n 2. 热备份也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来。\n\n\n\n备份的另外一种分类方式：依据数据备份的量来进行区分的。\n\n * 完全备份： 备份所有的数据\n * 差量备份： 仅备份上一次完全备份之后变化的数据\n * 增量备份： 备份上一次备份之后变化的数据\n\n制定一个备份策略：\n\n\n\n周一的增量备份针对周日的完全备份的版本，在完全版本的基础上删除了哪些东西，增加了哪些东西，修改了什么东西等都在增量备份中体现。假设周一备份完发生故障，恢复数据先恢复周日的完全版，再在周日完全版的基础上恢复周一的增量版。\n\n同理：周二的增量是针对周一的，周三的增量是针对周二的，周三数据出故障：先恢复周日，在恢复周一，在恢复周二，最后恢复周三的。周四的差量备份是直接针对周日的完全备份来记录的。这种变化量跨度大，恢复时候方便。增量和差量有机的结合，是有利用备份和恢复的。\n\n\n\n转储就是备份：海量指所有数据，增量指上一次转储之后的。 静态就是不运行状态，动态是运行状态。\n\n\n\n\n# 4.4 数据库故障与恢复\n\n\n\n\n# 4.5 数据仓库与数据挖掘\n\n数据仓库\n\n * 面向主题\n * 集成的\n * 相对稳定的（非易失的）\n * 反映历史变化（随着时间变化）\n\n\n\n数据库和数据仓库的差异：\n\n 1. 数据库： 数据库是根据业务的需求看需要记录那些数据，就将其记录下来。（面向应用）\n 2. 数据集市：部门级的数据仓库。\n\n数据挖掘\n\n数据挖掘的方法分类：\n\n 1. 决策树\n 2. 神经网络\n 3. 遗传算法\n 4. 关联规则挖掘算法\n\n分类：\n\n 1. 关联分析： 挖掘出隐藏在数据间的相互关系\n 2. 序列模式分析： 侧重点是分析数据间的前后关系（因果关系）\n 3. 分类分析： 为每一个记录赋予一个标记再按标记分类\n 4. 聚类分析：分类分析法的逆过程\n\n\n# 4.6 反规范化技术\n\n\n\n反规范化的技术手段：就是规范化的逆过程，以牺牲空间和规范化程度来换取时间。\n\n技术手段有如下及几种：\n\n * 增加派生性冗余列\n * 增加冗余列\n * 重新组表\n * 分割表\n\n\n# 5. 大数据的基本概念\n\n\n# 5.1 基本了解\n\n大数据技术：对海量数据进行处理的相关技术； 这些数据具备什么特点？ 数据量极大，要求处理的速度极快，数据具有多样性，并且数据具备一定的价值。\n\n\n\n\n# 5.2 大数据\n\n\n\n大数据处理系统应该具有的重要特征\n\n * 高度可扩展性\n * 高性能\n * 高度容错\n * 支持异构环境\n * 较短的分析延迟\n * 易用且开放的接口\n * 较低成本\n * 向下兼容性\n\n现在大数据往往和云计算，虚拟化等技术结合起来来分析；云计算可以将一些闲置资源利用起来，成本较低。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL的函数",frontmatter:{title:"MySQL的函数",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/7bb5a9/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL%E7%9A%84%E5%87%BD%E6%95%B0.html",relativePath:"01.指南/04.数据库/05.MySQL的函数.md",key:"v-02970178",path:"/pages/7bb5a9/",headers:[{level:2,title:"字符串函数",slug:"字符串函数",normalizedTitle:"字符串函数",charIndex:369},{level:2,title:"数值函数",slug:"数值函数",normalizedTitle:"数值函数",charIndex:375},{level:2,title:"日期函数",slug:"日期函数",normalizedTitle:"日期函数",charIndex:380},{level:2,title:"流程函数",slug:"流程函数",normalizedTitle:"流程函数",charIndex:385}],headersStr:"字符串函数 数值函数 日期函数 流程函数",content:"# MySQL的函数\n\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那么，函数到底在哪儿使用呢？我们先来看两个场景：\n\n\n\n1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计算出天数呢？\n\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的分数值，如98/75，如何快速判定分数的等级呢？\n\n其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。\n\nMySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。\n\n\n# 字符串函数\n\nMySQL中内置了很多字符串函数，常用的几个如下：\n\n函数                         功能\nCONCAT(S1,S2,...Sn)        字符串拼接，将S1，S2，... Sn拼接成一个字符串\nLOWER(str)                 将字符串str全部转为小写\nUPPER(str)                 将字符串str全部转为大写\nLPAD(str,n,pad)            左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\nRPAD(str,n,pad)            右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\nTRIM(str)                  去掉字符串头部和尾部的空格\nSUBSTRING(str,start,len)   返回从字符串str从start位置起的len个长度的字符串\n\n演示如下：\n\nA. concat : 字符串拼接\n\nMariaDB [(none)]> select concat('Hello','MySQL');\n+-------------------------+\n| concat('Hello','MySQL') |\n+-------------------------+\n| HelloMySQL              |\n+-------------------------+\n1 row in set (0.000 sec)\n\n\nB. lower : 全部转小写\n\nMariaDB [(none)]> select lower('Hello');\n+----------------+\n| lower('Hello') |\n+----------------+\n| hello          |\n+----------------+\n1 row in set (0.000 sec)\n\n\nC. upper : 全部转大写\n\nMariaDB [(none)]> select upper('Hello');\n+----------------+\n| upper('Hello') |\n+----------------+\n| HELLO          |\n+----------------+\n1 row in set (0.000 sec)\n\n\nD. lpad : 左填充\n\nMariaDB [(none)]> select lpad('01',5,'-');\n+------------------+\n| lpad('01',5,'-') |\n+------------------+\n| ---01            |\n+------------------+\n1 row in set (0.000 sec)\n\n\nE. rpad : 右填充\n\nMariaDB [(none)]> select rpad('01',5,'---');\n+--------------------+\n| rpad('01',5,'---') |\n+--------------------+\n| 01---              |\n+--------------------+\n1 row in set (0.000 sec)\n\n\nF. trim : 去除空格\n\nMariaDB [(none)]> select trim(' hello MySQL');\n+----------------------+\n| trim(' hello MySQL') |\n+----------------------+\n| hello MySQL          |\n+----------------------+\n1 row in set (0.000 sec)\n\n\nG. substring : 截取子字符串\n\nMariaDB [(none)]> select substring('hello MySQL',1,5);\n+------------------------------+\n| substring('hello MySQL',1,5) |\n+------------------------------+\n| hello                        |\n+------------------------------+\n1 row in set (0.000 sec)\n\n\n案例:\n\n\n\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001。\n\n处理完毕后, 具体的数据为:\n\nMariaDB [test]> update emp set workno = lpad(workno,5,'0');\nQuery OK, 0 rows affected (0.000 sec)\nRows matched: 16  Changed: 0  Warnings: 0\n\nMariaDB [test]> select * from emp;\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n|    2 | 00002  | 张无忌    | 男     |   18 | 123456789012345670 | 北京        | 2005-09-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    4 | 00004  | 赵敏      | 女     |   18 | 123456757123845670 | 北京        | 2009-12-01 |\n|    5 | 00005  | 小昭      | 女     |   16 | 123456769012345678 | 上海        | 2007-07-01 |\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567X | 北京        | 2006-01-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n|    8 | 00008  | 黛绮丝    | 女     |   38 | 123456157123645670 | 天津        | 2015-05-01 |\n|    9 | 00009  | 范凉凉    | 女     |   45 | 123156789012345678 | 北京        | 2010-04-01 |\n|   10 | 00010  | 陈友谅    | 男     |   53 | 123456789012345670 | 上海        | 2011-01-01 |\n|   11 | 00011  | 张士诚    | 男     |   55 | 123567897123465670 | 江苏        | 2015-05-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|   13 | 00013  | 张三丰    | 男     |   88 | 123656789012345678 | 江苏        | 2020-11-01 |\n|   14 | 00014  | 灭绝      | 女     |   65 | 123456719012345670 | 西安        | 2019-05-01 |\n|   15 | 00015  | 胡青牛    | 男     |   70 | 12345674971234567X | 西安        | 2018-04-01 |\n|   16 | 00016  | 周芷若    | 女     |   18 | NULL               | 北京        | 2012-06-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n16 rows in set (0.000 sec)\n\n\n\n# 数值函数\n\n常见的数值函数如下：\n\n函数           功能\nCEIL(x)      向上取整\nFLOOR(x)     向下取整\nMOD(x,y)     返回x/y的模\nRAND()       返回0~1内的随机数\nROUND(x,y)   求参数x的四舍五入的值，保留y位小数\n\n演示如下：\n\nA. ceil：向上取整\n\nMariaDB [test]> select ceil(1.1);\n+-----------+\n| ceil(1.1) |\n+-----------+\n|         2 |\n+-----------+\n1 row in set (0.000 sec)\n\n\nB. floor：向下取整\n\nMariaDB [test]> select floor(1.9);\n+------------+\n| floor(1.9) |\n+------------+\n|          1 |\n+------------+\n1 row in set (0.000 sec)\n\n\nC. mod：取模\n\nMariaDB [test]> select mod(7,4);\n+----------+\n| mod(7,4) |\n+----------+\n|        3 |\n+----------+\n1 row in set (0.000 sec)\n\n\nD. rand：获取随机数\n\nMariaDB [test]> select rand();\n+--------------------+\n| rand()             |\n+--------------------+\n| 0.5543058836407083 |\n+--------------------+\n1 row in set (0.000 sec)\n\n\nE. round：四舍五入\n\nMariaDB [test]> select round(2.345,2);\n+----------------+\n| round(2.345,2) |\n+----------------+\n|           2.35 |\n+----------------+\n1 row in set (0.000 sec)\n\n\n案例：通过数据库的函数，生成一个六位数的随机验证码。\n\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\n\nMariaDB [test]> select lpad(round(rand()*1000000,0),6,'0');\n+-------------------------------------+\n| lpad(round(rand()*1000000,0),6,'0') |\n+-------------------------------------+\n| 091292                              |\n+-------------------------------------+\n1 row in set (0.000 sec)\n\n\n\n# 日期函数\n\n常见的日期函数如下：\n\n函数                                   功能\nCURDATE()                            返回当前日期\nCURTIME()                            返回当前时间\nNOW()                                返回当前日期和时间\nYEAR(date)                           获取指定date的年份\nMONTH(date)                          获取指定date的月份\nDAY(date)                            获取指定date的日期\nDATE_ADD(date, INTERVAL expr type)   返回一个日期/时间值加上一个时间间隔expr后的时间值\nDATEDIFF(date1,date2)                返回起始时间date1 和 结束时间date2之间的天数\n\n演示如下：\n\nA. curdate：当前日期\n\nMariaDB [test]> select curdate();\n+------------+\n| curdate()  |\n+------------+\n| 2022-06-10 |\n+------------+\n1 row in set (0.000 sec)\n\n\nB. curtime：当前时间\n\nMariaDB [test]> select curtime();\n+-----------+\n| curtime() |\n+-----------+\n| 15:17:05  |\n+-----------+\n1 row in set (0.000 sec)\n\n\nC. now：当前日期和时间\n\nMariaDB [test]> select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2022-06-10 15:17:10 |\n+---------------------+\n1 row in set (0.000 sec)\n\n\nD. YEAR , MONTH , DAY：当前年、月、日\n\nMariaDB [test]> select year(now());\n+-------------+\n| year(now()) |\n+-------------+\n|        2022 |\n+-------------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> select month(now());\n+--------------+\n| month(now()) |\n+--------------+\n|            6 |\n+--------------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> select day(now());\n+------------+\n| day(now()) |\n+------------+\n|         10 |\n+------------+\n1 row in set (0.000 sec)\n\n\nE. date_add：增加指定的时间间隔\n\nMariaDB [test]> select date_add(now(), interval 70 day);\n+----------------------------------+\n| date_add(now(), interval 70 day) |\n+----------------------------------+\n| 2022-08-19 15:20:46              |\n+----------------------------------+\n1 row in set (0.000 sec)\n\n\nF. datediff：获取两个日期相差的天数\n\nMariaDB [test]> select datediff('2021-10-01','2021-12-30');\n+-------------------------------------+\n| datediff('2021-10-01','2021-12-30') |\n+-------------------------------------+\n|                                 -90 |\n+-------------------------------------+\n1 row in set (0.000 sec)\n\n\n案例：\n\n查询所有员工的入职天数，并根据入职天数倒序排序。\n\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\n\nMariaDB [test]> select name,datediff(curdate(),entrydate) as 'entrydays' from emp order by entrydays desc; \n+-----------+-----------+\n| name      | entrydays |\n+-----------+-----------+\n| 柳岩666   |      8196 |\n| 常遇春    |      6704 |\n| 范瑶      |      6249 |\n| 韦一笑    |      6157 |\n| 张无忌    |      6126 |\n| 杨逍      |      6004 |\n| 小昭      |      5458 |\n| 赵敏      |      4574 |\n| 范凉凉    |      4453 |\n| 陈友谅    |      4178 |\n| 周芷若    |      3661 |\n| 张士诚    |      2597 |\n| 黛绮丝    |      2597 |\n| 胡青牛    |      1531 |\n| 灭绝      |      1136 |\n| 张三丰    |       586 |\n+-----------+-----------+\n16 rows in set (0.000 sec)\n\n\n\n# 流程函数\n\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n函数                                                             功能\nIF(value , t , f)                                              如果value为true，则返回t，否则返回 f\nIFNULL(value1 , value2)                                        如果value1不为空，返回value1，否则返回value2\nCASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END        如果val1为true，返回res1，... 否则返回default默认值\nCASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ]   如果expr的值等于val1，返回 res1，... 否则返回default默认值\nEND\n\n演示如下：\n\nA. if\n\nMariaDB [test]> select if(true,'OK','Error');\n+-----------------------+\n| if(true,'OK','Error') |\n+-----------------------+\n| OK                    |\n+-----------------------+\n1 row in set (0.000 sec)\n\n\nB. ifnull\n\nMariaDB [test]> select ifnull('OK','Default');\n+------------------------+\n| ifnull('OK','Default') |\n+------------------------+\n| OK                     |\n+------------------------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> select ifnull('','Default');\n+----------------------+\n| ifnull('','Default') |\n+----------------------+\n|                      |\n+----------------------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> select ifnull(null,'Default');\n+------------------------+\n| ifnull(null,'Default') |\n+------------------------+\n| Default                |\n+------------------------+\n1 row in set (0.000 sec)\n\n\nC. case when then else end\n\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----\x3e 一线城市 , 其他 ----\x3e 二线城市)\n\n案例:\n\nMariaDB [test]> select \n    -> name,\n    -> (case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end) as '工作地址' \n    -> from emp;\n+-----------+--------------+\n| name      | 工作地址     |\n+-----------+--------------+\n| 柳岩666   | 一线城市     |\n| 张无忌    | 一线城市     |\n| 韦一笑    | 一线城市     |\n| 赵敏      | 一线城市     |\n| 小昭      | 一线城市     |\n| 杨逍      | 一线城市     |\n| 范瑶      | 一线城市     |\n| 黛绮丝    | 二线城市     |\n| 范凉凉    | 一线城市     |\n| 陈友谅    | 一线城市     |\n| 张士诚    | 二线城市     |\n| 常遇春    | 一线城市     |\n| 张三丰    | 二线城市     |\n| 灭绝      | 二线城市     |\n| 胡青牛    | 二线城市     |\n| 周芷若    | 一线城市     |\n+-----------+--------------+\n16 rows in set (0.000 sec)\n\n\n\n创建学员成绩表：\n\nMariaDB [test]> create table score(\n    id int comment 'ID',\n    name varchar(20) comment '姓名',\n    math int comment '数学',\n    english int comment '英语',\n    chinese int comment '语文'\n) comment '学员成绩表';\nQuery OK, 0 rows affected (0.004 sec)\n\nMariaDB [test]> insert into score(id,name,math,english,chinese) values(1,'Tom',67,88,95),(2,'Rose',23,66,90),(3,'Jack',56,98,76);\nQuery OK, 3 rows affected (0.001 sec)\nRecords: 3  Duplicates: 0  Warnings: 0\n\nMariaDB [test]> select * from score;\n+------+------+------+---------+---------+\n| id   | name | math | english | chinese |\n+------+------+------+---------+---------+\n|    1 | Tom  |   67 |      88 |      95 |\n|    2 | Rose |   23 |      66 |      90 |\n|    3 | Jack |   56 |      98 |      76 |\n+------+------+------+---------+---------+\n3 rows in set (0.000 sec)\n\n\n统计班级各个学院的成绩，展示的规则如下：\n\n>=85 展示优秀\n\n>=60 展示及格\n\n否则，展示不及格\n\nMariaDB [test]> select \n    -> id,\n    -> name,\n    -> (case when math >= 85 then '优秀' when math >= 60 then '及格' else '不及格' end) '数学',\n    -> (case when english >= 85 then '优秀' when english >= 60 then '及格' else '不及格' end) '英语',\n    -> (case when chinese >= 85 then '优秀' when chinese >= 60 then '及格' else '不及格' end) '语文'\n    -> from score;\n+------+------+-----------+--------+--------+\n| id   | name | 数学      | 英语   | 语文   |\n+------+------+-----------+--------+--------+\n|    1 | Tom  | 及格      | 优秀   | 优秀   |\n|    2 | Rose | 不及格    | 及格   | 优秀   |\n|    3 | Jack | 不及格    | 优秀   | 及格   |\n+------+------+-----------+--------+--------+\n3 rows in set (0.000 sec)\n\n\nMySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景，思考一下需要用到什么样的函数来实现?\n\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------\x3e 答案: datediff\n\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------\x3e\n\n答案: case ... when ...",normalizedContent:"# mysql的函数\n\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在mysql中已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那么，函数到底在哪儿使用呢？我们先来看两个场景：\n\n\n\n1). 在企业的oa或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计算出天数呢？\n\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的分数值，如98/75，如何快速判定分数的等级呢？\n\n其实，上述的这一类的需求呢，我们通过mysql中的函数都可以很方便的实现 。\n\nmysql中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。\n\n\n# 字符串函数\n\nmysql中内置了很多字符串函数，常用的几个如下：\n\n函数                         功能\nconcat(s1,s2,...sn)        字符串拼接，将s1，s2，... sn拼接成一个字符串\nlower(str)                 将字符串str全部转为小写\nupper(str)                 将字符串str全部转为大写\nlpad(str,n,pad)            左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\nrpad(str,n,pad)            右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\ntrim(str)                  去掉字符串头部和尾部的空格\nsubstring(str,start,len)   返回从字符串str从start位置起的len个长度的字符串\n\n演示如下：\n\na. concat : 字符串拼接\n\nmariadb [(none)]> select concat('hello','mysql');\n+-------------------------+\n| concat('hello','mysql') |\n+-------------------------+\n| hellomysql              |\n+-------------------------+\n1 row in set (0.000 sec)\n\n\nb. lower : 全部转小写\n\nmariadb [(none)]> select lower('hello');\n+----------------+\n| lower('hello') |\n+----------------+\n| hello          |\n+----------------+\n1 row in set (0.000 sec)\n\n\nc. upper : 全部转大写\n\nmariadb [(none)]> select upper('hello');\n+----------------+\n| upper('hello') |\n+----------------+\n| hello          |\n+----------------+\n1 row in set (0.000 sec)\n\n\nd. lpad : 左填充\n\nmariadb [(none)]> select lpad('01',5,'-');\n+------------------+\n| lpad('01',5,'-') |\n+------------------+\n| ---01            |\n+------------------+\n1 row in set (0.000 sec)\n\n\ne. rpad : 右填充\n\nmariadb [(none)]> select rpad('01',5,'---');\n+--------------------+\n| rpad('01',5,'---') |\n+--------------------+\n| 01---              |\n+--------------------+\n1 row in set (0.000 sec)\n\n\nf. trim : 去除空格\n\nmariadb [(none)]> select trim(' hello mysql');\n+----------------------+\n| trim(' hello mysql') |\n+----------------------+\n| hello mysql          |\n+----------------------+\n1 row in set (0.000 sec)\n\n\ng. substring : 截取子字符串\n\nmariadb [(none)]> select substring('hello mysql',1,5);\n+------------------------------+\n| substring('hello mysql',1,5) |\n+------------------------------+\n| hello                        |\n+------------------------------+\n1 row in set (0.000 sec)\n\n\n案例:\n\n\n\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001。\n\n处理完毕后, 具体的数据为:\n\nmariadb [test]> update emp set workno = lpad(workno,5,'0');\nquery ok, 0 rows affected (0.000 sec)\nrows matched: 16  changed: 0  warnings: 0\n\nmariadb [test]> select * from emp;\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n|    2 | 00002  | 张无忌    | 男     |   18 | 123456789012345670 | 北京        | 2005-09-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    4 | 00004  | 赵敏      | 女     |   18 | 123456757123845670 | 北京        | 2009-12-01 |\n|    5 | 00005  | 小昭      | 女     |   16 | 123456769012345678 | 上海        | 2007-07-01 |\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567x | 北京        | 2006-01-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n|    8 | 00008  | 黛绮丝    | 女     |   38 | 123456157123645670 | 天津        | 2015-05-01 |\n|    9 | 00009  | 范凉凉    | 女     |   45 | 123156789012345678 | 北京        | 2010-04-01 |\n|   10 | 00010  | 陈友谅    | 男     |   53 | 123456789012345670 | 上海        | 2011-01-01 |\n|   11 | 00011  | 张士诚    | 男     |   55 | 123567897123465670 | 江苏        | 2015-05-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|   13 | 00013  | 张三丰    | 男     |   88 | 123656789012345678 | 江苏        | 2020-11-01 |\n|   14 | 00014  | 灭绝      | 女     |   65 | 123456719012345670 | 西安        | 2019-05-01 |\n|   15 | 00015  | 胡青牛    | 男     |   70 | 12345674971234567x | 西安        | 2018-04-01 |\n|   16 | 00016  | 周芷若    | 女     |   18 | null               | 北京        | 2012-06-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n16 rows in set (0.000 sec)\n\n\n\n# 数值函数\n\n常见的数值函数如下：\n\n函数           功能\nceil(x)      向上取整\nfloor(x)     向下取整\nmod(x,y)     返回x/y的模\nrand()       返回0~1内的随机数\nround(x,y)   求参数x的四舍五入的值，保留y位小数\n\n演示如下：\n\na. ceil：向上取整\n\nmariadb [test]> select ceil(1.1);\n+-----------+\n| ceil(1.1) |\n+-----------+\n|         2 |\n+-----------+\n1 row in set (0.000 sec)\n\n\nb. floor：向下取整\n\nmariadb [test]> select floor(1.9);\n+------------+\n| floor(1.9) |\n+------------+\n|          1 |\n+------------+\n1 row in set (0.000 sec)\n\n\nc. mod：取模\n\nmariadb [test]> select mod(7,4);\n+----------+\n| mod(7,4) |\n+----------+\n|        3 |\n+----------+\n1 row in set (0.000 sec)\n\n\nd. rand：获取随机数\n\nmariadb [test]> select rand();\n+--------------------+\n| rand()             |\n+--------------------+\n| 0.5543058836407083 |\n+--------------------+\n1 row in set (0.000 sec)\n\n\ne. round：四舍五入\n\nmariadb [test]> select round(2.345,2);\n+----------------+\n| round(2.345,2) |\n+----------------+\n|           2.35 |\n+----------------+\n1 row in set (0.000 sec)\n\n\n案例：通过数据库的函数，生成一个六位数的随机验证码。\n\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\n\nmariadb [test]> select lpad(round(rand()*1000000,0),6,'0');\n+-------------------------------------+\n| lpad(round(rand()*1000000,0),6,'0') |\n+-------------------------------------+\n| 091292                              |\n+-------------------------------------+\n1 row in set (0.000 sec)\n\n\n\n# 日期函数\n\n常见的日期函数如下：\n\n函数                                   功能\ncurdate()                            返回当前日期\ncurtime()                            返回当前时间\nnow()                                返回当前日期和时间\nyear(date)                           获取指定date的年份\nmonth(date)                          获取指定date的月份\nday(date)                            获取指定date的日期\ndate_add(date, interval expr type)   返回一个日期/时间值加上一个时间间隔expr后的时间值\ndatediff(date1,date2)                返回起始时间date1 和 结束时间date2之间的天数\n\n演示如下：\n\na. curdate：当前日期\n\nmariadb [test]> select curdate();\n+------------+\n| curdate()  |\n+------------+\n| 2022-06-10 |\n+------------+\n1 row in set (0.000 sec)\n\n\nb. curtime：当前时间\n\nmariadb [test]> select curtime();\n+-----------+\n| curtime() |\n+-----------+\n| 15:17:05  |\n+-----------+\n1 row in set (0.000 sec)\n\n\nc. now：当前日期和时间\n\nmariadb [test]> select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2022-06-10 15:17:10 |\n+---------------------+\n1 row in set (0.000 sec)\n\n\nd. year , month , day：当前年、月、日\n\nmariadb [test]> select year(now());\n+-------------+\n| year(now()) |\n+-------------+\n|        2022 |\n+-------------+\n1 row in set (0.000 sec)\n\nmariadb [test]> select month(now());\n+--------------+\n| month(now()) |\n+--------------+\n|            6 |\n+--------------+\n1 row in set (0.000 sec)\n\nmariadb [test]> select day(now());\n+------------+\n| day(now()) |\n+------------+\n|         10 |\n+------------+\n1 row in set (0.000 sec)\n\n\ne. date_add：增加指定的时间间隔\n\nmariadb [test]> select date_add(now(), interval 70 day);\n+----------------------------------+\n| date_add(now(), interval 70 day) |\n+----------------------------------+\n| 2022-08-19 15:20:46              |\n+----------------------------------+\n1 row in set (0.000 sec)\n\n\nf. datediff：获取两个日期相差的天数\n\nmariadb [test]> select datediff('2021-10-01','2021-12-30');\n+-------------------------------------+\n| datediff('2021-10-01','2021-12-30') |\n+-------------------------------------+\n|                                 -90 |\n+-------------------------------------+\n1 row in set (0.000 sec)\n\n\n案例：\n\n查询所有员工的入职天数，并根据入职天数倒序排序。\n\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\n\nmariadb [test]> select name,datediff(curdate(),entrydate) as 'entrydays' from emp order by entrydays desc; \n+-----------+-----------+\n| name      | entrydays |\n+-----------+-----------+\n| 柳岩666   |      8196 |\n| 常遇春    |      6704 |\n| 范瑶      |      6249 |\n| 韦一笑    |      6157 |\n| 张无忌    |      6126 |\n| 杨逍      |      6004 |\n| 小昭      |      5458 |\n| 赵敏      |      4574 |\n| 范凉凉    |      4453 |\n| 陈友谅    |      4178 |\n| 周芷若    |      3661 |\n| 张士诚    |      2597 |\n| 黛绮丝    |      2597 |\n| 胡青牛    |      1531 |\n| 灭绝      |      1136 |\n| 张三丰    |       586 |\n+-----------+-----------+\n16 rows in set (0.000 sec)\n\n\n\n# 流程函数\n\n流程函数也是很常用的一类函数，可以在sql语句中实现条件筛选，从而提高语句的效率。\n\n函数                                                             功能\nif(value , t , f)                                              如果value为true，则返回t，否则返回 f\nifnull(value1 , value2)                                        如果value1不为空，返回value1，否则返回value2\ncase when [ val1 ] then [res1] ... else [ default ] end        如果val1为true，返回res1，... 否则返回default默认值\ncase [ expr ] when [ val1 ] then [res1] ... else [ default ]   如果expr的值等于val1，返回 res1，... 否则返回default默认值\nend\n\n演示如下：\n\na. if\n\nmariadb [test]> select if(true,'ok','error');\n+-----------------------+\n| if(true,'ok','error') |\n+-----------------------+\n| ok                    |\n+-----------------------+\n1 row in set (0.000 sec)\n\n\nb. ifnull\n\nmariadb [test]> select ifnull('ok','default');\n+------------------------+\n| ifnull('ok','default') |\n+------------------------+\n| ok                     |\n+------------------------+\n1 row in set (0.000 sec)\n\nmariadb [test]> select ifnull('','default');\n+----------------------+\n| ifnull('','default') |\n+----------------------+\n|                      |\n+----------------------+\n1 row in set (0.000 sec)\n\nmariadb [test]> select ifnull(null,'default');\n+------------------------+\n| ifnull(null,'default') |\n+------------------------+\n| default                |\n+------------------------+\n1 row in set (0.000 sec)\n\n\nc. case when then else end\n\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----\x3e 一线城市 , 其他 ----\x3e 二线城市)\n\n案例:\n\nmariadb [test]> select \n    -> name,\n    -> (case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end) as '工作地址' \n    -> from emp;\n+-----------+--------------+\n| name      | 工作地址     |\n+-----------+--------------+\n| 柳岩666   | 一线城市     |\n| 张无忌    | 一线城市     |\n| 韦一笑    | 一线城市     |\n| 赵敏      | 一线城市     |\n| 小昭      | 一线城市     |\n| 杨逍      | 一线城市     |\n| 范瑶      | 一线城市     |\n| 黛绮丝    | 二线城市     |\n| 范凉凉    | 一线城市     |\n| 陈友谅    | 一线城市     |\n| 张士诚    | 二线城市     |\n| 常遇春    | 一线城市     |\n| 张三丰    | 二线城市     |\n| 灭绝      | 二线城市     |\n| 胡青牛    | 二线城市     |\n| 周芷若    | 一线城市     |\n+-----------+--------------+\n16 rows in set (0.000 sec)\n\n\n\n创建学员成绩表：\n\nmariadb [test]> create table score(\n    id int comment 'id',\n    name varchar(20) comment '姓名',\n    math int comment '数学',\n    english int comment '英语',\n    chinese int comment '语文'\n) comment '学员成绩表';\nquery ok, 0 rows affected (0.004 sec)\n\nmariadb [test]> insert into score(id,name,math,english,chinese) values(1,'tom',67,88,95),(2,'rose',23,66,90),(3,'jack',56,98,76);\nquery ok, 3 rows affected (0.001 sec)\nrecords: 3  duplicates: 0  warnings: 0\n\nmariadb [test]> select * from score;\n+------+------+------+---------+---------+\n| id   | name | math | english | chinese |\n+------+------+------+---------+---------+\n|    1 | tom  |   67 |      88 |      95 |\n|    2 | rose |   23 |      66 |      90 |\n|    3 | jack |   56 |      98 |      76 |\n+------+------+------+---------+---------+\n3 rows in set (0.000 sec)\n\n\n统计班级各个学院的成绩，展示的规则如下：\n\n>=85 展示优秀\n\n>=60 展示及格\n\n否则，展示不及格\n\nmariadb [test]> select \n    -> id,\n    -> name,\n    -> (case when math >= 85 then '优秀' when math >= 60 then '及格' else '不及格' end) '数学',\n    -> (case when english >= 85 then '优秀' when english >= 60 then '及格' else '不及格' end) '英语',\n    -> (case when chinese >= 85 then '优秀' when chinese >= 60 then '及格' else '不及格' end) '语文'\n    -> from score;\n+------+------+-----------+--------+--------+\n| id   | name | 数学      | 英语   | 语文   |\n+------+------+-----------+--------+--------+\n|    1 | tom  | 及格      | 优秀   | 优秀   |\n|    2 | rose | 不及格    | 及格   | 优秀   |\n|    3 | jack | 不及格    | 优秀   | 及格   |\n+------+------+-----------+--------+--------+\n3 rows in set (0.000 sec)\n\n\nmysql的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景，思考一下需要用到什么样的函数来实现?\n\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------\x3e 答案: datediff\n\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------\x3e\n\n答案: case ... when ...",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"计算机网络",frontmatter:{title:"计算机网络",date:"2022-09-06T03:30:21.000Z",permalink:"/pages/fd02ba/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BD%91%E7%BB%9C/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"01.指南/03.计算机系统与网络/03.计算机网络.md",key:"v-6a3757ac",path:"/pages/fd02ba/",headers:[{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:12},{level:2,title:"1. OSI的基本概念及原则",slug:"_1-osi的基本概念及原则",normalizedTitle:"1. osi的基本概念及原则",charIndex:23},{level:3,title:"1.1 OSI七层模型介绍",slug:"_1-1-osi七层模型介绍",normalizedTitle:"1.1 osi七层模型介绍",charIndex:42},{level:3,title:"1.2 OSI七层模型详解",slug:"_1-2-osi七层模型详解",normalizedTitle:"1.2 osi七层模型详解",charIndex:290},{level:3,title:"1.3 网络技术标准与协议",slug:"_1-3-网络技术标准与协议",normalizedTitle:"1.3 网络技术标准与协议",charIndex:3357},{level:2,title:"2. 计算机网络拓扑",slug:"_2-计算机网络拓扑",normalizedTitle:"2. 计算机网络拓扑",charIndex:3901},{level:3,title:"2.1 网络拓扑的定义",slug:"_2-1-网络拓扑的定义",normalizedTitle:"2.1 网络拓扑的定义",charIndex:3976},{level:3,title:"2.2 星型结构",slug:"_2-2-星型结构",normalizedTitle:"2.2 星型结构",charIndex:4142},{level:3,title:"2.3 环形结构",slug:"_2-3-环形结构",normalizedTitle:"2.3 环形结构",charIndex:4438},{level:3,title:"2.4 树型结构",slug:"_2-4-树型结构",normalizedTitle:"2.4 树型结构",charIndex:4787},{level:3,title:"2.5 总线结构",slug:"_2-5-总线结构",normalizedTitle:"2.5 总线结构",charIndex:4988},{level:3,title:"2.6 网状结构",slug:"_2-6-网状结构",normalizedTitle:"2.6 网状结构",charIndex:5213},{level:3,title:"2.7 混合结构",slug:"_2-7-混合结构",normalizedTitle:"2.7 混合结构",charIndex:5613},{level:2,title:"3. 网络规划与设计",slug:"_3-网络规划与设计",normalizedTitle:"3. 网络规划与设计",charIndex:5719},{level:3,title:"3.1 结构化布线系统",slug:"_3-1-结构化布线系统",normalizedTitle:"3.1 结构化布线系统",charIndex:5734},{level:3,title:"3.2 网络分析与设计过程",slug:"_3-2-网络分析与设计过程",normalizedTitle:"3.2 网络分析与设计过程",charIndex:6133},{level:3,title:"3.3 逻辑网络设计",slug:"_3-3-逻辑网络设计",normalizedTitle:"3.3 逻辑网络设计",charIndex:6566},{level:3,title:"3.4 分层设计",slug:"_3-4-分层设计",normalizedTitle:"3.4 分层设计",charIndex:6733},{level:3,title:"3.5 IP地址的分类",slug:"_3-5-ip地址的分类",normalizedTitle:"3.5 ip地址的分类",charIndex:6804},{level:3,title:"3.6 子网掩码和子网划分",slug:"_3-6-子网掩码和子网划分",normalizedTitle:"3.6 子网掩码和子网划分",charIndex:8681},{level:2,title:"4. 无线网络技术",slug:"_4-无线网络技术",normalizedTitle:"4. 无线网络技术",charIndex:10265},{level:3,title:"4.1 什么是无线网络",slug:"_4-1-什么是无线网络",normalizedTitle:"4.1 什么是无线网络",charIndex:10279},{level:3,title:"4.2 无线网络的优势",slug:"_4-2-无线网络的优势",normalizedTitle:"4.2 无线网络的优势",charIndex:10955},{level:3,title:"4.3 网络接入技术",slug:"_4-3-网络接入技术",normalizedTitle:"4.3 网络接入技术",charIndex:11809},{level:3,title:"4.4 IPV6",slug:"_4-4-ipv6",normalizedTitle:"4.4 ipv6",charIndex:12727}],headersStr:"思维导图 1. OSI的基本概念及原则 1.1 OSI七层模型介绍 1.2 OSI七层模型详解 1.3 网络技术标准与协议 2. 计算机网络拓扑 2.1 网络拓扑的定义 2.2 星型结构 2.3 环形结构 2.4 树型结构 2.5 总线结构 2.6 网状结构 2.7 混合结构 3. 网络规划与设计 3.1 结构化布线系统 3.2 网络分析与设计过程 3.3 逻辑网络设计 3.4 分层设计 3.5 IP地址的分类 3.6 子网掩码和子网划分 4. 无线网络技术 4.1 什么是无线网络 4.2 无线网络的优势 4.3 网络接入技术 4.4 IPV6",content:'# 计算机网络\n\n\n# 思维导图\n\n\n\n\n# 1. OSI的基本概念及原则\n\n\n# 1.1 OSI七层模型介绍\n\nOSI是Open System Interconnect的缩写，意为开放式系统互联。各个层次的划分遵循以下原则\n\n 1. 同一层中的各网络节点都有相同的层次结构，具有同样的功能。\n 2. 同一节点内相邻层之间通过接口进行通信。\n 3. 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。（物理->数据链路层->…应用层）\n 4. 不同节点的同等层按照协议实现对等层之间的通信。\n\n原理图\n\n\n\n\n\nTCP/IP四层模型与OSI体系结构对比：\n\n\n\n\n# 1.2 OSI七层模型详解\n\n> 计算机的网络性能指标： 速率：bps=bit/s 时延：发送时延、传播时延、排队时延、处理时延 往返时间RTT：数据报文在端到端通信中的来回一次的时间。\n\n🚀第一层：物理层\n\n在OSI参考模型中，物理层是参考模型的最低层，也是OSI模型的第一层。物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么。\n\n1.物理层设备：\n\n * 中继器【Repeater，也叫放大器】：同一局域网的再生信号；两端口的网段必须同一协议；5-4-3规程：10BASE-5以太网中，最多串联4个中继器，5段中只能有3个连接主机；\n * 集线器：同一局域网的再生、放大信号（多端口的中继器）；半双工，不能隔离冲突域也不能隔离广播域。\n\n2.信道的基本概念 :信道是往一个方向传输信息的媒体，一条通信电路包含一个发送信道和一个接受信道。\n\n 1. 单工通信信道：只能一个方向通信，没有反方向反馈的信道；\n 2. 半双工通信信道：双方都可以发送和接受信息，但不能同时发送也不能同时接收；\n 3. 全双工通信信道：双方都可以同时发送和接收。\n\n🚀第二层：数据链路层\n\n数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。在计算机网络中由于各种干扰的存在，导致物理链路是不可靠的。因此这一层的主要功能是：在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。\n\n该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。\n\n有关数据链路层的重要知识点：\n\n 1. 数据链路层为网络层提供可靠的数据传输；\n 2. 基本数据单位为帧；\n 3. 主要的协议：以太网协议；\n 4. 两个重要设备名称：网桥和交换机。\n\n封装成帧：“帧”是数据链路层数据的基本单位：\n\n\n\n透明传输：“透明”是指即使控制字符在帧数据中，但是要当做不存在去处理。即在控制字符前加上转义字符ESC。\n\n\n\n🚀第三层：网络层\n\n网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层，它在下两层的基础上向资源子网提供服务。其主要功能是：在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接，将数据设法从源端经过若干个中间节点传送到目的端（点到点），从而向传输层提供最基本的端到端的数据传输服务。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。数据链路层和网络层的区别为：数据链路层的目的是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。\n\n与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：\n\n 1. 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；\n 2. 基本数据单位为IP数据报；\n 3. 包含的主要协议：\n\n * IP协议（Internet Protocol，因特网互联协议）;\n * ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;\n * ARP协议（Address Resolution Protocol，地址解析协议）;\n * RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。\n\n🚀第四层：传输层\n\nOSI下3层的任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。该层提供建立、维护和拆除传输连接的功能，起到承上启下的作用。该层的主要功能是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，同时向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。\n\n有关网络层的重点：\n\n 1. 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；\n 2. 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；\n 3. 重要设备：网关。\n\n🚀第五层：会话层\n\n会话层是OSI模型的第5层，是用户应用程序和网络之间的接口，该层的主要功能是：组织和协调两个会话进程之间的通信 ，并对数据交换进行管理。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名就是一种网络上使用的远程地址。会话层的具体功能如下：\n\n * 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。\n * 会话流量控制：提供会话流量控制和交叉会话功能。\n * 寻址：使用远程地址建立会话连接。\n * 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。\n\n🚀第六层：表示层\n\n表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。该层的主要功能是：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。表示层的具体功能如下：\n\n * 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。\n * 数据的编码：处理字符集和数字的转换。\n * 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。\n * 数据的加密和解密：可以提高网络的安全性。\n\n🚀第七层：应用层\n\n应用层是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，该层的主要功能是：直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外该层还负责协调各个应用程序间的工作。应用层的具体功能如下：\n\n * 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。\n * 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。\n\n为操作系统或网络应用程序提供访问网络服务的接口。应用层重点：\n\n 1. 数据传输基本单位为报文；\n 2. 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。\n\n\n# 1.3 网络技术标准与协议\n\n * TCP/IP协议：Internet，可扩展、可靠、应用最广、牺牲速度和效率\n * IPX/SPX协议： NOVELL、路由、大型网络\n * NETBEUI协议： IBM、非路由、快速\n\n\n\n 1. TCP/IP协议：可靠，但是速度不够\n 2. IPX/SPX协议：局域网的战略游戏等等都需要这种协议\n 3. NETBEUI协议：不支持路由所以速度比较快\n 4. ICMP: 因特网的控制协议 例如ping操作就是如此\n 5. ARP: 地址解析协议 ip -> mac\n 6. RARP: 反向地址解析协议 mac -> ip\n 7. TCP: 传输层可靠协议 建立连接确保所有数据包都接收到了（三次握手）\n 8. UDP: 不可靠协议 没有验证过程\n\n属于TCP类的协议\n\n * HTTP: 超文本传输协议 传输网页数据\n * TCP： 是文件传输协议\n * Telnet：是做远程登录的\n * POP3 ：与 SMTP:是做邮件传输的协议\n\n属于UDP类的协议\n\n * DHCP: 局域网中有DHCP服务器用来做动态的IP地址分配工作\n * TFTP: 小文件传输协议\n * SNMP：简单网络管理协议\n * DNS: 是用来做域名解析的\n\n\n# 2. 计算机网络拓扑\n\n计算机网络的分类有：\n\n 1. 局域网(LAN)\n 2. 城域网(MAN)\n 3. 广域网(WAN)\n 4. 因特网\n\n\n# 2.1 网络拓扑的定义\n\n在认识网络拓扑图前，我们先来了解下网络拓扑结构。\n\n所谓网络拓扑结构，是指用传输媒体互连各种设备的物理布局，就是用什么方式把网络中的计算机等设备连接起来。而网络拓扑图，就是指将这种网络连接结构呈现出来的图形。\n\n网络拓扑图的常见结构有星型结构、环形结构、总线结构、网状结构、树型结构、混合结构等。\n\n\n# 2.2 星型结构\n\n这是最古老的一种连接方式：网络有中央节点，其他节点（工作站、服务器）都与中央节点直接相连，这种结构以中央节点为中心，因此又称为集中式网络。\n\n优点：\n\n1、结构简单，连接方便，管理和维护都相对容易，重新配置灵活。\n\n2、各节点与中央交换单元直接连通，各节点之间通信必须经过中央单元转换，故障隔离和检测容易。\n\n3、网络延迟时间短，传输误差低。\n\n缺点：\n\n1、安装和维护的费用较高。\n\n2、共享资源的能力较差。\n\n3、一条通信线路只被该线路上的中央节点和边缘节点使用，通信线路利用率不高。\n\n4、对中央节点要求相当高，一旦中央节点出现故障，则整个网络将瘫痪。\n\n\n\n\n# 2.3 环形结构\n\n区别于星型结构对中心系统的依赖。\n\n环形结构中的传输媒体从一个端用户到另一个端用户，直到将所有的端用户连成环型。数据在环路中沿着一个方向在各个节点间传输，信息从一个节点传到另一个节点。\n\n优点：\n\n1、环型网中信息的流动方向是固定的，两个节点仅有一条通路，路径控制简单；\n\n2、有旁路设备，节点一旦发生故障，系统自动旁路，可靠性高；结构简单，节点的增、删和位置的变动较容易。\n\n缺点：\n\n1、环型拓扑结构的媒体访问控制协议都采用令牌传递的方式,在负载很轻时,信道利用率相对来说就比较低。\n\n2、信息要串行穿过多个节点，在网中节点过多时传输效率低，系统响应速度慢；\n\n3、故障检测困难。因为不是集中控制,故障检测需在网上各个节点进行。\n\n4、由于环路封闭，扩充较难。\n\n\n\n\n# 2.4 树型结构\n\n在实际建造一个大型网络时，往往是采用多级星形网络，将多级星形网络按层次方式排列即形成树形网络。\n\n优点：\n\n1、易于扩展。这种结构可以延伸出很多分支和子分支,这些新节点和新分支都能容易地加入网内。\n\n2、故障隔离较容易。如果某一分支的节点或线路发生故障,很容易将故障分支与整个系统隔离开来\n\n缺点：\n\n1、各个节点对根的依赖性太大，如果根发生故障，则全网不能正常工作。\n\n\n\n\n# 2.5 总线结构\n\n总线结构是使用同一媒体或电缆连接所有端用户的一种方式，也就是说，连接端用户的物理媒体由所有设备共享，各工作站地位平等，无中心节点控制。\n\n优点：\n\n1、结构简单。\n\n2、节点的增、删和位置的变动较容易。\n\n3、系统的扩充性能好。\n\n4、多个节点共用一条传输信道，信道利用率高。\n\n缺点：\n\n1、总线的传输距离有限,通信范围受到限制。\n\n2、负载重时，线路的利用率较低。\n\n3、网络延迟时间不确定，故障隔离和检测困难。\n\n\n\n\n# 2.6 网状结构\n\n主要指各节点通过传输线互联连接起来，并且每一个节点至少与其他两个节点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护，不常用于局域网。有时也称为分布式结构。\n\n优点：\n\n1、分布式网络具有较高的可靠性，网状拓扑结构保证了冗余度，因为在任何两个节点之间至少有两条链路，当一条线路有故障时，不会影响整个系统工作。\n\n2、资源共享方便，网络响应时间短。\n\n3、电缆长度短，连线容易。因为任何一个想到入网的计算设备只需就近连入网络，而不必直接连到中央节点。\n\n4、易于扩充。增加新的站点，只需在网络的任何点将其接入。\n\n缺点：\n\n1、建网复杂。网络难于管理。\n\n2、由于节点与多个节点连接，故节点的路由选择和流量控制难度大。\n\n3、故障诊断困难。分布式结构的网络不是集中控制，故障检测只能逐个检查各个站点。\n\n4、管理软件复杂，硬件成本高。\n\n\n\n\n# 2.7 混合结构\n\n混合结构是由星型结构或环型结构和总线型结构结合在一起的网络结构，这样的拓扑结构更能满足较大网络的拓展，解决星型网络在传输距离上的局限，而同时又解决了总线型网络在连接用户数量上的限制。\n\n\n# 3. 网络规划与设计\n\n\n# 3.1 结构化布线系统\n\n结构化布线系统分为 6 个子系统 : 工作区子系统、水平布线子系统、干线子系统、设备间子系统 、 管理子系统和建筑群子系统。\n\n1）工作区子系统 终端设备到信息插座的整个区域。 信息插座通常安装在工作间四周的墙壁下方，距离地面 30cm。\n\n2）水平布线子系统 各个楼层接线间的配线架到工作区信息插座之间所安装的线缆。 作用是将干线子系统线路延伸到用户工作区。\n\n3）管理子系统 楼层的接线间内，由各种交连设备(双绞线跳线架、光纤跳线架)以及 集线器和交换机等交换设备组成。\n\n4）干线子系统 建筑物的主干线缆，实现各楼层设备间子系统之间的互连。 一头端接于设备间的主配线架上，另 一头端接在楼层接线间 的管理配线架上。\n\n5）设备间子系统 建筑物的设备间是网络管理人员值班的场所。\n\n6）建筑群子系统 建筑群子系统也叫园区子系统，它是连接各个建筑物的通信系统。\n\n\n# 3.2 网络分析与设计过程\n\n1.网络规划原则\n\n * 考虑实用性原则\n * 开放性原则\n * 先进性原则\n\n2.网络设计任务\n\n * 确定网络总体目标\n * 确定总体设计原则\n * 通信子网设计\n * 资源子网设计\n * 设备选型\n * 网络操作系统与服务器资源设备\n * 网络安全设计\n\n3.网络设计原则\n\n * 可用性：指网络或网络设备可用于执行预期任务时间所占总量的百分比.\n * 可靠性：网络设各或计算机持续执行雌功能的可能性.\n * 可恢复性：指网络从故障中恢复的难易程度和时间.\n * 适应性：指在用户改变应用要求时网络的应变能力.\n * 可伸缩性：指网络技术或设备费者用户需求的增长而扩充的能力.\n\n4.网络实施原则\n\n * 可靠性原则\n * 安全性原则\n * 高效性原则\n * 可扩展性原则\n\n5.网络实施步骤\n\n * 工程实施计划\n * 网络设备到货验收\n * 设备安装\n * 系统测试\n * 系统试运行\n * 用户培训\n * 系统转换\n\n\n# 3.3 逻辑网络设计\n\n利用需求分析和现有的网络体系分析的结果来设计逻辑网络结构，最后得到一分逻辑网络设计文档，输出内容包括以下几点：\n\n * 逻辑网络设计图\n * IP地址方案\n * 安全方案\n * 具体的软硬件，广域网连接设备和基本服务\n * 招聘和培训网络员工的具体说明\n * 对软硬件、服务、员工和培训的费用初步估计\n\n\n# 3.4 分层设计\n\n接入层： 向本地网段提供用户接入\n\n汇聚层： 网络访问策略控制、数据包处理、过滤、寻址\n\n核心层： 数据交换\n\n\n\n\n# 3.5 IP地址的分类\n\n1.IP地址的介绍\n\nIP 地址就是给每个连接到 IPv4 网络上的设备分配的一个网络唯一的地址。IP 地址长度为 32 比特，\n\n通常采用点分十进制方式表示，即每个 IP 地址被表示为以小数点隔开的 4 个十进制整数，每个整\n\n数对应一个字节，如 10.1.1.1。\n\nIP地址的组成**：**\n\n 1. IP地址=网络部分+主机部分\n 2. 网络部分用来确定终端是不是在同一个网段;\n 3. 主机部分用来确定终端的容量大小 (这个网段最多可以容纳多少台主机)同一个部门应该要确保 其所有的终端在同一个网段，主机的数量应该在你的主机部分的范围内;\n\nIPV4地址:\n\n 1. 一个字节(byte)=8个比特 (bit)\n 2. IPV4地址是32位二进制数，点分四段十进制数表示\n 3. IP地址=网络部分+主机部分=32位\n 4. 现在用到IP地址的版本是IPV4 ( 第四个版本)，之后将会过渡到IPV6 (第六版本)，IPV6地址的位 数是128位二进制数。因为IPV4公网地址已经耗尽，没有办法做到一人一IP，所以将会过渡到 IPV6，IPV6可以满足一人一个全球通用的IP。\n\n2.IP地址的分类\n\n\n\n详解解析图：\n\n\n\n🛸A类地址\n\nA类地址第1字节为网络地址（最高位固定是0），另外3个字节为主机地址。 A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。 A类网络默认子网掩码为255.0.0.0，也可写作/8。 A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。\n\n🛸B类地址\n\nB类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。 B类地址范围：128.0.0.0 - 191.255.255.255。 B类网络默认子网掩码为255.255.0.0，也可写作/16。 B类网络最大主机数量256×256-2=6554。\n\n🛸C类地址\n\nC类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。 C类地址范围：192.0.0.0 - 223.255.255.255。 C类网络默认子网掩码为255.255.255.0，也可写作/24。 C类网络最大主机数量256-2=254。\n\n🛸D类地址\n\nD类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。 D类地址用于组播（也称为多播）的地址，无子网掩码。 D类地址范围：224.0.0.0 - 239.255.255.255。\n\n🛸E类地址\n\nE类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。 E类地址范围：240.0.0.0 - 255.255.255.255。 其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。\n\n🛸私有IP地址\n\n私有地址就是在A、B、C三类IP地址中保留下来为企业内部网络分配地址时所使用的IP地址。\n\n * A: 10.0.0.0~10.255.255.255 即10.0.0.0/8\n * B: 172.16.0.0~172.31.255.255即172.16.0.0/12\n * C: 192.168.0.0~192.168.255.255 即192.168.0.0/16\n\n还有一类是特殊IP地址：\n\n 1. 主机ID全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。\n 2. 主机ID全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机ID全是1的IP地址，数据链层地址用广播地址FF-FF-FF-FF-FF-FF。\n 3. 127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(Loopback Address)，即主机IP堆栈内部的IP地址。\n 4. 169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有IP地址。\n 5. 0.0.0.0：如果计算机的IP地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。\n\n\n# 3.6 子网掩码和子网划分\n\n1.子网掩码\n\n 1. 用32个二进制位来确定IP的网络地址，对应IP地址的网络部分用1表示，对应IP地址的主机部分用0表示。 IP地址和子网掩码作逻辑“与”运算得到网络地址，0和任何数相与都等于0，1和任何数相与都等于任何数本身。\n 2. A、B、C三类地址的默认子网掩码： A类:255.0.0.0 B类:255.255.0.0 C类:255.255.255.0\n 3. 子网划分的原因: 1)满足不同网络对IP地址的需求 2)实现网络的层次性 3)节省IP地址\n\n2.子网划分\n\nIP地址规划原则，要遵循4个原则：唯一性、可扩展性、连续性、实意性。\n\n * 子网的划分，实际上就是设计子网掩码的过程。子网掩码主要是用来区分IP地址中的网络ID和主机ID，它用来屏蔽IP地址的一部分，从IP地址中分离出网络ID和主机ID.子网掩码是由4个十进制数组成的数值"中间用"."分隔，如255.255.255.0。若将它写成二进制的形式为:11111111.11111111.11111111.00000000，其中为"1"的位分离出网络ID，为"0"的位分离出主机ID，也就是通过将IP地址与子网掩码进行"与"逻辑操作，得出网络号。\n\n * 例如，假设IP地址为192.160.4.1，子网掩码为255.255.255.0，则网络ID为192.160.4.0,主机ID为0.0.0.1。计算机网络ID的不同，则说明他们不在同一个物理子网内，需通过路由器转发才能进行数据交换。\n\n * 每类地址具有默认的子网掩码:对于A类为255.0.0.0，对于B类为255.255.0.0，对于C类为255.255.255.0。除了使用上述的表示方法之外，还有使用子网掩码中"1"的位数来表示的，在默认情况下，A类地址为8位，B类地址为16位，C类地址为24位。例如，A类的某个地址为 12.10.10.3/8，这里的最后一个"8"说明该地址的子网掩码为8位，而199.42.26.0/28表示网络199.42.26.0的子网掩码位数有28位。\n\n * 如果希望在一个网络中建立子网，就要在这个默认的子网掩码中加入一些位，它减少了用于主机地址的位数。加入到掩码中的位数决定了可以配置的子网。因而，在一个划分了子网的网络中，每个地址包含一个网络地址、一个子网位数和一个主机地址。\n\n> 子网划分举例\n\nC类地址例子：网络地址192.168.10.0;子网掩码255.255.255.192(/26）\n\n1、子网数=2*2=4\n\n2、主机数=2^ 6-2=62\n\n3、有效子网号:block size=256-192=64\n\n   第一个子网网络号：192.168.10.0\n\n   第二个子网网络号：192.168.10.64\n\n   第三个子网网络号：192.168.10.128\n\n   第四个子网网络号：192.168.10.192。\n\n\n4、广播地址：下个子网-1.\n\n   第一个子网广播：192.168.10.63\n\n   第二个子网广播：192.168.10.127\n\n   第三个子网广播：192.168.10.191\n\n   第四个子网广播：192.168.10.255\n\n\n5、有效主机范围是：（去掉该子网的网络号和广播地址）\n\n   第一个子网的有效主机范围：192.168.10.1到192.168.10.62\n\n   第二个子网的有效主机范围：192.168.10.65到192.168.10.126\n\n   第三个子网的有效主机范围：192.168.10.129到192.168.10.190\n\n   第四个子网的有效主机范围：192.168.10.193到192.168.10.254\n\n\n> IP的思维导图总结\n\n\n\n\n# 4. 无线网络技术\n\n\n# 4.1 什么是无线网络\n\n所谓无线网络，就是利用无线电波作为信息传输的媒介构成的无线局域网（WLAN），与有线网络的用途十分类似，最大的不同在于传输媒介的不同，利用无线电技术取代网线，可以和有线网络互为备份。\n\nWLAN是Wireless Local Area Network的简称，指应用无线通信技术将计算机设备互联起来，构成可以互相通信和实现资源共享的网络体系。无线局域网本质的特点是不再使用通信电缆将计算机与网络连接起来，而是通过无线的方式连接，从而使网络的构建和终端的移动更加灵活。\n\n它是相当便利的数据传输系统，它利用射频（Radio Frequency； RF）的技术，使用电磁波，取代旧式碍手碍脚的双绞铜线（Coaxial）所构成的局域网络，在空中进行通信连接，使得无线局域网络能利用简单的存取架构让用户透过它，达到“信息随身化、便利走天下”的理想境界。\n\n常见的标准有以下几种：\n\n * IEEE 802.11a ：使用5GHz频段，传输速度54Mbps，与802.11b不兼容\n * IEEE 802.11b ：使用2.4GHz频段，传输速度11Mbps\n * IEEE 802.11g ：使用2.4GHz频段，传输速度主要有54Mbps、108Mbps，可向下兼容802.11b\n * IEEE 802.11n草案：使用2.4GHz频段，传输速度可达300Mbps，目前标准尚为草案，但产品已层出不穷\n * 目前IEEE 802.11b最常用，但IEEE 802.11g更具下一代标准的实力，802.11n也在快速发展中。\n\n\n# 4.2 无线网络的优势\n\n⑴灵活性和移动性。在有线网络中，网络设备的安放位置受网络位置的限制，而无线局域网在无线信号覆盖区域内的任何一个位置都可以接入网络。无线局域网另一个最大的优点在于其移动性，连接到无线局域网的用户可以移动且能同时与网络保持连接。\n\n⑵安装便捷。无线局域网可以免去或最大程度地减少网络布线的工作量，一般只要安装一个或多个接入点设备，就可建立覆盖整个区域的局域网络。\n\n⑶易于进行网络规划和调整。对于有线网络来说，办公地点或网络拓扑的改变通常意味着重新建网。重新布线是一个昂贵、费时、浪费和琐碎的过程，无线局域网可以避免或减少以上情况的发生。\n\n⑷故障定位容易。有线网络一旦出现物理故障，尤其是由于线路连接不良而造成的网络中断，往往很难查明，而且检修线路需要付出很大的代价。无线网络则很容易定位故障，只需更换故障设备即可恢复网络连接。\n\n⑸易于扩展。无线局域网有多种配置方式，可以很快从只有几个用户的小型局域网扩展到上千用户的大型网络，并且能够提供节点间“漫游”等有线网络无法实现的特性。由于无线局域网有以上诸多优点，因此其发展十分迅速。最近几年，无线局域网已经在企业、医院、商店、工厂和学校等场合得到了广泛的应用。\n\n----------------------------------------\n\n无线局域网的不足之处：无线局域网在能够给网络用户带来便捷和实用的同时，也存在着一些缺陷。无线局域网的不足之处体现在以下几个方面：\n\n * ⑴性能。无线局域网是依靠无线电波进行传输的。这些电波通过无线发射装置进行发射，而建筑物、车辆、树木和其它障碍物都可能阻碍电磁波的传输，所以会影响网络的性能。\n * ⑵速率。无线信道的传输速率与有线信道相比要低得多。无线局域网的最大传输速率为1Gbit/s，只适合于个人终端和小规模网络应用。\n * ⑶安全性。本质上无线电波不要求建立物理的连接通道，无线信号是发散的。从理论上讲，很容易监听到无线电波广播范围内的任何信号，造成通信信息泄漏。\n\n\n# 4.3 网络接入技术\n\n网络接入技术是网络中与用户相连的最后一段线路上所采用的技术，接入技术已成为网络技术的一大热点，为了提供端到端的宽带连接，宽带接入是必须要解决的一个问题。\n\n主要分类\n\n1.光纤接入\n\n光纤是传输速率最高的传输介质，在主干网中已大量的采用了光纤。如果将光纤应用到用户环路中，就能满足用户将来各种宽带业务的要求。可以说，光纤接入是宽带接入网的最终形式，但要完全抛弃现有的用户网络而全部重新铺设光纤，对于大多数国家和地区来说还是不经济、不现实的。\n\n2.同轴接入\n\n同轴电缆也是传输带宽比较大的一种传输介质，CATV网就是一种混合光纤铜轴网络，主干部分采用光纤，用同轴电缆经分支器介入各家各户。混合光纤/铜轴（HFC）接入技术的一大优点是可以利用现有的CATV网，从而降低网络接入成本。\n\n3.铜线接入\n\n铜线接入是指以现有的电话线为传输介质，利用各种先进的调制技术和编码技术、数字信号处理技术来提高铜线的传输速率和传输距离。但是铜线的传输带宽毕竟有限，铜线接入方式的传输速率和传输距离一直是一对难以调和的矛盾，从长远的观点来看，铜线接入方式很难适应将来宽带业务发展的需要。\n\n4.无线接入\n\n无线用户环路是指利用无线技术为固定用户或移动用户提供电信业务，因此无线接入可分为固定无线接入和移动无线接入，采用的无线技术有微波、卫星等。无线接入的优点有：初期投入小，能迅速提供业务，不需要铺设线路，因而可以省去铺线的大量费用和时间；比较灵活，可以随时按照需要进行变更、扩容，抗灾难性比较强。\n\n有线接入总结：\n\n * 公用交换电话网络(PSTN)\n * 数据数据网(DDN)\n * 综合业务数字网(ISDN)\n * 非对称数字用户线路(ADSL)\n * 同轴光纤技术(HFC)\n\n无线接入总结：\n\n * IEEE 802.11(WIFI)\n * IEEE 802.15(蓝牙)\n * 红外(IrDA)\n * WAPI\n\n3G/4G：\n\n * WCDMA\n * CDMA2000\n * TD-SCDMA\n * LTE-Advanced\n * WirelessMAN-Advanced（802.16m）（WiMAX）\n\n\n# 4.4 IPV6\n\n由于internet规模的扩大，IPv4地址空间已经消耗殆尽，IETF在90年代提出了下一代互联网协议IPv6，IPv6支持几乎无限的地址空间，并且配置更加简单，IPv6还采用全新的报文格式，提高了报文处理的效率，安全性。也能更好的支持Qos。\n\n对比：\n\n * IPv4 长度32bit 大约有40亿，256^4\n * IPv6 长度128bit 2^96\n\nIPv6扩展报头\n\nIPv6扩展报头是跟在IPv6基本报头后面的可选报文，可以有一个或多个。\n\n报头按照一下顺序出现\n\n * IPv6基本报头\n * 逐跳选项扩展报头\n * 目的选项扩展报头\n * 路由扩展报头\n * 分片扩展报头\n * 认证扩展报头\n * 封装安全有效载荷扩展报头\n * 目的选项扩展报头\n * 上层协议数据报头\n\n目的选项报头最多出现两次，其他最多只能出现一次。\n\nIPv6地址格式\n\n长度128bit，每16比特划分为一段，每段由4个16进制数表示，一个IPv6地址由IPv6地址前缀（标识IPv6网络）和接口ID（标识接口）组成\n\nIPv6地址分类\n\n\n\n分为单播地址，任播地址，组播地址，没有广播地址。 2000：：/3 全球单播地址 fc00： ：/7 唯一本地地址 fe80 ：：/10 链路本地地址 ff00 ： ：/8 组播地址 ：：/ 128 未指定地址 ：：1/128 换回地址\n\n2400：：/12 APNIC 亚太互联网 2600：：/12 ARIN 美国 2800：：/12 LACNIC 拉丁美洲 2A00：：/12 RIPE NCC 欧洲 2C00：：/12 AFRINIC 非洲\n\n文档示例预留地址空间 2001 ：：/32 链路本地地址只能连接到同一本地链路的节点之间',normalizedContent:'# 计算机网络\n\n\n# 思维导图\n\n\n\n\n# 1. osi的基本概念及原则\n\n\n# 1.1 osi七层模型介绍\n\nosi是open system interconnect的缩写，意为开放式系统互联。各个层次的划分遵循以下原则\n\n 1. 同一层中的各网络节点都有相同的层次结构，具有同样的功能。\n 2. 同一节点内相邻层之间通过接口进行通信。\n 3. 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。（物理->数据链路层->…应用层）\n 4. 不同节点的同等层按照协议实现对等层之间的通信。\n\n原理图\n\n\n\n\n\ntcp/ip四层模型与osi体系结构对比：\n\n\n\n\n# 1.2 osi七层模型详解\n\n> 计算机的网络性能指标： 速率：bps=bit/s 时延：发送时延、传播时延、排队时延、处理时延 往返时间rtt：数据报文在端到端通信中的来回一次的时间。\n\n🚀第一层：物理层\n\n在osi参考模型中，物理层是参考模型的最低层，也是osi模型的第一层。物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么。\n\n1.物理层设备：\n\n * 中继器【repeater，也叫放大器】：同一局域网的再生信号；两端口的网段必须同一协议；5-4-3规程：10base-5以太网中，最多串联4个中继器，5段中只能有3个连接主机；\n * 集线器：同一局域网的再生、放大信号（多端口的中继器）；半双工，不能隔离冲突域也不能隔离广播域。\n\n2.信道的基本概念 :信道是往一个方向传输信息的媒体，一条通信电路包含一个发送信道和一个接受信道。\n\n 1. 单工通信信道：只能一个方向通信，没有反方向反馈的信道；\n 2. 半双工通信信道：双方都可以发送和接受信息，但不能同时发送也不能同时接收；\n 3. 全双工通信信道：双方都可以同时发送和接收。\n\n🚀第二层：数据链路层\n\n数据链路层（data link layer）是osi模型的第二层，负责建立和管理节点间的链路。在计算机网络中由于各种干扰的存在，导致物理链路是不可靠的。因此这一层的主要功能是：在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。\n\n该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。\n\n有关数据链路层的重要知识点：\n\n 1. 数据链路层为网络层提供可靠的数据传输；\n 2. 基本数据单位为帧；\n 3. 主要的协议：以太网协议；\n 4. 两个重要设备名称：网桥和交换机。\n\n封装成帧：“帧”是数据链路层数据的基本单位：\n\n\n\n透明传输：“透明”是指即使控制字符在帧数据中，但是要当做不存在去处理。即在控制字符前加上转义字符esc。\n\n\n\n🚀第三层：网络层\n\n网络层（network layer）是osi模型的第三层，它是osi参考模型中最复杂的一层，也是通信子网的最高一层，它在下两层的基础上向资源子网提供服务。其主要功能是：在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接，将数据设法从源端经过若干个中间节点传送到目的端（点到点），从而向传输层提供最基本的端到端的数据传输服务。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。数据链路层和网络层的区别为：数据链路层的目的是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。\n\n与ip协议配套使用实现其功能的还有地址解析协议arp、逆地址解析协议rarp、因特网报文协议icmp、因特网组管理协议igmp。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：\n\n 1. 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；\n 2. 基本数据单位为ip数据报；\n 3. 包含的主要协议：\n\n * ip协议（internet protocol，因特网互联协议）;\n * icmp协议（internet control message protocol，因特网控制报文协议）;\n * arp协议（address resolution protocol，地址解析协议）;\n * rarp协议（reverse address resolution protocol，逆地址解析协议）。\n\n🚀第四层：传输层\n\nosi下3层的任务是数据通信，上3层的任务是数据处理。而传输层（transport layer）是osi模型的第4层。该层提供建立、维护和拆除传输连接的功能，起到承上启下的作用。该层的主要功能是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，同时向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。\n\n有关网络层的重点：\n\n 1. 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；\n 2. 包含的主要协议：tcp协议（transmission control protocol，传输控制协议）、udp协议（user datagram protocol，用户数据报协议）；\n 3. 重要设备：网关。\n\n🚀第五层：会话层\n\n会话层是osi模型的第5层，是用户应用程序和网络之间的接口，该层的主要功能是：组织和协调两个会话进程之间的通信 ，并对数据交换进行管理。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与mac地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名就是一种网络上使用的远程地址。会话层的具体功能如下：\n\n * 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。\n * 会话流量控制：提供会话流量控制和交叉会话功能。\n * 寻址：使用远程地址建立会话连接。\n * 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。\n\n🚀第六层：表示层\n\n表示层是osi模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。该层的主要功能是：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。表示层的具体功能如下：\n\n * 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。\n * 数据的编码：处理字符集和数字的转换。\n * 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。\n * 数据的加密和解密：可以提高网络的安全性。\n\n🚀第七层：应用层\n\n应用层是osi参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，该层的主要功能是：直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外该层还负责协调各个应用程序间的工作。应用层的具体功能如下：\n\n * 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。\n * 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。\n\n为操作系统或网络应用程序提供访问网络服务的接口。应用层重点：\n\n 1. 数据传输基本单位为报文；\n 2. 包含的主要协议：ftp（文件传送协议）、telnet（远程登录协议）、dns（域名解析协议）、smtp（邮件传送协议），pop3协议（邮局协议），http协议（hyper text transfer protocol）。\n\n\n# 1.3 网络技术标准与协议\n\n * tcp/ip协议：internet，可扩展、可靠、应用最广、牺牲速度和效率\n * ipx/spx协议： novell、路由、大型网络\n * netbeui协议： ibm、非路由、快速\n\n\n\n 1. tcp/ip协议：可靠，但是速度不够\n 2. ipx/spx协议：局域网的战略游戏等等都需要这种协议\n 3. netbeui协议：不支持路由所以速度比较快\n 4. icmp: 因特网的控制协议 例如ping操作就是如此\n 5. arp: 地址解析协议 ip -> mac\n 6. rarp: 反向地址解析协议 mac -> ip\n 7. tcp: 传输层可靠协议 建立连接确保所有数据包都接收到了（三次握手）\n 8. udp: 不可靠协议 没有验证过程\n\n属于tcp类的协议\n\n * http: 超文本传输协议 传输网页数据\n * tcp： 是文件传输协议\n * telnet：是做远程登录的\n * pop3 ：与 smtp:是做邮件传输的协议\n\n属于udp类的协议\n\n * dhcp: 局域网中有dhcp服务器用来做动态的ip地址分配工作\n * tftp: 小文件传输协议\n * snmp：简单网络管理协议\n * dns: 是用来做域名解析的\n\n\n# 2. 计算机网络拓扑\n\n计算机网络的分类有：\n\n 1. 局域网(lan)\n 2. 城域网(man)\n 3. 广域网(wan)\n 4. 因特网\n\n\n# 2.1 网络拓扑的定义\n\n在认识网络拓扑图前，我们先来了解下网络拓扑结构。\n\n所谓网络拓扑结构，是指用传输媒体互连各种设备的物理布局，就是用什么方式把网络中的计算机等设备连接起来。而网络拓扑图，就是指将这种网络连接结构呈现出来的图形。\n\n网络拓扑图的常见结构有星型结构、环形结构、总线结构、网状结构、树型结构、混合结构等。\n\n\n# 2.2 星型结构\n\n这是最古老的一种连接方式：网络有中央节点，其他节点（工作站、服务器）都与中央节点直接相连，这种结构以中央节点为中心，因此又称为集中式网络。\n\n优点：\n\n1、结构简单，连接方便，管理和维护都相对容易，重新配置灵活。\n\n2、各节点与中央交换单元直接连通，各节点之间通信必须经过中央单元转换，故障隔离和检测容易。\n\n3、网络延迟时间短，传输误差低。\n\n缺点：\n\n1、安装和维护的费用较高。\n\n2、共享资源的能力较差。\n\n3、一条通信线路只被该线路上的中央节点和边缘节点使用，通信线路利用率不高。\n\n4、对中央节点要求相当高，一旦中央节点出现故障，则整个网络将瘫痪。\n\n\n\n\n# 2.3 环形结构\n\n区别于星型结构对中心系统的依赖。\n\n环形结构中的传输媒体从一个端用户到另一个端用户，直到将所有的端用户连成环型。数据在环路中沿着一个方向在各个节点间传输，信息从一个节点传到另一个节点。\n\n优点：\n\n1、环型网中信息的流动方向是固定的，两个节点仅有一条通路，路径控制简单；\n\n2、有旁路设备，节点一旦发生故障，系统自动旁路，可靠性高；结构简单，节点的增、删和位置的变动较容易。\n\n缺点：\n\n1、环型拓扑结构的媒体访问控制协议都采用令牌传递的方式,在负载很轻时,信道利用率相对来说就比较低。\n\n2、信息要串行穿过多个节点，在网中节点过多时传输效率低，系统响应速度慢；\n\n3、故障检测困难。因为不是集中控制,故障检测需在网上各个节点进行。\n\n4、由于环路封闭，扩充较难。\n\n\n\n\n# 2.4 树型结构\n\n在实际建造一个大型网络时，往往是采用多级星形网络，将多级星形网络按层次方式排列即形成树形网络。\n\n优点：\n\n1、易于扩展。这种结构可以延伸出很多分支和子分支,这些新节点和新分支都能容易地加入网内。\n\n2、故障隔离较容易。如果某一分支的节点或线路发生故障,很容易将故障分支与整个系统隔离开来\n\n缺点：\n\n1、各个节点对根的依赖性太大，如果根发生故障，则全网不能正常工作。\n\n\n\n\n# 2.5 总线结构\n\n总线结构是使用同一媒体或电缆连接所有端用户的一种方式，也就是说，连接端用户的物理媒体由所有设备共享，各工作站地位平等，无中心节点控制。\n\n优点：\n\n1、结构简单。\n\n2、节点的增、删和位置的变动较容易。\n\n3、系统的扩充性能好。\n\n4、多个节点共用一条传输信道，信道利用率高。\n\n缺点：\n\n1、总线的传输距离有限,通信范围受到限制。\n\n2、负载重时，线路的利用率较低。\n\n3、网络延迟时间不确定，故障隔离和检测困难。\n\n\n\n\n# 2.6 网状结构\n\n主要指各节点通过传输线互联连接起来，并且每一个节点至少与其他两个节点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护，不常用于局域网。有时也称为分布式结构。\n\n优点：\n\n1、分布式网络具有较高的可靠性，网状拓扑结构保证了冗余度，因为在任何两个节点之间至少有两条链路，当一条线路有故障时，不会影响整个系统工作。\n\n2、资源共享方便，网络响应时间短。\n\n3、电缆长度短，连线容易。因为任何一个想到入网的计算设备只需就近连入网络，而不必直接连到中央节点。\n\n4、易于扩充。增加新的站点，只需在网络的任何点将其接入。\n\n缺点：\n\n1、建网复杂。网络难于管理。\n\n2、由于节点与多个节点连接，故节点的路由选择和流量控制难度大。\n\n3、故障诊断困难。分布式结构的网络不是集中控制，故障检测只能逐个检查各个站点。\n\n4、管理软件复杂，硬件成本高。\n\n\n\n\n# 2.7 混合结构\n\n混合结构是由星型结构或环型结构和总线型结构结合在一起的网络结构，这样的拓扑结构更能满足较大网络的拓展，解决星型网络在传输距离上的局限，而同时又解决了总线型网络在连接用户数量上的限制。\n\n\n# 3. 网络规划与设计\n\n\n# 3.1 结构化布线系统\n\n结构化布线系统分为 6 个子系统 : 工作区子系统、水平布线子系统、干线子系统、设备间子系统 、 管理子系统和建筑群子系统。\n\n1）工作区子系统 终端设备到信息插座的整个区域。 信息插座通常安装在工作间四周的墙壁下方，距离地面 30cm。\n\n2）水平布线子系统 各个楼层接线间的配线架到工作区信息插座之间所安装的线缆。 作用是将干线子系统线路延伸到用户工作区。\n\n3）管理子系统 楼层的接线间内，由各种交连设备(双绞线跳线架、光纤跳线架)以及 集线器和交换机等交换设备组成。\n\n4）干线子系统 建筑物的主干线缆，实现各楼层设备间子系统之间的互连。 一头端接于设备间的主配线架上，另 一头端接在楼层接线间 的管理配线架上。\n\n5）设备间子系统 建筑物的设备间是网络管理人员值班的场所。\n\n6）建筑群子系统 建筑群子系统也叫园区子系统，它是连接各个建筑物的通信系统。\n\n\n# 3.2 网络分析与设计过程\n\n1.网络规划原则\n\n * 考虑实用性原则\n * 开放性原则\n * 先进性原则\n\n2.网络设计任务\n\n * 确定网络总体目标\n * 确定总体设计原则\n * 通信子网设计\n * 资源子网设计\n * 设备选型\n * 网络操作系统与服务器资源设备\n * 网络安全设计\n\n3.网络设计原则\n\n * 可用性：指网络或网络设备可用于执行预期任务时间所占总量的百分比.\n * 可靠性：网络设各或计算机持续执行雌功能的可能性.\n * 可恢复性：指网络从故障中恢复的难易程度和时间.\n * 适应性：指在用户改变应用要求时网络的应变能力.\n * 可伸缩性：指网络技术或设备费者用户需求的增长而扩充的能力.\n\n4.网络实施原则\n\n * 可靠性原则\n * 安全性原则\n * 高效性原则\n * 可扩展性原则\n\n5.网络实施步骤\n\n * 工程实施计划\n * 网络设备到货验收\n * 设备安装\n * 系统测试\n * 系统试运行\n * 用户培训\n * 系统转换\n\n\n# 3.3 逻辑网络设计\n\n利用需求分析和现有的网络体系分析的结果来设计逻辑网络结构，最后得到一分逻辑网络设计文档，输出内容包括以下几点：\n\n * 逻辑网络设计图\n * ip地址方案\n * 安全方案\n * 具体的软硬件，广域网连接设备和基本服务\n * 招聘和培训网络员工的具体说明\n * 对软硬件、服务、员工和培训的费用初步估计\n\n\n# 3.4 分层设计\n\n接入层： 向本地网段提供用户接入\n\n汇聚层： 网络访问策略控制、数据包处理、过滤、寻址\n\n核心层： 数据交换\n\n\n\n\n# 3.5 ip地址的分类\n\n1.ip地址的介绍\n\nip 地址就是给每个连接到 ipv4 网络上的设备分配的一个网络唯一的地址。ip 地址长度为 32 比特，\n\n通常采用点分十进制方式表示，即每个 ip 地址被表示为以小数点隔开的 4 个十进制整数，每个整\n\n数对应一个字节，如 10.1.1.1。\n\nip地址的组成**：**\n\n 1. ip地址=网络部分+主机部分\n 2. 网络部分用来确定终端是不是在同一个网段;\n 3. 主机部分用来确定终端的容量大小 (这个网段最多可以容纳多少台主机)同一个部门应该要确保 其所有的终端在同一个网段，主机的数量应该在你的主机部分的范围内;\n\nipv4地址:\n\n 1. 一个字节(byte)=8个比特 (bit)\n 2. ipv4地址是32位二进制数，点分四段十进制数表示\n 3. ip地址=网络部分+主机部分=32位\n 4. 现在用到ip地址的版本是ipv4 ( 第四个版本)，之后将会过渡到ipv6 (第六版本)，ipv6地址的位 数是128位二进制数。因为ipv4公网地址已经耗尽，没有办法做到一人一ip，所以将会过渡到 ipv6，ipv6可以满足一人一个全球通用的ip。\n\n2.ip地址的分类\n\n\n\n详解解析图：\n\n\n\n🛸a类地址\n\na类地址第1字节为网络地址（最高位固定是0），另外3个字节为主机地址。 a类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。 a类网络默认子网掩码为255.0.0.0，也可写作/8。 a类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。\n\n🛸b类地址\n\nb类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。 b类地址范围：128.0.0.0 - 191.255.255.255。 b类网络默认子网掩码为255.255.0.0，也可写作/16。 b类网络最大主机数量256×256-2=6554。\n\n🛸c类地址\n\nc类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。 c类地址范围：192.0.0.0 - 223.255.255.255。 c类网络默认子网掩码为255.255.255.0，也可写作/24。 c类网络最大主机数量256-2=254。\n\n🛸d类地址\n\nd类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。 d类地址用于组播（也称为多播）的地址，无子网掩码。 d类地址范围：224.0.0.0 - 239.255.255.255。\n\n🛸e类地址\n\ne类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。 e类地址范围：240.0.0.0 - 255.255.255.255。 其中240.0.0.0-255.255.255.254作为保留地址，主要用于internet试验和开发，255.255.255.255作为广播地址。\n\n🛸私有ip地址\n\n私有地址就是在a、b、c三类ip地址中保留下来为企业内部网络分配地址时所使用的ip地址。\n\n * a: 10.0.0.0~10.255.255.255 即10.0.0.0/8\n * b: 172.16.0.0~172.31.255.255即172.16.0.0/12\n * c: 192.168.0.0~192.168.255.255 即192.168.0.0/16\n\n还有一类是特殊ip地址：\n\n 1. 主机id全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。\n 2. 主机id全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机id全是1的ip地址，数据链层地址用广播地址ff-ff-ff-ff-ff-ff。\n 3. 127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(loopback address)，即主机ip堆栈内部的ip地址。\n 4. 169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有ip地址。\n 5. 0.0.0.0：如果计算机的ip地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。\n\n\n# 3.6 子网掩码和子网划分\n\n1.子网掩码\n\n 1. 用32个二进制位来确定ip的网络地址，对应ip地址的网络部分用1表示，对应ip地址的主机部分用0表示。 ip地址和子网掩码作逻辑“与”运算得到网络地址，0和任何数相与都等于0，1和任何数相与都等于任何数本身。\n 2. a、b、c三类地址的默认子网掩码： a类:255.0.0.0 b类:255.255.0.0 c类:255.255.255.0\n 3. 子网划分的原因: 1)满足不同网络对ip地址的需求 2)实现网络的层次性 3)节省ip地址\n\n2.子网划分\n\nip地址规划原则，要遵循4个原则：唯一性、可扩展性、连续性、实意性。\n\n * 子网的划分，实际上就是设计子网掩码的过程。子网掩码主要是用来区分ip地址中的网络id和主机id，它用来屏蔽ip地址的一部分，从ip地址中分离出网络id和主机id.子网掩码是由4个十进制数组成的数值"中间用"."分隔，如255.255.255.0。若将它写成二进制的形式为:11111111.11111111.11111111.00000000，其中为"1"的位分离出网络id，为"0"的位分离出主机id，也就是通过将ip地址与子网掩码进行"与"逻辑操作，得出网络号。\n\n * 例如，假设ip地址为192.160.4.1，子网掩码为255.255.255.0，则网络id为192.160.4.0,主机id为0.0.0.1。计算机网络id的不同，则说明他们不在同一个物理子网内，需通过路由器转发才能进行数据交换。\n\n * 每类地址具有默认的子网掩码:对于a类为255.0.0.0，对于b类为255.255.0.0，对于c类为255.255.255.0。除了使用上述的表示方法之外，还有使用子网掩码中"1"的位数来表示的，在默认情况下，a类地址为8位，b类地址为16位，c类地址为24位。例如，a类的某个地址为 12.10.10.3/8，这里的最后一个"8"说明该地址的子网掩码为8位，而199.42.26.0/28表示网络199.42.26.0的子网掩码位数有28位。\n\n * 如果希望在一个网络中建立子网，就要在这个默认的子网掩码中加入一些位，它减少了用于主机地址的位数。加入到掩码中的位数决定了可以配置的子网。因而，在一个划分了子网的网络中，每个地址包含一个网络地址、一个子网位数和一个主机地址。\n\n> 子网划分举例\n\nc类地址例子：网络地址192.168.10.0;子网掩码255.255.255.192(/26）\n\n1、子网数=2*2=4\n\n2、主机数=2^ 6-2=62\n\n3、有效子网号:block size=256-192=64\n\n   第一个子网网络号：192.168.10.0\n\n   第二个子网网络号：192.168.10.64\n\n   第三个子网网络号：192.168.10.128\n\n   第四个子网网络号：192.168.10.192。\n\n\n4、广播地址：下个子网-1.\n\n   第一个子网广播：192.168.10.63\n\n   第二个子网广播：192.168.10.127\n\n   第三个子网广播：192.168.10.191\n\n   第四个子网广播：192.168.10.255\n\n\n5、有效主机范围是：（去掉该子网的网络号和广播地址）\n\n   第一个子网的有效主机范围：192.168.10.1到192.168.10.62\n\n   第二个子网的有效主机范围：192.168.10.65到192.168.10.126\n\n   第三个子网的有效主机范围：192.168.10.129到192.168.10.190\n\n   第四个子网的有效主机范围：192.168.10.193到192.168.10.254\n\n\n> ip的思维导图总结\n\n\n\n\n# 4. 无线网络技术\n\n\n# 4.1 什么是无线网络\n\n所谓无线网络，就是利用无线电波作为信息传输的媒介构成的无线局域网（wlan），与有线网络的用途十分类似，最大的不同在于传输媒介的不同，利用无线电技术取代网线，可以和有线网络互为备份。\n\nwlan是wireless local area network的简称，指应用无线通信技术将计算机设备互联起来，构成可以互相通信和实现资源共享的网络体系。无线局域网本质的特点是不再使用通信电缆将计算机与网络连接起来，而是通过无线的方式连接，从而使网络的构建和终端的移动更加灵活。\n\n它是相当便利的数据传输系统，它利用射频（radio frequency； rf）的技术，使用电磁波，取代旧式碍手碍脚的双绞铜线（coaxial）所构成的局域网络，在空中进行通信连接，使得无线局域网络能利用简单的存取架构让用户透过它，达到“信息随身化、便利走天下”的理想境界。\n\n常见的标准有以下几种：\n\n * ieee 802.11a ：使用5ghz频段，传输速度54mbps，与802.11b不兼容\n * ieee 802.11b ：使用2.4ghz频段，传输速度11mbps\n * ieee 802.11g ：使用2.4ghz频段，传输速度主要有54mbps、108mbps，可向下兼容802.11b\n * ieee 802.11n草案：使用2.4ghz频段，传输速度可达300mbps，目前标准尚为草案，但产品已层出不穷\n * 目前ieee 802.11b最常用，但ieee 802.11g更具下一代标准的实力，802.11n也在快速发展中。\n\n\n# 4.2 无线网络的优势\n\n⑴灵活性和移动性。在有线网络中，网络设备的安放位置受网络位置的限制，而无线局域网在无线信号覆盖区域内的任何一个位置都可以接入网络。无线局域网另一个最大的优点在于其移动性，连接到无线局域网的用户可以移动且能同时与网络保持连接。\n\n⑵安装便捷。无线局域网可以免去或最大程度地减少网络布线的工作量，一般只要安装一个或多个接入点设备，就可建立覆盖整个区域的局域网络。\n\n⑶易于进行网络规划和调整。对于有线网络来说，办公地点或网络拓扑的改变通常意味着重新建网。重新布线是一个昂贵、费时、浪费和琐碎的过程，无线局域网可以避免或减少以上情况的发生。\n\n⑷故障定位容易。有线网络一旦出现物理故障，尤其是由于线路连接不良而造成的网络中断，往往很难查明，而且检修线路需要付出很大的代价。无线网络则很容易定位故障，只需更换故障设备即可恢复网络连接。\n\n⑸易于扩展。无线局域网有多种配置方式，可以很快从只有几个用户的小型局域网扩展到上千用户的大型网络，并且能够提供节点间“漫游”等有线网络无法实现的特性。由于无线局域网有以上诸多优点，因此其发展十分迅速。最近几年，无线局域网已经在企业、医院、商店、工厂和学校等场合得到了广泛的应用。\n\n----------------------------------------\n\n无线局域网的不足之处：无线局域网在能够给网络用户带来便捷和实用的同时，也存在着一些缺陷。无线局域网的不足之处体现在以下几个方面：\n\n * ⑴性能。无线局域网是依靠无线电波进行传输的。这些电波通过无线发射装置进行发射，而建筑物、车辆、树木和其它障碍物都可能阻碍电磁波的传输，所以会影响网络的性能。\n * ⑵速率。无线信道的传输速率与有线信道相比要低得多。无线局域网的最大传输速率为1gbit/s，只适合于个人终端和小规模网络应用。\n * ⑶安全性。本质上无线电波不要求建立物理的连接通道，无线信号是发散的。从理论上讲，很容易监听到无线电波广播范围内的任何信号，造成通信信息泄漏。\n\n\n# 4.3 网络接入技术\n\n网络接入技术是网络中与用户相连的最后一段线路上所采用的技术，接入技术已成为网络技术的一大热点，为了提供端到端的宽带连接，宽带接入是必须要解决的一个问题。\n\n主要分类\n\n1.光纤接入\n\n光纤是传输速率最高的传输介质，在主干网中已大量的采用了光纤。如果将光纤应用到用户环路中，就能满足用户将来各种宽带业务的要求。可以说，光纤接入是宽带接入网的最终形式，但要完全抛弃现有的用户网络而全部重新铺设光纤，对于大多数国家和地区来说还是不经济、不现实的。\n\n2.同轴接入\n\n同轴电缆也是传输带宽比较大的一种传输介质，catv网就是一种混合光纤铜轴网络，主干部分采用光纤，用同轴电缆经分支器介入各家各户。混合光纤/铜轴（hfc）接入技术的一大优点是可以利用现有的catv网，从而降低网络接入成本。\n\n3.铜线接入\n\n铜线接入是指以现有的电话线为传输介质，利用各种先进的调制技术和编码技术、数字信号处理技术来提高铜线的传输速率和传输距离。但是铜线的传输带宽毕竟有限，铜线接入方式的传输速率和传输距离一直是一对难以调和的矛盾，从长远的观点来看，铜线接入方式很难适应将来宽带业务发展的需要。\n\n4.无线接入\n\n无线用户环路是指利用无线技术为固定用户或移动用户提供电信业务，因此无线接入可分为固定无线接入和移动无线接入，采用的无线技术有微波、卫星等。无线接入的优点有：初期投入小，能迅速提供业务，不需要铺设线路，因而可以省去铺线的大量费用和时间；比较灵活，可以随时按照需要进行变更、扩容，抗灾难性比较强。\n\n有线接入总结：\n\n * 公用交换电话网络(pstn)\n * 数据数据网(ddn)\n * 综合业务数字网(isdn)\n * 非对称数字用户线路(adsl)\n * 同轴光纤技术(hfc)\n\n无线接入总结：\n\n * ieee 802.11(wifi)\n * ieee 802.15(蓝牙)\n * 红外(irda)\n * wapi\n\n3g/4g：\n\n * wcdma\n * cdma2000\n * td-scdma\n * lte-advanced\n * wirelessman-advanced（802.16m）（wimax）\n\n\n# 4.4 ipv6\n\n由于internet规模的扩大，ipv4地址空间已经消耗殆尽，ietf在90年代提出了下一代互联网协议ipv6，ipv6支持几乎无限的地址空间，并且配置更加简单，ipv6还采用全新的报文格式，提高了报文处理的效率，安全性。也能更好的支持qos。\n\n对比：\n\n * ipv4 长度32bit 大约有40亿，256^4\n * ipv6 长度128bit 2^96\n\nipv6扩展报头\n\nipv6扩展报头是跟在ipv6基本报头后面的可选报文，可以有一个或多个。\n\n报头按照一下顺序出现\n\n * ipv6基本报头\n * 逐跳选项扩展报头\n * 目的选项扩展报头\n * 路由扩展报头\n * 分片扩展报头\n * 认证扩展报头\n * 封装安全有效载荷扩展报头\n * 目的选项扩展报头\n * 上层协议数据报头\n\n目的选项报头最多出现两次，其他最多只能出现一次。\n\nipv6地址格式\n\n长度128bit，每16比特划分为一段，每段由4个16进制数表示，一个ipv6地址由ipv6地址前缀（标识ipv6网络）和接口id（标识接口）组成\n\nipv6地址分类\n\n\n\n分为单播地址，任播地址，组播地址，没有广播地址。 2000：：/3 全球单播地址 fc00： ：/7 唯一本地地址 fe80 ：：/10 链路本地地址 ff00 ： ：/8 组播地址 ：：/ 128 未指定地址 ：：1/128 换回地址\n\n2400：：/12 apnic 亚太互联网 2600：：/12 arin 美国 2800：：/12 lacnic 拉丁美洲 2a00：：/12 ripe ncc 欧洲 2c00：：/12 afrinic 非洲\n\n文档示例预留地址空间 2001 ：：/32 链路本地地址只能连接到同一本地链路的节点之间',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL的SQL详解",frontmatter:{title:"MySQL的SQL详解",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/972c8f/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/04.MySQL%E7%9A%84SQL%E8%AF%A6%E8%A7%A3.html",relativePath:"01.指南/04.数据库/04.MySQL的SQL详解.md",key:"v-3a027d70",path:"/pages/972c8f/",headers:[{level:2,title:"SQL通用语法",slug:"sql通用语法",normalizedTitle:"sql通用语法",charIndex:90},{level:2,title:"SQL分类",slug:"sql分类",normalizedTitle:"sql分类",charIndex:284},{level:2,title:"DDL",slug:"ddl",normalizedTitle:"ddl",charIndex:310},{level:3,title:"数据库操作",slug:"数据库操作",normalizedTitle:"数据库操作",charIndex:672},{level:3,title:"表操作",slug:"表操作",normalizedTitle:"表操作",charIndex:2035},{level:3,title:"图形化界面工具",slug:"图形化界面工具",normalizedTitle:"图形化界面工具",charIndex:10430},{level:4,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:10703},{level:4,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:170},{level:2,title:"DML",slug:"dml",normalizedTitle:"dml",charIndex:314},{level:3,title:"添加数据",slug:"添加数据",normalizedTitle:"添加数据",charIndex:10821},{level:3,title:"修改数据",slug:"修改数据",normalizedTitle:"修改数据",charIndex:8918},{level:3,title:"删除数据",slug:"删除数据",normalizedTitle:"删除数据",charIndex:1555},{level:2,title:"DQL",slug:"dql",normalizedTitle:"dql",charIndex:318},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:20444},{level:3,title:"基础查询",slug:"基础查询",normalizedTitle:"基础查询",charIndex:20719},{level:3,title:"条件查询",slug:"条件查询",normalizedTitle:"条件查询",charIndex:20621},{level:3,title:"聚合函数",slug:"聚合函数",normalizedTitle:"聚合函数",charIndex:20636},{level:3,title:"分组查询",slug:"分组查询",normalizedTitle:"分组查询",charIndex:20667},{level:3,title:"排序查询",slug:"排序查询",normalizedTitle:"排序查询",charIndex:20685},{level:3,title:"分页查询",slug:"分页查询",normalizedTitle:"分页查询",charIndex:20703},{level:3,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:834},{level:3,title:"执行顺序",slug:"执行顺序",normalizedTitle:"执行顺序",charIndex:27002},{level:2,title:"DCL",slug:"dcl",normalizedTitle:"dcl",charIndex:322},{level:3,title:"管理用户",slug:"管理用户",normalizedTitle:"管理用户",charIndex:33360},{level:3,title:"权限控制",slug:"权限控制",normalizedTitle:"权限控制",charIndex:34791}],headersStr:"SQL通用语法 SQL分类 DDL 数据库操作 表操作 图形化界面工具 安装 使用 DML 添加数据 修改数据 删除数据 DQL 基本语法 基础查询 条件查询 聚合函数 分组查询 排序查询 分页查询 案例 执行顺序 DCL 管理用户 权限控制",content:"# MySQL的SQL详解\n\n全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。\n\n\n# SQL通用语法\n\n在学习具体的SQL语句之前，先来了解一下SQL语言的同于语法。\n\n1). SQL语句可以单行或多行书写，以分号结尾。\n\n2). SQL语句可以使用空格/缩进来增强语句的可读性。\n\n3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n\n4). 注释：\n\n> 单行注释：-- 注释内容 或 # 注释内容\n> \n> 多行注释：/* 注释内容 */\n\n\n# SQL分类\n\nSQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。\n\n分类    全称                           说明\nDDL   Data Definition Language     数据定义语言，用来定义数据库对象(数据库，表，字段)\nDML   Data Manipulation Language   数据操作语言，用来对数据库表中的数据进行增删改\nDQL   Data Query Language          数据查询语言，用来查询数据库中表的记录\nDCL   Data Control Language        数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n# DDL\n\nData Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。\n\n\n# 数据库操作\n\n1). 查询所有数据库\n\nshow databases;\n\n\n\n\n2). 查询当前数据库\n\nselect database();\n\n\n3). 创建数据库\n\ncreate database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];\n\n\n案例：\n\nA. 创建一个itcast数据库, 使用数据库默认的字符集。\n\nMariaDB [(none)]> create database idtest;\nQuery OK, 1 row affected (0.000 sec)\n\nMariaDB [(none)]> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| idtest             |\n| information_schema |\n| mysql              |\n| performance_schema |\n| test               |\n+--------------------+\n5 rows in set (0.000 sec)\n\n\n在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\n\n可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。\n\nariaDB [(none)]> create database if not exists idtest;\nQuery OK, 0 rows affected, 1 warning (0.000 sec)\n\n\nB. 创建一个itheima数据库，并且指定字符集\n\nMariaDB [(none)]> create database itheima default charset utf8mb4;\nQuery OK, 1 row affected (0.000 sec)\n\n\n4). 删除数据库\n\ndrop database [if exists] 数据库名;\n\n\n如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\n\nMariaDB [(none)]> drop database test;\nERROR 1008 (HY000): Can't drop database 'test'; database doesn't exist\n\nMariaDB [(none)]> drop database if exists test;\nQuery OK, 0 rows affected, 1 warning (0.000 sec)\n\n\n5). 切换数据库\n\nuse 数据库名；\n\n\n我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。\n\n比如，切换到itcast数据，执行如下SQL：\n\nMariaDB [(none)]> use idtest;\nDatabase changed\nMariaDB [idtest]> \n\n\n\n# 表操作\n\n表操作-查询创建\n\n1). 查询当前数据库所有表\n\n比如,我们可以切换到mysql这个系统数据库,并查看系统数据库中的所有表结构。\n\nMariaDB [(none)]> use mysql;\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A\n\nDatabase changed\nMariaDB [mysql]> show tables;\n+---------------------------+\n| Tables_in_mysql           |\n+---------------------------+\n| column_stats              |\n| columns_priv              |\n| db                        |\n| event                     |\n| func                      |\n| general_log               |\n| gtid_slave_pos            |\n| help_category             |\n| plugin                    |\n| proc                      |\n| procs_priv                |\n| transaction_registry      |\n| user                      |\n+---------------------------+\n31 rows in set (0.000 sec)\n\n\n2). 查看指定表结构\n\n通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息。\n\nshow create table tb_user;\n\n\n3). 查询指定表的建表语句\n\ncreate table 表名(\n) [comment 表注释]\n\n\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\n\n4). 创建表结构\n\n> 注意: [...] 内为可选参数， 后一个字段后面没有逗号\n\ncreate table 表名(\n    字段1 字段1类型 [comment 字段1注释],\n    字段2 字段2类型 [comment 字段2注释],\n    字段3 字段3类型 [comment 字段3注释],\n    字段4 字段4类型 [comment 字段4注释]\n)[comment 表注释];\n\n\n比如，我们创建一张表 tb_user ，对应的结构如下，那么建表语句为：\n\n\n\nMariaDB [(none)]> use  test;\nDatabase changed\nMariaDB [test]> create table tb_user(\n    -> id int comment '编号',\n    -> name varchar(50) comment '姓名',\n    -> age int comment '年龄',\n    -> gender varchar(1) comment '性别'\n    -> ) comment '用户表';\nQuery OK, 0 rows affected (0.004 sec)\n\n\n2.3.2.2 表操作-数据类型\n\n在上述的建表语句中，我们在指定字段的数据类型时，用到了int ，varchar，那么在MySQL中除了以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下MySQL的数据类型。\n\nMySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。\n\n1). 数值类型\n\n类型            大小       有符号(SIGNED)范围                                           无符号(UNSIGNED)范围                                            描述\nTINYINT       1byte    (-128，127)                                              (0，255)                                                    小整数值\nSMALLINT      2bytes   (-32768，32767)                                          (0，65535)                                                  大整数值\nMEDIUMINT     3bytes   (-8388608，8388607)                                      (0，16777215)                                               大整数值\nINT/INTEGER   4bytes   (-2147483648， 2147483647)                               (0，4294967295)                                             大整数值\nBIGINT        8bytes   (-2^63，2^63-1)                                          (0，2^64-1)                                                 极大整数值\nFLOAT         4bytes   (-3.402823466 E+38， 3.402823466351 E+38)                0 和 (1.175494351 E- 38，3.402823466 E+38)                   单精度浮点数值\nDOUBLE        8bytes   (-1.7976931348623157 E+308， 1.7976931348623157 E+308)   0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308)   双精度浮点数值\nDECIMAL                依赖于M(精度)和D(标度) 的值                                       依赖于M(精度)和D(标度)的值                                           小数 值(精 确定点数)\n\n2). 字符串类型\n\n类型           大小                      描述\nCHAR         0-255 bytes             定长字符串(需要指定长度)\nVARCHAR      0-65535 bytes           变长字符串(需要指定长度)\nTINYBLOB     0-255 bytes             不超过255个字符的二进制数据\nTINYTEXT     0-255 bytes             短文本字符串\nBLOB         0-65 535 bytes          二进制形式的长文本数据\nTEXT         0-65 535 bytes          长文本数据\nMEDIUMBLOB   0-16 777 215 bytes      二进制形式的中等长度文本数据\nMEDIUMTEXT   0-16 777 215 bytes      中等长度文本数据\nLONGBLOB     0-4 294 967 295 bytes   二进制形式的极大文本数据\nLONGTEXT     0-4 294 967 295 bytes   极大文本数据\n\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为 大占用长度 。相对来说，char的性能会更高些。\n\n3). 日期时间类型\n\n类型          大小   范围                                          格式                    描述\nDATE        3    1000-01-01 至 9999-12-31                     YYYY-MM-DD            日期值\nTIME        3    -838:59:59 至 838:59:59                      HH:MM:SS              时间值或持续时间\nYEAR        1    1901 至 2155                                 YYYY                  年份值\nDATETIME    8    1000-01-01 00:00:00 至 9999-12-31 23:59:59   YYYY-MM-DD HH:MM:SS   混合日期和时间值\nTIMESTAMP   4    1970-01-01 00:00:01 至 2038-01-19 03:14:07   YYYY-MM-DD HH:MM:SS   混合日期和时间值，时间戳\n\n2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：\n\n 1. 编号（纯数字）\n\n 2. 员工工号 (字符串类型，长度不超过10位)\n\n 3. 员工姓名（字符串类型，长度不超过10位）\n\n 4. 性别（男/女，存储一个汉字）\n\n 5. 年龄（正常人年龄，不可能存储负数）\n\n 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符）\n\n 7. 入职时间（取值年月日即可）\n\n对应的建表语句如下:\n\nMariaDB [test]> create table emp(\n    -> id int comment '编号',\n    -> workno varchar(10) comment '工号',\n    -> name varchar(10) comment '姓名',\n    -> gender char(1) comment '性别',\n    -> age tinyint  unsigned comment '年龄',\n    -> idcard char(18) comment '身份证',\n    -> entrydate date comment '入职时间'\n    -> ) comment '员工表';\nQuery OK, 0 rows affected (0.004 sec)\n\n\nSQL语句编写完毕之后，就可以在MySQL的命令行中执行SQL，然后也可以通过 desc 指令查询表结构信息：\n\nMariaDB [test]> desc emp;\n+-----------+---------------------+------+-----+---------+-------+\n| Field     | Type                | Null | Key | Default | Extra |\n+-----------+---------------------+------+-----+---------+-------+\n| id        | int(11)             | YES  |     | NULL    |       |\n| workno    | varchar(10)         | YES  |     | NULL    |       |\n| name      | varchar(10)         | YES  |     | NULL    |       |\n| gender    | char(1)             | YES  |     | NULL    |       |\n| age       | tinyint(3) unsigned | YES  |     | NULL    |       |\n| idcard    | char(18)            | YES  |     | NULL    |       |\n| entrydate | date                | YES  |     | NULL    |       |\n+-----------+---------------------+------+-----+---------+-------+\n7 rows in set (0.001 sec)\n\n\n表结构创建好了，里面的name字段是varchar类型， 大长度为10，也就意味着如果超过10将会报错，如果我们想修改这个字段的类型 或 修改字段的长度该如何操作呢？接下来再来讲解DDL语句中，如何操作表字段。\n\n2.3.2.4 表操作-修改\n\n1). 添加字段\n\nALTER TABLE 表名 ADD 字段名 类型（长度） [comment 注释] [约束];\n\n\n案例:\n\n为emp表增加一个新的字段\"昵称\"为nickname，类型为varchar(20)\n\nMariaDB [test]> alter table emp add nickname varchar(20) comment '昵称';\nQuery OK, 0 rows affected (0.001 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nMariaDB [test]> desc emp;\n+-----------+---------------------+------+-----+---------+-------+\n| Field     | Type                | Null | Key | Default | Extra |\n+-----------+---------------------+------+-----+---------+-------+\n| id        | int(11)             | YES  |     | NULL    |       |\n| workno    | varchar(10)         | YES  |     | NULL    |       |\n| name      | varchar(10)         | YES  |     | NULL    |       |\n| gender    | char(1)             | YES  |     | NULL    |       |\n| age       | tinyint(3) unsigned | YES  |     | NULL    |       |\n| idcard    | char(18)            | YES  |     | NULL    |       |\n| entrydate | date                | YES  |     | NULL    |       |\n| nickname  | varchar(20)         | YES  |     | NULL    |       |\n+-----------+---------------------+------+-----+---------+-------+\n8 rows in set (0.001 sec)\n\n\n2). 修改数据类型\n\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n\n\n3). 修改字段名和字段类型\n\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度） [comment 注释] [约束];\n\n\n案例:\n\n将emp表的nickname字段修改为username，类型为varchar(30)\n\nMariaDB [test]> alter table emp change nickname username varchar(30) comment '昵称';\nQuery OK, 0 rows affected (0.002 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\n4). 删除字段\n\nALTER TABLE 表名 DROP 字段名;\n\n\n案例:\n\n将emp表的字段username删除\n\nMariaDB [test]> alter table emp drop username;\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\n5). 修改表名\n\nALTER TABLE emp RENAME TO employee;\n\n\n例:\n\n将emp表的表名修改为 employee\n\nMariaDB [test]> alter table emp rename to employee;\nQuery OK, 0 rows affected (0.004 sec)\n\nMariaDB [test]> show tables;\n+----------------+\n| Tables_in_test |\n+----------------+\n| employee       |\n| tb_user        |\n+----------------+\n2 rows in set (0.000 sec)\n\n\n2.3.2.5 表操作-删除\n\n1). 删除表\n\nDROP TABLE [IF EXISTS] 表名;\n\n\n可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\n\n如果tb_user表存在，则删除tb_user表\n\nMariaDB [test]> drop table if exists tb_user;\nQuery OK, 0 rows affected (0.002 sec)\n\n// 如下是属于提示报错\nMariaDB [test]> drop table if exists tb_user;\nQuery OK, 0 rows affected, 1 warning (0.000 sec)\n\n\n2). 删除指定表, 并重新创建表\n\nTRUNCATE TABLE 表名;\n\n\n> 注意: 在删除表的时候，表中的全部数据也都会被删除。\n\nMariaDB [test]> show tables;\n+----------------+\n| Tables_in_test |\n+----------------+\n| employee       |\n+----------------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> truncate table employee;\nQuery OK, 0 rows affected (0.006 sec)\n\n\n\n# 图形化界面工具\n\n上述，我们已经讲解了通过DDL语句，如何操作数据库、操作表、操作表中的字段，而通过DDL语句执行在命令进行操作，主要存在以下两点问题：\n\n1).会影响开发效率 ;\n\n2). 使用起来，并不直观，并不方便 ；\n\n所以呢，我们在日常的开发中，会借助于MySQL的图形化界面，来简化开发，提高开发效率。而目前 mysql主流的图形化界面工具，有以下几种：\n\n\n\n而本次课程中，选择 后一种DataGrip，这种图形化界面工具，功能更加强大，界面提示更加友好，是我们使用MySQL的不二之选。接下来，我们来介绍一下DataGrip该如何安装、使用。\n\n# 安装\n\n1). 找到资料中准备好的安装包，双击开始安装\n\n\n\n2). 点击next，一步一步的完成安装\n\n\n\n选择DataGrip的安装目录，然后选择下一步\n\n\n\n\n\n下一步，执行安装\n\n\n\n\n\n# 使用\n\n1). 添加数据源\n\n参考图示, 一步步操作即可\n\n\n\n配置以及驱动jar包下载完毕之后，就可以点击 \"Test Connection\" 就可以测试，是否可以连接\n\nMySQL，如果出现 \"Successed\"，就表名连接成功了 。\n\n\n\n2). 展示所有数据库\n\n连接上了MySQL服务之后，并未展示出所有的数据库，此时，我们需要设置，展示所有的数据库，具体操作如下：\n\n\n\n3). 创建数据库\n\n\n\n> 注意:\n> \n> 以下两种方式都可以创建数据库：\n\nA. create database db01;\n\nB. create schema db01;\n\n4). 创建表\n\n在指定的数据库上面右键，选择new --\x3e Table\n\n\n\n\n\n5). 修改表结构\n\n在需要修改的表上，右键选择 \"Modify Table...\"\n\n\n\n\n\n如果想增加字段，直接点击+号，录入字段信息，然后点击Execute即可。\n\n如果想删除字段，直接点击-号，就可以删除字段，然后点击Execute即可。如果想修改字段，双击对应的字段，修改字段信息，然后点击Execute即可。如果要修改表名，或表的注释，直接在输入框修改，然后点击Execute即可。\n\n6). 在DataGrip中执行SQL语句\n\n在指定的数据库上，右键，选择 New --\x3e Query Console\n\n\n\n然后就可以在打开的Query Console控制台，并在控制台中编写SQL，执行SQL。\n\n\n\n\n# DML\n\nDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\n\n> 添加数据（INSERT）修改数据（UPDATE）删除数据（DELETE）\n\n\n# 添加数据\n\n1). 给指定字段添加数据\n\nINSERT INTO 表名(字段名1,字段名2，...) VALUES(值1，值2，...);\n\n\n案例: 给employee表所有的字段添加数据 ；\n\nMariaDB [test]> insert into emp(id,workno,name,gender,age,idcard,entrydate) values(1,'1','itest','男','10','123456789012345678','2022-05-20');\n\n\n插入数据完成之后，我们有两种方式，查询数据库的数据：\n\nA. 方式一\n\n在左侧的表名上双击，就可以查看这张表的数据。\n\n\n\nB. 方式二\n\n可以直接一条查询数据的SQL语句, 语句如下:\n\nselect * from emp;\n\n\n查询如下:\n\nMariaDB [test]> select * from employee;\n+------+--------+-------+--------+------+--------------------+------------+\n| id   | workno | name  | gender | age  | idcard             | entrydate  |\n+------+--------+-------+--------+------+--------------------+------------+\n|    1 | 1      | itest | 男     |   10 | 123456789012345678 | 2022-05-20 |\n+------+--------+-------+--------+------+--------------------+------------+\n1 row in set (0.000 sec)\n\n\n2). 给全部字段添加数据\n\nINSERT INTO 表名 VALUES(值1，值2，...);\n\n\n案例：插入数据到employee表，具体的SQL如下：\n\nMariaDB [test]> insert into employee values(2,'2','张无忌','男',18,'123456789012345678','2005-08-10');\nQuery OK, 1 row affected (0.001 sec)\n\nMariaDB [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n2 rows in set (0.000 sec)\n\n\n3). 批量添加数据\n\nINSERT INTO 表名（字段名1，字段名2，...） VALUES（值1，值2，...),(值1，值2，...),(值1，值2，...);\n\n\nINSERT INTO 表名 VALUES（值1，值2，...),(值1，值2，...),(值1，值2，...);\n\n\n案例：批量插入数据到employee表，具体的SQL如下：\n\n> 注意事项:\n\n * 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n\n * 字符串和日期型数据应该包含在引号中。\n\n * 插入的数据大小，应该在字段的规定范围内。\n\nMariaDB [test]> insert into employee values(3,'3','周一','男',18,'123456789012345678','2005-08-11'),(4,'4','周停','女',20,'123456789012345678','2005-08-11');\nQuery OK, 2 rows affected (0.001 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\nMariaDB [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n|    3 | 3      | 周一      | 男     |   18 | 123456789012345678 | 2005-08-11 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2005-08-11 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\n\n\n# 修改数据\n\n修改数据的具体语法为:\n\nUPDATE 表名 SET 字段名1=值1，字段名2=值2，... [WHERE 条件]; \n\n\n案例:\n\nA. 修改id为1的数据，将name修改为itheima\n\nB. 修改id为1的数据, 将name修改为小昭, gender修改为 女\n\nC. 将所有的员工入职日期修改为 2008-01-01\n\nMariaDB [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n|    3 | 3      | 周一      | 男     |   18 | 123456789012345678 | 2005-08-11 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2005-08-11 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\nMariaDB [test]> update employee set name = 'itheima' where id = 1;\nQuery OK, 1 row affected (0.001 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nMariaDB [test]> update employee set name = '小爱',gender = '女' where id = 3;\nQuery OK, 1 row affected (0.001 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nMariaDB [test]> update employee set entrydate = '2022-06-10';\nQuery OK, 4 rows affected (0.001 sec)\nRows matched: 4  Changed: 4  Warnings: 0\n\nMariaDB [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itheima   | 男     |   10 | 123456789012345678 | 2022-06-10 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2022-06-10 |\n|    3 | 3      | 小爱      | 女     |   18 | 123456789012345678 | 2022-06-10 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2022-06-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\n\n> 注意事项:\n> \n> 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n\n\n# 删除数据\n\n删除数据的具体语法为：\n\nDELETE FROM 表名 [WHERE 条件];\n\n\n案例:\n\nA. 删除gender为女的员工\n\nB. 删除所有员工\n\nMariaDB [test]> delete from employee where gender = '女';\nQuery OK, 2 rows affected (0.001 sec)\n\nMariaDB [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itheima   | 男     |   10 | 123456789012345678 | 2022-06-10 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2022-06-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n2 rows in set (0.000 sec)\n\nMariaDB [test]> delete from employee;\nQuery OK, 2 rows affected (0.023 sec)\n\n\n> 注意事项：\n> \n> • DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n> \n> • DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即\n> \n> 可)。\n> \n> • 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击\n> \n> Execute即可。\n\n\n# DQL\n\nDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。\n\n查询关键字: SELECT\n\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\n\n\n\n环境准备：\n\ndrop table if exists employee;\n\ncreate table emp(\n\tid int comment '编号',\n\tworkno varchar(10) comment '工号',\n\tname varchar(10) comment '姓名',\n\tgender char(1) comment '性别',\n\tage tinyint unsigned comment '年龄',\n\tidcard char(18) comment '身份证号',\n\tworkaddress varchar(50) comment '工作地址',\n\tentrydate date comment '入职时间'\n)comment '员工表';\n\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (1, '00001', '柳岩666', '女', 20, '123456789012345678', '北京', '2000-01-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (2, '00002', '张无忌', '男', 18, '123456789012345670', '北京', '2005-09-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (3, '00003', '韦一笑', '男', 38, '123456789712345670', '上海', '2005-08-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (4, '00004', '赵敏', '女', 18, '123456757123845670', '北京', '2009-12-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (5, '00005', '小昭', '女', 16, '123456769012345678', '上海', '2007-07-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (6, '00006', '杨逍', '男', 28, '12345678931234567X', '北京', '2006-01-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (7, '00007', '范瑶', '男', 40, '123456789212345670', '北京', '2005-05-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (8, '00008', '黛绮丝', '女', 38, '123456157123645670', '天津', '2015-05-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (9, '00009', '范凉凉', '女', 45, '123156789012345678', '北京', '2010-04-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (10, '00010', '陈友谅', '男', 53, '123456789012345670', '上海', '2011-01-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (11, '00011', '张士诚', '男', 55, '123567897123465670', '江苏', '2015-05-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (12, '00012', '常遇春', '男', 32, '123446757152345670', '北京', '2004-02-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (13, '00013', '张三丰', '男', 88, '123656789012345678', '江苏', '2020-11-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (14, '00014', '灭绝', '女', 65, '123456719012345670', '西安', '2019-05-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (15, '00015', '胡青牛', '男', 70, '12345674971234567X', '西安', '2018-04-01');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (16, '00016', '周芷若', '女', 18, null, '北京', '2012-06-01');\n\n\n\n# 基本语法\n\nDQL 查询语句，语法结构如下：\n\nSELECT \n\t字段列表\nFROM\n\t表名列表\nWHERE\n\t条件列表\nGROUP BY\n\t分组列表\nHAVING\n\t分组后条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n\n\n我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：\n\n * 基本查询（不带任何条件）条件查询（WHERE）\n * 聚合函数（count、max、min、avg、sum）\n * 分组查询（group by）\n * 排序查询（order by）\n * 分页查询（limit）\n\n\n# 基础查询\n\n在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：\n\n1). 查询多个字段\n\nSElECT 字段1，字段2，字段3,... FROM 表名;\n\nSELECT * FROM 表名;\n\n\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\n\n2). 字段设置别名\n\nSELECT 字段1 [AS 别名1],字段2 [AS 别名2]，... FROM 表名;\nSELECT 字段1 [别名1],字段2 [别名2]，... FROM 表名;\n\n\n3). 去除重复记录\n\nSELECT DISTINCT 字段列表 FROM 表名;\n\n\n案例：\n\nA. 查询指定字段 name, workno, age并返回\n\nMariaDB [test]> select name,workno,age from emp;\n+-----------+--------+------+\n| name      | workno | age  |\n+-----------+--------+------+\n| 柳岩666   | 00001  |   20 |\n| 张无忌    | 00002  |   18 |\n| 韦一笑    | 00003  |   38 |\n| 赵敏      | 00004  |   18 |\n| 小昭      | 00005  |   16 |\n| 杨逍      | 00006  |   28 |\n| 范瑶      | 00007  |   40 |\n| 黛绮丝    | 00008  |   38 |\n| 范凉凉    | 00009  |   45 |\n| 陈友谅    | 00010  |   53 |\n| 张士诚    | 00011  |   55 |\n| 常遇春    | 00012  |   32 |\n| 张三丰    | 00013  |   88 |\n| 灭绝      | 00014  |   65 |\n| 胡青牛    | 00015  |   70 |\n| 周芷若    | 00016  |   18 |\n+-----------+--------+------+\n16 rows in set (0.000 sec)\n\n\nB. 查询返回所有字段\n\nMariaDB [test]> select * from emp;\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n|    2 | 00002  | 张无忌    | 男     |   18 | 123456789012345670 | 北京        | 2005-09-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    4 | 00004  | 赵敏      | 女     |   18 | 123456757123845670 | 北京        | 2009-12-01 |\n|    5 | 00005  | 小昭      | 女     |   16 | 123456769012345678 | 上海        | 2007-07-01 |\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567X | 北京        | 2006-01-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n|    8 | 00008  | 黛绮丝    | 女     |   38 | 123456157123645670 | 天津        | 2015-05-01 |\n|    9 | 00009  | 范凉凉    | 女     |   45 | 123156789012345678 | 北京        | 2010-04-01 |\n|   10 | 00010  | 陈友谅    | 男     |   53 | 123456789012345670 | 上海        | 2011-01-01 |\n|   11 | 00011  | 张士诚    | 男     |   55 | 123567897123465670 | 江苏        | 2015-05-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|   13 | 00013  | 张三丰    | 男     |   88 | 123656789012345678 | 江苏        | 2020-11-01 |\n|   14 | 00014  | 灭绝      | 女     |   65 | 123456719012345670 | 西安        | 2019-05-01 |\n|   15 | 00015  | 胡青牛    | 男     |   70 | 12345674971234567X | 西安        | 2018-04-01 |\n|   16 | 00016  | 周芷若    | 女     |   18 | NULL               | 北京        | 2012-06-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n16 rows in set (0.000 sec)\n\n\nC. 查询所有员工的工作地址,起别名\n\nMariaDB [test]> select workaddress as '工作地址' from emp;\n+--------------+\n| 工作地址     |\n+--------------+\n| 北京         |\n| 北京         |\n| 上海         |\n| 北京         |\n| 上海         |\n| 北京         |\n| 北京         |\n| 天津         |\n| 北京         |\n| 上海         |\n| 江苏         |\n| 北京         |\n| 江苏         |\n| 西安         |\n| 西安         |\n| 北京         |\n+--------------+\n16 rows in set (0.000 sec)\n\nMariaDB [test]> select workaddress '工作地址' from emp;\n\n\nD. 查询公司员工的上班地址有哪些(不要重复)\n\nMariaDB [test]> select distinct workaddress '工作地址' from emp;\n+--------------+\n| 工作地址     |\n+--------------+\n| 北京         |\n| 上海         |\n| 天津         |\n| 江苏         |\n| 西安         |\n+--------------+\n5 rows in set (0.000 sec)\n\n\n\n# 条件查询\n\n1). 语法\n\nSELECT 字段列表 FROM 表名 WHERE 条件列表;\n\n\n2). 条件\n\n常用的比较运算符如下:\n\n比较运算符                 功能\n>                     大于\n>=                    大于等于\n<                     小于\n<=                    小于等于\n=                     等于\n<> 或 !=               不等于\nBETWEEN ... AND ...   在某个范围之内(含 小、 大值)\nIN(...)               在in之后的列表中的值，多选一\nLIKE 占位符              模糊匹配(_匹配单个字符, %匹配任意个字符)\nIS NULL               是NULL\n\n常用的逻辑运算符如下:\n\n逻辑运算符      功能\nAND 或 &&   并且 (多个条件同时成立)\nOR 或 ||    或者 (多个条件任意一个成立)\nNOT 或 !    非 , 不是\n\n案例:\n\nA. 查询年龄等于 88 的员工\n\nMariaDB [test]> select * from emp where age = 88;\n\n\nB. 查询没有身份证号的员工信息\n\nMariaDB [test]> select * from emp where idcard is null;\n\n\nC. 查询有身份证号的员工信息\n\nMariaDB [test]> select * from emp where idcard is not null;\n\n\nD. 查询年龄不等于 88 的员工信息\n\nMariaDB [test]> select * from emp where age != 88;\n\n\nE. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息\n\nMariaDB [test]> select * from emp where age between 15 and 20;\n\n\nF. 查询性别为 女 且年龄小于 25岁的员工信息\n\nMariaDB [test]> select * from emp where gender = '女' and age <25 ;\n\n\nG. 查询年龄等于18 或 20 或 40 的员工信息\n\nMariaDB [test]> select * from emp where age = 18 || age = 20 || age = 40;\nMariaDB [test]> select * from emp where age in(20,40,80);\n\n\nH. 查询姓名为两个字的员工信息 _ %\n\nMariaDB [test]> select * from emp where name like '__';\n\n\nI. 查询身份证号 后一位是X的员工信息\n\nMariaDB [test]> select * from emp where idcard like '%X';\n\n\n\n# 聚合函数\n\n1). 介绍\n\n将一列数据作为一个整体，进行纵向计算 。\n\n2). 常见的聚合函数\n\n函数      功能\ncount   统计数量\nmax     大值\nmin     小值\navg     平均值\nsum     求和\n\n3). 语法\n\nSELECT 聚合函数（字段列表）FROM 表名;\n\n\n> 注意 : NULL值是不参与所有聚合函数运算的。\n\n案例：\n\nA. 统计该企业员工数量\n\nMariaDB [test]> select count(*) from emp;\n+----------+\n| count(*) |\n+----------+\n|       16 |\n+----------+\n1 row in set (0.000 sec)\n\nMariaDB [test]> select count(idcard) from emp;\n+---------------+\n| count(idcard) |\n+---------------+\n|            15 |\n+---------------+\n1 row in set (0.000 sec)\n\n\n对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计查询，比如：\n\nselect count(1) from emp;\n\n\n> 对于count(*) 、count(字段)、 count(1) 的具体原理，我们在进阶篇中SQL优化部分会详细讲解，此处大家只需要知道如何使用即可。\n\nB. 统计该企业员工的平均年龄\n\n> 统计该企业员工的 大年龄\n\nMariaDB [test]> select  avg(age) from emp;\n+----------+\n| avg(age) |\n+----------+\n|  40.1250 |\n+----------+\n1 row in set (0.000 sec)\n\n\nD. 统计该企业员工的 小年龄\n\nMariaDB [test]> select  min(age) from emp;\n+----------+\n| max(age) |\n+----------+\n|       88 |\n+----------+\n1 row in set (0.000 sec)\n\n\nE. 统计西安地区员工的年龄之和\n\nMariaDB [test]> select sum(age) from emp where workaddress = '西安';\n+----------+\n| sum(age) |\n+----------+\n|      135 |\n+----------+\n1 row in set (0.000 sec)\n\n\n\n# 分组查询\n\n1). 语法\n\nSELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n\n\n2). where与having区别\n\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n注意事项:\n\n * 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n\n * 执行顺序: where > 聚合函数 > having 。\n\n * 支持多字段分组, 具体语法为 : group by columnA,columnB\n\n案例:\n\nA. 根据性别分组 , 统计男性员工 和 女性员工的数量\n\nMariaDB [test]> select gender,count(*) from emp group by gender;\n+--------+----------+\n| gender | count(*) |\n+--------+----------+\n| 女     |        7 |\n| 男     |        9 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\nB. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄\n\nMariaDB [test]> select gender,avg(age) from emp group by gender;\n+--------+----------+\n| gender | avg(age) |\n+--------+----------+\n| 女     |  31.4286 |\n| 男     |  46.8889 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\nC.查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址\n\n// 这里的address_count是分组别名\n\nMariaDB [test]> select workaddress,count(*) address_count from emp where age < 45 group by workaddress having address_count >= 3;\n+-------------+---------------+\n| workaddress | address_count |\n+-------------+---------------+\n| 北京        |             7 |\n+-------------+---------------+\n1 row in set (0.000 sec)\n\n\nD. 统计各个工作地址上班的男性及女性员工的数量\n\nMariaDB [test]> select workaddress,gender,count(*) '数量' from emp group by gender,workaddress;\n+-------------+--------+--------+\n| workaddress | gender | 数量   |\n+-------------+--------+--------+\n| 上海        | 女     |      1 |\n| 北京        | 女     |      4 |\n| 天津        | 女     |      1 |\n| 西安        | 女     |      1 |\n| 上海        | 男     |      2 |\n| 北京        | 男     |      4 |\n| 江苏        | 男     |      2 |\n| 西安        | 男     |      1 |\n+-------------+--------+--------+\n8 rows in set (0.000 sec)\n\n\n\n# 排序查询\n\n排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\n\n\n\n1). 语法\n\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式，字段2 排序方式2\n\n\n2). 排序方式\n\n * ASC : 升序(默认值)\n\n * DESC: 降序\n\n> 注意事项：\n> \n>  * 如果是升序, 可以不指定排序方式ASC ;\n> \n>  * 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n\n案例:\n\nA. 根据年龄对公司的员工进行升序排序\n\nMariaDB [test]> select * from emp order by age asc;\n\n\nB. 根据入职时间, 对员工进行降序排序\n\nMariaDB [test]> select * from emp order by entrydate desc;\n\n\nC. 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序\n\nMariaDB [test]> select * from emp order by age asc,entrydate desc;\n\n\n\n# 分页查询\n\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。\n\n\n\n1). 语法\n\nSELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n\n\n注意事项:\n\n * 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。\n\n * 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n\n * 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。\n\n案例:\n\nA. 查询第1页员工数据, 每页展示10条记录\n\nMariaDB [test]> select * from emp limit 0,10;\n\n\nB. 查询第2页员工数据, 每页展示10条记录 --------\x3e (页码-1)*页展示记录数\n\nMariaDB [test]> select * from emp limit 10,10;\n\n\n\n# 案例\n\n1). 查询年龄为20,21,22,23岁的员工信息。\n\nMariaDB [test]> select * from emp where age in(20,21,22,23);\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n1 row in set (0.000 sec)\n\n\n2). 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。\n\nMariaDB [test]> select * from emp where gender = '男' and (age between 20 and 40) and name like '___';\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n2 rows in set (0.000 sec)\n\n\n3). 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数。\n\nMariaDB [test]> select gender,count(*)  from emp where age < 60 group by gender;\n+--------+----------+\n| gender | count(*) |\n+--------+----------+\n| 女     |        6 |\n| 男     |        7 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\n4). 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。\n\nMariaDB [test]> select name,age from emp where age <= 35 order by age asc,entrydate desc;\n+-----------+------+\n| name      | age  |\n+-----------+------+\n| 小昭      |   16 |\n| 周芷若    |   18 |\n| 赵敏      |   18 |\n| 张无忌    |   18 |\n| 柳岩666   |   20 |\n| 杨逍      |   28 |\n| 常遇春    |   32 |\n+-----------+------+\n7 rows in set (0.000 sec)\n\n\n5). 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。\n\nMariaDB [test]> select * from emp where gender = '男' and (age between 20 and 40) order by age asc,entrydate asc limit 5; \n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567X | 北京        | 2006-01-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n4 rows in set (0.000 sec)\n\n\n\n# 执行顺序\n\n在讲解DQL语句的具体语法之前，我们已经讲解了DQL语句的完整语法，及编写顺序，接下来，我们要来说明的是DQL语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。\n\n\n\n验证：查询年龄大于15的员工姓名、年龄，并根据年龄进行升序排序。\n\nMariaDB [test]> select name,age  from emp where age > 15 order by age asc;\n\n\n在查询时，我们给emp表起一个别名 e，然后在select 及 where中使用该别名。\n\nMariaDB [test]> select e.name,e.age from emp e where e.age > 15 order by age asc;\n\n\n执行上述SQL语句后，我们看到依然可以正常的查询到结果，此时就说明： from 先执行, 然后 where 和 select 执行。那 where 和 select 到底哪个先执行呢?\n\n此时，此时我们可以给select后面的字段起别名，然后在 where 中使用这个别名，然后看看是否可以执行成功。\n\nMariaDB [test]> select e.name ename,e.age eage from emp e where eage > 15 order by age asc;\n\n\n执行上述SQL报错了:\n\n\n\n由此我们可以得出结论: from 先执行，然后执行 where ， 再执行select 。\n\n接下来，我们再执行如下SQL语句，查看执行效果：\n\nMariaDB [test]> select e.name ename,e.age eage from emp e where e.age > 15 order by age asc;\n\n\n结果执行成功。 那么也就验证了: order by 是在select 语句之后执行的。\n\n综上所述，我们可以看到DQL语句的执行顺序为：\n\nfrom ... where ... group by ... having ... select ... order by ... limit ...\n\n\n# DCL\n\nDCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。\n\n\n\n\n# 管理用户\n\n1). 查询用户\n\nUSE mysql;\nSELECT * FROM user;\n\n\n查询的结果如下:\n\n\n\n其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。\n\n2). 创建用户\n\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n\n3). 修改用户密码\n\nALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';\n\n\n4). 删除用户\n\nDROP USER '用户名'@'主机名';\n\n\n注意事项:\n\n * 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n\n * 主机名可以使用 % 通配。\n\n * 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。\n\n案例：\n\nA. 创建用户itcast, 只能够在当前主机localhost访问, 密码123456;\n\nMariaDB [mysql]> create user 'itcast'@'localhost' identified by '123456';\nQuery OK, 0 rows affected (0.000 sec)\n\nMariaDB [mysql]> exit\nBye\n[root@localhost ~]# mysql -uitcast -p123456\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\nYour MariaDB connection id is 23\nServer version: 10.3.23-MariaDB MariaDB Server\n\nCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nMariaDB [(none)]>\n\n\nB. 创建用户heima, 可以在任意主机访问该数据库, 密码123456;\n\nMariaDB [(none)]> create user 'heima'@'%' identified by '123456';\nQuery OK, 0 rows affected (0.000 sec)\n\n\nC. 修改用户heima的访问密码为1234;\n\nMariaDB [(none)]> alter user 'heima'@'%' identified with mysql_native_password by '000000';\nQuery OK, 0 rows affected (0.000 sec)\n\n\nD. 删除 itcast@localhost 用户\n\nMariaDB [(none)]> drop user 'heima'@'%';\nQuery OK, 0 rows affected (0.000 sec)\n\n\n\n# 权限控制\n\nMySQL中定义了很多种权限，但是常用的就以下几种：\n\n权限                    说明\nALL, ALL PRIVILEGES   所有权限\nSELECT                查询数据\nINSERT                插入数据\nUPDATE                修改数据\nDELETE                删除数据\nALTER                 修改表\nDROP                  删除数据库/表/视图\nCREATE                创建数据库/表\n\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考官方文档。\n\n1). 查询权限\n\nSHOW GRANTS FOR '用户名'@'主机名';\n\n\n2). 授予权限\n\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n\n\n3). 撤销权限\n\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n\n\n注意事项：\n\n * 多个权限之间，使用逗号分隔\n\n * 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\n\n案例:\n\nA. 查询 'heima'@'%' 用户的权限\n\nMariaDB [(none)]> show grants for 'heima'@'%';\n+------------------------------------------------------------------------------------------------------+\n| Grants for heima@%                                                                                   |\n+------------------------------------------------------------------------------------------------------+\n| GRANT USAGE ON *.* TO `heima`@`%` IDENTIFIED BY PASSWORD '*032197AE5731D4664921A6CCAC7CFCE6A0698693' |\n+------------------------------------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n\n\nB. 授予 'heima'@'%' 用户itcast数据库所有表的所有操作权限\n\nMariaDB [(none)]> grant all on itcast.* to 'heima'@'%';\nQuery OK, 0 rows affected (0.000 sec)\n\nMariaDB [(none)]> show grants for 'heima'@'%';\n+------------------------------------------------------------------------------------------------------+\n| Grants for heima@%                                                                                   |\n+------------------------------------------------------------------------------------------------------+\n| GRANT USAGE ON *.* TO `heima`@`%` IDENTIFIED BY PASSWORD '*032197AE5731D4664921A6CCAC7CFCE6A0698693' |\n| GRANT ALL PRIVILEGES ON `itcast`.* TO `heima`@`%`                                                    |\n+------------------------------------------------------------------------------------------------------+\n2 rows in set (0.000 sec)\n\n\nC. 撤销 'heima'@'%' 用户的itcast数据库的所有权限\n\nMariaDB [(none)]> revoke all on itcast.* from 'heima'@'%';\nQuery OK, 0 rows affected (0.000 sec)remo\n",normalizedContent:"# mysql的sql详解\n\n全称 structured query language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。\n\n\n# sql通用语法\n\n在学习具体的sql语句之前，先来了解一下sql语言的同于语法。\n\n1). sql语句可以单行或多行书写，以分号结尾。\n\n2). sql语句可以使用空格/缩进来增强语句的可读性。\n\n3). mysql数据库的sql语句不区分大小写，关键字建议使用大写。\n\n4). 注释：\n\n> 单行注释：-- 注释内容 或 # 注释内容\n> \n> 多行注释：/* 注释内容 */\n\n\n# sql分类\n\nsql语句，根据其功能，主要分为四类：ddl、dml、dql、dcl。\n\n分类    全称                           说明\nddl   data definition language     数据定义语言，用来定义数据库对象(数据库，表，字段)\ndml   data manipulation language   数据操作语言，用来对数据库表中的数据进行增删改\ndql   data query language          数据查询语言，用来查询数据库中表的记录\ndcl   data control language        数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n# ddl\n\ndata definition language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。\n\n\n# 数据库操作\n\n1). 查询所有数据库\n\nshow databases;\n\n\n\n\n2). 查询当前数据库\n\nselect database();\n\n\n3). 创建数据库\n\ncreate database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];\n\n\n案例：\n\na. 创建一个itcast数据库, 使用数据库默认的字符集。\n\nmariadb [(none)]> create database idtest;\nquery ok, 1 row affected (0.000 sec)\n\nmariadb [(none)]> show databases;\n+--------------------+\n| database           |\n+--------------------+\n| idtest             |\n| information_schema |\n| mysql              |\n| performance_schema |\n| test               |\n+--------------------+\n5 rows in set (0.000 sec)\n\n\n在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\n\n可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。\n\nariadb [(none)]> create database if not exists idtest;\nquery ok, 0 rows affected, 1 warning (0.000 sec)\n\n\nb. 创建一个itheima数据库，并且指定字符集\n\nmariadb [(none)]> create database itheima default charset utf8mb4;\nquery ok, 1 row affected (0.000 sec)\n\n\n4). 删除数据库\n\ndrop database [if exists] 数据库名;\n\n\n如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\n\nmariadb [(none)]> drop database test;\nerror 1008 (hy000): can't drop database 'test'; database doesn't exist\n\nmariadb [(none)]> drop database if exists test;\nquery ok, 0 rows affected, 1 warning (0.000 sec)\n\n\n5). 切换数据库\n\nuse 数据库名；\n\n\n我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。\n\n比如，切换到itcast数据，执行如下sql：\n\nmariadb [(none)]> use idtest;\ndatabase changed\nmariadb [idtest]> \n\n\n\n# 表操作\n\n表操作-查询创建\n\n1). 查询当前数据库所有表\n\n比如,我们可以切换到mysql这个系统数据库,并查看系统数据库中的所有表结构。\n\nmariadb [(none)]> use mysql;\nreading table information for completion of table and column names\nyou can turn off this feature to get a quicker startup with -a\n\ndatabase changed\nmariadb [mysql]> show tables;\n+---------------------------+\n| tables_in_mysql           |\n+---------------------------+\n| column_stats              |\n| columns_priv              |\n| db                        |\n| event                     |\n| func                      |\n| general_log               |\n| gtid_slave_pos            |\n| help_category             |\n| plugin                    |\n| proc                      |\n| procs_priv                |\n| transaction_registry      |\n| user                      |\n+---------------------------+\n31 rows in set (0.000 sec)\n\n\n2). 查看指定表结构\n\n通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为null，是否存在默认值等信息。\n\nshow create table tb_user;\n\n\n3). 查询指定表的建表语句\n\ncreate table 表名(\n) [comment 表注释]\n\n\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\n\n4). 创建表结构\n\n> 注意: [...] 内为可选参数， 后一个字段后面没有逗号\n\ncreate table 表名(\n    字段1 字段1类型 [comment 字段1注释],\n    字段2 字段2类型 [comment 字段2注释],\n    字段3 字段3类型 [comment 字段3注释],\n    字段4 字段4类型 [comment 字段4注释]\n)[comment 表注释];\n\n\n比如，我们创建一张表 tb_user ，对应的结构如下，那么建表语句为：\n\n\n\nmariadb [(none)]> use  test;\ndatabase changed\nmariadb [test]> create table tb_user(\n    -> id int comment '编号',\n    -> name varchar(50) comment '姓名',\n    -> age int comment '年龄',\n    -> gender varchar(1) comment '性别'\n    -> ) comment '用户表';\nquery ok, 0 rows affected (0.004 sec)\n\n\n2.3.2.2 表操作-数据类型\n\n在上述的建表语句中，我们在指定字段的数据类型时，用到了int ，varchar，那么在mysql中除了以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下mysql的数据类型。\n\nmysql中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。\n\n1). 数值类型\n\n类型            大小       有符号(signed)范围                                           无符号(unsigned)范围                                            描述\ntinyint       1byte    (-128，127)                                              (0，255)                                                    小整数值\nsmallint      2bytes   (-32768，32767)                                          (0，65535)                                                  大整数值\nmediumint     3bytes   (-8388608，8388607)                                      (0，16777215)                                               大整数值\nint/integer   4bytes   (-2147483648， 2147483647)                               (0，4294967295)                                             大整数值\nbigint        8bytes   (-2^63，2^63-1)                                          (0，2^64-1)                                                 极大整数值\nfloat         4bytes   (-3.402823466 e+38， 3.402823466351 e+38)                0 和 (1.175494351 e- 38，3.402823466 e+38)                   单精度浮点数值\ndouble        8bytes   (-1.7976931348623157 e+308， 1.7976931348623157 e+308)   0 和 (2.2250738585072014 e-308， 1.7976931348623157 e+308)   双精度浮点数值\ndecimal                依赖于m(精度)和d(标度) 的值                                       依赖于m(精度)和d(标度)的值                                           小数 值(精 确定点数)\n\n2). 字符串类型\n\n类型           大小                      描述\nchar         0-255 bytes             定长字符串(需要指定长度)\nvarchar      0-65535 bytes           变长字符串(需要指定长度)\ntinyblob     0-255 bytes             不超过255个字符的二进制数据\ntinytext     0-255 bytes             短文本字符串\nblob         0-65 535 bytes          二进制形式的长文本数据\ntext         0-65 535 bytes          长文本数据\nmediumblob   0-16 777 215 bytes      二进制形式的中等长度文本数据\nmediumtext   0-16 777 215 bytes      中等长度文本数据\nlongblob     0-4 294 967 295 bytes   二进制形式的极大文本数据\nlongtext     0-4 294 967 295 bytes   极大文本数据\n\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为 大占用长度 。相对来说，char的性能会更高些。\n\n3). 日期时间类型\n\n类型          大小   范围                                          格式                    描述\ndate        3    1000-01-01 至 9999-12-31                     yyyy-mm-dd            日期值\ntime        3    -838:59:59 至 838:59:59                      hh:mm:ss              时间值或持续时间\nyear        1    1901 至 2155                                 yyyy                  年份值\ndatetime    8    1000-01-01 00:00:00 至 9999-12-31 23:59:59   yyyy-mm-dd hh:mm:ss   混合日期和时间值\ntimestamp   4    1970-01-01 00:00:01 至 2038-01-19 03:14:07   yyyy-mm-dd hh:mm:ss   混合日期和时间值，时间戳\n\n2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：\n\n 1. 编号（纯数字）\n\n 2. 员工工号 (字符串类型，长度不超过10位)\n\n 3. 员工姓名（字符串类型，长度不超过10位）\n\n 4. 性别（男/女，存储一个汉字）\n\n 5. 年龄（正常人年龄，不可能存储负数）\n\n 6. 身份证号（二代身份证号均为18位，身份证中有x这样的字符）\n\n 7. 入职时间（取值年月日即可）\n\n对应的建表语句如下:\n\nmariadb [test]> create table emp(\n    -> id int comment '编号',\n    -> workno varchar(10) comment '工号',\n    -> name varchar(10) comment '姓名',\n    -> gender char(1) comment '性别',\n    -> age tinyint  unsigned comment '年龄',\n    -> idcard char(18) comment '身份证',\n    -> entrydate date comment '入职时间'\n    -> ) comment '员工表';\nquery ok, 0 rows affected (0.004 sec)\n\n\nsql语句编写完毕之后，就可以在mysql的命令行中执行sql，然后也可以通过 desc 指令查询表结构信息：\n\nmariadb [test]> desc emp;\n+-----------+---------------------+------+-----+---------+-------+\n| field     | type                | null | key | default | extra |\n+-----------+---------------------+------+-----+---------+-------+\n| id        | int(11)             | yes  |     | null    |       |\n| workno    | varchar(10)         | yes  |     | null    |       |\n| name      | varchar(10)         | yes  |     | null    |       |\n| gender    | char(1)             | yes  |     | null    |       |\n| age       | tinyint(3) unsigned | yes  |     | null    |       |\n| idcard    | char(18)            | yes  |     | null    |       |\n| entrydate | date                | yes  |     | null    |       |\n+-----------+---------------------+------+-----+---------+-------+\n7 rows in set (0.001 sec)\n\n\n表结构创建好了，里面的name字段是varchar类型， 大长度为10，也就意味着如果超过10将会报错，如果我们想修改这个字段的类型 或 修改字段的长度该如何操作呢？接下来再来讲解ddl语句中，如何操作表字段。\n\n2.3.2.4 表操作-修改\n\n1). 添加字段\n\nalter table 表名 add 字段名 类型（长度） [comment 注释] [约束];\n\n\n案例:\n\n为emp表增加一个新的字段\"昵称\"为nickname，类型为varchar(20)\n\nmariadb [test]> alter table emp add nickname varchar(20) comment '昵称';\nquery ok, 0 rows affected (0.001 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\nmariadb [test]> desc emp;\n+-----------+---------------------+------+-----+---------+-------+\n| field     | type                | null | key | default | extra |\n+-----------+---------------------+------+-----+---------+-------+\n| id        | int(11)             | yes  |     | null    |       |\n| workno    | varchar(10)         | yes  |     | null    |       |\n| name      | varchar(10)         | yes  |     | null    |       |\n| gender    | char(1)             | yes  |     | null    |       |\n| age       | tinyint(3) unsigned | yes  |     | null    |       |\n| idcard    | char(18)            | yes  |     | null    |       |\n| entrydate | date                | yes  |     | null    |       |\n| nickname  | varchar(20)         | yes  |     | null    |       |\n+-----------+---------------------+------+-----+---------+-------+\n8 rows in set (0.001 sec)\n\n\n2). 修改数据类型\n\nalter table 表名 modify 字段名 新数据类型(长度);\n\n\n3). 修改字段名和字段类型\n\nalter table 表名 change 旧字段名 新字段名 类型（长度） [comment 注释] [约束];\n\n\n案例:\n\n将emp表的nickname字段修改为username，类型为varchar(30)\n\nmariadb [test]> alter table emp change nickname username varchar(30) comment '昵称';\nquery ok, 0 rows affected (0.002 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\n4). 删除字段\n\nalter table 表名 drop 字段名;\n\n\n案例:\n\n将emp表的字段username删除\n\nmariadb [test]> alter table emp drop username;\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\n5). 修改表名\n\nalter table emp rename to employee;\n\n\n例:\n\n将emp表的表名修改为 employee\n\nmariadb [test]> alter table emp rename to employee;\nquery ok, 0 rows affected (0.004 sec)\n\nmariadb [test]> show tables;\n+----------------+\n| tables_in_test |\n+----------------+\n| employee       |\n| tb_user        |\n+----------------+\n2 rows in set (0.000 sec)\n\n\n2.3.2.5 表操作-删除\n\n1). 删除表\n\ndrop table [if exists] 表名;\n\n\n可选项 if exists 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\n\n如果tb_user表存在，则删除tb_user表\n\nmariadb [test]> drop table if exists tb_user;\nquery ok, 0 rows affected (0.002 sec)\n\n// 如下是属于提示报错\nmariadb [test]> drop table if exists tb_user;\nquery ok, 0 rows affected, 1 warning (0.000 sec)\n\n\n2). 删除指定表, 并重新创建表\n\ntruncate table 表名;\n\n\n> 注意: 在删除表的时候，表中的全部数据也都会被删除。\n\nmariadb [test]> show tables;\n+----------------+\n| tables_in_test |\n+----------------+\n| employee       |\n+----------------+\n1 row in set (0.000 sec)\n\nmariadb [test]> truncate table employee;\nquery ok, 0 rows affected (0.006 sec)\n\n\n\n# 图形化界面工具\n\n上述，我们已经讲解了通过ddl语句，如何操作数据库、操作表、操作表中的字段，而通过ddl语句执行在命令进行操作，主要存在以下两点问题：\n\n1).会影响开发效率 ;\n\n2). 使用起来，并不直观，并不方便 ；\n\n所以呢，我们在日常的开发中，会借助于mysql的图形化界面，来简化开发，提高开发效率。而目前 mysql主流的图形化界面工具，有以下几种：\n\n\n\n而本次课程中，选择 后一种datagrip，这种图形化界面工具，功能更加强大，界面提示更加友好，是我们使用mysql的不二之选。接下来，我们来介绍一下datagrip该如何安装、使用。\n\n# 安装\n\n1). 找到资料中准备好的安装包，双击开始安装\n\n\n\n2). 点击next，一步一步的完成安装\n\n\n\n选择datagrip的安装目录，然后选择下一步\n\n\n\n\n\n下一步，执行安装\n\n\n\n\n\n# 使用\n\n1). 添加数据源\n\n参考图示, 一步步操作即可\n\n\n\n配置以及驱动jar包下载完毕之后，就可以点击 \"test connection\" 就可以测试，是否可以连接\n\nmysql，如果出现 \"successed\"，就表名连接成功了 。\n\n\n\n2). 展示所有数据库\n\n连接上了mysql服务之后，并未展示出所有的数据库，此时，我们需要设置，展示所有的数据库，具体操作如下：\n\n\n\n3). 创建数据库\n\n\n\n> 注意:\n> \n> 以下两种方式都可以创建数据库：\n\na. create database db01;\n\nb. create schema db01;\n\n4). 创建表\n\n在指定的数据库上面右键，选择new --\x3e table\n\n\n\n\n\n5). 修改表结构\n\n在需要修改的表上，右键选择 \"modify table...\"\n\n\n\n\n\n如果想增加字段，直接点击+号，录入字段信息，然后点击execute即可。\n\n如果想删除字段，直接点击-号，就可以删除字段，然后点击execute即可。如果想修改字段，双击对应的字段，修改字段信息，然后点击execute即可。如果要修改表名，或表的注释，直接在输入框修改，然后点击execute即可。\n\n6). 在datagrip中执行sql语句\n\n在指定的数据库上，右键，选择 new --\x3e query console\n\n\n\n然后就可以在打开的query console控制台，并在控制台中编写sql，执行sql。\n\n\n\n\n# dml\n\ndml英文全称是data manipulation language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\n\n> 添加数据（insert）修改数据（update）删除数据（delete）\n\n\n# 添加数据\n\n1). 给指定字段添加数据\n\ninsert into 表名(字段名1,字段名2，...) values(值1，值2，...);\n\n\n案例: 给employee表所有的字段添加数据 ；\n\nmariadb [test]> insert into emp(id,workno,name,gender,age,idcard,entrydate) values(1,'1','itest','男','10','123456789012345678','2022-05-20');\n\n\n插入数据完成之后，我们有两种方式，查询数据库的数据：\n\na. 方式一\n\n在左侧的表名上双击，就可以查看这张表的数据。\n\n\n\nb. 方式二\n\n可以直接一条查询数据的sql语句, 语句如下:\n\nselect * from emp;\n\n\n查询如下:\n\nmariadb [test]> select * from employee;\n+------+--------+-------+--------+------+--------------------+------------+\n| id   | workno | name  | gender | age  | idcard             | entrydate  |\n+------+--------+-------+--------+------+--------------------+------------+\n|    1 | 1      | itest | 男     |   10 | 123456789012345678 | 2022-05-20 |\n+------+--------+-------+--------+------+--------------------+------------+\n1 row in set (0.000 sec)\n\n\n2). 给全部字段添加数据\n\ninsert into 表名 values(值1，值2，...);\n\n\n案例：插入数据到employee表，具体的sql如下：\n\nmariadb [test]> insert into employee values(2,'2','张无忌','男',18,'123456789012345678','2005-08-10');\nquery ok, 1 row affected (0.001 sec)\n\nmariadb [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n2 rows in set (0.000 sec)\n\n\n3). 批量添加数据\n\ninsert into 表名（字段名1，字段名2，...） values（值1，值2，...),(值1，值2，...),(值1，值2，...);\n\n\ninsert into 表名 values（值1，值2，...),(值1，值2，...),(值1，值2，...);\n\n\n案例：批量插入数据到employee表，具体的sql如下：\n\n> 注意事项:\n\n * 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n\n * 字符串和日期型数据应该包含在引号中。\n\n * 插入的数据大小，应该在字段的规定范围内。\n\nmariadb [test]> insert into employee values(3,'3','周一','男',18,'123456789012345678','2005-08-11'),(4,'4','周停','女',20,'123456789012345678','2005-08-11');\nquery ok, 2 rows affected (0.001 sec)\nrecords: 2  duplicates: 0  warnings: 0\n\nmariadb [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n|    3 | 3      | 周一      | 男     |   18 | 123456789012345678 | 2005-08-11 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2005-08-11 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\n\n\n# 修改数据\n\n修改数据的具体语法为:\n\nupdate 表名 set 字段名1=值1，字段名2=值2，... [where 条件]; \n\n\n案例:\n\na. 修改id为1的数据，将name修改为itheima\n\nb. 修改id为1的数据, 将name修改为小昭, gender修改为 女\n\nc. 将所有的员工入职日期修改为 2008-01-01\n\nmariadb [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itest     | 男     |   10 | 123456789012345678 | 2022-05-20 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2005-08-10 |\n|    3 | 3      | 周一      | 男     |   18 | 123456789012345678 | 2005-08-11 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2005-08-11 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\nmariadb [test]> update employee set name = 'itheima' where id = 1;\nquery ok, 1 row affected (0.001 sec)\nrows matched: 1  changed: 1  warnings: 0\n\nmariadb [test]> update employee set name = '小爱',gender = '女' where id = 3;\nquery ok, 1 row affected (0.001 sec)\nrows matched: 1  changed: 1  warnings: 0\n\nmariadb [test]> update employee set entrydate = '2022-06-10';\nquery ok, 4 rows affected (0.001 sec)\nrows matched: 4  changed: 4  warnings: 0\n\nmariadb [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itheima   | 男     |   10 | 123456789012345678 | 2022-06-10 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2022-06-10 |\n|    3 | 3      | 小爱      | 女     |   18 | 123456789012345678 | 2022-06-10 |\n|    4 | 4      | 周停      | 女     |   20 | 123456789012345678 | 2022-06-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n4 rows in set (0.000 sec)\n\n\n> 注意事项:\n> \n> 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n\n\n# 删除数据\n\n删除数据的具体语法为：\n\ndelete from 表名 [where 条件];\n\n\n案例:\n\na. 删除gender为女的员工\n\nb. 删除所有员工\n\nmariadb [test]> delete from employee where gender = '女';\nquery ok, 2 rows affected (0.001 sec)\n\nmariadb [test]> select * from employee;\n+------+--------+-----------+--------+------+--------------------+------------+\n| id   | workno | name      | gender | age  | idcard             | entrydate  |\n+------+--------+-----------+--------+------+--------------------+------------+\n|    1 | 1      | itheima   | 男     |   10 | 123456789012345678 | 2022-06-10 |\n|    2 | 2      | 张无忌    | 男     |   18 | 123456789012345678 | 2022-06-10 |\n+------+--------+-----------+--------+------+--------------------+------------+\n2 rows in set (0.000 sec)\n\nmariadb [test]> delete from employee;\nquery ok, 2 rows affected (0.023 sec)\n\n\n> 注意事项：\n> \n> • delete 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n> \n> • delete 语句不能删除某一个字段的值(可以使用update，将该字段值置为null即\n> \n> 可)。\n> \n> • 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击\n> \n> execute即可。\n\n\n# dql\n\ndql英文全称是data query language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。\n\n查询关键字: select\n\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\n\n\n\n环境准备：\n\ndrop table if exists employee;\n\ncreate table emp(\n\tid int comment '编号',\n\tworkno varchar(10) comment '工号',\n\tname varchar(10) comment '姓名',\n\tgender char(1) comment '性别',\n\tage tinyint unsigned comment '年龄',\n\tidcard char(18) comment '身份证号',\n\tworkaddress varchar(50) comment '工作地址',\n\tentrydate date comment '入职时间'\n)comment '员工表';\n\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (1, '00001', '柳岩666', '女', 20, '123456789012345678', '北京', '2000-01-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (2, '00002', '张无忌', '男', 18, '123456789012345670', '北京', '2005-09-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (3, '00003', '韦一笑', '男', 38, '123456789712345670', '上海', '2005-08-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (4, '00004', '赵敏', '女', 18, '123456757123845670', '北京', '2009-12-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (5, '00005', '小昭', '女', 16, '123456769012345678', '上海', '2007-07-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (6, '00006', '杨逍', '男', 28, '12345678931234567x', '北京', '2006-01-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (7, '00007', '范瑶', '男', 40, '123456789212345670', '北京', '2005-05-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (8, '00008', '黛绮丝', '女', 38, '123456157123645670', '天津', '2015-05-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (9, '00009', '范凉凉', '女', 45, '123156789012345678', '北京', '2010-04-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (10, '00010', '陈友谅', '男', 53, '123456789012345670', '上海', '2011-01-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (11, '00011', '张士诚', '男', 55, '123567897123465670', '江苏', '2015-05-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (12, '00012', '常遇春', '男', 32, '123446757152345670', '北京', '2004-02-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (13, '00013', '张三丰', '男', 88, '123656789012345678', '江苏', '2020-11-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (14, '00014', '灭绝', '女', 65, '123456719012345670', '西安', '2019-05-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (15, '00015', '胡青牛', '男', 70, '12345674971234567x', '西安', '2018-04-01');\ninsert into emp (id, workno, name, gender, age, idcard, workaddress, entrydate) values (16, '00016', '周芷若', '女', 18, null, '北京', '2012-06-01');\n\n\n\n# 基本语法\n\ndql 查询语句，语法结构如下：\n\nselect \n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组列表\nhaving\n\t分组后条件列表\norder by\n\t排序字段列表\nlimit\n\t分页参数\n\n\n我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：\n\n * 基本查询（不带任何条件）条件查询（where）\n * 聚合函数（count、max、min、avg、sum）\n * 分组查询（group by）\n * 排序查询（order by）\n * 分页查询（limit）\n\n\n# 基础查询\n\n在基本查询的dql语句中，不带任何的查询条件，查询的语法如下：\n\n1). 查询多个字段\n\nselect 字段1，字段2，字段3,... from 表名;\n\nselect * from 表名;\n\n\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\n\n2). 字段设置别名\n\nselect 字段1 [as 别名1],字段2 [as 别名2]，... from 表名;\nselect 字段1 [别名1],字段2 [别名2]，... from 表名;\n\n\n3). 去除重复记录\n\nselect distinct 字段列表 from 表名;\n\n\n案例：\n\na. 查询指定字段 name, workno, age并返回\n\nmariadb [test]> select name,workno,age from emp;\n+-----------+--------+------+\n| name      | workno | age  |\n+-----------+--------+------+\n| 柳岩666   | 00001  |   20 |\n| 张无忌    | 00002  |   18 |\n| 韦一笑    | 00003  |   38 |\n| 赵敏      | 00004  |   18 |\n| 小昭      | 00005  |   16 |\n| 杨逍      | 00006  |   28 |\n| 范瑶      | 00007  |   40 |\n| 黛绮丝    | 00008  |   38 |\n| 范凉凉    | 00009  |   45 |\n| 陈友谅    | 00010  |   53 |\n| 张士诚    | 00011  |   55 |\n| 常遇春    | 00012  |   32 |\n| 张三丰    | 00013  |   88 |\n| 灭绝      | 00014  |   65 |\n| 胡青牛    | 00015  |   70 |\n| 周芷若    | 00016  |   18 |\n+-----------+--------+------+\n16 rows in set (0.000 sec)\n\n\nb. 查询返回所有字段\n\nmariadb [test]> select * from emp;\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n|    2 | 00002  | 张无忌    | 男     |   18 | 123456789012345670 | 北京        | 2005-09-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    4 | 00004  | 赵敏      | 女     |   18 | 123456757123845670 | 北京        | 2009-12-01 |\n|    5 | 00005  | 小昭      | 女     |   16 | 123456769012345678 | 上海        | 2007-07-01 |\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567x | 北京        | 2006-01-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n|    8 | 00008  | 黛绮丝    | 女     |   38 | 123456157123645670 | 天津        | 2015-05-01 |\n|    9 | 00009  | 范凉凉    | 女     |   45 | 123156789012345678 | 北京        | 2010-04-01 |\n|   10 | 00010  | 陈友谅    | 男     |   53 | 123456789012345670 | 上海        | 2011-01-01 |\n|   11 | 00011  | 张士诚    | 男     |   55 | 123567897123465670 | 江苏        | 2015-05-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|   13 | 00013  | 张三丰    | 男     |   88 | 123656789012345678 | 江苏        | 2020-11-01 |\n|   14 | 00014  | 灭绝      | 女     |   65 | 123456719012345670 | 西安        | 2019-05-01 |\n|   15 | 00015  | 胡青牛    | 男     |   70 | 12345674971234567x | 西安        | 2018-04-01 |\n|   16 | 00016  | 周芷若    | 女     |   18 | null               | 北京        | 2012-06-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n16 rows in set (0.000 sec)\n\n\nc. 查询所有员工的工作地址,起别名\n\nmariadb [test]> select workaddress as '工作地址' from emp;\n+--------------+\n| 工作地址     |\n+--------------+\n| 北京         |\n| 北京         |\n| 上海         |\n| 北京         |\n| 上海         |\n| 北京         |\n| 北京         |\n| 天津         |\n| 北京         |\n| 上海         |\n| 江苏         |\n| 北京         |\n| 江苏         |\n| 西安         |\n| 西安         |\n| 北京         |\n+--------------+\n16 rows in set (0.000 sec)\n\nmariadb [test]> select workaddress '工作地址' from emp;\n\n\nd. 查询公司员工的上班地址有哪些(不要重复)\n\nmariadb [test]> select distinct workaddress '工作地址' from emp;\n+--------------+\n| 工作地址     |\n+--------------+\n| 北京         |\n| 上海         |\n| 天津         |\n| 江苏         |\n| 西安         |\n+--------------+\n5 rows in set (0.000 sec)\n\n\n\n# 条件查询\n\n1). 语法\n\nselect 字段列表 from 表名 where 条件列表;\n\n\n2). 条件\n\n常用的比较运算符如下:\n\n比较运算符                 功能\n>                     大于\n>=                    大于等于\n<                     小于\n<=                    小于等于\n=                     等于\n<> 或 !=               不等于\nbetween ... and ...   在某个范围之内(含 小、 大值)\nin(...)               在in之后的列表中的值，多选一\nlike 占位符              模糊匹配(_匹配单个字符, %匹配任意个字符)\nis null               是null\n\n常用的逻辑运算符如下:\n\n逻辑运算符      功能\nand 或 &&   并且 (多个条件同时成立)\nor 或 ||    或者 (多个条件任意一个成立)\nnot 或 !    非 , 不是\n\n案例:\n\na. 查询年龄等于 88 的员工\n\nmariadb [test]> select * from emp where age = 88;\n\n\nb. 查询没有身份证号的员工信息\n\nmariadb [test]> select * from emp where idcard is null;\n\n\nc. 查询有身份证号的员工信息\n\nmariadb [test]> select * from emp where idcard is not null;\n\n\nd. 查询年龄不等于 88 的员工信息\n\nmariadb [test]> select * from emp where age != 88;\n\n\ne. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息\n\nmariadb [test]> select * from emp where age between 15 and 20;\n\n\nf. 查询性别为 女 且年龄小于 25岁的员工信息\n\nmariadb [test]> select * from emp where gender = '女' and age <25 ;\n\n\ng. 查询年龄等于18 或 20 或 40 的员工信息\n\nmariadb [test]> select * from emp where age = 18 || age = 20 || age = 40;\nmariadb [test]> select * from emp where age in(20,40,80);\n\n\nh. 查询姓名为两个字的员工信息 _ %\n\nmariadb [test]> select * from emp where name like '__';\n\n\ni. 查询身份证号 后一位是x的员工信息\n\nmariadb [test]> select * from emp where idcard like '%x';\n\n\n\n# 聚合函数\n\n1). 介绍\n\n将一列数据作为一个整体，进行纵向计算 。\n\n2). 常见的聚合函数\n\n函数      功能\ncount   统计数量\nmax     大值\nmin     小值\navg     平均值\nsum     求和\n\n3). 语法\n\nselect 聚合函数（字段列表）from 表名;\n\n\n> 注意 : null值是不参与所有聚合函数运算的。\n\n案例：\n\na. 统计该企业员工数量\n\nmariadb [test]> select count(*) from emp;\n+----------+\n| count(*) |\n+----------+\n|       16 |\n+----------+\n1 row in set (0.000 sec)\n\nmariadb [test]> select count(idcard) from emp;\n+---------------+\n| count(idcard) |\n+---------------+\n|            15 |\n+---------------+\n1 row in set (0.000 sec)\n\n\n对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计查询，比如：\n\nselect count(1) from emp;\n\n\n> 对于count(*) 、count(字段)、 count(1) 的具体原理，我们在进阶篇中sql优化部分会详细讲解，此处大家只需要知道如何使用即可。\n\nb. 统计该企业员工的平均年龄\n\n> 统计该企业员工的 大年龄\n\nmariadb [test]> select  avg(age) from emp;\n+----------+\n| avg(age) |\n+----------+\n|  40.1250 |\n+----------+\n1 row in set (0.000 sec)\n\n\nd. 统计该企业员工的 小年龄\n\nmariadb [test]> select  min(age) from emp;\n+----------+\n| max(age) |\n+----------+\n|       88 |\n+----------+\n1 row in set (0.000 sec)\n\n\ne. 统计西安地区员工的年龄之和\n\nmariadb [test]> select sum(age) from emp where workaddress = '西安';\n+----------+\n| sum(age) |\n+----------+\n|      135 |\n+----------+\n1 row in set (0.000 sec)\n\n\n\n# 分组查询\n\n1). 语法\n\nselect 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\n\n\n2). where与having区别\n\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n注意事项:\n\n * 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n\n * 执行顺序: where > 聚合函数 > having 。\n\n * 支持多字段分组, 具体语法为 : group by columna,columnb\n\n案例:\n\na. 根据性别分组 , 统计男性员工 和 女性员工的数量\n\nmariadb [test]> select gender,count(*) from emp group by gender;\n+--------+----------+\n| gender | count(*) |\n+--------+----------+\n| 女     |        7 |\n| 男     |        9 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\nb. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄\n\nmariadb [test]> select gender,avg(age) from emp group by gender;\n+--------+----------+\n| gender | avg(age) |\n+--------+----------+\n| 女     |  31.4286 |\n| 男     |  46.8889 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\nc.查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址\n\n// 这里的address_count是分组别名\n\nmariadb [test]> select workaddress,count(*) address_count from emp where age < 45 group by workaddress having address_count >= 3;\n+-------------+---------------+\n| workaddress | address_count |\n+-------------+---------------+\n| 北京        |             7 |\n+-------------+---------------+\n1 row in set (0.000 sec)\n\n\nd. 统计各个工作地址上班的男性及女性员工的数量\n\nmariadb [test]> select workaddress,gender,count(*) '数量' from emp group by gender,workaddress;\n+-------------+--------+--------+\n| workaddress | gender | 数量   |\n+-------------+--------+--------+\n| 上海        | 女     |      1 |\n| 北京        | 女     |      4 |\n| 天津        | 女     |      1 |\n| 西安        | 女     |      1 |\n| 上海        | 男     |      2 |\n| 北京        | 男     |      4 |\n| 江苏        | 男     |      2 |\n| 西安        | 男     |      1 |\n+-------------+--------+--------+\n8 rows in set (0.000 sec)\n\n\n\n# 排序查询\n\n排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\n\n\n\n1). 语法\n\nselect 字段列表 from 表名 order by 字段1 排序方式，字段2 排序方式2\n\n\n2). 排序方式\n\n * asc : 升序(默认值)\n\n * desc: 降序\n\n> 注意事项：\n> \n>  * 如果是升序, 可以不指定排序方式asc ;\n> \n>  * 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n\n案例:\n\na. 根据年龄对公司的员工进行升序排序\n\nmariadb [test]> select * from emp order by age asc;\n\n\nb. 根据入职时间, 对员工进行降序排序\n\nmariadb [test]> select * from emp order by entrydate desc;\n\n\nc. 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序\n\nmariadb [test]> select * from emp order by age asc,entrydate desc;\n\n\n\n# 分页查询\n\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。\n\n\n\n1). 语法\n\nselect 字段列表 from 表名 limit 起始索引,查询记录数;\n\n\n注意事项:\n\n * 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。\n\n * 分页查询是数据库的方言，不同的数据库有不同的实现，mysql中是limit。\n\n * 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。\n\n案例:\n\na. 查询第1页员工数据, 每页展示10条记录\n\nmariadb [test]> select * from emp limit 0,10;\n\n\nb. 查询第2页员工数据, 每页展示10条记录 --------\x3e (页码-1)*页展示记录数\n\nmariadb [test]> select * from emp limit 10,10;\n\n\n\n# 案例\n\n1). 查询年龄为20,21,22,23岁的员工信息。\n\nmariadb [test]> select * from emp where age in(20,21,22,23);\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    1 | 00001  | 柳岩666   | 女     |   20 | 123456789012345678 | 北京        | 2000-01-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n1 row in set (0.000 sec)\n\n\n2). 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。\n\nmariadb [test]> select * from emp where gender = '男' and (age between 20 and 40) and name like '___';\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n2 rows in set (0.000 sec)\n\n\n3). 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数。\n\nmariadb [test]> select gender,count(*)  from emp where age < 60 group by gender;\n+--------+----------+\n| gender | count(*) |\n+--------+----------+\n| 女     |        6 |\n| 男     |        7 |\n+--------+----------+\n2 rows in set (0.000 sec)\n\n\n4). 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。\n\nmariadb [test]> select name,age from emp where age <= 35 order by age asc,entrydate desc;\n+-----------+------+\n| name      | age  |\n+-----------+------+\n| 小昭      |   16 |\n| 周芷若    |   18 |\n| 赵敏      |   18 |\n| 张无忌    |   18 |\n| 柳岩666   |   20 |\n| 杨逍      |   28 |\n| 常遇春    |   32 |\n+-----------+------+\n7 rows in set (0.000 sec)\n\n\n5). 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。\n\nmariadb [test]> select * from emp where gender = '男' and (age between 20 and 40) order by age asc,entrydate asc limit 5; \n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n| id   | workno | name      | gender | age  | idcard             | workaddress | entrydate  |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n|    6 | 00006  | 杨逍      | 男     |   28 | 12345678931234567x | 北京        | 2006-01-01 |\n|   12 | 00012  | 常遇春    | 男     |   32 | 123446757152345670 | 北京        | 2004-02-01 |\n|    3 | 00003  | 韦一笑    | 男     |   38 | 123456789712345670 | 上海        | 2005-08-01 |\n|    7 | 00007  | 范瑶      | 男     |   40 | 123456789212345670 | 北京        | 2005-05-01 |\n+------+--------+-----------+--------+------+--------------------+-------------+------------+\n4 rows in set (0.000 sec)\n\n\n\n# 执行顺序\n\n在讲解dql语句的具体语法之前，我们已经讲解了dql语句的完整语法，及编写顺序，接下来，我们要来说明的是dql语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。\n\n\n\n验证：查询年龄大于15的员工姓名、年龄，并根据年龄进行升序排序。\n\nmariadb [test]> select name,age  from emp where age > 15 order by age asc;\n\n\n在查询时，我们给emp表起一个别名 e，然后在select 及 where中使用该别名。\n\nmariadb [test]> select e.name,e.age from emp e where e.age > 15 order by age asc;\n\n\n执行上述sql语句后，我们看到依然可以正常的查询到结果，此时就说明： from 先执行, 然后 where 和 select 执行。那 where 和 select 到底哪个先执行呢?\n\n此时，此时我们可以给select后面的字段起别名，然后在 where 中使用这个别名，然后看看是否可以执行成功。\n\nmariadb [test]> select e.name ename,e.age eage from emp e where eage > 15 order by age asc;\n\n\n执行上述sql报错了:\n\n\n\n由此我们可以得出结论: from 先执行，然后执行 where ， 再执行select 。\n\n接下来，我们再执行如下sql语句，查看执行效果：\n\nmariadb [test]> select e.name ename,e.age eage from emp e where e.age > 15 order by age asc;\n\n\n结果执行成功。 那么也就验证了: order by 是在select 语句之后执行的。\n\n综上所述，我们可以看到dql语句的执行顺序为：\n\nfrom ... where ... group by ... having ... select ... order by ... limit ...\n\n\n# dcl\n\ndcl英文全称是data control language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。\n\n\n\n\n# 管理用户\n\n1). 查询用户\n\nuse mysql;\nselect * from user;\n\n\n查询的结果如下:\n\n\n\n其中 host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 user代表的是访问该数据库的用户名。在mysql中需要通过host和user来唯一标识一个用户。\n\n2). 创建用户\n\ncreate user '用户名'@'主机名' identified by '密码';\n\n\n3). 修改用户密码\n\nalter user '用户名'@'主机名' identified with mysql_native_password by '新密码';\n\n\n4). 删除用户\n\ndrop user '用户名'@'主机名';\n\n\n注意事项:\n\n * 在mysql中需要通过用户名@主机名的方式，来唯一标识一个用户。\n\n * 主机名可以使用 % 通配。\n\n * 这类sql开发人员操作的比较少，主要是dba（ database administrator 数据库管理员）使用。\n\n案例：\n\na. 创建用户itcast, 只能够在当前主机localhost访问, 密码123456;\n\nmariadb [mysql]> create user 'itcast'@'localhost' identified by '123456';\nquery ok, 0 rows affected (0.000 sec)\n\nmariadb [mysql]> exit\nbye\n[root@localhost ~]# mysql -uitcast -p123456\nwelcome to the mariadb monitor.  commands end with ; or \\g.\nyour mariadb connection id is 23\nserver version: 10.3.23-mariadb mariadb server\n\ncopyright (c) 2000, 2018, oracle, mariadb corporation ab and others.\n\ntype 'help;' or '\\h' for help. type '\\c' to clear the current input statement.\n\nmariadb [(none)]>\n\n\nb. 创建用户heima, 可以在任意主机访问该数据库, 密码123456;\n\nmariadb [(none)]> create user 'heima'@'%' identified by '123456';\nquery ok, 0 rows affected (0.000 sec)\n\n\nc. 修改用户heima的访问密码为1234;\n\nmariadb [(none)]> alter user 'heima'@'%' identified with mysql_native_password by '000000';\nquery ok, 0 rows affected (0.000 sec)\n\n\nd. 删除 itcast@localhost 用户\n\nmariadb [(none)]> drop user 'heima'@'%';\nquery ok, 0 rows affected (0.000 sec)\n\n\n\n# 权限控制\n\nmysql中定义了很多种权限，但是常用的就以下几种：\n\n权限                    说明\nall, all privileges   所有权限\nselect                查询数据\ninsert                插入数据\nupdate                修改数据\ndelete                删除数据\nalter                 修改表\ndrop                  删除数据库/表/视图\ncreate                创建数据库/表\n\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考官方文档。\n\n1). 查询权限\n\nshow grants for '用户名'@'主机名';\n\n\n2). 授予权限\n\ngrant 权限列表 on 数据库名.表名 to '用户名'@'主机名';\n\n\n3). 撤销权限\n\nrevoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';\n\n\n注意事项：\n\n * 多个权限之间，使用逗号分隔\n\n * 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\n\n案例:\n\na. 查询 'heima'@'%' 用户的权限\n\nmariadb [(none)]> show grants for 'heima'@'%';\n+------------------------------------------------------------------------------------------------------+\n| grants for heima@%                                                                                   |\n+------------------------------------------------------------------------------------------------------+\n| grant usage on *.* to `heima`@`%` identified by password '*032197ae5731d4664921a6ccac7cfce6a0698693' |\n+------------------------------------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n\n\nb. 授予 'heima'@'%' 用户itcast数据库所有表的所有操作权限\n\nmariadb [(none)]> grant all on itcast.* to 'heima'@'%';\nquery ok, 0 rows affected (0.000 sec)\n\nmariadb [(none)]> show grants for 'heima'@'%';\n+------------------------------------------------------------------------------------------------------+\n| grants for heima@%                                                                                   |\n+------------------------------------------------------------------------------------------------------+\n| grant usage on *.* to `heima`@`%` identified by password '*032197ae5731d4664921a6ccac7cfce6a0698693' |\n| grant all privileges on `itcast`.* to `heima`@`%`                                                    |\n+------------------------------------------------------------------------------------------------------+\n2 rows in set (0.000 sec)\n\n\nc. 撤销 'heima'@'%' 用户的itcast数据库的所有权限\n\nmariadb [(none)]> revoke all on itcast.* from 'heima'@'%';\nquery ok, 0 rows affected (0.000 sec)remo\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL的约束",frontmatter:{title:"MySQL的约束",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/c2207f/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/06.MySQL%E7%9A%84%E7%BA%A6%E6%9D%9F.html",relativePath:"01.指南/04.数据库/06.MySQL的约束.md",key:"v-782af799",path:"/pages/c2207f/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:15},{level:3,title:"约束演示",slug:"约束演示",normalizedTitle:"约束演示",charIndex:532},{level:3,title:"外键约束",slug:"外键约束",normalizedTitle:"外键约束",charIndex:428},{level:4,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:542},{level:4,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:1337},{level:4,title:"删除/更新行为",slug:"删除-更新行为",normalizedTitle:"删除/更新行为",charIndex:3873}],headersStr:"概述 约束演示 外键约束 介绍 语法 删除/更新行为",content:"# MySQL的约束\n\n\n# 概述\n\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n目的：保证数据库中数据的正确、有效性和完整性。\n\n分类:\n\n约束                 描述                             关键字\n非空约束               限制该字段的数据不能为null                NOT NULL\n唯一约束               保证该字段的所有数据都是唯一、不重复的            UNIQUE\n主键约束               主键是一行数据的唯一标识，要求非空且唯一           PRIMARY KEY\n默认约束               保存数据时，如果未指定该字段的值，则采用默认值        DEFAULT\n检查约束(8.0.16版本之后)   保证字段值满足某一个条件                   CHECK\n外键约束               用来让两张表的数据之间建立连接，保证数据的一致性和完整性   FOREIGN KEY\n\n> 注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\n\n\n# 约束演示\n\n上面我们介绍了数据库中常见的约束，以及约束涉及到的关键字，那这些约束我们到底如何在创建表、修改表的时候来指定呢，接下来我们就通过一个案例，来演示一下。\n\n案例需求： 根据需求，完成表结构的创建。需求如下：\n\n字段名      字段含义     字段类型          约束条件            约束关键字\nid       ID唯一标识   int           主键，并且自动增长       PRIMARY KEY, AUTO_INCREMENT\nname     姓名       varchar(10)   不为空，并且唯一        NOT NULL , UNIQUE\nage      年龄       int           大于0，并且小于等于120   CHECK\nstatus   状态       char(1)       如果没有指定该值，默认为1   DEFAULT\ngender   性别       char(1)       无               \n\n对应的建表语句为：\n\nMariaDB [test]> create table user(\n    id int primary key auto_increment comment '主键',\n    name varchar(10) not null unique comment '姓名',\n    age int check ( age > 0 && age <= 120 ) comment '年龄',\n    status char(1) default '1' comment '状态',\n    gender char(1) comment '性别'\n) comment '用户表';\n\n\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。我们执行上面的SQL把表结构创建完成，然后接下来，就可以通过一组数据进行测试，从而验证一下，约束是否可以生效。\n\ninsert into user( name, age, status, gender) values('Tom1',19,'1','男'),('Tom2',20,'1','男');\ninsert into user( name, age, status, gender) values('Tom3',19,'1','男');\ninsert into user( name, age, status, gender) values(null,19,'1','男');\ninsert into user( name, age, status, gender) values('Tom4',-1,'1','男');\ninsert into user( name, age, status, gender) values('Tom5',121,'1','男');\ninsert into user( name, age, gender) values('Tom6',19,'男');\n\n\n上面，我们是通过编写SQL语句的形式来完成约束的指定，那加入我们是通过图形化界面来创建表结构时，又该如何来指定约束呢？ 只需要在创建表的时候，根据我们的需要选择对应的约束即可。\n\n\n\n\n# 外键约束\n\n# 介绍\n\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。\n\n我们来看一个例子：\n\n\n\n左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。\n\n> 注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，\n> \n> 所以是无法保证数据的一致性和完整性的。\n\n没有数据库外键关联的情况下，能够保证一致性和完整性呢，我们来测试一下。\n\n准备数据\n\ncreate table dept(\n    id   int auto_increment comment 'ID' primary key,\n    name varchar(50) not null comment '部门名称'\n)comment '部门表';\nINSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办');\n\n\ncreate table emp(\n    id  int auto_increment comment 'ID' primary key,\n    name varchar(50) not null comment '姓名',\n    age  int comment '年龄',\n    job varchar(20) comment '职位',\n    salary int comment '薪资',\n    entrydate date comment '入职时间',\n    managerid int comment '直属领导ID',\n    dept_id int comment '部门ID'\n)comment '员工表';\n\nINSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1);\n\n\n接下来，我们可以做一个测试，删除id为1的部门信息。\n\n\n\n结果，我们看到删除成功，而删除成功之后，部门表不存在id为1的部门，而在emp表中还有很多的员工，关联的为id为1的部门，此时就出现了数据的不完整性。 而要想解决这个问题就得通过数据库的外键约束。\n\n# 语法\n\n1). 添加外键\n\nCREATE TABLE 表名(\n\t字段名\t数据类型,\n    ...\n    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)\n);\n\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);\n\n\n案例:\n\n为emp表的dept_id字段添加外键约束,关联dept表的主键id。\n\nMariaDB [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);\n\n\n添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。\n\n2). 删除外键\n\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n\n案例：\n\n删除emp表的外键fk_emp_dept_id。\n\nMariaDB [test]> alter table emp drop foreign key fk_emp_dept_id;\n\n\n# 删除/更新行为\n\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种:\n\n行为            说明\nNO ACTION     当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 RESTRICT 一致)\n              默认行为\nRESTRICT      当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 NO ACTION\n              一致) 默认行为\nCASCADE       当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。\nSET NULL      当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。\nSET DEFAULT   父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)\n\n具体语法为:\n\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名（主表字段名） ON UPDATE CASCADE ON DELETE CASCADE;\n\n\n演示如下：\n\n由于NO ACTION 是默认行为，我们前面语法演示的时候，已经测试过了，就不再演示了，这里我们再演示其他的两种行为：CASCADE、SET NULL。\n\n1). CASCADE\n\nMariaDB [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade;\n\n\nA. 修改父表id为1的记录，将id修改为6\n\n\n\n我们发现，原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。\n\n> 在一般的业务系统中，不会修改一张表的主键值。\n\nB. 删除父表id为6的记录\n\n\n\n我们发现，父表的数据删除成功了，但是子表中关联的记录也被级联删除了。\n\n2). SET NULL\n\n在进行测试之前，我们先需要删除上面建立的外键 fk_emp_dept_id。然后再通过数据脚本，将 emp、dept表的数据恢复了。\n\nMariaDB [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null;\n\n\n接下来，我们删除id为1的数据，看看会发生什么样的现象。\n\n\n\n我们发现父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，我们发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。\n\n\n\n这就是SET NULL这种删除/更新行为的效果。",normalizedContent:"# mysql的约束\n\n\n# 概述\n\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n目的：保证数据库中数据的正确、有效性和完整性。\n\n分类:\n\n约束                 描述                             关键字\n非空约束               限制该字段的数据不能为null                not null\n唯一约束               保证该字段的所有数据都是唯一、不重复的            unique\n主键约束               主键是一行数据的唯一标识，要求非空且唯一           primary key\n默认约束               保存数据时，如果未指定该字段的值，则采用默认值        default\n检查约束(8.0.16版本之后)   保证字段值满足某一个条件                   check\n外键约束               用来让两张表的数据之间建立连接，保证数据的一致性和完整性   foreign key\n\n> 注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\n\n\n# 约束演示\n\n上面我们介绍了数据库中常见的约束，以及约束涉及到的关键字，那这些约束我们到底如何在创建表、修改表的时候来指定呢，接下来我们就通过一个案例，来演示一下。\n\n案例需求： 根据需求，完成表结构的创建。需求如下：\n\n字段名      字段含义     字段类型          约束条件            约束关键字\nid       id唯一标识   int           主键，并且自动增长       primary key, auto_increment\nname     姓名       varchar(10)   不为空，并且唯一        not null , unique\nage      年龄       int           大于0，并且小于等于120   check\nstatus   状态       char(1)       如果没有指定该值，默认为1   default\ngender   性别       char(1)       无               \n\n对应的建表语句为：\n\nmariadb [test]> create table user(\n    id int primary key auto_increment comment '主键',\n    name varchar(10) not null unique comment '姓名',\n    age int check ( age > 0 && age <= 120 ) comment '年龄',\n    status char(1) default '1' comment '状态',\n    gender char(1) comment '性别'\n) comment '用户表';\n\n\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。我们执行上面的sql把表结构创建完成，然后接下来，就可以通过一组数据进行测试，从而验证一下，约束是否可以生效。\n\ninsert into user( name, age, status, gender) values('tom1',19,'1','男'),('tom2',20,'1','男');\ninsert into user( name, age, status, gender) values('tom3',19,'1','男');\ninsert into user( name, age, status, gender) values(null,19,'1','男');\ninsert into user( name, age, status, gender) values('tom4',-1,'1','男');\ninsert into user( name, age, status, gender) values('tom5',121,'1','男');\ninsert into user( name, age, gender) values('tom6',19,'男');\n\n\n上面，我们是通过编写sql语句的形式来完成约束的指定，那加入我们是通过图形化界面来创建表结构时，又该如何来指定约束呢？ 只需要在创建表的时候，根据我们的需要选择对应的约束即可。\n\n\n\n\n# 外键约束\n\n# 介绍\n\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。\n\n我们来看一个例子：\n\n\n\n左侧的emp表是员工表，里面存储员工的基本信息，包含员工的id、姓名、年龄、职位、薪资、入职日期、上级主管id、部门id，在员工的信息中存储的是部门的id dept_id，而这个部门的id是关联的部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。\n\n> 注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，\n> \n> 所以是无法保证数据的一致性和完整性的。\n\n没有数据库外键关联的情况下，能够保证一致性和完整性呢，我们来测试一下。\n\n准备数据\n\ncreate table dept(\n    id   int auto_increment comment 'id' primary key,\n    name varchar(50) not null comment '部门名称'\n)comment '部门表';\ninsert into dept (id, name) values (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办');\n\n\ncreate table emp(\n    id  int auto_increment comment 'id' primary key,\n    name varchar(50) not null comment '姓名',\n    age  int comment '年龄',\n    job varchar(20) comment '职位',\n    salary int comment '薪资',\n    entrydate date comment '入职时间',\n    managerid int comment '直属领导id',\n    dept_id int comment '部门id'\n)comment '员工表';\n\ninsert into emp (id, name, age, job,salary, entrydate, managerid, dept_id) values(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1);\n\n\n接下来，我们可以做一个测试，删除id为1的部门信息。\n\n\n\n结果，我们看到删除成功，而删除成功之后，部门表不存在id为1的部门，而在emp表中还有很多的员工，关联的为id为1的部门，此时就出现了数据的不完整性。 而要想解决这个问题就得通过数据库的外键约束。\n\n# 语法\n\n1). 添加外键\n\ncreate table 表名(\n\t字段名\t数据类型,\n    ...\n    [constraint] [外键名称] foreign key (外键字段名) references 主表(主表列名)\n);\n\nalter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);\n\n\n案例:\n\n为emp表的dept_id字段添加外键约束,关联dept表的主键id。\n\nmariadb [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);\n\n\n添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。\n\n2). 删除外键\n\nalter table 表名 drop foreign key 外键名称;\n\n\n案例：\n\n删除emp表的外键fk_emp_dept_id。\n\nmariadb [test]> alter table emp drop foreign key fk_emp_dept_id;\n\n\n# 删除/更新行为\n\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种:\n\n行为            说明\nno action     当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 restrict 一致)\n              默认行为\nrestrict      当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 no action\n              一致) 默认行为\ncascade       当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。\nset null      当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。\nset default   父表有变更时，子表将外键列设置成一个默认的值 (innodb不支持)\n\n具体语法为:\n\nalter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名（主表字段名） on update cascade on delete cascade;\n\n\n演示如下：\n\n由于no action 是默认行为，我们前面语法演示的时候，已经测试过了，就不再演示了，这里我们再演示其他的两种行为：cascade、set null。\n\n1). cascade\n\nmariadb [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade;\n\n\na. 修改父表id为1的记录，将id修改为6\n\n\n\n我们发现，原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。\n\n> 在一般的业务系统中，不会修改一张表的主键值。\n\nb. 删除父表id为6的记录\n\n\n\n我们发现，父表的数据删除成功了，但是子表中关联的记录也被级联删除了。\n\n2). set null\n\n在进行测试之前，我们先需要删除上面建立的外键 fk_emp_dept_id。然后再通过数据脚本，将 emp、dept表的数据恢复了。\n\nmariadb [test]> alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null;\n\n\n接下来，我们删除id为1的数据，看看会发生什么样的现象。\n\n\n\n我们发现父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，我们发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为null了。\n\n\n\n这就是set null这种删除/更新行为的效果。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL多表查询",frontmatter:{title:"MySQL多表查询",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/7cdfba/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/07.MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2.html",relativePath:"01.指南/04.数据库/07.MySQL多表查询.md",key:"v-2ec934f2",path:"/pages/7cdfba/",headers:[{level:2,title:"多表关系",slug:"多表关系",normalizedTitle:"多表关系",charIndex:102},{level:3,title:"一对多",slug:"一对多",normalizedTitle:"一对多",charIndex:196},{level:3,title:"多对多",slug:"多对多",normalizedTitle:"多对多",charIndex:208},{level:3,title:"一对一",slug:"一对一",normalizedTitle:"一对一",charIndex:215},{level:2,title:"多表查询概述",slug:"多表查询概述",normalizedTitle:"多表查询概述",charIndex:2514},{level:3,title:"数据准备",slug:"数据准备",normalizedTitle:"数据准备",charIndex:2525},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2518},{level:3,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:4696},{level:2,title:"内连接",slug:"内连接",normalizedTitle:"内连接",charIndex:4709},{level:2,title:"外连接",slug:"外连接",normalizedTitle:"外连接",charIndex:4727},{level:2,title:"自连接",slug:"自连接",normalizedTitle:"自连接",charIndex:4791},{level:3,title:"自连接查询",slug:"自连接查询",normalizedTitle:"自连接查询",charIndex:6403},{level:3,title:"联合查询",slug:"联合查询",normalizedTitle:"联合查询",charIndex:7594},{level:2,title:"子查询",slug:"子查询",normalizedTitle:"子查询",charIndex:4817},{level:3,title:"概述",slug:"概述-2",normalizedTitle:"概述",charIndex:2518},{level:3,title:"标量子查询",slug:"标量子查询",normalizedTitle:"标量子查询",charIndex:8229},{level:3,title:"列子查询",slug:"列子查询",normalizedTitle:"列子查询",charIndex:8250},{level:3,title:"行子查询",slug:"行子查询",normalizedTitle:"行子查询",charIndex:8269},{level:3,title:"表子查询",slug:"表子查询",normalizedTitle:"表子查询",charIndex:8288},{level:3,title:"多表查询案例",slug:"多表查询案例",normalizedTitle:"多表查询案例",charIndex:17388}],headersStr:"多表关系 一对多 多对多 一对一 多表查询概述 数据准备 概述 分类 内连接 外连接 自连接 自连接查询 联合查询 子查询 概述 标量子查询 列子查询 行子查询 表子查询 多表查询案例",content:"# MySQL多表查询\n\n我们之前在讲解SQL语句的时候，讲解了DQL语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作，主要从以下几个方面进行讲解。\n\n\n# 多表关系\n\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n * 一对多(多对一)\n * 多对多\n * 一对一\n\n\n# 一对多\n\n> 案例: 部门 与 员工的关系\n> \n> 关系: 一个部门对应多个员工，一个员工对应一个部门实现: 在多的一方建立外键，指向一的一方的主键\n\n\n\n\n# 多对多\n\ncreate table student(\n    id int auto_increment primary key comment '主键ID',\n    name varchar(10) comment '姓名',\n    no varchar(10) comment '学号'\n) comment '学生表';\n\n\ninsert into student values (null, '黛绮丝', '2000100101'),(null, '谢逊','2000100102'),(null, '殷天正', '2000100103'),(null, '韦一笑', '2000100104');\n\ncreate table course(\n    id int auto_increment primary key comment '主键ID',\n    name varchar(10) comment '课程名称'\n) comment '课程表';\n\ninsert into course values (null, 'Java'), (null, 'PHP'), (null , 'MySQL') ,(null, 'Hadoop');\n\ncreate table student_course(\n    id int auto_increment comment '主键' primary key,\n    studentid int not null comment '学生ID',\n    courseid int not null comment '课程ID',\n    constraint fk_courseid foreign key (courseid) references course (id),\n    constraint fk_studentid foreign key (studentid) references student (id)\n)comment '学生课程中间表';\n\ninsert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,2),(null,2,3),(null,3,4);\n\n\n\n\n\n# 一对一\n\n案例: 用户 与 用户详情的关系\n\n关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n\ncreate table tb_user(\n\tid int auto_increment primary key comment '主键ID',\t\n\tname varchar(10) comment '姓名',\n\tage int comment '年龄',\n\tgender char(1) comment '1: 男 , 2: 女',\n\tphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\ncreate table tb_user_edu(\n\tid int auto_increment primary key comment '主键ID',\n\tdegree varchar(20) comment '学历',\n\tmajor varchar(50) comment '专业',\n\tprimaryschool varchar(50) comment '小学',\n\tmiddleschool varchar(50) comment '中学',\n    university varchar(50) comment '大学',\n\tuserid int unique comment '用户ID',\n\tconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\ninsert into tb_user(id, name, age, gender, phone) values\n\t(null,'黄渤',45,'1','18800001111'),\n\t(null,'冰冰',35,'2','18800002222'),\n\t(null,'码云',55,'1','18800008888'),\n\t(null,'李彦宏',50,'1','18800009999');\n\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,university, userid) values\n\t(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),\n\t(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),\n\t(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),\n\t(null,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);\n\n\n\n\n\n# 多表查询概述\n\n\n# 数据准备\n\n1). 删除之前 emp, dept表的测试数据\n\n2). 执行如下脚本，创建emp表与dept表并插入测试数据\n\n-- 创建dept表，并插入数据\ncreate table dept(\n    id int auto_increment comment 'ID' primary key,\n    name varchar(50) not null comment '部门名称'\n)comment '部门表';\n\nINSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4,'销售部'), (5, '总经办'), (6, '人事部');\n\n-- 创建emp表，并插入数据\ncreate table emp(\n    id int auto_increment comment 'ID' primary key,\n    name varchar(50) not null comment '姓名',\n    age int comment '年龄',\n    job varchar(20) comment '职位',\n    salary int comment '薪资',\n    entrydate date comment '入职时间',\n    managerid int comment '直属领导ID',\n    dept_id int comment '部门ID'\n)comment '员工表';\n\n-- 添加外键\nalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);\n\nINSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES\n(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),\n(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),\n(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),\n(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),\n(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),\n(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),\n(7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),\n(8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),\n(9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),\n(10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),\n(11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),\n(12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),\n(13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),\n(14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),\n(15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),\n(16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),\n(17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);\n\n\ndept表共6条记录，emp表共17条记录。\n\n\n# 概述\n\n多表查询就是指从多张表中查询数据。\n\n原来查询单表数据，执行的SQL形式为：select * from emp;\n\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept; 具体的执行结果如下:\n\n\n\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录\n\n(17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单介绍下笛卡尔积。\n\n笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。\n\n\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\n\n\n\n\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\n\nselect * from emp , dept where emp.dept_id = dept.id;\n\n\n\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。\n\n\n# 分类\n\n连接查询\n\n * 内连接：相当于查询A、B交集部分数据外连接：\n\n * 左外连接：查询左表所有数据，以及两张表交集部分数据右外连接：查询右表所有数据，以及两张表交集部分数据\n\n * 自连接：当前表与自身的连接查询，自连接必须使用表别名子查询\n\n\n# 内连接\n\n\n\n内连接查询的是两张表交集部分的数\n\n据。(也就是绿色部分的数据)\n\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构。\n\n1). 隐式内连接\n\nSELECT 字段列表 FROM 表1，表2 WHERE 条件...;\n\n\n2). 显式内连接\n\nSELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;\n\n\n案例:\n\nA. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)\n\n表结构: emp , dept 连接条件: emp.dept_id = dept.id\n\nMariaDB [test]> select emp.name ,dept.name from emp,dept where emp.dept_id = dept.id;\n\n// 如下是给表起一个别名更方便查看\nMariaDB [test]> select e.name,d.name from emp e,dept d where e.dept_id = d.id;\n\n\nB. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) --- INNER JOIN ... ON ...\n\n表结构: emp , dept 连接条件: emp.dept_id = dept.id\n\n表的别名:\n\n 1. tablea as 别名1 , tableb as 别名2 ;\n\n 2. tablea 别名1 , tableb 别名2 ;\n\nMariaDB [test]> select e.name,d.name from emp e inner join dept d on e.dept_id = d.id;\n\n\n> 注意事项: 一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字\n> \n> 段。\n\n\n# 外连接\n\n\n\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\n\n1). 左外连接\n\nSELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;\n\n\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n2). 右外连接\n\nSELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;\n\n\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n案例:\n\nA. 查询emp表的所有数据, 和对应的部门信息\n\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\n\n表结构: emp, dept\n\n连接条件: emp.dept_id = dept.id\n\nMariaDB [test]> select e.*,d.name from emp e left outer join  dept d on e.dept_id = d.id;\n\n\nB. 查询dept表的所有数据, 和对应的员工信息(右外连接) 由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\n\n表结构: emp, dept\n\n连接条件: emp.dept_id = dept.id\n\n> 注意事项：\n> \n> 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺\n> \n> 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n\nMariaDB [test]> select d.*,e.* from emp e right outer join  dept d on e.dept_id = d.id;\n\n\n\n# 自连接\n\n\n# 自连接查询\n\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。我们先来学习一下自连接的查询语法：\n\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;\n\n\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\n\n案例：\n\nA. 查询员工 及其 所属领导的名字 表结构: emp\n\nMariaDB [test]> select a.name,b.name from emp a,emp b where a.managerid = b.id;\n+--------+--------+\n| name   | name   |\n+--------+--------+\n| 张无忌 | 金庸   |\n| 杨逍   | 张无忌 |\n| 韦一笑 | 张无忌 |\n| 常遇春 | 杨逍   |\n| 小昭   | 张无忌 |\n| 灭绝   | 金庸   |\n| 周芷若 | 灭绝   |\n| 丁敏君 | 灭绝   |\n| 赵敏   | 金庸   |\n| 鹿杖客 | 赵敏   |\n| 鹤笔翁 | 赵敏   |\n| 方东白 | 赵敏   |\n| 张三丰 | 金庸   |\n| 俞莲舟 | 张三丰 |\n| 宋远桥 | 张三丰 |\n| 陈友谅 | 金庸   |\n+--------+--------+\n16 rows in set (0.00 sec)\n\n\nB. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来\n\n表结构: emp a , emp b\n\nMariaDB [test]> select a.name,b.name from emp a left join emp b on a.managerid = b.id;\n+--------+--------+\n| name   | name   |\n+--------+--------+\n| 金庸   | NULL   |\n| 张无忌 | 金庸   |\n| 杨逍   | 张无忌 |\n| 韦一笑 | 张无忌 |\n| 常遇春 | 杨逍   |\n| 小昭   | 张无忌 |\n| 灭绝   | 金庸   |\n| 周芷若 | 灭绝   |\n| 丁敏君 | 灭绝   |\n| 赵敏   | 金庸   |\n| 鹿杖客 | 赵敏   |\n| 鹤笔翁 | 赵敏   |\n| 方东白 | 赵敏   |\n| 张三丰 | 金庸   |\n| 俞莲舟 | 张三丰 |\n| 宋远桥 | 张三丰 |\n| 陈友谅 | 金庸   |\n+--------+--------+\n17 rows in set (0.00 sec)\n\n\n> 注意事项:\n> \n> 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底\n> \n> 是哪一张表的字段。\n\n\n# 联合查询\n\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\nSELECT 字段列表 FROM 表A ...\nUNION [ALL] \nSELECT 字段列表 FROM 表B ...\n\n\n案例:\n\nA. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.\n\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们也可以通过union/union all来联合查询.\n\nselect from emp where salary < 5000\nunion all\nselect from emp where age > 50;\n\n\nunion all查询出来的结果，仅仅进行简单的合并，并未去重。\n\n\n\nunion 联合查询，会对查询出来的结果进行去重处理。\n\n注意：\n\n如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：\n\n\n\n\n# 子查询\n\n\n# 概述\n\n1). 概念: SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\n\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);\n\n\n子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。\n\n2). 分类\n\n根据子查询结果不同，分为：\n\n * 标量子查询（子查询结果为单个值）\n\n * 列子查询(子查询结果为一列)\n\n * 行子查询(子查询结果为一行)\n\n * 表子查询(子查询结果为多行多列)\n\n根据子查询位置，分为：\n\n * WHERE之后\n\n * FROM之后\n\n * SELECT之后\n\n\n# 标量子查询\n\n子查询返回的结果是单个值（数字、字符串、日期等）， 简单的形式，这种子查询称为标量子查询。\n\n常用的操作符：= <> > >= < <=\n\n案例:\n\nA. 查询 \"销售部\" 的所有员工信息\n\n完成这个需求时，我们可以将需求分解为两步：\n\n 1. 查询 \"销售部\" 部门ID\n\n 2. 根据 \"销售部\" 部门ID, 查询员工信息\n\nmysql> select id from dept where name = '销售部';\n+----+\n| id |\n+----+\n|  4 |\n+----+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where dept_id = (select id from dept where name = '销售部');\n+----+--------+------+----------+--------+------------+-----------+---------+\n| id | name   | age  | job      | salary | entrydate  | managerid | dept_id |\n+----+--------+------+----------+--------+------------+-----------+---------+\n| 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 |\n| 15 | 俞莲舟 |   38 | 销售     |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售     |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+----------+--------+------------+-----------+---------+\n3 rows in set (0.00 sec)\n\n\nB. 查询在 \"方东白\" 入职之后的员工信息完成这个需求时，我们可以将需求分解为两步：\n\n 1. 查询 方东白 的入职日期\n\n 2. 查询指定入职日期之后入职的员工信息\n\nmysql> select entrydate from emp where name = '方东白';\n+------------+\n| entrydate  |\n+------------+\n| 2009-02-12 |\n+------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where entrydate > (select entrydate from emp where name = '方东白');\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |\n| 17 | 陈友谅 |   42 | NULL |   2000 | 2011-10-12 |         1 |    NULL |\n+----+--------+------+------+--------+------------+-----------+---------+\n2 rows in set (0.00 sec)\n\n\n\n# 列子查询\n\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。\n\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n操作符      描述\nIN       在指定的集合范围之内，多选一\nNOT IN   不在指定的集合范围之内\nANY      子查询返回列表中，有任意一个满足即可\nSOME     与ANY等同，使用SOME的地方都可以使用ANY\nALL      子查询返回列表的所有值都必须满足\n\n案例:\n\nA. 查询 \"销售部\" 和 \"市场部\" 的所有员工信息\n\n分解为以下两步:\n\n 1. 查询 \"销售部\" 和 \"市场部\" 的部门ID\n\n 2. 根据部门ID, 查询员工信息\n\nmysql> select id  from dept where name = '销售部' or name = '市场部';\n+----+\n| id |\n+----+\n|  2 |\n|  4 |\n+----+\n2 rows in set (0.00 sec)\n\nmysql> select * from emp where dept_id in (select id  from dept where name = '销售部' or name = '市场部');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 11 | 鹿杖客 |   56 | 职员       |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员       |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员       |   5500 | 2009-02-12 |        10 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n| 15 | 俞莲舟 |   38 | 销售       |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售       |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n7 rows in set (0.00 sec)\n\n\nB. 查询比 财务部 所有人工资都高的员工信息\n\n分解为以下两步:\n\n 1. 查询所有 财务部 人员工资\n\n 2. 比 财务部 所有人工资都高的员工信息\n\nmysql> select id  from dept where name = '财务部';\n+----+\n| id |\n+----+\n|  3 |\n+----+\n1 row in set (0.00 sec)\n\nmysql> select salary from emp where dept_id = (select id  from dept where name = '财务部');\n+--------+\n| salary |\n+--------+\n|   8500 |\n|  48000 |\n|   5250 |\n+--------+\n3 rows in set (0.00 sec)\n\nmysql> select * from emp where salary > all ( select salary from emp where dept_id = (select id from dept where name = '财务部') );\n\n\nC. 查询比研发部其中任意一人工资高的员工信息分解为以下两步:\n\n 1. 查询研发部所有人工资\n\n 2. 比研发部其中任意一人工资高的员工信息\n\nmysql> select salary from emp where dept_id = (select id  from dept where name = '研发部');\n+--------+\n| salary |\n+--------+\n|  12500 |\n|   8400 |\n|  11000 |\n|  10500 |\n|   6600 |\n+--------+\n5 rows in set (0.00 sec)\n\nmysql> select * from emp where salary > any (select salary from emp where dept_id = (select id  from dept where name = '研发部'));\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  3 | 杨逍   |   33 | 开发       |   8400 | 2000-11-03 |         2 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |\n|  7 | 灭绝   |   60 | 财务总监   |   8500 | 2002-09-12 |         1 |       3 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n9 rows in set (0.00 sec)\n\n\n\n# 行子查询\n\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。\n\n常用的操作符：= 、<> 、IN 、NOT IN\n\n案例:\n\nA. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ; 这个需求同样可以拆解为两步进行:\n\n 1. 查询 \"张无忌\" 的薪资及直属领导\n\n 2. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ;\n\nmysql> select salary,managerid from emp where name = '张无忌';\n+--------+-----------+\n| salary | managerid |\n+--------+-----------+\n|  12500 |         1 |\n+--------+-----------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where (salary,managerid) = (select salary,managerid from emp where name = '张无忌');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n2 rows in set (0.00 sec)\n\n\n\n# 表子查询\n\n子查询返回的结果是多行多列，这种子查询称为表子查询。\n\n常用的操作符：IN\n\n案例:\n\nA. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\n分解为两步执行:\n\n 1. 查询 \"鹿杖客\" , \"宋远桥\" 的职位和薪资\n\n 2. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\nmysql> select job,salary from emp where name = '鹿杖客' or name = '宋远桥';\n+------+--------+\n| job  | salary |\n+------+--------+\n| 职员 |   3750 |\n| 销售 |   4600 |\n+------+--------+\n2 rows in set (0.00 sec)\n\nmysql> select * from emp where (job,salary) in (select job,salary from emp where name = '鹿杖客' or name = '宋远桥');\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |\n| 15 | 俞莲舟 |   38 | 销售 |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售 |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+------+--------+------------+-----------+---------+\n4 rows in set (0.00 sec)\n\n\nB. 查询入职日期是 \"2006-01-01\" 之后的员工信息 , 及其部门信息分解为两步执行:\n\n 1. 入职日期是 \"2006-01-01\" 之后的员工信息\n\n 2. 查询这部分员工, 对应的部门信息;\n\nmysql> select * from emp where entrydate > '2006-01-01';\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n|  8 | 周芷若 |   19 | 会计 |  48000 | 2006-06-02 |         7 |       3 |\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员 |   5500 | 2009-02-12 |        10 |       2 |\n| 17 | 陈友谅 |   42 | NULL |   2000 | 2011-10-12 |         1 |    NULL |\n+----+--------+------+------+--------+------------+-----------+---------+\n6 rows in set (0.00 sec)\n\nmysql> select e.*,d.*  from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id;\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id | id   | name   |\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n|  8 | 周芷若 |   19 | 会计 |  48000 | 2006-06-02 |         7 |       3 |    3 | 财务部 |\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |    3 | 财务部 |\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |    2 | 市场部 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |    2 | 市场部 |\n| 13 | 方东白 |   19 | 职员 |   5500 | 2009-02-12 |        10 |       2 |    2 | 市场部 |\n| 17 | 陈友谅 |   42 | NULL |   2000 | 2011-10-12 |         1 |    NULL | NULL | NULL   |\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n6 rows in set (0.00 sec)\n\n\n\n# 多表查询案例\n\n数据环境准备:\n\ncreate table salgrade(\n\tgrade int,\n\tlosal int,\n\thisal int\n) comment '薪资等级表';\n\ninsert into salgrade values (1,0,3000);\ninsert into salgrade values (2,3001,5000);\ninsert into salgrade values (3,5001,8000);\ninsert into salgrade values (4,8001,10000);\ninsert into salgrade values (5,10001,15000);\ninsert into salgrade values (6,15001,20000);\ninsert into salgrade values (7,20001,25000);\ninsert into salgrade values (8,25001,30000);\n\n\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\n\n1). 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.name,e.age,e.job,d.name from emp e,dept d where e.dept_id = d.id;\n+--------+------+--------------+--------+\n| name   | age  | job          | name   |\n+--------+------+--------------+--------+\n| 张无忌 |   20 | 项目经理     | 研发部 |\n| 杨逍   |   33 | 开发         | 研发部 |\n| 韦一笑 |   48 | 开发         | 研发部 |\n| 常遇春 |   43 | 开发         | 研发部 |\n| 小昭   |   19 | 程序员鼓励师 | 研发部 |\n| 赵敏   |   20 | 市场部总监   | 市场部 |\n| 鹿杖客 |   56 | 职员         | 市场部 |\n| 鹤笔翁 |   19 | 职员         | 市场部 |\n| 方东白 |   19 | 职员         | 市场部 |\n| 灭绝   |   60 | 财务总监     | 财务部 |\n| 周芷若 |   19 | 会计         | 财务部 |\n| 丁敏君 |   23 | 出纳         | 财务部 |\n| 张三丰 |   88 | 销售总监     | 销售部 |\n| 俞莲舟 |   38 | 销售         | 销售部 |\n| 宋远桥 |   40 | 销售         | 销售部 |\n| 金庸   |   66 | 总裁         | 总经办 |\n+--------+------+--------------+--------+\n16 rows in set (0.00 sec)\n\n\n2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.name,e.age,e.job,d.name from emp e inner join dept d on e.dept_id = d.id where e.age < 30; \n+--------+------+--------------+--------+\n| name   | age  | job          | name   |\n+--------+------+--------------+--------+\n| 张无忌 |   20 | 项目经理     | 研发部 |\n| 小昭   |   19 | 程序员鼓励师 | 研发部 |\n| 周芷若 |   19 | 会计         | 财务部 |\n| 丁敏君 |   23 | 出纳         | 财务部 |\n| 赵敏   |   20 | 市场部总监   | 市场部 |\n| 鹤笔翁 |   19 | 职员         | 市场部 |\n| 方东白 |   19 | 职员         | 市场部 |\n+--------+------+--------------+--------+\n7 rows in set (0.00 sec)\n\n\n3). 查询拥有员工的部门ID、部门名称\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select distinct d.id,d.name from emp e,dept d where e.dept_id = d.id;\n+----+--------+\n| id | name   |\n+----+--------+\n|  1 | 研发部 |\n|  2 | 市场部 |\n|  3 | 财务部 |\n|  4 | 销售部 |\n|  5 | 总经办 |\n+----+--------+\n5 rows in set (0.00 sec)\n\n\n4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.*,d.name from emp e left join dept d on e.dept_id = d.id where age > 40;\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n| id | name   | age  | job      | salary | entrydate  | managerid | dept_id | name   |\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n|  1 | 金庸   |   66 | 总裁     |  20000 | 2000-01-01 |      NULL |       5 | 总经办 |\n|  4 | 韦一笑 |   48 | 开发     |  11000 | 2002-02-05 |         2 |       1 | 研发部 |\n|  5 | 常遇春 |   43 | 开发     |  10500 | 2004-09-07 |         3 |       1 | 研发部 |\n|  7 | 灭绝   |   60 | 财务总监 |   8500 | 2002-09-12 |         1 |       3 | 财务部 |\n| 11 | 鹿杖客 |   56 | 职员     |   3750 | 2006-10-03 |        10 |       2 | 市场部 |\n| 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 | 销售部 |\n| 17 | 陈友谅 |   42 | NULL     |   2000 | 2011-10-12 |         1 |    NULL | NULL   |\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n7 rows in set (0.00 sec)\n\n\n5). 查询所有员工的工资等级\n\n表: emp , salgrade\n\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\n\nmysql> select e.*,s.grade from emp e ,salgrade s where e.salary >= s.losal and e.salary <= s.hisal;\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | grade |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n|  1 | 金庸   |   66 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |     6 |\n|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |     5 |\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |     4 |\n|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |     5 |\n|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |     5 |\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |     3 |\n|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |     4 |\n|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |     3 |\n| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |     5 |\n| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |     2 |\n| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |     2 |\n| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |     3 |\n| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |     5 |\n| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |     2 |\n| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |     2 |\n| 17 | 陈友谅 |   42 | NULL         |   2000 | 2011-10-12 |         1 |    NULL |     1 |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n16 rows in set (0.00 sec)\n\n\n6). 查询 \"研发部\" 所有员工的信息及 工资等级\n\n表: emp , salgrade , dept\n\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id\n\n查询条件 : dept.name = '研发部'\n\nmysql> select e.*,s.grade from emp e,dept d, salgrade s where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发部';\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | grade |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |     3 |\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |     4 |\n|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |     5 |\n|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |     5 |\n|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |     5 |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n5 rows in set (0.00 sec)\n\n\n\n7). 查询 \"研发部\" 员工的平均工资\n\n表: emp , dept\n\n连接条件 : emp.dept_id = dept.id\n\nmysql> select avg(e.salary) from emp e,dept d where e.dept_id = d.id and d.name = '研发部';\n+---------------+\n| avg(e.salary) |\n+---------------+\n|     9800.0000 |\n+---------------+\n1 row in set (0.00 sec)\n\n\n8). 查询工资比 \"灭绝\" 高的员工信息。\n\n 1. 查询 \"灭绝\" 的薪资\n\n 2. 查询比她工资高的员工数据\n\nmysql> select salary from emp where name = '灭绝';\n+--------+\n| salary |\n+--------+\n|   8500 |\n+--------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where salary > (select salary from emp where name = '灭绝');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n7 rows in set (0.00 sec)\n\n\n9). 查询比平均薪资高的员工信息\n\n 1. 查询员工的平均薪资\n\n 2. 查询比平均薪资高的员工信息\n\nmysql> select avg(salary) from emp;\n+-------------+\n| avg(salary) |\n+-------------+\n|  10673.5294 |\n+-------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where salary > (select avg(salary) from emp);\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n6 rows in set (0.00 sec)\n\n\n10). 查询低于本部门平均工资的员工信息\n\n 1. 查询指定部门平均薪资\n\n 2. 查询低于本部门平均工资的员工信息\n\nmysql> select avg(e1.salary) from emp e1 where e1.dept_id = 1;\n+----------------+\n| avg(e1.salary) |\n+----------------+\n|      9800.0000 |\n+----------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp e2 where e2.salary < (select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);\n+----+--------+------+--------------+--------+------------+-----------+---------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id |\n+----+--------+------+--------------+--------+------------+-----------+---------+\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |\n|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |\n|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |\n| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |\n| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+--------------+--------+------------+-----------+---------+\n9 rows in set (0.00 sec)\n\n\n11). 查询所有的部门信息, 并统计部门的员工人数\n\nmysql> select count(*) from emp where dept_id = 1;\n+----------+\n| count(*) |\n+----------+\n|        5 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql> select d.id,d.name,(select count(*) from emp e where e.dept_id =d.id) '人数' from dept d;\n+------+--------+------+\n| id   | name   | 人数 |\n+------+--------+------+\n|    1 | 研发部 |    5 |\n|    2 | 市场部 |    4 |\n|    3 | 财务部 |    3 |\n|    4 | 销售部 |    3 |\n|    5 | 总经办 |    1 |\n|    6 | 人事部 |    0 |\n+------+--------+------+\n6 rows in set (0.00 sec)\n\n\n12). 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n表: student , course , student_course\n\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\n\nmysql> select s.name,s.no,c.name from student s,student_course sc,course c where s.id = sc.studentid and sc.courseid = c.id;\n+--------+------------+--------+\n| name   | no         | name   |\n+--------+------------+--------+\n| 黛绮丝 | 2000100101 | Java   |\n| 黛绮丝 | 2000100101 | PHP    |\n| 黛绮丝 | 2000100101 | MySQL  |\n| 谢逊   | 2000100102 | PHP    |\n| 谢逊   | 2000100102 | MySQL  |\n| 殷天正 | 2000100103 | Hadoop |\n+--------+------------+--------+\n6 rows in set (0.00 sec)\n\n\n> 备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条件的记录即可。\n\n",normalizedContent:"# mysql多表查询\n\n我们之前在讲解sql语句的时候，讲解了dql语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作，主要从以下几个方面进行讲解。\n\n\n# 多表关系\n\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n * 一对多(多对一)\n * 多对多\n * 一对一\n\n\n# 一对多\n\n> 案例: 部门 与 员工的关系\n> \n> 关系: 一个部门对应多个员工，一个员工对应一个部门实现: 在多的一方建立外键，指向一的一方的主键\n\n\n\n\n# 多对多\n\ncreate table student(\n    id int auto_increment primary key comment '主键id',\n    name varchar(10) comment '姓名',\n    no varchar(10) comment '学号'\n) comment '学生表';\n\n\ninsert into student values (null, '黛绮丝', '2000100101'),(null, '谢逊','2000100102'),(null, '殷天正', '2000100103'),(null, '韦一笑', '2000100104');\n\ncreate table course(\n    id int auto_increment primary key comment '主键id',\n    name varchar(10) comment '课程名称'\n) comment '课程表';\n\ninsert into course values (null, 'java'), (null, 'php'), (null , 'mysql') ,(null, 'hadoop');\n\ncreate table student_course(\n    id int auto_increment comment '主键' primary key,\n    studentid int not null comment '学生id',\n    courseid int not null comment '课程id',\n    constraint fk_courseid foreign key (courseid) references course (id),\n    constraint fk_studentid foreign key (studentid) references student (id)\n)comment '学生课程中间表';\n\ninsert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,2),(null,2,3),(null,3,4);\n\n\n\n\n\n# 一对一\n\n案例: 用户 与 用户详情的关系\n\n关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）\n\ncreate table tb_user(\n\tid int auto_increment primary key comment '主键id',\t\n\tname varchar(10) comment '姓名',\n\tage int comment '年龄',\n\tgender char(1) comment '1: 男 , 2: 女',\n\tphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\ncreate table tb_user_edu(\n\tid int auto_increment primary key comment '主键id',\n\tdegree varchar(20) comment '学历',\n\tmajor varchar(50) comment '专业',\n\tprimaryschool varchar(50) comment '小学',\n\tmiddleschool varchar(50) comment '中学',\n    university varchar(50) comment '大学',\n\tuserid int unique comment '用户id',\n\tconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\ninsert into tb_user(id, name, age, gender, phone) values\n\t(null,'黄渤',45,'1','18800001111'),\n\t(null,'冰冰',35,'2','18800002222'),\n\t(null,'码云',55,'1','18800008888'),\n\t(null,'李彦宏',50,'1','18800009999');\n\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,university, userid) values\n\t(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),\n\t(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),\n\t(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),\n\t(null,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);\n\n\n\n\n\n# 多表查询概述\n\n\n# 数据准备\n\n1). 删除之前 emp, dept表的测试数据\n\n2). 执行如下脚本，创建emp表与dept表并插入测试数据\n\n-- 创建dept表，并插入数据\ncreate table dept(\n    id int auto_increment comment 'id' primary key,\n    name varchar(50) not null comment '部门名称'\n)comment '部门表';\n\ninsert into dept (id, name) values (1, '研发部'), (2, '市场部'),(3, '财务部'), (4,'销售部'), (5, '总经办'), (6, '人事部');\n\n-- 创建emp表，并插入数据\ncreate table emp(\n    id int auto_increment comment 'id' primary key,\n    name varchar(50) not null comment '姓名',\n    age int comment '年龄',\n    job varchar(20) comment '职位',\n    salary int comment '薪资',\n    entrydate date comment '入职时间',\n    managerid int comment '直属领导id',\n    dept_id int comment '部门id'\n)comment '员工表';\n\n-- 添加外键\nalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);\n\ninsert into emp (id, name, age, job,salary, entrydate, managerid, dept_id) values\n(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),\n(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),\n(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),\n(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),\n(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),\n(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),\n(7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),\n(8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),\n(9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),\n(10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),\n(11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),\n(12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),\n(13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),\n(14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),\n(15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),\n(16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),\n(17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);\n\n\ndept表共6条记录，emp表共17条记录。\n\n\n# 概述\n\n多表查询就是指从多张表中查询数据。\n\n原来查询单表数据，执行的sql形式为：select * from emp;\n\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept; 具体的执行结果如下:\n\n\n\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录\n\n(17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单介绍下笛卡尔积。\n\n笛卡尔积: 笛卡尔乘积是指在数学中，两个集合a集合 和 b集合的所有组合情况。\n\n\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\n\n\n\n\n在sql语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\n\nselect * from emp , dept where emp.dept_id = dept.id;\n\n\n\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。\n\n\n# 分类\n\n连接查询\n\n * 内连接：相当于查询a、b交集部分数据外连接：\n\n * 左外连接：查询左表所有数据，以及两张表交集部分数据右外连接：查询右表所有数据，以及两张表交集部分数据\n\n * 自连接：当前表与自身的连接查询，自连接必须使用表别名子查询\n\n\n# 内连接\n\n\n\n内连接查询的是两张表交集部分的数\n\n据。(也就是绿色部分的数据)\n\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构。\n\n1). 隐式内连接\n\nselect 字段列表 from 表1，表2 where 条件...;\n\n\n2). 显式内连接\n\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件...;\n\n\n案例:\n\na. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)\n\n表结构: emp , dept 连接条件: emp.dept_id = dept.id\n\nmariadb [test]> select emp.name ,dept.name from emp,dept where emp.dept_id = dept.id;\n\n// 如下是给表起一个别名更方便查看\nmariadb [test]> select e.name,d.name from emp e,dept d where e.dept_id = d.id;\n\n\nb. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) --- inner join ... on ...\n\n表结构: emp , dept 连接条件: emp.dept_id = dept.id\n\n表的别名:\n\n 1. tablea as 别名1 , tableb as 别名2 ;\n\n 2. tablea 别名1 , tableb 别名2 ;\n\nmariadb [test]> select e.name,d.name from emp e inner join dept d on e.dept_id = d.id;\n\n\n> 注意事项: 一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字\n> \n> 段。\n\n\n# 外连接\n\n\n\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\n\n1). 左外连接\n\nselect 字段列表 from 表1 left [outer] join 表2 on 条件...;\n\n\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n2). 右外连接\n\nselect 字段列表 from 表1 right [outer] join 表2 on 条件...;\n\n\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n案例:\n\na. 查询emp表的所有数据, 和对应的部门信息\n\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\n\n表结构: emp, dept\n\n连接条件: emp.dept_id = dept.id\n\nmariadb [test]> select e.*,d.name from emp e left outer join  dept d on e.dept_id = d.id;\n\n\nb. 查询dept表的所有数据, 和对应的员工信息(右外连接) 由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\n\n表结构: emp, dept\n\n连接条件: emp.dept_id = dept.id\n\n> 注意事项：\n> \n> 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时sql中，表结构的先后顺\n> \n> 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n\nmariadb [test]> select d.*,e.* from emp e right outer join  dept d on e.dept_id = d.id;\n\n\n\n# 自连接\n\n\n# 自连接查询\n\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。我们先来学习一下自连接的查询语法：\n\nselect 字段列表 from 表a 别名a join 表a 别名b on 条件...;\n\n\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\n\n案例：\n\na. 查询员工 及其 所属领导的名字 表结构: emp\n\nmariadb [test]> select a.name,b.name from emp a,emp b where a.managerid = b.id;\n+--------+--------+\n| name   | name   |\n+--------+--------+\n| 张无忌 | 金庸   |\n| 杨逍   | 张无忌 |\n| 韦一笑 | 张无忌 |\n| 常遇春 | 杨逍   |\n| 小昭   | 张无忌 |\n| 灭绝   | 金庸   |\n| 周芷若 | 灭绝   |\n| 丁敏君 | 灭绝   |\n| 赵敏   | 金庸   |\n| 鹿杖客 | 赵敏   |\n| 鹤笔翁 | 赵敏   |\n| 方东白 | 赵敏   |\n| 张三丰 | 金庸   |\n| 俞莲舟 | 张三丰 |\n| 宋远桥 | 张三丰 |\n| 陈友谅 | 金庸   |\n+--------+--------+\n16 rows in set (0.00 sec)\n\n\nb. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来\n\n表结构: emp a , emp b\n\nmariadb [test]> select a.name,b.name from emp a left join emp b on a.managerid = b.id;\n+--------+--------+\n| name   | name   |\n+--------+--------+\n| 金庸   | null   |\n| 张无忌 | 金庸   |\n| 杨逍   | 张无忌 |\n| 韦一笑 | 张无忌 |\n| 常遇春 | 杨逍   |\n| 小昭   | 张无忌 |\n| 灭绝   | 金庸   |\n| 周芷若 | 灭绝   |\n| 丁敏君 | 灭绝   |\n| 赵敏   | 金庸   |\n| 鹿杖客 | 赵敏   |\n| 鹤笔翁 | 赵敏   |\n| 方东白 | 赵敏   |\n| 张三丰 | 金庸   |\n| 俞莲舟 | 张三丰 |\n| 宋远桥 | 张三丰 |\n| 陈友谅 | 金庸   |\n+--------+--------+\n17 rows in set (0.00 sec)\n\n\n> 注意事项:\n> \n> 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底\n> \n> 是哪一张表的字段。\n\n\n# 联合查询\n\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\nselect 字段列表 from 表a ...\nunion [all] \nselect 字段列表 from 表b ...\n\n\n案例:\n\na. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.\n\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们也可以通过union/union all来联合查询.\n\nselect from emp where salary < 5000\nunion all\nselect from emp where age > 50;\n\n\nunion all查询出来的结果，仅仅进行简单的合并，并未去重。\n\n\n\nunion 联合查询，会对查询出来的结果进行去重处理。\n\n注意：\n\n如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：\n\n\n\n\n# 子查询\n\n\n# 概述\n\n1). 概念: sql语句中嵌套select语句，称为嵌套查询，又称子查询。\n\nselect * from t1 where column1 = (select column1 from t2);\n\n\n子查询外部的语句可以是insert / update / delete / select 的任何一个。\n\n2). 分类\n\n根据子查询结果不同，分为：\n\n * 标量子查询（子查询结果为单个值）\n\n * 列子查询(子查询结果为一列)\n\n * 行子查询(子查询结果为一行)\n\n * 表子查询(子查询结果为多行多列)\n\n根据子查询位置，分为：\n\n * where之后\n\n * from之后\n\n * select之后\n\n\n# 标量子查询\n\n子查询返回的结果是单个值（数字、字符串、日期等）， 简单的形式，这种子查询称为标量子查询。\n\n常用的操作符：= <> > >= < <=\n\n案例:\n\na. 查询 \"销售部\" 的所有员工信息\n\n完成这个需求时，我们可以将需求分解为两步：\n\n 1. 查询 \"销售部\" 部门id\n\n 2. 根据 \"销售部\" 部门id, 查询员工信息\n\nmysql> select id from dept where name = '销售部';\n+----+\n| id |\n+----+\n|  4 |\n+----+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where dept_id = (select id from dept where name = '销售部');\n+----+--------+------+----------+--------+------------+-----------+---------+\n| id | name   | age  | job      | salary | entrydate  | managerid | dept_id |\n+----+--------+------+----------+--------+------------+-----------+---------+\n| 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 |\n| 15 | 俞莲舟 |   38 | 销售     |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售     |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+----------+--------+------------+-----------+---------+\n3 rows in set (0.00 sec)\n\n\nb. 查询在 \"方东白\" 入职之后的员工信息完成这个需求时，我们可以将需求分解为两步：\n\n 1. 查询 方东白 的入职日期\n\n 2. 查询指定入职日期之后入职的员工信息\n\nmysql> select entrydate from emp where name = '方东白';\n+------------+\n| entrydate  |\n+------------+\n| 2009-02-12 |\n+------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where entrydate > (select entrydate from emp where name = '方东白');\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |\n| 17 | 陈友谅 |   42 | null |   2000 | 2011-10-12 |         1 |    null |\n+----+--------+------+------+--------+------------+-----------+---------+\n2 rows in set (0.00 sec)\n\n\n\n# 列子查询\n\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。\n\n常用的操作符：in 、not in 、 any 、some 、 all\n\n操作符      描述\nin       在指定的集合范围之内，多选一\nnot in   不在指定的集合范围之内\nany      子查询返回列表中，有任意一个满足即可\nsome     与any等同，使用some的地方都可以使用any\nall      子查询返回列表的所有值都必须满足\n\n案例:\n\na. 查询 \"销售部\" 和 \"市场部\" 的所有员工信息\n\n分解为以下两步:\n\n 1. 查询 \"销售部\" 和 \"市场部\" 的部门id\n\n 2. 根据部门id, 查询员工信息\n\nmysql> select id  from dept where name = '销售部' or name = '市场部';\n+----+\n| id |\n+----+\n|  2 |\n|  4 |\n+----+\n2 rows in set (0.00 sec)\n\nmysql> select * from emp where dept_id in (select id  from dept where name = '销售部' or name = '市场部');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 11 | 鹿杖客 |   56 | 职员       |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员       |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员       |   5500 | 2009-02-12 |        10 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n| 15 | 俞莲舟 |   38 | 销售       |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售       |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n7 rows in set (0.00 sec)\n\n\nb. 查询比 财务部 所有人工资都高的员工信息\n\n分解为以下两步:\n\n 1. 查询所有 财务部 人员工资\n\n 2. 比 财务部 所有人工资都高的员工信息\n\nmysql> select id  from dept where name = '财务部';\n+----+\n| id |\n+----+\n|  3 |\n+----+\n1 row in set (0.00 sec)\n\nmysql> select salary from emp where dept_id = (select id  from dept where name = '财务部');\n+--------+\n| salary |\n+--------+\n|   8500 |\n|  48000 |\n|   5250 |\n+--------+\n3 rows in set (0.00 sec)\n\nmysql> select * from emp where salary > all ( select salary from emp where dept_id = (select id from dept where name = '财务部') );\n\n\nc. 查询比研发部其中任意一人工资高的员工信息分解为以下两步:\n\n 1. 查询研发部所有人工资\n\n 2. 比研发部其中任意一人工资高的员工信息\n\nmysql> select salary from emp where dept_id = (select id  from dept where name = '研发部');\n+--------+\n| salary |\n+--------+\n|  12500 |\n|   8400 |\n|  11000 |\n|  10500 |\n|   6600 |\n+--------+\n5 rows in set (0.00 sec)\n\nmysql> select * from emp where salary > any (select salary from emp where dept_id = (select id  from dept where name = '研发部'));\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      null |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  3 | 杨逍   |   33 | 开发       |   8400 | 2000-11-03 |         2 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |\n|  7 | 灭绝   |   60 | 财务总监   |   8500 | 2002-09-12 |         1 |       3 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n9 rows in set (0.00 sec)\n\n\n\n# 行子查询\n\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。\n\n常用的操作符：= 、<> 、in 、not in\n\n案例:\n\na. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ; 这个需求同样可以拆解为两步进行:\n\n 1. 查询 \"张无忌\" 的薪资及直属领导\n\n 2. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ;\n\nmysql> select salary,managerid from emp where name = '张无忌';\n+--------+-----------+\n| salary | managerid |\n+--------+-----------+\n|  12500 |         1 |\n+--------+-----------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where (salary,managerid) = (select salary,managerid from emp where name = '张无忌');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n2 rows in set (0.00 sec)\n\n\n\n# 表子查询\n\n子查询返回的结果是多行多列，这种子查询称为表子查询。\n\n常用的操作符：in\n\n案例:\n\na. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\n分解为两步执行:\n\n 1. 查询 \"鹿杖客\" , \"宋远桥\" 的职位和薪资\n\n 2. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\nmysql> select job,salary from emp where name = '鹿杖客' or name = '宋远桥';\n+------+--------+\n| job  | salary |\n+------+--------+\n| 职员 |   3750 |\n| 销售 |   4600 |\n+------+--------+\n2 rows in set (0.00 sec)\n\nmysql> select * from emp where (job,salary) in (select job,salary from emp where name = '鹿杖客' or name = '宋远桥');\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |\n| 15 | 俞莲舟 |   38 | 销售 |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售 |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+------+--------+------------+-----------+---------+\n4 rows in set (0.00 sec)\n\n\nb. 查询入职日期是 \"2006-01-01\" 之后的员工信息 , 及其部门信息分解为两步执行:\n\n 1. 入职日期是 \"2006-01-01\" 之后的员工信息\n\n 2. 查询这部分员工, 对应的部门信息;\n\nmysql> select * from emp where entrydate > '2006-01-01';\n+----+--------+------+------+--------+------------+-----------+---------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------+--------+------------+-----------+---------+\n|  8 | 周芷若 |   19 | 会计 |  48000 | 2006-06-02 |         7 |       3 |\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员 |   5500 | 2009-02-12 |        10 |       2 |\n| 17 | 陈友谅 |   42 | null |   2000 | 2011-10-12 |         1 |    null |\n+----+--------+------+------+--------+------------+-----------+---------+\n6 rows in set (0.00 sec)\n\nmysql> select e.*,d.*  from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id;\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n| id | name   | age  | job  | salary | entrydate  | managerid | dept_id | id   | name   |\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n|  8 | 周芷若 |   19 | 会计 |  48000 | 2006-06-02 |         7 |       3 |    3 | 财务部 |\n|  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3 |    3 | 财务部 |\n| 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2 |    2 | 市场部 |\n| 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |    2 | 市场部 |\n| 13 | 方东白 |   19 | 职员 |   5500 | 2009-02-12 |        10 |       2 |    2 | 市场部 |\n| 17 | 陈友谅 |   42 | null |   2000 | 2011-10-12 |         1 |    null | null | null   |\n+----+--------+------+------+--------+------------+-----------+---------+------+--------+\n6 rows in set (0.00 sec)\n\n\n\n# 多表查询案例\n\n数据环境准备:\n\ncreate table salgrade(\n\tgrade int,\n\tlosal int,\n\thisal int\n) comment '薪资等级表';\n\ninsert into salgrade values (1,0,3000);\ninsert into salgrade values (2,3001,5000);\ninsert into salgrade values (3,5001,8000);\ninsert into salgrade values (4,8001,10000);\ninsert into salgrade values (5,10001,15000);\ninsert into salgrade values (6,15001,20000);\ninsert into salgrade values (7,20001,25000);\ninsert into salgrade values (8,25001,30000);\n\n\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\n\n1). 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.name,e.age,e.job,d.name from emp e,dept d where e.dept_id = d.id;\n+--------+------+--------------+--------+\n| name   | age  | job          | name   |\n+--------+------+--------------+--------+\n| 张无忌 |   20 | 项目经理     | 研发部 |\n| 杨逍   |   33 | 开发         | 研发部 |\n| 韦一笑 |   48 | 开发         | 研发部 |\n| 常遇春 |   43 | 开发         | 研发部 |\n| 小昭   |   19 | 程序员鼓励师 | 研发部 |\n| 赵敏   |   20 | 市场部总监   | 市场部 |\n| 鹿杖客 |   56 | 职员         | 市场部 |\n| 鹤笔翁 |   19 | 职员         | 市场部 |\n| 方东白 |   19 | 职员         | 市场部 |\n| 灭绝   |   60 | 财务总监     | 财务部 |\n| 周芷若 |   19 | 会计         | 财务部 |\n| 丁敏君 |   23 | 出纳         | 财务部 |\n| 张三丰 |   88 | 销售总监     | 销售部 |\n| 俞莲舟 |   38 | 销售         | 销售部 |\n| 宋远桥 |   40 | 销售         | 销售部 |\n| 金庸   |   66 | 总裁         | 总经办 |\n+--------+------+--------------+--------+\n16 rows in set (0.00 sec)\n\n\n2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.name,e.age,e.job,d.name from emp e inner join dept d on e.dept_id = d.id where e.age < 30; \n+--------+------+--------------+--------+\n| name   | age  | job          | name   |\n+--------+------+--------------+--------+\n| 张无忌 |   20 | 项目经理     | 研发部 |\n| 小昭   |   19 | 程序员鼓励师 | 研发部 |\n| 周芷若 |   19 | 会计         | 财务部 |\n| 丁敏君 |   23 | 出纳         | 财务部 |\n| 赵敏   |   20 | 市场部总监   | 市场部 |\n| 鹤笔翁 |   19 | 职员         | 市场部 |\n| 方东白 |   19 | 职员         | 市场部 |\n+--------+------+--------------+--------+\n7 rows in set (0.00 sec)\n\n\n3). 查询拥有员工的部门id、部门名称\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select distinct d.id,d.name from emp e,dept d where e.dept_id = d.id;\n+----+--------+\n| id | name   |\n+----+--------+\n|  1 | 研发部 |\n|  2 | 市场部 |\n|  3 | 财务部 |\n|  4 | 销售部 |\n|  5 | 总经办 |\n+----+--------+\n5 rows in set (0.00 sec)\n\n\n4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)\n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\nmysql> select e.*,d.name from emp e left join dept d on e.dept_id = d.id where age > 40;\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n| id | name   | age  | job      | salary | entrydate  | managerid | dept_id | name   |\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n|  1 | 金庸   |   66 | 总裁     |  20000 | 2000-01-01 |      null |       5 | 总经办 |\n|  4 | 韦一笑 |   48 | 开发     |  11000 | 2002-02-05 |         2 |       1 | 研发部 |\n|  5 | 常遇春 |   43 | 开发     |  10500 | 2004-09-07 |         3 |       1 | 研发部 |\n|  7 | 灭绝   |   60 | 财务总监 |   8500 | 2002-09-12 |         1 |       3 | 财务部 |\n| 11 | 鹿杖客 |   56 | 职员     |   3750 | 2006-10-03 |        10 |       2 | 市场部 |\n| 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 | 销售部 |\n| 17 | 陈友谅 |   42 | null     |   2000 | 2011-10-12 |         1 |    null | null   |\n+----+--------+------+----------+--------+------------+-----------+---------+--------+\n7 rows in set (0.00 sec)\n\n\n5). 查询所有员工的工资等级\n\n表: emp , salgrade\n\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\n\nmysql> select e.*,s.grade from emp e ,salgrade s where e.salary >= s.losal and e.salary <= s.hisal;\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | grade |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n|  1 | 金庸   |   66 | 总裁         |  20000 | 2000-01-01 |      null |       5 |     6 |\n|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |     5 |\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |     4 |\n|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |     5 |\n|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |     5 |\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |     3 |\n|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |     4 |\n|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |     3 |\n| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |     5 |\n| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |     2 |\n| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |     2 |\n| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |     3 |\n| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |     5 |\n| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |     2 |\n| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |     2 |\n| 17 | 陈友谅 |   42 | null         |   2000 | 2011-10-12 |         1 |    null |     1 |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n16 rows in set (0.00 sec)\n\n\n6). 查询 \"研发部\" 所有员工的信息及 工资等级\n\n表: emp , salgrade , dept\n\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id\n\n查询条件 : dept.name = '研发部'\n\nmysql> select e.*,s.grade from emp e,dept d, salgrade s where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发部';\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | grade |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |     3 |\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |     4 |\n|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |     5 |\n|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |     5 |\n|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |     5 |\n+----+--------+------+--------------+--------+------------+-----------+---------+-------+\n5 rows in set (0.00 sec)\n\n\n\n7). 查询 \"研发部\" 员工的平均工资\n\n表: emp , dept\n\n连接条件 : emp.dept_id = dept.id\n\nmysql> select avg(e.salary) from emp e,dept d where e.dept_id = d.id and d.name = '研发部';\n+---------------+\n| avg(e.salary) |\n+---------------+\n|     9800.0000 |\n+---------------+\n1 row in set (0.00 sec)\n\n\n8). 查询工资比 \"灭绝\" 高的员工信息。\n\n 1. 查询 \"灭绝\" 的薪资\n\n 2. 查询比她工资高的员工数据\n\nmysql> select salary from emp where name = '灭绝';\n+--------+\n| salary |\n+--------+\n|   8500 |\n+--------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where salary > (select salary from emp where name = '灭绝');\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      null |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n7 rows in set (0.00 sec)\n\n\n9). 查询比平均薪资高的员工信息\n\n 1. 查询员工的平均薪资\n\n 2. 查询比平均薪资高的员工信息\n\nmysql> select avg(salary) from emp;\n+-------------+\n| avg(salary) |\n+-------------+\n|  10673.5294 |\n+-------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp where salary > (select avg(salary) from emp);\n+----+--------+------+------------+--------+------------+-----------+---------+\n| id | name   | age  | job        | salary | entrydate  | managerid | dept_id |\n+----+--------+------+------------+--------+------------+-----------+---------+\n|  1 | 金庸   |   66 | 总裁       |  20000 | 2000-01-01 |      null |       5 |\n|  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |\n|  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |\n|  8 | 周芷若 |   19 | 会计       |  48000 | 2006-06-02 |         7 |       3 |\n| 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |\n| 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |\n+----+--------+------+------------+--------+------------+-----------+---------+\n6 rows in set (0.00 sec)\n\n\n10). 查询低于本部门平均工资的员工信息\n\n 1. 查询指定部门平均薪资\n\n 2. 查询低于本部门平均工资的员工信息\n\nmysql> select avg(e1.salary) from emp e1 where e1.dept_id = 1;\n+----------------+\n| avg(e1.salary) |\n+----------------+\n|      9800.0000 |\n+----------------+\n1 row in set (0.00 sec)\n\nmysql> select * from emp e2 where e2.salary < (select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);\n+----+--------+------+--------------+--------+------------+-----------+---------+\n| id | name   | age  | job          | salary | entrydate  | managerid | dept_id |\n+----+--------+------+--------------+--------+------------+-----------+---------+\n|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |\n|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |\n|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |\n|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |\n| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |\n| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |\n| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |\n| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |\n| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |\n+----+--------+------+--------------+--------+------------+-----------+---------+\n9 rows in set (0.00 sec)\n\n\n11). 查询所有的部门信息, 并统计部门的员工人数\n\nmysql> select count(*) from emp where dept_id = 1;\n+----------+\n| count(*) |\n+----------+\n|        5 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql> select d.id,d.name,(select count(*) from emp e where e.dept_id =d.id) '人数' from dept d;\n+------+--------+------+\n| id   | name   | 人数 |\n+------+--------+------+\n|    1 | 研发部 |    5 |\n|    2 | 市场部 |    4 |\n|    3 | 财务部 |    3 |\n|    4 | 销售部 |    3 |\n|    5 | 总经办 |    1 |\n|    6 | 人事部 |    0 |\n+------+--------+------+\n6 rows in set (0.00 sec)\n\n\n12). 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n表: student , course , student_course\n\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\n\nmysql> select s.name,s.no,c.name from student s,student_course sc,course c where s.id = sc.studentid and sc.courseid = c.id;\n+--------+------------+--------+\n| name   | no         | name   |\n+--------+------------+--------+\n| 黛绮丝 | 2000100101 | java   |\n| 黛绮丝 | 2000100101 | php    |\n| 黛绮丝 | 2000100101 | mysql  |\n| 谢逊   | 2000100102 | php    |\n| 谢逊   | 2000100102 | mysql  |\n| 殷天正 | 2000100103 | hadoop |\n+--------+------------+--------+\n6 rows in set (0.00 sec)\n\n\n> 备注: 以上需求的实现方式可能会很多, sql写法也有很多，只要能满足我们的需求，查询出符合条件的记录即可。\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL的存储引擎和索引",frontmatter:{title:"MySQL的存储引擎和索引",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/751d08/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/09.MySQL%E7%B4%A2%E5%BC%95.html",relativePath:"01.指南/04.数据库/09.MySQL索引.md",key:"v-1a40dcf1",path:"/pages/751d08/",headers:[{level:2,title:"1.1 MySQL体系结构",slug:"_1-1-mysql体系结构",normalizedTitle:"1.1 mysql体系结构",charIndex:14},{level:3,title:"1.2 存储引擎介绍",slug:"_1-2-存储引擎介绍",normalizedTitle:"1.2 存储引擎介绍",charIndex:770},{level:3,title:"1.3 存储引擎特点",slug:"_1-3-存储引擎特点",normalizedTitle:"1.3 存储引擎特点",charIndex:5851},{level:4,title:"1.3.1 InnoDB",slug:"_1-3-1-innodb",normalizedTitle:"1.3.1 innodb",charIndex:5948},{level:4,title:"1.3.2 MyISAM",slug:"_1-3-2-myisam",normalizedTitle:"1.3.2 myisam",charIndex:7191},{level:4,title:"1.3.3 Memory",slug:"_1-3-3-memory",normalizedTitle:"1.3.3 memory",charIndex:7343},{level:4,title:"1.3.4 区别及特点",slug:"_1-3-4-区别及特点",normalizedTitle:"1.3.4 区别及特点",charIndex:7483},{level:3,title:"1.4 存储引擎选择",slug:"_1-4-存储引擎选择",normalizedTitle:"1.4 存储引擎选择",charIndex:8244},{level:2,title:"2. 索引",slug:"_2-索引",normalizedTitle:"2. 索引",charIndex:8606},{level:3,title:"2.1 索引概述",slug:"_2-1-索引概述",normalizedTitle:"2.1 索引概述",charIndex:8616},{level:4,title:"2.1.1 介绍",slug:"_2-1-1-介绍",normalizedTitle:"2.1.1 介绍",charIndex:8628},{level:4,title:"2.3 特点",slug:"_2-3-特点",normalizedTitle:"2.3 特点",charIndex:9144},{level:3,title:"2.2 索引结构",slug:"_2-2-索引结构",normalizedTitle:"2.2 索引结构",charIndex:9335},{level:4,title:"2.2.1 概述",slug:"_2-2-1-概述",normalizedTitle:"2.2.1 概述",charIndex:9347},{level:4,title:"2.2.2 二叉树",slug:"_2-2-2-二叉树",normalizedTitle:"2.2.2 二叉树",charIndex:9929},{level:4,title:"2.2.3 B-Tree",slug:"_2-2-3-b-tree",normalizedTitle:"2.2.3 b-tree",charIndex:10305},{level:4,title:"2.2.4 B+Tree",slug:"_2-2-4-b-tree",normalizedTitle:"2.2.4 b+tree",charIndex:10759},{level:4,title:"2.2.5 Hash",slug:"_2-2-5-hash",normalizedTitle:"2.2.5 hash",charIndex:11395},{level:3,title:"2.3 索引分类",slug:"_2-3-索引分类",normalizedTitle:"2.3 索引分类",charIndex:11998},{level:4,title:"2.3.1 索引分类",slug:"_2-3-1-索引分类",normalizedTitle:"2.3.1 索引分类",charIndex:12010},{level:4,title:"2.3.2 聚集索引&二级索引",slug:"_2-3-2-聚集索引-二级索引",normalizedTitle:"2.3.2 聚集索引&amp;二级索引",charIndex:null},{level:3,title:"2.4 索引语法",slug:"_2-4-索引语法",normalizedTitle:"2.4 索引语法",charIndex:13586},{level:3,title:"2.5 SQL性能分析",slug:"_2-5-sql性能分析",normalizedTitle:"2.5 sql性能分析",charIndex:25861},{level:4,title:"2.5.1 SQL执行频率",slug:"_2-5-1-sql执行频率",normalizedTitle:"2.5.1 sql执行频率",charIndex:25876},{level:4,title:"2.5.2 慢查询日志",slug:"_2-5-2-慢查询日志",normalizedTitle:"2.5.2 慢查询日志",charIndex:27467},{level:4,title:"2.5.3 profile详情",slug:"_2-5-3-profile详情",normalizedTitle:"2.5.3 profile详情",charIndex:28983},{level:4,title:"2.5.4 explain",slug:"_2-5-4-explain",normalizedTitle:"2.5.4 explain",charIndex:31577},{level:4,title:"2.6 索引使用",slug:"_2-6-索引使用",normalizedTitle:"2.6 索引使用",charIndex:32430},{level:5,title:"2.6.1 验证索引效率",slug:"_2-6-1-验证索引效率",normalizedTitle:"2.6.1 验证索引效率",charIndex:32442},{level:5,title:"2.6.2 最左前缀法则",slug:"_2-6-2-最左前缀法则",normalizedTitle:"2.6.2 最左前缀法则",charIndex:33110},{level:5,title:"2.6.3 范围查询",slug:"_2-6-3-范围查询",normalizedTitle:"2.6.3 范围查询",charIndex:41377},{level:5,title:"2.6.4 索引失效情况",slug:"_2-6-4-索引失效情况",normalizedTitle:"2.6.4 索引失效情况",charIndex:43204},{level:5,title:"2.6.5 SQL提示",slug:"_2-6-5-sql提示",normalizedTitle:"2.6.5 sql提示",charIndex:56789},{level:5,title:"2.6.6 覆盖索引",slug:"_2-6-6-覆盖索引",normalizedTitle:"2.6.6 覆盖索引",charIndex:65357},{level:5,title:"2.6.7 前缀索引",slug:"_2-6-7-前缀索引",normalizedTitle:"2.6.7 前缀索引",charIndex:71049},{level:5,title:"2.6.8 单列索引与联合索引",slug:"_2-6-8-单列索引与联合索引",normalizedTitle:"2.6.8 单列索引与联合索引",charIndex:74178},{level:4,title:"2.7 索引设计原则",slug:"_2-7-索引设计原则",normalizedTitle:"2.7 索引设计原则",charIndex:78906}],headersStr:"1.1 MySQL体系结构 1.2 存储引擎介绍 1.3 存储引擎特点 1.3.1 InnoDB 1.3.2 MyISAM 1.3.3 Memory 1.3.4 区别及特点 1.4 存储引擎选择 2. 索引 2.1 索引概述 2.1.1 介绍 2.3 特点 2.2 索引结构 2.2.1 概述 2.2.2 二叉树 2.2.3 B-Tree 2.2.4 B+Tree 2.2.5 Hash 2.3 索引分类 2.3.1 索引分类 2.3.2 聚集索引&二级索引 2.4 索引语法 2.5 SQL性能分析 2.5.1 SQL执行频率 2.5.2 慢查询日志 2.5.3 profile详情 2.5.4 explain 2.6 索引使用 2.6.1 验证索引效率 2.6.2 最左前缀法则 2.6.3 范围查询 2.6.4 索引失效情况 2.6.5 SQL提示 2.6.6 覆盖索引 2.6.7 前缀索引 2.6.8 单列索引与联合索引 2.7 索引设计原则",content:"# 存储引擎和索引\n\n\n# 1.1 MySQL体系结构\n\n\n\n1). 连接层\n\n最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\n\n2). 服务层\n\n第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n\n3). 引擎层\n\n存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。\n\n4). 存储层\n\n数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。\n\n和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。\n\n这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n\n# 1.2 存储引擎介绍\n\n\n\n大家可能没有听说过存储引擎，但是一定听过引擎这个词，引擎就是发动机，是一个机器的核心组件。比如，对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎一样。\n\n而对于存储引擎，也是一样，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。\n\n存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。\n\n1.建表时指定存储引擎\n\nCREATE TABLE '表名'(\n    字段1 字段1类型 [COMMIT 字段1注释],\n    字段2 字段3类型 [COMMIT 字段3注释]\n) ENGINE = INNODB [COMMIT 表注释];\n\n\n2.查询当前数据库支持的存储引擎\n\nMariaDB [itheima]> show engines;\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| Engine             | Support | Comment                                                                                         | Transactions | XA   | Savepoints |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| CSV                | YES     | Stores tables as CSV files                                                                      | NO           | NO   | NO         |\n| MRG_MyISAM         | YES     | Collection of identical MyISAM tables                                                           | NO           | NO   | NO         |\n| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables                                       | NO           | NO   | NO         |\n| Aria               | YES     | Crash-safe tables with MyISAM heritage. Used for internal temporary tables and privilege tables | NO           | NO   | NO         |\n| MyISAM             | YES     | Non-transactional engine with good performance and small data footprint                         | NO           | NO   | NO         |\n| SEQUENCE           | YES     | Generated tables filled with sequential values                                                  | YES          | NO   | YES        |\n| InnoDB             | DEFAULT | Supports transactions, row-level locking, foreign keys and encryption for tables                | YES          | YES  | YES        |\n| PERFORMANCE_SCHEMA | YES     | Performance Schema                                                                              | NO           | NO   | NO         |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n8 rows in set (0.000 sec)\n\n\n示例演示:\n\nA. 查询建表语句 --- 默认存储引擎: InnoDB\n\nMariaDB [test]> show create table account;\n\n\n\n\n我们可以看到，创建表时，即使我们没有指定存储疫情，数据库也会自动选择默认的存储引擎。\n\nB. 查询当前数据库支持的存储引擎\n\nMariaDB [test]> show engines;\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| Engine             | Support | Comment                                                                                         | Transactions | XA   | Savepoints |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| CSV                | YES     | Stores tables as CSV files                                                                      | NO           | NO   | NO         |\n| MRG_MyISAM         | YES     | Collection of identical MyISAM tables                                                           | NO           | NO   | NO         |\n| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables                                       | NO           | NO   | NO         |\n| Aria               | YES     | Crash-safe tables with MyISAM heritage. Used for internal temporary tables and privilege tables | NO           | NO   | NO         |\n| MyISAM             | YES     | Non-transactional engine with good performance and small data footprint                         | NO           | NO   | NO         |\n| SEQUENCE           | YES     | Generated tables filled with sequential values                                                  | YES          | NO   | YES        |\n| InnoDB             | DEFAULT | Supports transactions, row-level locking, foreign keys and encryption for tables                | YES          | YES  | YES        |\n| PERFORMANCE_SCHEMA | YES     | Performance Schema                                                                              | NO           | NO   | NO         |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n8 rows in set (0.000 sec)\n\n\nC. 创建表 my_myisam , 并指定MyISAM存储引擎\n\nMariaDB [test]> create table my_myisam(\n    -> id int,\n    -> name varchar(10)\n    -> ) engine = MyISAM;\nQuery OK, 0 rows affected (0.002 sec)\n\n\nD. 创建表 my_memory , 指定Memory存储引擎\n\nMariaDB [test]> create table my_memory(\n    -> id int,\n    -> name varchar(10)\n    -> ) engine = Memory;\nQuery OK, 0 rows affected (0.002 sec)\n\n\n\n# 1.3 存储引擎特点\n\n上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面重点提到的三种存储引擎 InnoDB、MyISAM、Memory的特点。\n\n# 1.3.1 InnoDB\n\n1). 介绍\n\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。\n\n2). 特点\n\n * DML操作遵循ACID模型，支持事务；\n\n * 行级锁，提高并发访问性能；\n\n * 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n\n3). 文件\n\nxxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。\n\n参数：innodb_file_per_table\n\nMariaDB [test]> show variables like 'innodb_file_per_table';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| innodb_file_per_table | ON    |\n+-----------------------+-------+\n1 row in set (0.001 sec)\n\n\n如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的\n\n数据存放目录： C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。\n\n\n\n可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。\n\n\n\n逻辑存储结构\n\n * 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。\n * 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。\n * 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。\n * 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。\n\n# 1.3.2 MyISAM\n\n1). 介绍\n\nMyISAM是MySQL早期的默认存储引擎。\n\n2). 特点\n\n不支持事务，不支持外键支持表锁，不支持行锁\n\n访问速度快\n\n3). 文件\n\n * xxx.sdi：存储表结构信息\n\n * xxx.MYD: 存储数据\n\n * xxx.MYI: 存储索引\n\n\n\n# 1.3.3 Memory\n\n1). 介绍\n\n * Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。\n\n2). 特点 内存存放\n\n * hash索引（默认）\n\n3).文件\n\n * xxx.sdi：存储表结构信息\n\n# 1.3.4 区别及特点\n\n特点         INNODB        MYISAM   MEMORY\n存储限制       64TB          有        有\n事务安全       支持            -        -\n锁机制        行锁            表锁       表锁\nB+tree索引   支持            支持       支持\nHash索引     -             -        支持\n全文索引       支持(5.6版本之后)   支持       -\n空间使用       高             低        N/A\n内存使用       高             低        中等\n批量插入速度     低             高        高\n支持外键       支持            -        -\n\n面试题:\n\nInnoDB引擎与MyISAM引擎的区别 ?\n\n 1. InnoDB引擎, 支持事务, 而MyISAM不支持。\n\n 2. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。\n\n 3. InnoDB引擎, 支持外键, 而MyISAM是不支持的。\n\n> 主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参考如下官方文档：\n> \n> https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html\n> \n> https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html\n\n\n# 1.4 存储引擎选择\n\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\n * InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。\n * MyISAM： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\n * MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n\n\n# 2. 索引\n\n\n# 2.1 索引概述\n\n# 2.1.1 介绍\n\n索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n\n\n\n一提到数据结构，大家都会有所担心，担心自己不能理解，跟不上节奏。不过在这里大家完全不用担心，我们后面在讲解时，会详细介绍。\n\n2.2 演示\n\n表结构及其数据如下：\n\n\n\n假如我们要执行的SQL语句为 ： select * from user where age = 45;\n\n1). 无索引情况\n\n\n\n在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。\n\n2). 有索引情况如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。\n\n\n\n此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。\n\n> 备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并不是索引的真实结构，索引的真实结构，后面会详细介绍。\n\n# 2.3 特点\n\n优势                                 劣势\n提高数据检索的效率，降低数据库的IO成本               索引列也是要占用空间的。\n通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。   索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。\n\n\n# 2.2 索引结构\n\n# 2.2.1 概述\n\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\n\n索引结构              描述\nB+Tree索引          最常见的索引类型，大部分引擎都支持 B+ 树索引\nHash索引            底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询\nR-tree(空间索 引）     空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少\nFull-text(全文索引)   是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES\n\n上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。\n\n索引          INNODB      MYISAM   MEMORY\nB+tree索引    支持          支持       支持\nHash 索引     不支持         不支持      支持\nR-tree 索引   不支持         支持       不支持\nFull-text   5.6版本之后支持   支持       不支持\n\n> 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。\n\n# 2.2.2 二叉树\n\n假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：\n\n\n\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\n\n\n\n所以，如果选择二叉树作为索引结构，会存在以下缺点：\n\n * 顺序插入时，会形成一个链表，查询性能大大降低。\n\n * 大数据量情况下，层级较深，检索速度慢。\n\n此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:\n\n\n\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\n\n * 大数据量情况下，层级较深，检索速度慢。\n\n所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。\n\n# 2.2.3 B-Tree\n\nB-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。\n\n以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：\n\n\n\n> 知识小贴士: 树的度数指的是一个节点的子节点个数。\n\n我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~gall es/visualization/BTree.html\n\n\n\n插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。\n\n\n\n特点：\n\n * 5阶的B树，每一个节点最多存储4个key，对应5个指针。\n\n * 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。\n\n * 在B树中，非叶子节点和叶子节点都会存放数据。\n\n# 2.2.4 B+Tree\n\nB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：\n\n\n\n我们可以看到，两部分：\n\n * 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\n\n我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~gall es/visualization/BPlusTree.html\n\n\n\n插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。\n\n\n\n最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别：\n\n * 所有的数据都会出现在叶子节点。\n\n * 叶子节点形成一个单向链表。\n\n * 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\n\n上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。\n\nMySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。\n\n\n\n# 2.2.5 Hash\n\nMySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。\n\n1).结构\n\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。\n\n\n\n如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n\n\n2). 特点\n\nA. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）\n\nB. 无法利用索引完成排序操作\n\nC. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引\n\n3). 存储引擎支持\n\n在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是\n\nInnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。\n\n> 思考题： 为什么InnoDB存储引擎选择使用B+tree索引结构?\n\n * A. 相对于二叉树，层级更少，搜索效率高；\n\n * B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；\n\n * C. 相对Hash索引，B+tree支持范围匹配及排序操作；\n\n\n# 2.3 索引分类\n\n# 2.3.1 索引分类\n\n在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。\n\n分类     含义                           特点              关键字\n主键索引   针对于表中主键创建的索引                 默认自动创建, 只能有一个   PRIMARY\n唯一索引   避免同一个表中某数据列中的值重复             可以有多个           UNIQUE\n常规索引   快速定位特定数据                     可以有多个           \n全文索引   全文索引查找的是文本中的关键词，而不是比较索引中的值   可以有多个           FULLTEXT\n\n# 2.3.2 聚集索引&二级索引\n\n而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n分类                      含义                              特点\n聚集索引(Clustered Index)   将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据   必须有,而且只有一个\n二级索引(Secondary Index)   将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键   可以存在多个\n\n聚集索引选取规则:\n\n * 如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。\n\n * 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。\n\n聚集索引和二级索引的具体结构如下：\n\n\n\n * 聚集索引的叶子节点下挂的是这一行的数据\n * 二级索引的叶子节点下挂的是该字段值对应的主键值。\n\n接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\n\n\n\n具体过程如下:\n\n 1. 由于是根据name字段进行查询，所以先根据name='Arm'到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。\n\n 2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。\n\n 3. 最终拿到这一行的数据，直接返回即可。\n\n> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。\n> \n> 思考题：以下两条SQL语句，那个执行效率高? 为什么?\n\nselect * from user where id = 10 ;\nselect * from user where name = 'Arm' ;\n\n备注: id为主键，name字段创建的有索引；\n\n\n解答：\n\nA 语句的执行性能要高于B 语句。因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。\n\n> 思考题：InnoDB主键索引的B+tree高度为多高呢?\n\n\n\n假设: 一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。高度为2：\nn * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170\n1171* 16 = 18736\n\n也就是说，如果树的高度为2，则可以存储 18000 多条记录。高度为3：\n1171 * 1171 * 16 = 21939856\n\n也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。\n\n\n\n# 2.4 索引语法\n\n1). 创建索引\n\nCREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name(index_col_name,...);\n\n\n2). 查看索引\n\nSHOW INDEX FROM table_name;\n\n\n3). 删除索引\n\nDROP INDEX index_name ON table_name;\n\n\n案例演示:\n\n先来创建一张表 tb_user，并且查询测试数据。\n\ncreate table tb_user(\n\tid int primary key auto_increment comment '主键',\n\tname varchar(50) not null comment '用户名',\n\tphone varchar(11) not null comment '手机号',\n\temail varchar(100) comment '邮箱',\n\tprofession varchar(11) comment '专业',\n\tage tinyint unsigned comment '年龄',\n\tgender char(1) comment '性别 , 1: 男, 2: 女',\n\tstatus char(1) comment '状态',\n\tcreatetime datetime comment '创建时间'\n) comment '系统用户表';\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('吕布', '17799990000', 'lvbu666@163.com', '软件工程', 23, '1','6', '2001-02-02 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('曹操', '17799990001', 'caocao666@qq.com', '通讯工程', 33,'1', '0', '2001-03-05 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('赵云', '17799990002', '17799990@139.com', '英语', 34, '1','2', '2002-03-02 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('孙悟空', '17799990003', '17799990@sina.com', '工程造价', 54,'1', '0', '2001-07-02 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('花木兰', '17799990004', '19980729@sina.com', '软件工程', 23,'2', '1', '2001-04-22 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('大乔', '17799990005', 'daqiao666@sina.com', '舞蹈', 22, '2','0', '2001-02-07 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('露娜', '17799990006', 'luna_love@sina.com', '应用数学', 24,'2', '0', '2001-02-08 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('程咬金', '17799990007', 'chengyaojin@163.com', '化工', 38,'1', '5', '2001-05-23 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('项羽', '17799990008', 'xiaoyu666@qq.com', '金属材料', 43,'1', '0', '2001-09-18 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('白起', '17799990009', 'baiqi666@sina.com', '机械工程及其自动化', 27, '1', '2', '2001-08-16 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('韩信', '17799990010', 'hanxin520@163.com', '无机非金属材料工程', 27, '1', '0', '2001-06-12 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('荆轲', '17799990011', 'jingke123@163.com', '会计', 29, '1','0', '2001-05-11 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('兰陵王', '17799990012', 'lanlinwang666@126.com', '工程造价',44, '1', '1', '2001-04-09 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('狂铁', '17799990013', 'kuangtie@sina.com', '应用数学', 43,'1', '2', '2001-04-10 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('貂蝉', '17799990014', '84958948374@qq.com', '软件工程', 40,'2', '3', '2001-02-12 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('妲己', '17799990015', '2783238293@qq.com', '软件工程', 31,'2', '0', '2001-01-30 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('芈月', '17799990016', 'xiaomin2001@sina.com', '工业经济', 35,'2', '0', '2000-05-03 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('嬴政', '17799990017', '8839434342@qq.com', '化工', 38, '1','1', '2001-08-08 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('狄仁杰', '17799990018', 'jujiamlm8166@163.com', '国际贸易',30, '1', '0', '2007-03-12 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('安琪拉', '17799990019', 'jdodm1h@126.com', '城市规划', 51,'2', '0', '2001-08-15 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('典韦', '17799990020', 'ycaunanjian@163.com', '城市规划', 52,'1', '2', '2000-04-12 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('廉颇', '17799990021', 'lianpo321@126.com', '土木工程', 19,'1', '3', '2002-07-18 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('后羿', '17799990022', 'altycj2000@139.com', '城市园林', 20,'1', '0', '2002-03-10 00:00:00');\nINSERT INTO tb_user (name, phone, email, profession, age, gender, status,createtime) VALUES ('姜子牙', '17799990023', '37483844@qq.com', '工程造价', 29,'1', '4', '2003-05-26 00:00:00');\n\n\n表结构中插入的数据如下：\n\nMariaDB [itheima]> select * from tb_user;\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n| id | name      | phone       | email                 | profession                  | age  | gender | status | createtime          |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n|  1 | 吕布      | 17799990000 | lvbu666@163.com       | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |\n|  2 | 曹操      | 17799990001 | caocao666@qq.com      | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |\n|  3 | 赵云      | 17799990002 | 17799990@139.com      | 英语                        |   34 | 1      | 2      | 2002-03-02 00:00:00 |\n|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价                    |   54 | 1      | 0      | 2001-07-02 00:00:00 |\n|  5 | 花木兰    | 17799990004 | 19980729@sina.com     | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |\n|  6 | 大乔      | 17799990005 | daqiao666@sina.com    | 舞蹈                        |   22 | 2      | 0      | 2001-02-07 00:00:00 |\n|  7 | 露娜      | 17799990006 | luna_love@sina.com    | 应用数学                    |   24 | 2      | 0      | 2001-02-08 00:00:00 |\n|  8 | 程咬金    | 17799990007 | chengyaojin@163.com   | 化工                        |   38 | 1      | 5      | 2001-05-23 00:00:00 |\n|  9 | 项羽      | 17799990008 | xiaoyu666@qq.com      | 金属材料                    |   43 | 1      | 0      | 2001-09-18 00:00:00 |\n| 10 | 白起      | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |\n| 11 | 韩信      | 17799990010 | hanxin520@163.com     | 无机非金属材料工程          |   27 | 1      | 0      | 2001-06-12 00:00:00 |\n| 12 | 荆轲      | 17799990011 | jingke123@163.com     | 会计                        |   29 | 1      | 0      | 2001-05-11 00:00:00 |\n| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价                    |   44 | 1      | 1      | 2001-04-09 00:00:00 |\n| 14 | 狂铁      | 17799990013 | kuangtie@sina.com     | 应用数学                    |   43 | 1      | 2      | 2001-04-10 00:00:00 |\n| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com    | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |\n| 16 | 妲己      | 17799990015 | 2783238293@qq.com     | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |\n| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济                    |   35 | 2      | 0      | 2000-05-03 00:00:00 |\n| 18 | 嬴政      | 17799990017 | 8839434342@qq.com     | 化工                        |   38 | 1      | 1      | 2001-08-08 00:00:00 |\n| 19 | 狄仁杰    | 17799990018 | jujiamlm8166@163.com  | 国际贸易                    |   30 | 1      | 0      | 2007-03-12 00:00:00 |\n| 20 | 安琪拉    | 17799990019 | jdodm1h@126.com       | 城市规划                    |   51 | 2      | 0      | 2001-08-15 00:00:00 |\n| 21 | 典韦      | 17799990020 | ycaunanjian@163.com   | 城市规划                    |   52 | 1      | 2      | 2000-04-12 00:00:00 |\n| 22 | 廉颇      | 17799990021 | lianpo321@126.com     | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |\n| 23 | 后羿      | 17799990022 | altycj2000@139.com    | 城市园林                    |   20 | 1      | 0      | 2002-03-10 00:00:00 |\n| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价                    |   29 | 1      | 4      | 2003-05-26 00:00:00 |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n24 rows in set (0.000 sec)\n![](media/image36.jpg){width=\"6.138267716535433in\" height=\"3.1889818460192476in\"}\n\n\n数据准备好了之后，接下来，我们就来完成如下需求：\n\nA. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。\n\nMariaDB [itheima]> create index idx_user_name on tb_user(name);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\nB. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。\n\nMariaDB [itheima]> create index idx_user_phone on tb_user(phone);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\nC. 为profession、age、status创建联合索引。\n\nMariaDB [itheima]> create index idx_user_pro_age_sta on tb_user(profession,age,status);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\nD. 为email建立合适的索引来提升查询效率。\n\nMariaDB [itheima]> create index idx_email on tb_user(email);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\n完成上述的需求之后，我们再查看tb_user表的所有的索引数据。\n\nMariaDB [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone_name  |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone_name  |            2 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_use_profession   |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email_5          |            1 | email       | A         |          24 |        5 | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n11 rows in set (0.000 sec)\n\n\n\n# 2.5 SQL性能分析\n\n# 2.5.1 SQL执行频率\n\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\n\n-- session 是查看当前会话 ;\n-- global 是查询全局数据 ;\nSHOW GLOBAL STATUS LIKE 'Com_______';\n\nMariaDB [itheima]> SHOW GLOBAL STATUS LIKE 'Com_______';\n+---------------+---------+\n| Variable_name | Value   |\n+---------------+---------+\n| Com_backup    | 0       |\n| Com_binlog    | 0       |\n| Com_commit    | 0       |\n| Com_delete    | 0       |\n| Com_insert    | 1119203 |\n| Com_repair    | 0       |\n| Com_revoke    | 0       |\n| Com_select    | 134     |\n| Com_signal    | 0       |\n| Com_update    | 0       |\n| Com_xa_end    | 0       |\n+---------------+---------+\n11 rows in set (0.001 sec)\n\n\nCom_delete: 删除次数\n\nCom_insert: 插入次数\n\nCom_select: 查询次数\n\nCom_update: 更新次数\n\n我们可以在当前数据库再执行几次查询操作，然后再次查看执行频次，看看 Com_select 参数会不会变化。\n\nMariaDB [itheima]> SHOW GLOBAL STATUS LIKE 'Com_______';\n+---------------+---------+\n| Variable_name | Value   |\n+---------------+---------+\n| Com_backup    | 0       |\n| Com_binlog    | 0       |\n| Com_commit    | 0       |\n| Com_delete    | 0       |\n| Com_insert    | 1152203 |\n| Com_repair    | 0       |\n| Com_revoke    | 0       |\n| Com_select    | 134     |\n| Com_signal    | 0       |\n| Com_update    | 0       |\n| Com_xa_end    | 0       |\n+---------------+---------+\n11 rows in set (0.001 sec)\n\n\n> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以\n> \n> 查询为主，那么就要考虑对数据库的索引进行优化了。\n\n那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询日志。\n\n接下来，我们就来介绍一下MySQL中的慢查询日志。\n\n# 2.5.2 慢查询日志\n\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\n\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\n\nMariaDB [itheima]> show variables like 'slow_query_log';\n+----------------+-------+\n| Variable_name  | Value |\n+----------------+-------+\n| slow_query_log | OFF   |\n+----------------+-------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> show variables like 'slow_query_log'\\G;\n*************************** 1. row ***************************\nVariable_name: slow_query_log\n        Value: OFF\n1 row in set (0.000 sec)\n\nERROR: No query specified\n\n\n如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\n\n[mysqld]\n# 开启MySQL慢日志查询开关\nslow_query_log=1\n\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\nlong_query_time=2\n\n\n配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。\n\n然后，再次查看开关情况，慢查询日志就已经打开了。\n\nMariaDB [itheima]> show variables like 'slow_query_log';\n+----------------+-------+\n| Variable_name  | Value |\n+----------------+-------+\n| slow_query_log | ON    |\n+----------------+-------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> show variables like 'slow_query_log'\\G;\n*************************** 1. row ***************************\nVariable_name: slow_query_log\n        Value: ON\n1 row in set (0.000 sec)\n\n\n测试：\n\nA. 执行如下SQL语句 ：\n\nselect * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00sec\n\nselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec\n\n\nB. 检查慢查询日志 ：\n\n最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL 是不会记录的。\n\n\n\n那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。\n\n# 2.5.3 profile详情\n\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：\n\nMariaDB [itheima]> SELECT @@have_profiling;\n+------------------+\n| @@have_profiling |\n+------------------+\n| YES              |\n+------------------+\n1 row in set (0.000 sec)\n\n\n可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：\n\nSET profiling = 1;\n\n\n开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：\n\nselect * from tb_user;\nselect * from tb_user where id = 1;\nselect * from tb_user where name = '白起';\nselect count(*) from tb_sku;\n\n\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n\n-- 查看每一条SQL的耗时基本情况\nshow profiles;\n\n-- 查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n\n-- 查看指定query_id的SQL语句CPU的使用情况\nshow profile cpu for query query_id;\n\n\n查看每一条SQL的耗时情况:\n\nMariaDB [itheima]> show profiles;\n+----------+------------+---------------------------------------------+\n| Query_ID | Duration   | Query                                       |\n+----------+------------+---------------------------------------------+\n|        1 | 0.00014831 | select * from tb_user where id = 1          |\n|        2 | 0.00037277 | select * from tb_user where name = '白起'   |\n|        3 | 0.00016053 | select * from tb_user where id = 1          |\n|        4 | 0.00015029 | select * from tb_user where id = 1          |\n+----------+------------+---------------------------------------------+\n4 rows in set (0.000 sec)\n\n\n查看指定SQL各个阶段的耗时情况 :\n\nMariaDB [itheima]> show profile for query 3;\n+------------------------+----------+\n| Status                 | Duration |\n+------------------------+----------+\n| Starting               | 0.000035 |\n| checking permissions   | 0.000003 |\n| Opening tables         | 0.000022 |\n| After opening tables   | 0.000004 |\n| System lock            | 0.000002 |\n| table lock             | 0.000003 |\n| init                   | 0.000018 |\n| Optimizing             | 0.000010 |\n| Statistics             | 0.000025 |\n| Preparing              | 0.000001 |\n| Unlocking tables       | 0.000002 |\n| Preparing              | 0.000006 |\n| Executing              | 0.000001 |\n| Sending data           | 0.000009 |\n| End of update loop     | 0.000001 |\n| Query end              | 0.000001 |\n| Commit                 | 0.000002 |\n| closing tables         | 0.000001 |\n| Unlocking tables       | 0.000000 |\n| closing tables         | 0.000002 |\n| Starting cleanup       | 0.000001 |\n| Freeing items          | 0.000002 |\n| Updating status        | 0.000009 |\n| Reset for next command | 0.000001 |\n+------------------------+----------+\n24 rows in set (0.000 sec)\n\n\n# 2.5.4 explain\n\nEXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法:\n\n-- 直接在select语句之前加上关键字 explain / desc\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;\n\n\nExplain 执行计划中各个字段的含义:\n\n字段             含义\nid             select查询的序列号，表示查询中执行select子句或者是操作表的顺序\n               (id相同，执行顺序从上到下；id不同，值越大，越先执行)。\nselect_type    表示 SELECT 的类型，常见的取值有\n               SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION\n               中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等\ntype           表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、\n               index、all 。\npossible_key   显示可能应用在这张表上的索引，一个或多个。\nkey            实际使用的索引，如果为NULL，则没有使用索引。\nkey_len        表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\nrows           MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\nfiltered       表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。\n\n# 2.6 索引使用\n\n# 2.6.1 验证索引效率\n\n在讲解索引的使用原则之前，先通过一个简单的案例，来验证一下索引，看看是否能够通过索引来提升数据查询性能。在演示的时候，我们还是使用之前准备的一张表 tb_sku , 在这张表中准备了1000w 的记录。\n\n\n\n这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 我们先来查询其中的一条记录，看看里面的字段情况，执行如下SQL：\n\nSELECT * FROM tb_sku WHERE id = 1\\G;\n\n\n\n\n可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。 那么接下来，我们再来根据 sn 字段进行查询，执行如下SQL：\n\nSELECT * FROM tb_sku WHERE sn = '100000003145001';\n\n\n\n\n我们可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索引，而造成查询效率很低。\n\n那么我们可以针对于sn字段，建立一个索引，建立了索引之后，我们再次根据sn进行查询，再来看一下查询耗时情况。\n\n创建索引：\n\ncreate index idx_sku_sn on tb_sku(sn) ;\n\n\n\n\n然后再次执行相同的SQL语句，再次查看SQL的耗时。\n\nselect * from tb_sku where sn = '100000003145001';\n\n\n我们明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数量级的。\n\n\n\n# 2.6.2 最左前缀法则\n\n如果索引了多列（联合索引），要遵守最左前 法则。最左前 法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。\n\n以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。\n\nMariaDB [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n7 rows in set (0.000 sec)\n\n\n在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前 法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。\n\n而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下具体的执行计划：\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref         | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const | 1    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\n以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age 字段索引长度为2、status字段索引长度为5。\n\nMariaDB [itheima]> explain select * from tb_user where age = 31 and status = '0';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where status = '0';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前 法则，联合索引最左边的列profession不存在。\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前 法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。\n\n> 思考题：当执行SQL语句: explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程'； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？\n> \n> MariaDB [itheima]> explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程';\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> | id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | Extra                 |\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> |    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | Using index condition |\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> 1 row in set (0.000 sec)\n> \n> \n> 可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。\n\n# 2.6.3 范围查询\n\n联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age > 30 and status = '0';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | Extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | NULL | 2    | Using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n当范围查询使用> 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age >= 30 and status = '0';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | Extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | NULL | 2    | Using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。所以，在业务允许的情况下，尽可能的使用类似于 >= 或<= 这类的范围查询，而避免使用 > 或 <。\n\n# 2.6.4 索引失效情况\n\n2.6.4.1 索引列运算 不要在索引列上进行运算操作， 索引将失效。\n\n在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。\n\nMariaDB [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n7 rows in set (0.000 sec)\n\n\n\nA. 当根据phone字段进行等值匹配查询时, 索引生效。\n\nMariaDB [itheima]> explain select * from tb_user where phone = '17799990015';\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref   | rows | Extra |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n|    1 | SIMPLE      | tb_user | const | idx_user_phone | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\n\nB. 当根据phone字段进行函数运算操作之后，索引失效。\n\nMariaDB [itheima]> explain select * from tb_user where substring(phone,10,2) = '15';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n2.6.4.2 字符串不加引号\n\n字符串类型字段使用时，不加引号，索引将失效。\n\n接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = 0;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref         | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const | 1    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\nMariaDB [itheima]> explain select * from tb_user where phone = '17799990015';\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref   | rows | Extra |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n|    1 | SIMPLE      | tb_user | const | idx_user_phone | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where phone = 17799990015;\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | idx_user_phone | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。\n\n2.6.4.3 模糊查询\n\n如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n\n接下来，我们来看一下这三条SQL语句的执行效果，查看一下其执行计划：\n\n由于下面查询语句中，都是根据profession字段查询，符合最左前 法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。\n\nMariaDB [itheima]> explain select * from tb_user where profession like '软件%';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | Extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | NULL | 4    | Using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where profession like '%工程';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where profession like '%工%';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。\n\n3.6.4.4 or连接条件\n\n用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n\nMariaDB [itheima]> explain select * from tb_user where id = 10 or age = 23;\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | PRIMARY       | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where phone = '17799990017' or age = 23;\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | idx_user_phone | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。\n\n然后，我们可以对age字段建立索引。\n\nMariaDB [itheima]> create index idx_user_age on tb_user(age);\nQuery OK, 0 rows affected (0.003 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\n建立了索引之后，我们再次执行上述的SQL语句，看看前后执行计划的变化。\n\n\n\n最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。\n\n3.6.4.5 数据分布影响\n\n如果MySQL评估使用索引比全表更慢，则不使用索引。\n\nMariaDB [itheima]> explain select * from tb_user where phone >= '17799990015';\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | idx_user_phone | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where phone >= '17799999015';\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref  | rows | Extra                 |\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | range | idx_user_phone | idx_user_phone | 46      | NULL | 1    | Using index condition |\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\n经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？\n\n就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。\n\n接下来，我们再来看看 is null 与 is not null 操作是否走索引。\n\n执行如下两条语句 ：\n\nMariaDB [itheima]> explain select * from tb_user where profession is null;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 1    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\nMariaDB [itheima]> explain select * from tb_user where profession is not null;\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys        | key  | key_len | ref  | rows | Extra       |\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n|    1 | SIMPLE      | tb_user | ALL  | idx_user_pro_age_sta | NULL | NULL    | NULL | 24   | Using where |\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n最终我们看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。\n\n# 2.6.5 SQL提示\n\n目前tb_user表的数据情况如下:\n\nMariaDB [itheima]> select * from tb_user;\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n| id | name      | phone       | email                 | profession                  | age  | gender | status | createtime          |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n|  1 | 吕布      | 17799990000 | lvbu666@163.com       | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |\n|  2 | 曹操      | 17799990001 | caocao666@qq.com      | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |\n|  3 | 赵云      | 17799990002 | 17799990@139.com      | 英语                        |   34 | 1      | 2      | 2002-03-02 00:00:00 |\n|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价                    |   54 | 1      | 0      | 2001-07-02 00:00:00 |\n|  5 | 花木兰    | 17799990004 | 19980729@sina.com     | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |\n|  6 | 大乔      | 17799990005 | daqiao666@sina.com    | 舞蹈                        |   22 | 2      | 0      | 2001-02-07 00:00:00 |\n|  7 | 露娜      | 17799990006 | luna_love@sina.com    | 应用数学                    |   24 | 2      | 0      | 2001-02-08 00:00:00 |\n|  8 | 程咬金    | 17799990007 | chengyaojin@163.com   | 化工                        |   38 | 1      | 5      | 2001-05-23 00:00:00 |\n|  9 | 项羽      | 17799990008 | xiaoyu666@qq.com      | 金属材料                    |   43 | 1      | 0      | 2001-09-18 00:00:00 |\n| 10 | 白起      | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |\n| 11 | 韩信      | 17799990010 | hanxin520@163.com     | 无机非金属材料工程          |   27 | 1      | 0      | 2001-06-12 00:00:00 |\n| 12 | 荆轲      | 17799990011 | jingke123@163.com     | 会计                        |   29 | 1      | 0      | 2001-05-11 00:00:00 |\n| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价                    |   44 | 1      | 1      | 2001-04-09 00:00:00 |\n| 14 | 狂铁      | 17799990013 | kuangtie@sina.com     | 应用数学                    |   43 | 1      | 2      | 2001-04-10 00:00:00 |\n| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com    | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |\n| 16 | 妲己      | 17799990015 | 2783238293@qq.com     | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |\n| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济                    |   35 | 2      | 0      | 2000-05-03 00:00:00 |\n| 18 | 嬴政      | 17799990017 | 8839434342@qq.com     | 化工                        |   38 | 1      | 1      | 2001-08-08 00:00:00 |\n| 19 | 狄仁杰    | 17799990018 | jujiamlm8166@163.com  | 国际贸易                    |   30 | 1      | 0      | 2007-03-12 00:00:00 |\n| 20 | 安琪拉    | 17799990019 | jdodm1h@126.com       | 城市规划                    |   51 | 2      | 0      | 2001-08-15 00:00:00 |\n| 21 | 典韦      | 17799990020 | ycaunanjian@163.com   | 城市规划                    |   52 | 1      | 2      | 2000-04-12 00:00:00 |\n| 22 | 廉颇      | 17799990021 | lianpo321@126.com     | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |\n| 23 | 后羿      | 17799990022 | altycj2000@139.com    | 城市园林                    |   20 | 1      | 0      | 2002-03-10 00:00:00 |\n| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价                    |   29 | 1      | 4      | 2003-05-26 00:00:00 |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n24 rows in set (0.000 sec)\n\n\n\n索引情况如下:\n\nMariaDB [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_age         |            1 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n8 rows in set (0.000 sec)\n\n\n\n把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。\n\nA. 执行SQL : explain select * from tb_user where profession = '软件工程';\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n查询走了联合索引。\n\nB. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);\n\nMariaDB [itheima]> create index idx_user_pro on tb_user(profession);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n\n\nC. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | Extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | Using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。\n\n那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。\n\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\n * use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。\n * ignore index ： 忽略指定的索引。\n * force index ： 强制使用索引。\n\n示例演示：\n\nA. use index\n\nexplain select * from tb_user use index(idx_user_pro) where profession = '软件工程';\n\n\nB. ignore index\n\nexplain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';\n\n\nC. force index\n\nexplain select * from tb_user force index(idx_user_pro) where profession = '软件程';\n\n\n# 2.6.6 覆盖索引\n\n尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。接下来，我们来看一组SQL的执行计划，看看执行计划的差别，然后再来具体做一个解析。\n\n上述这几条SQL的执行结果为:\n\nMariaDB [itheima]> explain select id, profession from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n| id   | select_type | table   | type | possible_keys                                  | key                  | key_len | ref               | rows | Extra                    |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_pro_age_sta | 54      | const,const,const | 1    | Using where; Using index |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n1 row in set (0.000 sec)\n\n\nMariaDB [itheima]> explain select id,profession,age, status from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n| id   | select_type | table   | type | possible_keys                                  | key                  | key_len | ref               | rows | Extra                    |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n|    1 | SIMPLE      | tb_user | ref  | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_pro_age_sta | 54      | const,const,const | 1    | Using where; Using index |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n1 row in set (0.000 sec)\n\n\nMariaDB [itheima]> explain select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n| id   | select_type | table   | type       | possible_keys                                  | key                       | key_len | ref   | rows   | Extra                           |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n|    1 | SIMPLE      | tb_user | ref|filter | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_age|idx_user_pro | 2|47    | const | 1 (4%) | Using where; Using rowid filter |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n1 row in set (0.000 sec)\n\n\nMariaDB [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n| id   | select_type | table   | type       | possible_keys                                  | key                       | key_len | ref   | rows    | Extra                           |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n|    1 | SIMPLE      | tb_user | ref|filter | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_age|idx_user_pro | 2|47    | const | 1 (17%) | Using where; Using rowid filter |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n1 row in set (0.000 sec)\n\n\n\n从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。\n\nEXTRA                      含义\nUsing where; Using Index   查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\nUsing index condition      查找使用了索引，但是需要回表查询数据\n\n因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。\n\n为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。\n\nA. 表结构及索引示意图:\n\n\n\nid是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。\n\nB. 执行SQL : select * from tb_user where id = 2;\n\n\n\n根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。\n\nC. 执行SQL：selet id,name from tb_user where name = 'Arm';\n\n\n\n虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。\n\nD. 执行SQL：selet id,name,gender from tb_user where name = 'Arm';\n\n\n\n由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。\n\n> 思考题：\n\n一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:\n\nselect id,username,password from tb_user where username = 'itcast';\n\n答案: 针对于 username, password建立联合索引, sql为:\n\ncreate index idx_user_name_pass on tb_user(username,password);\n\n这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。\n\n# 2.6.7 前缀索引\n\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前 ，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n\n1). 语法\n\ncreate index idx_xxxx on table_name(column(n));\n\n\n示例:\n\n为tb_user表的email字段，建立长度为5的前 索引。\n\nMariaDB [itheima]> create index idx_email_5 on tb_user(email(5));\n\n\nMariaDB [itheima]> show index from  tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_age         |            1 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro         |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email_5          |            1 | email       | A         |          24 |        5 | NULL   | YES  | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n10 rows in set (0.000 sec)\n\n\n2). 前 长度\n\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\n\nselect count(distinct email) / count(*) from tb_user ;\nselect count(distinct substring(email,1,5)) / count(*) from tb_user ;\n\n\n3). 前 索引的查询流程\n\n\n\n# 2.6.8 单列索引与联合索引\n\n单列索引：即一个索引只包含单个列。联合索引：即一个索引包含了多个列。\n\n我们先来看看 tb_user 表中目前的索引情况:\n\nMariaDB [itheima]> show index from  tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | PRIMARY              |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email            |            1 | email       | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 |     NULL | NULL   |      | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_age         |            1 | age         | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_user_pro         |            1 | profession  | A         |          24 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |\n| tb_user |          1 | idx_email_5          |            1 | email       | A         |          24 |        5 | NULL   | YES  | BTREE      |         |               | NO      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n10 rows in set (0.000 sec)\n\n\n在查询出来的索引中，既有单列索引，又有联合索引。\n\n接下来，我们来执行一条SQL语句，看看其执行计划：\n\nMariaDB [itheima]> explain select id,phone,name from tb_user where phone = '17799990010' and name = '韩信';\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys                | key            | key_len | ref   | rows | Extra |\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n|    1 | SIMPLE      | tb_user | const | idx_user_phone,idx_user_name | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\n\n\n通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。\n\n紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。\n\nMariaDB [itheima]> create unique index idx_user_phone_name on tb_user(phone,name);\nQuery OK, 0 rows affected (0.004 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nMariaDB [itheima]> explain select id,phone,name from tb_user use index(idx_user_phone_name) where phone = '17799990010' and name = '韩信';\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n| id   | select_type | table   | type  | possible_keys       | key                 | key_len | ref         | rows | Extra       |\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n|    1 | SIMPLE      | tb_user | const | idx_user_phone_name | idx_user_phone_name | 248     | const,const | 1    | Using index |\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。\n\n> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，\n> \n> 而非单列索引。\n\n如果查询使用的是联合索引，具体的结构示意图如下：\n\n\n\n# 2.7 索引设计原则\n\n 1. 针对于数据量较大，且查询比较频繁的表建立索引。\n\n 2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n\n 3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n\n 4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前 索引。\n\n 5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n 6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n\n 7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含\n\n 8. NULL值时，它可以更好地确定哪个索引最有效地用于查询。",normalizedContent:"# 存储引擎和索引\n\n\n# 1.1 mysql体系结构\n\n\n\n1). 连接层\n\n最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于ssl的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\n\n2). 服务层\n\n第二层架构主要完成大多数的核心服务功能，如sql接口，并完成缓存的查询，sql的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n\n3). 引擎层\n\n存储引擎层， 存储引擎真正的负责了mysql中数据的存储和提取，服务器通过api和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。\n\n4). 存储层\n\n数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。\n\n和其他数据库相比，mysql有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。\n\n这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n\n# 1.2 存储引擎介绍\n\n\n\n大家可能没有听说过存储引擎，但是一定听过引擎这个词，引擎就是发动机，是一个机器的核心组件。比如，对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎一样。\n\n而对于存储引擎，也是一样，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。\n\n存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。\n\n1.建表时指定存储引擎\n\ncreate table '表名'(\n    字段1 字段1类型 [commit 字段1注释],\n    字段2 字段3类型 [commit 字段3注释]\n) engine = innodb [commit 表注释];\n\n\n2.查询当前数据库支持的存储引擎\n\nmariadb [itheima]> show engines;\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| engine             | support | comment                                                                                         | transactions | xa   | savepoints |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| csv                | yes     | stores tables as csv files                                                                      | no           | no   | no         |\n| mrg_myisam         | yes     | collection of identical myisam tables                                                           | no           | no   | no         |\n| memory             | yes     | hash based, stored in memory, useful for temporary tables                                       | no           | no   | no         |\n| aria               | yes     | crash-safe tables with myisam heritage. used for internal temporary tables and privilege tables | no           | no   | no         |\n| myisam             | yes     | non-transactional engine with good performance and small data footprint                         | no           | no   | no         |\n| sequence           | yes     | generated tables filled with sequential values                                                  | yes          | no   | yes        |\n| innodb             | default | supports transactions, row-level locking, foreign keys and encryption for tables                | yes          | yes  | yes        |\n| performance_schema | yes     | performance schema                                                                              | no           | no   | no         |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n8 rows in set (0.000 sec)\n\n\n示例演示:\n\na. 查询建表语句 --- 默认存储引擎: innodb\n\nmariadb [test]> show create table account;\n\n\n\n\n我们可以看到，创建表时，即使我们没有指定存储疫情，数据库也会自动选择默认的存储引擎。\n\nb. 查询当前数据库支持的存储引擎\n\nmariadb [test]> show engines;\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| engine             | support | comment                                                                                         | transactions | xa   | savepoints |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n| csv                | yes     | stores tables as csv files                                                                      | no           | no   | no         |\n| mrg_myisam         | yes     | collection of identical myisam tables                                                           | no           | no   | no         |\n| memory             | yes     | hash based, stored in memory, useful for temporary tables                                       | no           | no   | no         |\n| aria               | yes     | crash-safe tables with myisam heritage. used for internal temporary tables and privilege tables | no           | no   | no         |\n| myisam             | yes     | non-transactional engine with good performance and small data footprint                         | no           | no   | no         |\n| sequence           | yes     | generated tables filled with sequential values                                                  | yes          | no   | yes        |\n| innodb             | default | supports transactions, row-level locking, foreign keys and encryption for tables                | yes          | yes  | yes        |\n| performance_schema | yes     | performance schema                                                                              | no           | no   | no         |\n+--------------------+---------+-------------------------------------------------------------------------------------------------+--------------+------+------------+\n8 rows in set (0.000 sec)\n\n\nc. 创建表 my_myisam , 并指定myisam存储引擎\n\nmariadb [test]> create table my_myisam(\n    -> id int,\n    -> name varchar(10)\n    -> ) engine = myisam;\nquery ok, 0 rows affected (0.002 sec)\n\n\nd. 创建表 my_memory , 指定memory存储引擎\n\nmariadb [test]> create table my_memory(\n    -> id int,\n    -> name varchar(10)\n    -> ) engine = memory;\nquery ok, 0 rows affected (0.002 sec)\n\n\n\n# 1.3 存储引擎特点\n\n上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面重点提到的三种存储引擎 innodb、myisam、memory的特点。\n\n# 1.3.1 innodb\n\n1). 介绍\n\ninnodb是一种兼顾高可靠性和高性能的通用存储引擎，在 mysql 5.5 之后，innodb是默认的mysql 存储引擎。\n\n2). 特点\n\n * dml操作遵循acid模型，支持事务；\n\n * 行级锁，提高并发访问性能；\n\n * 支持外键foreign key约束，保证数据的完整性和正确性；\n\n3). 文件\n\nxxx.ibd：xxx代表的是表名，innodb引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。\n\n参数：innodb_file_per_table\n\nmariadb [test]> show variables like 'innodb_file_per_table';\n+-----------------------+-------+\n| variable_name         | value |\n+-----------------------+-------+\n| innodb_file_per_table | on    |\n+-----------------------+-------+\n1 row in set (0.001 sec)\n\n\n如果该参数开启，代表对于innodb引擎的表，每一张表都对应一个ibd文件。 我们直接打开mysql的\n\n数据存放目录： c:\\programdata\\mysql\\mysql server 8.0\\data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。\n\n\n\n可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。\n\n\n\n逻辑存储结构\n\n * 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。innodb中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。\n * 区 : 区是表空间的单元结构，每个区的大小为1m。 默认情况下， innodb存储引擎页大小为16k， 即一个区中一共有64个连续的页。\n * 页 : 页是组成区的最小单元，页也是innodb 存储引擎磁盘管理的最小单元，每个页的大小默认为 16kb。为了保证页的连续性，innodb 存储引擎每次从磁盘申请 4-5 个区。\n * 行 : innodb 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。\n\n# 1.3.2 myisam\n\n1). 介绍\n\nmyisam是mysql早期的默认存储引擎。\n\n2). 特点\n\n不支持事务，不支持外键支持表锁，不支持行锁\n\n访问速度快\n\n3). 文件\n\n * xxx.sdi：存储表结构信息\n\n * xxx.myd: 存储数据\n\n * xxx.myi: 存储索引\n\n\n\n# 1.3.3 memory\n\n1). 介绍\n\n * memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。\n\n2). 特点 内存存放\n\n * hash索引（默认）\n\n3).文件\n\n * xxx.sdi：存储表结构信息\n\n# 1.3.4 区别及特点\n\n特点         innodb        myisam   memory\n存储限制       64tb          有        有\n事务安全       支持            -        -\n锁机制        行锁            表锁       表锁\nb+tree索引   支持            支持       支持\nhash索引     -             -        支持\n全文索引       支持(5.6版本之后)   支持       -\n空间使用       高             低        n/a\n内存使用       高             低        中等\n批量插入速度     低             高        高\n支持外键       支持            -        -\n\n面试题:\n\ninnodb引擎与myisam引擎的区别 ?\n\n 1. innodb引擎, 支持事务, 而myisam不支持。\n\n 2. innodb引擎, 支持行锁和表锁, 而myisam仅支持表锁, 不支持行锁。\n\n 3. innodb引擎, 支持外键, 而myisam是不支持的。\n\n> 主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参考如下官方文档：\n> \n> https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html\n> \n> https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html\n\n\n# 1.4 存储引擎选择\n\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\n * innodb: 是mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么innodb存储引擎是比较合适的选择。\n * myisam： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\n * memory：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n\n\n# 2. 索引\n\n\n# 2.1 索引概述\n\n# 2.1.1 介绍\n\n索引（index）是帮助mysql高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n\n\n\n一提到数据结构，大家都会有所担心，担心自己不能理解，跟不上节奏。不过在这里大家完全不用担心，我们后面在讲解时，会详细介绍。\n\n2.2 演示\n\n表结构及其数据如下：\n\n\n\n假如我们要执行的sql语句为 ： select * from user where age = 45;\n\n1). 无索引情况\n\n\n\n在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。\n\n2). 有索引情况如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。\n\n\n\n此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。\n\n> 备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并不是索引的真实结构，索引的真实结构，后面会详细介绍。\n\n# 2.3 特点\n\n优势                                 劣势\n提高数据检索的效率，降低数据库的io成本               索引列也是要占用空间的。\n通过索引列对数据进行排序，降低数据排序的成本，降低cpu的消耗。   索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行insert、update、delete时，效率降低。\n\n\n# 2.2 索引结构\n\n# 2.2.1 概述\n\nmysql的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\n\n索引结构              描述\nb+tree索引          最常见的索引类型，大部分引擎都支持 b+ 树索引\nhash索引            底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询\nr-tree(空间索 引）     空间索引是myisam引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少\nfull-text(全文索引)   是一种通过建立倒排索引,快速匹配文档的方式。类似于 lucene,solr,es\n\n上述是mysql中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。\n\n索引          innodb      myisam   memory\nb+tree索引    支持          支持       支持\nhash 索引     不支持         不支持      支持\nr-tree 索引   不支持         支持       不支持\nfull-text   5.6版本之后支持   支持       不支持\n\n> 注意： 我们平常所说的索引，如果没有特别指明，都是指b+树结构组织的索引。\n\n# 2.2.2 二叉树\n\n假如说mysql的索引结构采用二叉树的数据结构，比较理想的结构如下：\n\n\n\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\n\n\n\n所以，如果选择二叉树作为索引结构，会存在以下缺点：\n\n * 顺序插入时，会形成一个链表，查询性能大大降低。\n\n * 大数据量情况下，层级较深，检索速度慢。\n\n此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:\n\n\n\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\n\n * 大数据量情况下，层级较深，检索速度慢。\n\n所以，在mysql的索引结构中，并没有选择二叉树或者红黑树，而选择的是b+tree，那么什么是b+tree呢？在详解b+tree之前，先来介绍一个b-tree。\n\n# 2.2.3 b-tree\n\nb-tree，b树是一种多叉路衡查找树，相对于二叉树，b树每个节点可以有多个分支，即多叉。\n\n以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个b树每个节点最多存储4个key，5 个指针：\n\n\n\n> 知识小贴士: 树的度数指的是一个节点的子节点个数。\n\n我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~gall es/visualization/btree.html\n\n\n\n插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。\n\n\n\n特点：\n\n * 5阶的b树，每一个节点最多存储4个key，对应5个指针。\n\n * 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。\n\n * 在b树中，非叶子节点和叶子节点都会存放数据。\n\n# 2.2.4 b+tree\n\nb+tree是b-tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：\n\n\n\n我们可以看到，两部分：\n\n * 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\n\n我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~gall es/visualization/bplustree.html\n\n\n\n插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。\n\n\n\n最终我们看到，b+tree 与 b-tree相比，主要有以下三点区别：\n\n * 所有的数据都会出现在叶子节点。\n\n * 叶子节点形成一个单向链表。\n\n * 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\n\n上述我们所看到的结构是标准的b+tree的数据结构，接下来，我们再来看看mysql中优化之后的b+tree。\n\nmysql索引数据结构对经典的b+tree进行了优化。在原b+tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的b+tree，提高区间访问的性能，利于排序。\n\n\n\n# 2.2.5 hash\n\nmysql中除了支持b+tree索引，还支持一种索引类型---hash索引。\n\n1).结构\n\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。\n\n\n\n如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n\n\n2). 特点\n\na. hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）\n\nb. 无法利用索引完成排序操作\n\nc. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于b+tree索引\n\n3). 存储引擎支持\n\n在mysql中，支持hash索引的是memory存储引擎。 而innodb中具有自适应hash功能，hash索引是\n\ninnodb存储引擎根据b+tree索引在指定条件下自动构建的。\n\n> 思考题： 为什么innodb存储引擎选择使用b+tree索引结构?\n\n * a. 相对于二叉树，层级更少，搜索效率高；\n\n * b. 对于b-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；\n\n * c. 相对hash索引，b+tree支持范围匹配及排序操作；\n\n\n# 2.3 索引分类\n\n# 2.3.1 索引分类\n\n在mysql数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。\n\n分类     含义                           特点              关键字\n主键索引   针对于表中主键创建的索引                 默认自动创建, 只能有一个   primary\n唯一索引   避免同一个表中某数据列中的值重复             可以有多个           unique\n常规索引   快速定位特定数据                     可以有多个           \n全文索引   全文索引查找的是文本中的关键词，而不是比较索引中的值   可以有多个           fulltext\n\n# 2.3.2 聚集索引&二级索引\n\n而在在innodb存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n分类                      含义                              特点\n聚集索引(clustered index)   将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据   必须有,而且只有一个\n二级索引(secondary index)   将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键   可以存在多个\n\n聚集索引选取规则:\n\n * 如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引。\n\n * 如果表没有主键，或没有合适的唯一索引，则innodb会自动生成一个rowid作为隐藏的聚集索引。\n\n聚集索引和二级索引的具体结构如下：\n\n\n\n * 聚集索引的叶子节点下挂的是这一行的数据\n * 二级索引的叶子节点下挂的是该字段值对应的主键值。\n\n接下来，我们来分析一下，当我们执行如下的sql语句时，具体的查找过程是什么样子的。\n\n\n\n具体过程如下:\n\n 1. 由于是根据name字段进行查询，所以先根据name='arm'到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 arm 对应的主键值 10。\n\n 2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。\n\n 3. 最终拿到这一行的数据，直接返回即可。\n\n> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。\n> \n> 思考题：以下两条sql语句，那个执行效率高? 为什么?\n\nselect * from user where id = 10 ;\nselect * from user where name = 'arm' ;\n\n备注: id为主键，name字段创建的有索引；\n\n\n解答：\n\na 语句的执行性能要高于b 语句。因为a语句直接走聚集索引，直接返回数据。 而b语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。\n\n> 思考题：innodb主键索引的b+tree高度为多高呢?\n\n\n\n假设: 一行数据大小为1k，一页中可以存储16行这样的数据。innodb的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。高度为2：\nn * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170\n1171* 16 = 18736\n\n也就是说，如果树的高度为2，则可以存储 18000 多条记录。高度为3：\n1171 * 1171 * 16 = 21939856\n\n也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。\n\n\n\n# 2.4 索引语法\n\n1). 创建索引\n\ncreate [unique | fulltext] index index_name on table_name(index_col_name,...);\n\n\n2). 查看索引\n\nshow index from table_name;\n\n\n3). 删除索引\n\ndrop index index_name on table_name;\n\n\n案例演示:\n\n先来创建一张表 tb_user，并且查询测试数据。\n\ncreate table tb_user(\n\tid int primary key auto_increment comment '主键',\n\tname varchar(50) not null comment '用户名',\n\tphone varchar(11) not null comment '手机号',\n\temail varchar(100) comment '邮箱',\n\tprofession varchar(11) comment '专业',\n\tage tinyint unsigned comment '年龄',\n\tgender char(1) comment '性别 , 1: 男, 2: 女',\n\tstatus char(1) comment '状态',\n\tcreatetime datetime comment '创建时间'\n) comment '系统用户表';\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('吕布', '17799990000', 'lvbu666@163.com', '软件工程', 23, '1','6', '2001-02-02 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('曹操', '17799990001', 'caocao666@qq.com', '通讯工程', 33,'1', '0', '2001-03-05 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('赵云', '17799990002', '17799990@139.com', '英语', 34, '1','2', '2002-03-02 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('孙悟空', '17799990003', '17799990@sina.com', '工程造价', 54,'1', '0', '2001-07-02 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('花木兰', '17799990004', '19980729@sina.com', '软件工程', 23,'2', '1', '2001-04-22 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('大乔', '17799990005', 'daqiao666@sina.com', '舞蹈', 22, '2','0', '2001-02-07 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('露娜', '17799990006', 'luna_love@sina.com', '应用数学', 24,'2', '0', '2001-02-08 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('程咬金', '17799990007', 'chengyaojin@163.com', '化工', 38,'1', '5', '2001-05-23 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('项羽', '17799990008', 'xiaoyu666@qq.com', '金属材料', 43,'1', '0', '2001-09-18 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('白起', '17799990009', 'baiqi666@sina.com', '机械工程及其自动化', 27, '1', '2', '2001-08-16 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('韩信', '17799990010', 'hanxin520@163.com', '无机非金属材料工程', 27, '1', '0', '2001-06-12 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('荆轲', '17799990011', 'jingke123@163.com', '会计', 29, '1','0', '2001-05-11 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('兰陵王', '17799990012', 'lanlinwang666@126.com', '工程造价',44, '1', '1', '2001-04-09 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('狂铁', '17799990013', 'kuangtie@sina.com', '应用数学', 43,'1', '2', '2001-04-10 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('貂蝉', '17799990014', '84958948374@qq.com', '软件工程', 40,'2', '3', '2001-02-12 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('妲己', '17799990015', '2783238293@qq.com', '软件工程', 31,'2', '0', '2001-01-30 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('芈月', '17799990016', 'xiaomin2001@sina.com', '工业经济', 35,'2', '0', '2000-05-03 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('嬴政', '17799990017', '8839434342@qq.com', '化工', 38, '1','1', '2001-08-08 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('狄仁杰', '17799990018', 'jujiamlm8166@163.com', '国际贸易',30, '1', '0', '2007-03-12 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('安琪拉', '17799990019', 'jdodm1h@126.com', '城市规划', 51,'2', '0', '2001-08-15 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('典韦', '17799990020', 'ycaunanjian@163.com', '城市规划', 52,'1', '2', '2000-04-12 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('廉颇', '17799990021', 'lianpo321@126.com', '土木工程', 19,'1', '3', '2002-07-18 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('后羿', '17799990022', 'altycj2000@139.com', '城市园林', 20,'1', '0', '2002-03-10 00:00:00');\ninsert into tb_user (name, phone, email, profession, age, gender, status,createtime) values ('姜子牙', '17799990023', '37483844@qq.com', '工程造价', 29,'1', '4', '2003-05-26 00:00:00');\n\n\n表结构中插入的数据如下：\n\nmariadb [itheima]> select * from tb_user;\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n| id | name      | phone       | email                 | profession                  | age  | gender | status | createtime          |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n|  1 | 吕布      | 17799990000 | lvbu666@163.com       | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |\n|  2 | 曹操      | 17799990001 | caocao666@qq.com      | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |\n|  3 | 赵云      | 17799990002 | 17799990@139.com      | 英语                        |   34 | 1      | 2      | 2002-03-02 00:00:00 |\n|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价                    |   54 | 1      | 0      | 2001-07-02 00:00:00 |\n|  5 | 花木兰    | 17799990004 | 19980729@sina.com     | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |\n|  6 | 大乔      | 17799990005 | daqiao666@sina.com    | 舞蹈                        |   22 | 2      | 0      | 2001-02-07 00:00:00 |\n|  7 | 露娜      | 17799990006 | luna_love@sina.com    | 应用数学                    |   24 | 2      | 0      | 2001-02-08 00:00:00 |\n|  8 | 程咬金    | 17799990007 | chengyaojin@163.com   | 化工                        |   38 | 1      | 5      | 2001-05-23 00:00:00 |\n|  9 | 项羽      | 17799990008 | xiaoyu666@qq.com      | 金属材料                    |   43 | 1      | 0      | 2001-09-18 00:00:00 |\n| 10 | 白起      | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |\n| 11 | 韩信      | 17799990010 | hanxin520@163.com     | 无机非金属材料工程          |   27 | 1      | 0      | 2001-06-12 00:00:00 |\n| 12 | 荆轲      | 17799990011 | jingke123@163.com     | 会计                        |   29 | 1      | 0      | 2001-05-11 00:00:00 |\n| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价                    |   44 | 1      | 1      | 2001-04-09 00:00:00 |\n| 14 | 狂铁      | 17799990013 | kuangtie@sina.com     | 应用数学                    |   43 | 1      | 2      | 2001-04-10 00:00:00 |\n| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com    | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |\n| 16 | 妲己      | 17799990015 | 2783238293@qq.com     | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |\n| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济                    |   35 | 2      | 0      | 2000-05-03 00:00:00 |\n| 18 | 嬴政      | 17799990017 | 8839434342@qq.com     | 化工                        |   38 | 1      | 1      | 2001-08-08 00:00:00 |\n| 19 | 狄仁杰    | 17799990018 | jujiamlm8166@163.com  | 国际贸易                    |   30 | 1      | 0      | 2007-03-12 00:00:00 |\n| 20 | 安琪拉    | 17799990019 | jdodm1h@126.com       | 城市规划                    |   51 | 2      | 0      | 2001-08-15 00:00:00 |\n| 21 | 典韦      | 17799990020 | ycaunanjian@163.com   | 城市规划                    |   52 | 1      | 2      | 2000-04-12 00:00:00 |\n| 22 | 廉颇      | 17799990021 | lianpo321@126.com     | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |\n| 23 | 后羿      | 17799990022 | altycj2000@139.com    | 城市园林                    |   20 | 1      | 0      | 2002-03-10 00:00:00 |\n| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价                    |   29 | 1      | 4      | 2003-05-26 00:00:00 |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n24 rows in set (0.000 sec)\n![](media/image36.jpg){width=\"6.138267716535433in\" height=\"3.1889818460192476in\"}\n\n\n数据准备好了之后，接下来，我们就来完成如下需求：\n\na. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。\n\nmariadb [itheima]> create index idx_user_name on tb_user(name);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\nb. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。\n\nmariadb [itheima]> create index idx_user_phone on tb_user(phone);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\nc. 为profession、age、status创建联合索引。\n\nmariadb [itheima]> create index idx_user_pro_age_sta on tb_user(profession,age,status);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\nd. 为email建立合适的索引来提升查询效率。\n\nmariadb [itheima]> create index idx_email on tb_user(email);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\n完成上述的需求之后，我们再查看tb_user表的所有的索引数据。\n\nmariadb [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone_name  |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone_name  |            2 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_use_profession   |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email_5          |            1 | email       | a         |          24 |        5 | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n11 rows in set (0.000 sec)\n\n\n\n# 2.5 sql性能分析\n\n# 2.5.1 sql执行频率\n\nmysql 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的insert、update、delete、select的访问频次：\n\n-- session 是查看当前会话 ;\n-- global 是查询全局数据 ;\nshow global status like 'com_______';\n\nmariadb [itheima]> show global status like 'com_______';\n+---------------+---------+\n| variable_name | value   |\n+---------------+---------+\n| com_backup    | 0       |\n| com_binlog    | 0       |\n| com_commit    | 0       |\n| com_delete    | 0       |\n| com_insert    | 1119203 |\n| com_repair    | 0       |\n| com_revoke    | 0       |\n| com_select    | 134     |\n| com_signal    | 0       |\n| com_update    | 0       |\n| com_xa_end    | 0       |\n+---------------+---------+\n11 rows in set (0.001 sec)\n\n\ncom_delete: 删除次数\n\ncom_insert: 插入次数\n\ncom_select: 查询次数\n\ncom_update: 更新次数\n\n我们可以在当前数据库再执行几次查询操作，然后再次查看执行频次，看看 com_select 参数会不会变化。\n\nmariadb [itheima]> show global status like 'com_______';\n+---------------+---------+\n| variable_name | value   |\n+---------------+---------+\n| com_backup    | 0       |\n| com_binlog    | 0       |\n| com_commit    | 0       |\n| com_delete    | 0       |\n| com_insert    | 1152203 |\n| com_repair    | 0       |\n| com_revoke    | 0       |\n| com_select    | 134     |\n| com_signal    | 0       |\n| com_update    | 0       |\n| com_xa_end    | 0       |\n+---------------+---------+\n11 rows in set (0.001 sec)\n\n\n> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以\n> \n> 查询为主，那么就要考虑对数据库的索引进行优化了。\n\n那么通过查询sql的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询日志。\n\n接下来，我们就来介绍一下mysql中的慢查询日志。\n\n# 2.5.2 慢查询日志\n\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有sql语句的日志。\n\nmysql的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\n\nmariadb [itheima]> show variables like 'slow_query_log';\n+----------------+-------+\n| variable_name  | value |\n+----------------+-------+\n| slow_query_log | off   |\n+----------------+-------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> show variables like 'slow_query_log'\\g;\n*************************** 1. row ***************************\nvariable_name: slow_query_log\n        value: off\n1 row in set (0.000 sec)\n\nerror: no query specified\n\n\n如果要开启慢查询日志，需要在mysql的配置文件（/etc/my.cnf）中配置如下信息：\n\n[mysqld]\n# 开启mysql慢日志查询开关\nslow_query_log=1\n\n# 设置慢日志的时间为2秒，sql语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\nlong_query_time=2\n\n\n配置完毕之后，通过以下指令重新启动mysql服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。\n\n然后，再次查看开关情况，慢查询日志就已经打开了。\n\nmariadb [itheima]> show variables like 'slow_query_log';\n+----------------+-------+\n| variable_name  | value |\n+----------------+-------+\n| slow_query_log | on    |\n+----------------+-------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> show variables like 'slow_query_log'\\g;\n*************************** 1. row ***************************\nvariable_name: slow_query_log\n        value: on\n1 row in set (0.000 sec)\n\n\n测试：\n\na. 执行如下sql语句 ：\n\nselect * from tb_user; -- 这条sql执行效率比较高, 执行耗时 0.00sec\n\nselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec\n\n\nb. 检查慢查询日志 ：\n\n最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的sql，执行较快的sql 是不会记录的。\n\n\n\n那这样，通过慢查询日志，就可以定位出执行效率比较低的sql，从而有针对性的进行优化。\n\n# 2.5.3 profile详情\n\nshow profiles 能够在做sql优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前mysql是否支持profile操作：\n\nmariadb [itheima]> select @@have_profiling;\n+------------------+\n| @@have_profiling |\n+------------------+\n| yes              |\n+------------------+\n1 row in set (0.000 sec)\n\n\n可以看到，当前mysql是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：\n\nset profiling = 1;\n\n\n开关已经打开了，接下来，我们所执行的sql语句，都会被mysql记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的sql语句：\n\nselect * from tb_user;\nselect * from tb_user where id = 1;\nselect * from tb_user where name = '白起';\nselect count(*) from tb_sku;\n\n\n执行一系列的业务sql的操作，然后通过如下指令查看指令的执行耗时：\n\n-- 查看每一条sql的耗时基本情况\nshow profiles;\n\n-- 查看指定query_id的sql语句各个阶段的耗时情况\nshow profile for query query_id;\n\n-- 查看指定query_id的sql语句cpu的使用情况\nshow profile cpu for query query_id;\n\n\n查看每一条sql的耗时情况:\n\nmariadb [itheima]> show profiles;\n+----------+------------+---------------------------------------------+\n| query_id | duration   | query                                       |\n+----------+------------+---------------------------------------------+\n|        1 | 0.00014831 | select * from tb_user where id = 1          |\n|        2 | 0.00037277 | select * from tb_user where name = '白起'   |\n|        3 | 0.00016053 | select * from tb_user where id = 1          |\n|        4 | 0.00015029 | select * from tb_user where id = 1          |\n+----------+------------+---------------------------------------------+\n4 rows in set (0.000 sec)\n\n\n查看指定sql各个阶段的耗时情况 :\n\nmariadb [itheima]> show profile for query 3;\n+------------------------+----------+\n| status                 | duration |\n+------------------------+----------+\n| starting               | 0.000035 |\n| checking permissions   | 0.000003 |\n| opening tables         | 0.000022 |\n| after opening tables   | 0.000004 |\n| system lock            | 0.000002 |\n| table lock             | 0.000003 |\n| init                   | 0.000018 |\n| optimizing             | 0.000010 |\n| statistics             | 0.000025 |\n| preparing              | 0.000001 |\n| unlocking tables       | 0.000002 |\n| preparing              | 0.000006 |\n| executing              | 0.000001 |\n| sending data           | 0.000009 |\n| end of update loop     | 0.000001 |\n| query end              | 0.000001 |\n| commit                 | 0.000002 |\n| closing tables         | 0.000001 |\n| unlocking tables       | 0.000000 |\n| closing tables         | 0.000002 |\n| starting cleanup       | 0.000001 |\n| freeing items          | 0.000002 |\n| updating status        | 0.000009 |\n| reset for next command | 0.000001 |\n+------------------------+----------+\n24 rows in set (0.000 sec)\n\n\n# 2.5.4 explain\n\nexplain 或者 desc命令获取 mysql 如何执行 select 语句的信息，包括在 select 语句执行过程中表如何连接和连接的顺序。语法:\n\n-- 直接在select语句之前加上关键字 explain / desc\nexplain select 字段列表 from 表名 where 条件 ;\n\n\nexplain 执行计划中各个字段的含义:\n\n字段             含义\nid             select查询的序列号，表示查询中执行select子句或者是操作表的顺序\n               (id相同，执行顺序从上到下；id不同，值越大，越先执行)。\nselect_type    表示 select 的类型，常见的取值有\n               simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、 union（union\n               中的第二个或者后面的查询语句）、 subquery（select/where之后包含了子查询）等\ntype           表示连接类型，性能由好到差的连接类型为null、system、const、 eq_ref、ref、range、\n               index、all 。\npossible_key   显示可能应用在这张表上的索引，一个或多个。\nkey            实际使用的索引，如果为null，则没有使用索引。\nkey_len        表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\nrows           mysql认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\nfiltered       表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。\n\n# 2.6 索引使用\n\n# 2.6.1 验证索引效率\n\n在讲解索引的使用原则之前，先通过一个简单的案例，来验证一下索引，看看是否能够通过索引来提升数据查询性能。在演示的时候，我们还是使用之前准备的一张表 tb_sku , 在这张表中准备了1000w 的记录。\n\n\n\n这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 我们先来查询其中的一条记录，看看里面的字段情况，执行如下sql：\n\nselect * from tb_sku where id = 1\\g;\n\n\n\n\n可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。 那么接下来，我们再来根据 sn 字段进行查询，执行如下sql：\n\nselect * from tb_sku where sn = '100000003145001';\n\n\n\n\n我们可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索引，而造成查询效率很低。\n\n那么我们可以针对于sn字段，建立一个索引，建立了索引之后，我们再次根据sn进行查询，再来看一下查询耗时情况。\n\n创建索引：\n\ncreate index idx_sku_sn on tb_sku(sn) ;\n\n\n\n\n然后再次执行相同的sql语句，再次查看sql的耗时。\n\nselect * from tb_sku where sn = '100000003145001';\n\n\n我们明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数量级的。\n\n\n\n# 2.6.2 最左前缀法则\n\n如果索引了多列（联合索引），要遵守最左前 法则。最左前 法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。\n\n以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。\n\nmariadb [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n7 rows in set (0.000 sec)\n\n\n在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前 法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。\n\n而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下具体的执行计划：\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref         | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const | 1    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\n以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age 字段索引长度为2、status字段索引长度为5。\n\nmariadb [itheima]> explain select * from tb_user where age = 31 and status = '0';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | null          | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where status = '0';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | null          | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前 法则，联合索引最左边的列profession不存在。\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n上述的sql查询时，存在profession字段，最左边的列是存在的，索引满足最左前 法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。\n\n> 思考题：当执行sql语句: explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程'； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？\n> \n> mariadb [itheima]> explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程';\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> | id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | extra                 |\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> |    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | using index condition |\n> +------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n> 1 row in set (0.000 sec)\n> \n> \n> 可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写sql时，条件编写的先后顺序无关。\n\n# 2.6.3 范围查询\n\n联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age > 30 and status = '0';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | simple      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | null | 2    | using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n当范围查询使用> 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age >= 30 and status = '0';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | simple      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | null | 2    | using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。所以，在业务允许的情况下，尽可能的使用类似于 >= 或<= 这类的范围查询，而避免使用 > 或 <。\n\n# 2.6.4 索引失效情况\n\n2.6.4.1 索引列运算 不要在索引列上进行运算操作， 索引将失效。\n\n在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。\n\nmariadb [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n7 rows in set (0.000 sec)\n\n\n\na. 当根据phone字段进行等值匹配查询时, 索引生效。\n\nmariadb [itheima]> explain select * from tb_user where phone = '17799990015';\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref   | rows | extra |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n|    1 | simple      | tb_user | const | idx_user_phone | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\n\nb. 当根据phone字段进行函数运算操作之后，索引失效。\n\nmariadb [itheima]> explain select * from tb_user where substring(phone,10,2) = '15';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | null          | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n2.6.4.2 字符串不加引号\n\n字符串类型字段使用时，不加引号，索引将失效。\n\n接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref               | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const | 1    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------------+------+-----------------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = 0;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref         | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const | 1    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\nmariadb [itheima]> explain select * from tb_user where phone = '17799990015';\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref   | rows | extra |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n|    1 | simple      | tb_user | const | idx_user_phone | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+----------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where phone = 17799990015;\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | idx_user_phone | null | null    | null | 24   | using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。\n\n2.6.4.3 模糊查询\n\n如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n\n接下来，我们来看一下这三条sql语句的执行效果，查看一下其执行计划：\n\n由于下面查询语句中，都是根据profession字段查询，符合最左前 法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。\n\nmariadb [itheima]> explain select * from tb_user where profession like '软件%';\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys        | key                  | key_len | ref  | rows | extra                 |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n|    1 | simple      | tb_user | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | null | 4    | using index condition |\n+------+-------------+---------+-------+----------------------+----------------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where profession like '%工程';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | null          | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where profession like '%工%';\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | null          | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。\n\n3.6.4.4 or连接条件\n\n用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n\nmariadb [itheima]> explain select * from tb_user where id = 10 or age = 23;\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | primary       | null | null    | null | 24   | using where |\n+------+-------------+---------+------+---------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where phone = '17799990017' or age = 23;\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | idx_user_phone | null | null    | null | 24   | using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。\n\n然后，我们可以对age字段建立索引。\n\nmariadb [itheima]> create index idx_user_age on tb_user(age);\nquery ok, 0 rows affected (0.003 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\n建立了索引之后，我们再次执行上述的sql语句，看看前后执行计划的变化。\n\n\n\n最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。\n\n3.6.4.5 数据分布影响\n\n如果mysql评估使用索引比全表更慢，则不使用索引。\n\nmariadb [itheima]> explain select * from tb_user where phone >= '17799990015';\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys  | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | idx_user_phone | null | null    | null | 24   | using where |\n+------+-------------+---------+------+----------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where phone >= '17799999015';\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n| id   | select_type | table   | type  | possible_keys  | key            | key_len | ref  | rows | extra                 |\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n|    1 | simple      | tb_user | range | idx_user_phone | idx_user_phone | 46      | null | 1    | using index condition |\n+------+-------------+---------+-------+----------------+----------------+---------+------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n\n经过测试我们发现，相同的sql语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？\n\n就是因为mysql在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。\n\n接下来，我们再来看看 is null 与 is not null 操作是否走索引。\n\n执行如下两条语句 ：\n\nmariadb [itheima]> explain select * from tb_user where profession is null;\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 1    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\nmariadb [itheima]> explain select * from tb_user where profession is not null;\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n| id   | select_type | table   | type | possible_keys        | key  | key_len | ref  | rows | extra       |\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n|    1 | simple      | tb_user | all  | idx_user_pro_age_sta | null | null    | null | 24   | using where |\n+------+-------------+---------+------+----------------------+------+---------+------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n最终我们看到，一模一样的sql语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时mysql会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。\n\n# 2.6.5 sql提示\n\n目前tb_user表的数据情况如下:\n\nmariadb [itheima]> select * from tb_user;\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n| id | name      | phone       | email                 | profession                  | age  | gender | status | createtime          |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n|  1 | 吕布      | 17799990000 | lvbu666@163.com       | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |\n|  2 | 曹操      | 17799990001 | caocao666@qq.com      | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |\n|  3 | 赵云      | 17799990002 | 17799990@139.com      | 英语                        |   34 | 1      | 2      | 2002-03-02 00:00:00 |\n|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价                    |   54 | 1      | 0      | 2001-07-02 00:00:00 |\n|  5 | 花木兰    | 17799990004 | 19980729@sina.com     | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |\n|  6 | 大乔      | 17799990005 | daqiao666@sina.com    | 舞蹈                        |   22 | 2      | 0      | 2001-02-07 00:00:00 |\n|  7 | 露娜      | 17799990006 | luna_love@sina.com    | 应用数学                    |   24 | 2      | 0      | 2001-02-08 00:00:00 |\n|  8 | 程咬金    | 17799990007 | chengyaojin@163.com   | 化工                        |   38 | 1      | 5      | 2001-05-23 00:00:00 |\n|  9 | 项羽      | 17799990008 | xiaoyu666@qq.com      | 金属材料                    |   43 | 1      | 0      | 2001-09-18 00:00:00 |\n| 10 | 白起      | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |\n| 11 | 韩信      | 17799990010 | hanxin520@163.com     | 无机非金属材料工程          |   27 | 1      | 0      | 2001-06-12 00:00:00 |\n| 12 | 荆轲      | 17799990011 | jingke123@163.com     | 会计                        |   29 | 1      | 0      | 2001-05-11 00:00:00 |\n| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价                    |   44 | 1      | 1      | 2001-04-09 00:00:00 |\n| 14 | 狂铁      | 17799990013 | kuangtie@sina.com     | 应用数学                    |   43 | 1      | 2      | 2001-04-10 00:00:00 |\n| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com    | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |\n| 16 | 妲己      | 17799990015 | 2783238293@qq.com     | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |\n| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济                    |   35 | 2      | 0      | 2000-05-03 00:00:00 |\n| 18 | 嬴政      | 17799990017 | 8839434342@qq.com     | 化工                        |   38 | 1      | 1      | 2001-08-08 00:00:00 |\n| 19 | 狄仁杰    | 17799990018 | jujiamlm8166@163.com  | 国际贸易                    |   30 | 1      | 0      | 2007-03-12 00:00:00 |\n| 20 | 安琪拉    | 17799990019 | jdodm1h@126.com       | 城市规划                    |   51 | 2      | 0      | 2001-08-15 00:00:00 |\n| 21 | 典韦      | 17799990020 | ycaunanjian@163.com   | 城市规划                    |   52 | 1      | 2      | 2000-04-12 00:00:00 |\n| 22 | 廉颇      | 17799990021 | lianpo321@126.com     | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |\n| 23 | 后羿      | 17799990022 | altycj2000@139.com    | 城市园林                    |   20 | 1      | 0      | 2002-03-10 00:00:00 |\n| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价                    |   29 | 1      | 4      | 2003-05-26 00:00:00 |\n+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+\n24 rows in set (0.000 sec)\n\n\n\n索引情况如下:\n\nmariadb [itheima]> show index from tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_age         |            1 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n8 rows in set (0.000 sec)\n\n\n\n把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。\n\na. 执行sql : explain select * from tb_user where profession = '软件工程';\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n查询走了联合索引。\n\nb. 执行sql，创建profession的单列索引：create index idx_user_pro on tb_user(profession);\n\nmariadb [itheima]> create index idx_user_pro on tb_user(profession);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\n\n\nc. 创建单列索引后，再次执行a中的sql语句，查看执行计划，看看到底走哪个索引。\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程';\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n| id   | select_type | table   | type | possible_keys        | key                  | key_len | ref   | rows | extra                 |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const | 4    | using index condition |\n+------+-------------+---------+------+----------------------+----------------------+---------+-------+------+-----------------------+\n1 row in set (0.000 sec)\n\n\n测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终mysql选择了idx_user_pro_age_sta索引。这是mysql自动选择的结果。\n\n那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 mysql的sql提示来完成。 接下来，介绍一下sql提示。\n\nsql提示，是优化数据库的一个重要手段，简单来说，就是在sql语句中加入一些人为的提示来达到优化操作的目的。\n\n * use index ： 建议mysql使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。\n * ignore index ： 忽略指定的索引。\n * force index ： 强制使用索引。\n\n示例演示：\n\na. use index\n\nexplain select * from tb_user use index(idx_user_pro) where profession = '软件工程';\n\n\nb. ignore index\n\nexplain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';\n\n\nc. force index\n\nexplain select * from tb_user force index(idx_user_pro) where profession = '软件程';\n\n\n# 2.6.6 覆盖索引\n\n尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。接下来，我们来看一组sql的执行计划，看看执行计划的差别，然后再来具体做一个解析。\n\n上述这几条sql的执行结果为:\n\nmariadb [itheima]> explain select id, profession from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n| id   | select_type | table   | type | possible_keys                                  | key                  | key_len | ref               | rows | extra                    |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_pro_age_sta | 54      | const,const,const | 1    | using where; using index |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n1 row in set (0.000 sec)\n\n\nmariadb [itheima]> explain select id,profession,age, status from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n| id   | select_type | table   | type | possible_keys                                  | key                  | key_len | ref               | rows | extra                    |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n|    1 | simple      | tb_user | ref  | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_pro_age_sta | 54      | const,const,const | 1    | using where; using index |\n+------+-------------+---------+------+------------------------------------------------+----------------------+---------+-------------------+------+--------------------------+\n1 row in set (0.000 sec)\n\n\nmariadb [itheima]> explain select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status = '0' ;\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n| id   | select_type | table   | type       | possible_keys                                  | key                       | key_len | ref   | rows   | extra                           |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n|    1 | simple      | tb_user | ref|filter | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_age|idx_user_pro | 2|47    | const | 1 (4%) | using where; using rowid filter |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+--------+---------------------------------+\n1 row in set (0.000 sec)\n\n\nmariadb [itheima]> explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n| id   | select_type | table   | type       | possible_keys                                  | key                       | key_len | ref   | rows    | extra                           |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n|    1 | simple      | tb_user | ref|filter | idx_user_pro_age_sta,idx_user_age,idx_user_pro | idx_user_age|idx_user_pro | 2|47    | const | 1 (17%) | using where; using rowid filter |\n+------+-------------+---------+------------+------------------------------------------------+---------------------------+---------+-------+---------+---------------------------------+\n1 row in set (0.000 sec)\n\n\n\n从上述的执行计划我们可以看到，这四条sql语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的extra，前面两天sql的结果为 using where; using index ; 而后面两条sql的结果为: using index condition 。\n\nextra                      含义\nusing where; using index   查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\nusing index condition      查找使用了索引，但是需要回表查询数据\n\n因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。\n\n为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组sql的执行过程。\n\na. 表结构及索引示意图:\n\n\n\nid是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。\n\nb. 执行sql : select * from tb_user where id = 2;\n\n\n\n根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。\n\nc. 执行sql：selet id,name from tb_user where name = 'arm';\n\n\n\n虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。\n\nd. 执行sql：selet id,name,gender from tb_user where name = 'arm';\n\n\n\n由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。\n\n> 思考题：\n\n一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下sql语句进行优化, 该如何进行才是最优方案:\n\nselect id,username,password from tb_user where username = 'itcast';\n\n答案: 针对于 username, password建立联合索引, sql为:\n\ncreate index idx_user_name_pass on tb_user(username,password);\n\n这样可以避免上述的sql语句，在查询的过程中，出现回表查询。\n\n# 2.6.7 前缀索引\n\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘io， 影响查询效率。此时可以只将字符串的一部分前 ，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n\n1). 语法\n\ncreate index idx_xxxx on table_name(column(n));\n\n\n示例:\n\n为tb_user表的email字段，建立长度为5的前 索引。\n\nmariadb [itheima]> create index idx_email_5 on tb_user(email(5));\n\n\nmariadb [itheima]> show index from  tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_age         |            1 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro         |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email_5          |            1 | email       | a         |          24 |        5 | null   | yes  | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n10 rows in set (0.000 sec)\n\n\n2). 前 长度\n\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\n\nselect count(distinct email) / count(*) from tb_user ;\nselect count(distinct substring(email,1,5)) / count(*) from tb_user ;\n\n\n3). 前 索引的查询流程\n\n\n\n# 2.6.8 单列索引与联合索引\n\n单列索引：即一个索引只包含单个列。联合索引：即一个索引包含了多个列。\n\n我们先来看看 tb_user 表中目前的索引情况:\n\nmariadb [itheima]> show index from  tb_user;\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| table   | non_unique | key_name             | seq_in_index | column_name | collation | cardinality | sub_part | packed | null | index_type | comment | index_comment | ignored |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n| tb_user |          0 | primary              |            1 | id          | a         |           2 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          0 | idx_user_phone       |            1 | phone       | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email            |            1 | email       | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_name        |            1 | name        | a         |          24 |     null | null   |      | btree      |         |               | no      |\n| tb_user |          1 | idx_user_age         |            1 | age         | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_user_pro         |            1 | profession  | a         |          24 |     null | null   | yes  | btree      |         |               | no      |\n| tb_user |          1 | idx_email_5          |            1 | email       | a         |          24 |        5 | null   | yes  | btree      |         |               | no      |\n+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+\n10 rows in set (0.000 sec)\n\n\n在查询出来的索引中，既有单列索引，又有联合索引。\n\n接下来，我们来执行一条sql语句，看看其执行计划：\n\nmariadb [itheima]> explain select id,phone,name from tb_user where phone = '17799990010' and name = '韩信';\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n| id   | select_type | table   | type  | possible_keys                | key            | key_len | ref   | rows | extra |\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n|    1 | simple      | tb_user | const | idx_user_phone,idx_user_name | idx_user_phone | 46      | const | 1    |       |\n+------+-------------+---------+-------+------------------------------+----------------+---------+-------+------+-------+\n1 row in set (0.000 sec)\n\n\n\n通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。\n\n紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。\n\nmariadb [itheima]> create unique index idx_user_phone_name on tb_user(phone,name);\nquery ok, 0 rows affected (0.004 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\nmariadb [itheima]> explain select id,phone,name from tb_user use index(idx_user_phone_name) where phone = '17799990010' and name = '韩信';\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n| id   | select_type | table   | type  | possible_keys       | key                 | key_len | ref         | rows | extra       |\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n|    1 | simple      | tb_user | const | idx_user_phone_name | idx_user_phone_name | 248     | const,const | 1    | using index |\n+------+-------------+---------+-------+---------------------+---------------------+---------+-------------+------+-------------+\n1 row in set (0.000 sec)\n\n\n\n此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。\n\n> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，\n> \n> 而非单列索引。\n\n如果查询使用的是联合索引，具体的结构示意图如下：\n\n\n\n# 2.7 索引设计原则\n\n 1. 针对于数据量较大，且查询比较频繁的表建立索引。\n\n 2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n\n 3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n\n 4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前 索引。\n\n 5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n 6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n\n 7. 如果索引列不能存储null值，请在创建表时使用not null约束它。当优化器知道每列是否包含\n\n 8. null值时，它可以更好地确定哪个索引最有效地用于查询。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"MySQL的事务",frontmatter:{title:"MySQL的事务",date:"2022-06-11T16:37:35.000Z",category:["Mysql"],tag:["Mysql"],permalink:"/pages/904c55/"},regularPath:"/01.%E6%8C%87%E5%8D%97/04.%E6%95%B0%E6%8D%AE%E5%BA%93/08.MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1.html",relativePath:"01.指南/04.数据库/08.MySQL的事务.md",key:"v-6f629324",path:"/pages/904c55/",headers:[{level:2,title:"事务简介",slug:"事务简介",normalizedTitle:"事务简介",charIndex:15},{level:2,title:"事务操作",slug:"事务操作",normalizedTitle:"事务操作",charIndex:500},{level:3,title:"未控制事务",slug:"未控制事务",normalizedTitle:"未控制事务",charIndex:827},{level:3,title:"控制事务一",slug:"控制事务一",normalizedTitle:"控制事务一",charIndex:1711},{level:3,title:"控制事务二",slug:"控制事务二",normalizedTitle:"控制事务二",charIndex:2214},{level:2,title:"事务四大特性",slug:"事务四大特性",normalizedTitle:"事务四大特性",charIndex:2609},{level:2,title:"并发事务问题",slug:"并发事务问题",normalizedTitle:"并发事务问题",charIndex:2839},{level:2,title:"事务隔离级别",slug:"事务隔离级别",normalizedTitle:"事务隔离级别",charIndex:3043}],headersStr:"事务简介 事务操作 未控制事务 控制事务一 控制事务二 事务四大特性 并发事务问题 事务隔离级别",content:"# MySQL的事务\n\n\n# 事务简介\n\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加\n\n1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\n\n\n\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 :\n\n\n\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\n\n\n\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\n\n\n\n> 注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。\n\n\n# 事务操作\n\n数据准备：\n\n-- ---------------------------- 事务操作 ----------------------------\n-- 数据准备\ncreate table account(\n    id int auto_increment primary key comment '主键ID',\n    name varchar(10) comment '姓名',\n    money int comment '余额'\n) comment '账户表';\ninsert into account(id, name, money) VALUES (null,'张三',2000),(null,'李四',2000);\n\n\n\n\n# 未控制事务\n\n1). 测试正常情况\n\n-- 查看张三余额\nmysql> select * from account where name = '张三';\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | 张三 |  2000 |\n+----+------+-------+\n1 row in set (0.00 sec)\n\n-- 张三的余额减少1000\nmysql> update account set money = money - 1000 where name = '张三';\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n-- 李四的余额增加1000\nmysql> update account set money = money + 1000 where name = '李四';\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\n\n\n\n2). 测试异常情况\n\n我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语法,执行就会报错)，检查 终的数据情况, 发现数据在操作前后不一致了。\n\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n出错了....\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n\n\n# 控制事务一\n\n1). 查看/设置事务提交方式\n\nSELECT @@autocommit;\nSET @@autocommit = 0;  //设置手动提交\n\n\n2). 提交事务\n\nCOMMIT;\n\n\n3). 回滚事务\n\nROLLBACK;\n\n\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\n\n控制事务示例：\n\nset @@autocommit = 0;\n\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n\n程序执行报错...\n\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n--- 提交事务\ncommit;\n\n--- 回滚事务\nrollback;\n\n\n\n# 控制事务二\n\n1). 开启事务\n\nSTART TRANSACTION 或 BEGIN;\n\n\n2). 提交事务\n\nCOMMIT;\n\n\n3). 回滚事务\n\nROLLBACK;\n\n\n转账案例：\n\n-- 开启事务\nstart transaction;\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n-- 如果正常执行完毕, 则提交事务\ncommit;\n-- 如果执行过程中报错, 则回滚事务\n-- rollback;\n\n\n\n# 事务四大特性\n\n * 原子性（Atomicity）：事务是不可分割的 小操作单元，要么全部成功，要么全部失败。\n * 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n * 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n * 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n上述就是事务的四大特性，简称ACID。\n\n\n\n\n# 并发事务问题\n\n1). 赃读：一个事务读到另外一个事务还没有提交的数据。\n\n\n\n比如B读取到了A未提交的数据。\n\n2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n\n\n\n事务A两次读取同一条记录，但是读取到的数据却是不一样的。\n\n3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 \"幻影\"。\n\n\n\n\n# 事务隔离级别\n\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\n\n隔离级别                  脏读   不可重复读   幻读\nRead uncommitted      √    √       √\nRead committed        ×    √       √\nRepeatable Read(默认)   ×    ×       √\nSerializable          ×    ×       ×\n\n1). 查看事务隔离级别\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| REPEATABLE-READ         |\n+-------------------------+\n1 row in set (0.00 sec)\n\n\n2). 设置事务隔离级别\n\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }\n\n\nmysql> set session transaction isolation level read uncommitted;\nmysql> set session transaction isolation level repeatable read;\n\n\n> 注意：事务隔离级别越高，数据越安全，但是性能越低。",normalizedContent:"# mysql的事务\n\n\n# 事务简介\n\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加\n\n1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\n\n\n\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 :\n\n\n\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\n\n\n\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\n\n\n\n> 注意： 默认mysql的事务是自动提交的，也就是说，当执行完一条dml语句时，mysql会立即隐式的提交事务。\n\n\n# 事务操作\n\n数据准备：\n\n-- ---------------------------- 事务操作 ----------------------------\n-- 数据准备\ncreate table account(\n    id int auto_increment primary key comment '主键id',\n    name varchar(10) comment '姓名',\n    money int comment '余额'\n) comment '账户表';\ninsert into account(id, name, money) values (null,'张三',2000),(null,'李四',2000);\n\n\n\n\n# 未控制事务\n\n1). 测试正常情况\n\n-- 查看张三余额\nmysql> select * from account where name = '张三';\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | 张三 |  2000 |\n+----+------+-------+\n1 row in set (0.00 sec)\n\n-- 张三的余额减少1000\nmysql> update account set money = money - 1000 where name = '张三';\nquery ok, 1 row affected (0.01 sec)\nrows matched: 1  changed: 1  warnings: 0\n\n-- 李四的余额增加1000\nmysql> update account set money = money + 1000 where name = '李四';\nquery ok, 1 row affected (0.01 sec)\nrows matched: 1  changed: 1  warnings: 0\n\n\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\n\n\n\n2). 测试异常情况\n\n我们把数据都恢复到2000， 然后再次一次性执行上述的sql语句(出错了.... 这句话不符合sql语法,执行就会报错)，检查 终的数据情况, 发现数据在操作前后不一致了。\n\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n出错了....\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n\n\n# 控制事务一\n\n1). 查看/设置事务提交方式\n\nselect @@autocommit;\nset @@autocommit = 0;  //设置手动提交\n\n\n2). 提交事务\n\ncommit;\n\n\n3). 回滚事务\n\nrollback;\n\n\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的dml语句都不会提交, 需要手动的执行commit进行提交。\n\n控制事务示例：\n\nset @@autocommit = 0;\n\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n\n程序执行报错...\n\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n--- 提交事务\ncommit;\n\n--- 回滚事务\nrollback;\n\n\n\n# 控制事务二\n\n1). 开启事务\n\nstart transaction 或 begin;\n\n\n2). 提交事务\n\ncommit;\n\n\n3). 回滚事务\n\nrollback;\n\n\n转账案例：\n\n-- 开启事务\nstart transaction;\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n-- 如果正常执行完毕, 则提交事务\ncommit;\n-- 如果执行过程中报错, 则回滚事务\n-- rollback;\n\n\n\n# 事务四大特性\n\n * 原子性（atomicity）：事务是不可分割的 小操作单元，要么全部成功，要么全部失败。\n * 一致性（consistency）：事务完成时，必须使所有的数据都保持一致状态。\n * 隔离性（isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n * 持久性（durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n上述就是事务的四大特性，简称acid。\n\n\n\n\n# 并发事务问题\n\n1). 赃读：一个事务读到另外一个事务还没有提交的数据。\n\n\n\n比如b读取到了a未提交的数据。\n\n2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n\n\n\n事务a两次读取同一条记录，但是读取到的数据却是不一样的。\n\n3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 \"幻影\"。\n\n\n\n\n# 事务隔离级别\n\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\n\n隔离级别                  脏读   不可重复读   幻读\nread uncommitted      √    √       √\nread committed        ×    √       √\nrepeatable read(默认)   ×    ×       √\nserializable          ×    ×       ×\n\n1). 查看事务隔离级别\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| repeatable-read         |\n+-------------------------+\n1 row in set (0.00 sec)\n\n\n2). 设置事务隔离级别\n\nset [session | global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable }\n\n\nmysql> set session transaction isolation level read uncommitted;\nmysql> set session transaction isolation level repeatable read;\n\n\n> 注意：事务隔离级别越高，数据越安全，但是性能越低。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"Java面向对象(上)",frontmatter:{title:"Java面向对象(上)",date:"2022-05-31T11:26:29.000Z",category:["Java"],tag:["Java"],permalink:"/pages/f5abb7/"},regularPath:"/01.%E6%8C%87%E5%8D%97/05.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01.Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A).html",relativePath:"01.指南/05.面向对象/01.Java面向对象(上).md",key:"v-0d5c43ac",path:"/pages/f5abb7/",headers:[{level:2,title:"面向对象简要",slug:"面向对象简要",normalizedTitle:"面向对象简要",charIndex:15},{level:3,title:"🚥面向对象思想",slug:"🚥面向对象思想",normalizedTitle:"🚥面向对象思想",charIndex:26},{level:3,title:"🚥类和对象的关系",slug:"🚥类和对象的关系",normalizedTitle:"🚥类和对象的关系",charIndex:327},{level:3,title:"🚥封装思想",slug:"🚥封装思想",normalizedTitle:"🚥封装思想",charIndex:570},{level:3,title:"🚥继承和类实例化过程",slug:"🚥继承和类实例化过程",normalizedTitle:"🚥继承和类实例化过程",charIndex:1130},{level:3,title:"🚥多态、反射和组件解耦",slug:"🚥多态、反射和组件解耦",normalizedTitle:"🚥多态、反射和组件解耦",charIndex:1909},{level:2,title:"面向对象基础",slug:"面向对象基础",normalizedTitle:"面向对象基础",charIndex:2541},{level:3,title:"🚥如何设计类",slug:"🚥如何设计类",normalizedTitle:"🚥如何设计类",charIndex:2554},{level:3,title:"🚥第一个示例",slug:"🚥第一个示例",normalizedTitle:"🚥第一个示例",charIndex:3069},{level:3,title:"🚥private关键字",slug:"🚥private关键字",normalizedTitle:"🚥private关键字",charIndex:3812},{level:3,title:"🚥this关键字",slug:"🚥this关键字",normalizedTitle:"🚥this关键字",charIndex:5257},{level:3,title:"🚥构造方法",slug:"🚥构造方法",normalizedTitle:"🚥构造方法",charIndex:6145},{level:3,title:"🚥标准的JavaBean类",slug:"🚥标准的javabean类",normalizedTitle:"🚥标准的javabean类",charIndex:7311}],headersStr:"面向对象简要 🚥面向对象思想 🚥类和对象的关系 🚥封装思想 🚥继承和类实例化过程 🚥多态、反射和组件解耦 面向对象基础 🚥如何设计类 🚥第一个示例 🚥private关键字 🚥this关键字 🚥构造方法 🚥标准的JavaBean类",content:'# Java面向对象\n\n\n# 面向对象简要\n\n\n# 🚥面向对象思想\n\n面向对象编程是当今主流的程序设计思想，已经取代了过程化程序开发技术，Java 是完全面向对象编程语言，所以必须熟悉面向对象才能够编写 Java 程序。\n\n面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。程序中的很多对象来自 JDK 标准库，而更多的类需要我们程序员自定义。\n\n面向对象有以下特点：\n\n 1. 面向对象是一种常见的思想，比较符合人们的思考习惯；\n 2. 面向对象可以将复杂的业务逻辑简单化，增强代码复用性；\n 3. 面向对象具有抽象、封装、继承、多态等特性。\n 4. 面向对象的编程语言主要有：C++、Java、C#等。\n\n\n# 🚥类和对象的关系\n\n类：\n\n对某类事物的普遍一致性特征、功能的抽象、描述和封装，是构造对象的模版或蓝图，用 Java 编写的代码都会在某些类的内部。类之间主要有：依赖、聚合、继承等关系。\n\n对象：\n\n使用 new 关键字或反射技术创建的某个类的实例。同一个类的所有对象，都具有相似的数据（比如人的年龄、性别）和行为（比如人的吃饭、睡觉），但是每个对象都保存着自己独特的状态，对象状态会随着程序的运行而发生改变，需要注意状态的变化必须通过调用方法来改变，这就是封装的基本原则。\n\n\n# 🚥封装思想\n\n核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。\n\n具体的实现方式就是：\n\n使用 private 修饰符把成员变量设置为私有，防止外部程序直接随意调用或修改成员变量，然后对外提供 public 的 set 和 get 方法按照开发者的意愿（可以编写一些业务逻辑代码，虽然很少这样做）设置和获取成员变量的值。也可以把只在本类内部使用的方法使用 private，这就是封装的思想，是面向对象最基本的开发规范之一。\n\n在此，我们有必要说一下 Java 的访问权限修饰关键字。Java 中主要有 private、protected、public 和 默认访问权限 四种：\n\n * public 修饰符，具有最大的访问权限，可以访问任何一个在 CLASSPATH 下的类、接口、异常等。\n * protected 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。\n * default 修饰符，主要是本包的类可以访问。\n * private 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 private 修饰的。\n\n\n\n\n# 🚥继承和类实例化过程\n\n * 在多个不同的类中抽取出共性的数据和逻辑，对这些共性的内容进行封装一个新的类即父类（也叫做超类或基类），让之前的类来继承这个类，那些共性的内容在子类中就不必重复定义，比如 BaseDAO、BaseAction 等。\n * Java 的继承机制是单继承，即一个类只能有一个直接父类。\n * 如果子类和父类有同名成员变量和方法，子类可以使用 super 关键字调用父类的成员变量和方法，上述使用方式前提是成员在子类可见。\n * 在调用子类构造方法时，会隐式的调用父类的构造方法 super()。如果父类没有无参构造方法，为了避免编译错误，需要在子类构造方法中显式的调用父类的含参构造方法。\n * 子类创建时调用父类构造方法：子类需要使用父类的成员变量和方法，所以就要调用父类构造方法来初始化，之后再进行子类成员变量和方法的初始化。因此，构造方法是无法覆盖的。\n * 当子类需要扩展父类的某个方法时，可以覆盖父类方法，但是子类方法访问权限必须大于或等于父类权限。\n * 继承提高了程序的复用性、扩展性，也是 Java 语言多态特征的前提。\n * 在实际开发、程序设计过程中，并非先有的父类，而是先有了子类中通用的数据和逻辑，然后再抽取封装出来的父类。\n\n我们简单了解下类的实例化过程\n\n 1. JVM 读取指定 classpath 路径下的 class 文件，加载到内存，如果有直接父类，也会加载父类；\n 2. 堆内存分配空间；\n 3. 执行父类、子类静态代码块；\n 4. 对象属性进行默认初始化；\n 5. 调用构造方法；\n 6. 在构造方法中，先调用父类构造方法初始化父类数据；\n 7. 初始化父类数据后，显示初始化，执行子类的构造代码块；\n 8. 再进行子类构造方法的特定初始化；\n 9. 初始化完毕后，将地址赋值给引用\n\n\n# 🚥多态、反射和组件解耦\n\n多态指允许不同类的对象对同一“消息”做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。\n\n 1. Java 中可以使用父类、接口变量引用子类、实现类对象；\n 2. 在这个过程中，会对子类、实现类对象做自动类型提升，其特有功能就无法访问了，如果需要使用，可以做强制类型转换。\n\nJava 的反射技术和多态特性是框架开发、组件解耦的核心，在这方面，Spring 的 IOC 和 DI 为我们提供了一个极好的学习范例，Spring 的 IOC 使用反射技术创建、管理对象，DI 使用多态技术为组件注入依赖对象。\n\n在没有学习 Spring 之前，简单的解决方案是使用一个 .properties 文件保存程序中使用的接口、实现类类型键值信息，然后在程序中使用一个全局 Properties 对象保存这些信息，并且使用反射技术把这些实现类初始化、提供一个静态的方法获取指定接口的实现类对象，在组件中就可以使用依赖对象的键获取需要的对象。\n\n这样的方案带来的好处就是：当我们需要修改某个组件的实现方式时，比如把之前 JDBC 的 DAO 实现改为 Hibernate 实现，只要把这些新的实现类放到 classpath 下，把 .properties 文件对应接口的实现类类型改成新的 Hibernate 实现类，而不需要修改依赖组件的代码。\n\n\n# 面向对象基础\n\n\n\n\n# 🚥如何设计类\n\n类的基本语法：\n\n> public class 类名 {\n> \n> 1、成员变量（代表属性的,一般是名词)\n> \n> 2、成员方法（代表行为的,一般是动词）\n> \n> }\n\npublic class 类名 {\n          1、成员变量（代表属性,一般是名词)\n           2、成员方法（代表行为,一般是动词）\n           3、构造器 （后几节再说）\n           4、代码块 （后面再学）\n           5、内部类 （后面再学）\n}\n\n\npublic class Car{\n    // 属性（成员变量）\n    String name;\n    double price;\n    \n   // 行为\n    public void start(){\n        \n    }\n    public void run(){\n        \n    }\n}\n\n\n如何得到类的对象\n\n类名 对象名 = new 类名();\nCar c = new Car();\n\n\n如何使用对象\n\n * 访问属性: 对象名.成员变量\n * 访问行为: 对象名.方法名(…)\n\n\n# 🚥第一个示例\n\n定义一个类，包含女朋友的关键信息，比如名字，年龄，包括行为动作。\n\npackage com.zyh.test;\n\npublic class GirlFriend {\n    String name;\n    int age;\n    String gender;\n\n    public void sleep(){\n        System.out.println("女朋友在睡觉");\n    }\n\n    public void eat(){\n        System.out.println("女朋友在吃饭");\n    }\n}\n\n\n再另外一个类中去使用它。\n\npackage com.zyh.test;\n\npublic class GirlFrendTest {\n    public static void main(String[] args) {\n        // 创建女朋友的对象\n        GirlFriend gf1 = new GirlFriend();\n        gf1.name = "小诗诗";\n        gf1.age = 18;\n        gf1.gender = "萌妹子";\n\n        System.out.println(gf1.name);\n        System.out.println(gf1.age);\n        System.out.println(gf1.gender);\n\n        gf1.eat();\n        gf1.sleep();\n    }\n}\n\n\n以上代码返回的结果是：\n\n小诗诗\n18\n萌妹子\n女朋友在吃饭\n女朋友在睡觉\n\n\n\n# 🚥private关键字\n\n 1. 是一个权限修饰符\n 2. 可以修饰成员（成员变量和成员方法）\n 3. 被private修饰的成员只能在本类中才能访问。\n\npublic class GirlFriend {\n    private String name;\n    private int age;\n    private String gender;\n}\n\n\n使用private关键字修饰字符：\n\npackage com.zyh.test;\n\npublic class GirlFriend {\n    private String name;\n    private int age;\n    private String gender;\n\t// 针对每一个私有化的成员变量，都要提供get和set的方法\n    // set方法： 给成员变量赋值\n    // get方法： 对外提供成员变量的值\n    \n    // 作用： 给成员变量name进行赋值\n    public void setName(String n){\n        name = n;\n    }\n    // 作用： 给成员变量name\n    public String getName(){\n        return name;\n    }\n\n    public void setage(int a){\n        if (a >= 18 && a <= 50){\n            age = a;\n        }else {\n            System.out.println("非法赋值");\n        }\n    }\n    public int getage(){\n        return age;\n    }\n\n    public void setGender(String n){\n        gender = n;\n    }\n\n    public String getGender(){\n        return gender;\n    }\n\n    public void sleep(){\n        System.out.println("女朋友在睡觉");\n    }\n    public void eat(){\n        System.out.println("女朋友在吃饭");\n    }\n}\n\n\n再创建一个类，调用此类。\n\npackage com.zyh.test;\n\npublic class GirlFrendTest {\n    public static void main(String[] args) {\n        GirlFriend gf1 = new GirlFriend();\n\n        gf1.setName("小诗诗");\n        gf1.setage(18);\n        gf1.setGender("女");\n\n        System.out.println(gf1.getName() + gf1.getage() + gf1.getGender());\n\n        gf1.eat();\n        gf1.sleep();\n    }\n}\n\n\n以上代码返回的结果：\n\n小诗诗18女\n女朋友在吃饭\n女朋友在睡觉\n\n\n\n# 🚥this关键字\n\n变量的范围：\n\n * 成员变量： 定义在类中的变量\n * 局部变量： 定义在方法中的变量\n\nthis关键字引用的变量是使用成员变量，也就是定义在方法外部的变量。\n\nthis关键字的作用就是起到区别成员变量和局部变量\n\npackage com.zyh.test;\n\npublic class GirlFrend2 {\n    private String name;\n    private int age;\n\n    public void setName(String name){\n        this.name = name;\n    }\n    public String getName(){\n        return name;\n    }\n\n    public void setage(int age){\n        if (age >= 18 && age <= 50){\n            this.age = age;\n        }else {\n            System.out.println("非法参数");\n        }\n    }\n    public int getage(){\n        return age;\n    }\n}\n\n\n编写一个新的类去调用方法：\n\npackage com.zyh.test;\n\npublic class GrilFrendTest {\n    public static void main(String[] args) {\n        GirlFrend2 gf1 = new GirlFrend2();\n        gf1.getage();\n        gf1.setName("小诗诗");\n        gf1.setage(20);\n        System.out.println(gf1.getName() + gf1.getage());\n    }\n}\n\n\n以上代码返回的结果：\n\n小诗诗20\n\n\n\n# 🚥构造方法\n\n构造方法的概述\n\n * 构造方法也叫做构造器、构造函数\n * 作用： 在创建对象的时候给成员变量进行赋值的。\n\n构造方法的格式：\n\n    public class Student{\n        修饰符 类名(参数){\n            方法体;\n        }\n    }\n\n\n特点：\n\n 1. 方法名与类名相同，大小也要一致\n 2. 没有返回值类型，连void都没有\n 3. 没有具体的返回值，（不能由retrun带回结果数据）\n\n执行时机：\n\n 1. 创建对象的时候由虚拟机调用，不能手动调用构造方法\n 2. 每创建一次对象，就会调用一次构造方法\n\n构造方法注意事项：\n\n * 如果没有定义构造方法，系统将会给出一个默认的无参数构造方法\n * 如果定义了构造方法，系统将不再提供默认的构造方法\n * 构造方法的重载，带参构造方法和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载\n * 无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法\n\n如果我们自己没有写任何的构造方法，那么虚拟机会给我们加一个空参构造方法\n\npackage com.zyh.test;\n\nimport javax.swing.border.CompoundBorder;\n\npublic class Student {\n    private String name;\n    private int age;\n\n    public Student(){\n        System.out.println("在这里");\n    }\n\n    public Student(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName(){\n        return name;\n    }\n    public int getage(){\n        return age;\n    }\n}\n\n\n创建对象，调用的空参构造\n\npackage com.zyh.test;\n\npublic class StudentTest {\n    public static void main(String[] args) {\n        Student s = new Student("张三",23);\n        System.out.println(s.getName());\n        System.out.println(s.getage());\n\n    }\n}\n\n\n以上代码返回的结果：\n\n张三\n23\n\n\n\n\n\n# 🚥标准的JavaBean类\n\n① 类名需要见名知意\n\n②成员变量使用private修饰\n\n③提供至少两个构造方法\n\n * 无参构造方法\n * 带全部参数构造方法\n\n④成员方法\n\n * 提供每一个成员变量对应的setXxx()/getXxx()\n * 如果还有其他行为，也要加上\n\n满足一个登录页面的需求：\n\n\n\npackage test6;\n\npublic class User {\n    private String username;\n    private String password;\n    private String email;\n    private String gender;\n    private int age;\n\n    public User() {\n    }\n\n    public User(String username, String password, String email, String gender, int age) {\n        this.username = username;\n        this.password = password;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * 设置\n     * @param username\n     */\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    /**\n     * 获取\n     * @return password\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * 设置\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * 获取\n     * @return email\n     */\n    public String getEmail() {\n        return email;\n    }\n\n    /**\n     * 设置\n     * @param email\n     */\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getage() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "User{username = " + username + ", password = " + password + ", email = " + email + ", gender = " + gender + ", age = " + age + "}";\n    }\n\n\n技巧：\n\n 1. Alt + Fn + Insert\n 2. IDEA下载ptg插件\n\n',normalizedContent:'# java面向对象\n\n\n# 面向对象简要\n\n\n# 🚥面向对象思想\n\n面向对象编程是当今主流的程序设计思想，已经取代了过程化程序开发技术，java 是完全面向对象编程语言，所以必须熟悉面向对象才能够编写 java 程序。\n\n面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。程序中的很多对象来自 jdk 标准库，而更多的类需要我们程序员自定义。\n\n面向对象有以下特点：\n\n 1. 面向对象是一种常见的思想，比较符合人们的思考习惯；\n 2. 面向对象可以将复杂的业务逻辑简单化，增强代码复用性；\n 3. 面向对象具有抽象、封装、继承、多态等特性。\n 4. 面向对象的编程语言主要有：c++、java、c#等。\n\n\n# 🚥类和对象的关系\n\n类：\n\n对某类事物的普遍一致性特征、功能的抽象、描述和封装，是构造对象的模版或蓝图，用 java 编写的代码都会在某些类的内部。类之间主要有：依赖、聚合、继承等关系。\n\n对象：\n\n使用 new 关键字或反射技术创建的某个类的实例。同一个类的所有对象，都具有相似的数据（比如人的年龄、性别）和行为（比如人的吃饭、睡觉），但是每个对象都保存着自己独特的状态，对象状态会随着程序的运行而发生改变，需要注意状态的变化必须通过调用方法来改变，这就是封装的基本原则。\n\n\n# 🚥封装思想\n\n核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。\n\n具体的实现方式就是：\n\n使用 private 修饰符把成员变量设置为私有，防止外部程序直接随意调用或修改成员变量，然后对外提供 public 的 set 和 get 方法按照开发者的意愿（可以编写一些业务逻辑代码，虽然很少这样做）设置和获取成员变量的值。也可以把只在本类内部使用的方法使用 private，这就是封装的思想，是面向对象最基本的开发规范之一。\n\n在此，我们有必要说一下 java 的访问权限修饰关键字。java 中主要有 private、protected、public 和 默认访问权限 四种：\n\n * public 修饰符，具有最大的访问权限，可以访问任何一个在 classpath 下的类、接口、异常等。\n * protected 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。\n * default 修饰符，主要是本包的类可以访问。\n * private 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 private 修饰的。\n\n\n\n\n# 🚥继承和类实例化过程\n\n * 在多个不同的类中抽取出共性的数据和逻辑，对这些共性的内容进行封装一个新的类即父类（也叫做超类或基类），让之前的类来继承这个类，那些共性的内容在子类中就不必重复定义，比如 basedao、baseaction 等。\n * java 的继承机制是单继承，即一个类只能有一个直接父类。\n * 如果子类和父类有同名成员变量和方法，子类可以使用 super 关键字调用父类的成员变量和方法，上述使用方式前提是成员在子类可见。\n * 在调用子类构造方法时，会隐式的调用父类的构造方法 super()。如果父类没有无参构造方法，为了避免编译错误，需要在子类构造方法中显式的调用父类的含参构造方法。\n * 子类创建时调用父类构造方法：子类需要使用父类的成员变量和方法，所以就要调用父类构造方法来初始化，之后再进行子类成员变量和方法的初始化。因此，构造方法是无法覆盖的。\n * 当子类需要扩展父类的某个方法时，可以覆盖父类方法，但是子类方法访问权限必须大于或等于父类权限。\n * 继承提高了程序的复用性、扩展性，也是 java 语言多态特征的前提。\n * 在实际开发、程序设计过程中，并非先有的父类，而是先有了子类中通用的数据和逻辑，然后再抽取封装出来的父类。\n\n我们简单了解下类的实例化过程\n\n 1. jvm 读取指定 classpath 路径下的 class 文件，加载到内存，如果有直接父类，也会加载父类；\n 2. 堆内存分配空间；\n 3. 执行父类、子类静态代码块；\n 4. 对象属性进行默认初始化；\n 5. 调用构造方法；\n 6. 在构造方法中，先调用父类构造方法初始化父类数据；\n 7. 初始化父类数据后，显示初始化，执行子类的构造代码块；\n 8. 再进行子类构造方法的特定初始化；\n 9. 初始化完毕后，将地址赋值给引用\n\n\n# 🚥多态、反射和组件解耦\n\n多态指允许不同类的对象对同一“消息”做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，spring 的核心就是多态和面向接口编程。\n\n 1. java 中可以使用父类、接口变量引用子类、实现类对象；\n 2. 在这个过程中，会对子类、实现类对象做自动类型提升，其特有功能就无法访问了，如果需要使用，可以做强制类型转换。\n\njava 的反射技术和多态特性是框架开发、组件解耦的核心，在这方面，spring 的 ioc 和 di 为我们提供了一个极好的学习范例，spring 的 ioc 使用反射技术创建、管理对象，di 使用多态技术为组件注入依赖对象。\n\n在没有学习 spring 之前，简单的解决方案是使用一个 .properties 文件保存程序中使用的接口、实现类类型键值信息，然后在程序中使用一个全局 properties 对象保存这些信息，并且使用反射技术把这些实现类初始化、提供一个静态的方法获取指定接口的实现类对象，在组件中就可以使用依赖对象的键获取需要的对象。\n\n这样的方案带来的好处就是：当我们需要修改某个组件的实现方式时，比如把之前 jdbc 的 dao 实现改为 hibernate 实现，只要把这些新的实现类放到 classpath 下，把 .properties 文件对应接口的实现类类型改成新的 hibernate 实现类，而不需要修改依赖组件的代码。\n\n\n# 面向对象基础\n\n\n\n\n# 🚥如何设计类\n\n类的基本语法：\n\n> public class 类名 {\n> \n> 1、成员变量（代表属性的,一般是名词)\n> \n> 2、成员方法（代表行为的,一般是动词）\n> \n> }\n\npublic class 类名 {\n          1、成员变量（代表属性,一般是名词)\n           2、成员方法（代表行为,一般是动词）\n           3、构造器 （后几节再说）\n           4、代码块 （后面再学）\n           5、内部类 （后面再学）\n}\n\n\npublic class car{\n    // 属性（成员变量）\n    string name;\n    double price;\n    \n   // 行为\n    public void start(){\n        \n    }\n    public void run(){\n        \n    }\n}\n\n\n如何得到类的对象\n\n类名 对象名 = new 类名();\ncar c = new car();\n\n\n如何使用对象\n\n * 访问属性: 对象名.成员变量\n * 访问行为: 对象名.方法名(…)\n\n\n# 🚥第一个示例\n\n定义一个类，包含女朋友的关键信息，比如名字，年龄，包括行为动作。\n\npackage com.zyh.test;\n\npublic class girlfriend {\n    string name;\n    int age;\n    string gender;\n\n    public void sleep(){\n        system.out.println("女朋友在睡觉");\n    }\n\n    public void eat(){\n        system.out.println("女朋友在吃饭");\n    }\n}\n\n\n再另外一个类中去使用它。\n\npackage com.zyh.test;\n\npublic class girlfrendtest {\n    public static void main(string[] args) {\n        // 创建女朋友的对象\n        girlfriend gf1 = new girlfriend();\n        gf1.name = "小诗诗";\n        gf1.age = 18;\n        gf1.gender = "萌妹子";\n\n        system.out.println(gf1.name);\n        system.out.println(gf1.age);\n        system.out.println(gf1.gender);\n\n        gf1.eat();\n        gf1.sleep();\n    }\n}\n\n\n以上代码返回的结果是：\n\n小诗诗\n18\n萌妹子\n女朋友在吃饭\n女朋友在睡觉\n\n\n\n# 🚥private关键字\n\n 1. 是一个权限修饰符\n 2. 可以修饰成员（成员变量和成员方法）\n 3. 被private修饰的成员只能在本类中才能访问。\n\npublic class girlfriend {\n    private string name;\n    private int age;\n    private string gender;\n}\n\n\n使用private关键字修饰字符：\n\npackage com.zyh.test;\n\npublic class girlfriend {\n    private string name;\n    private int age;\n    private string gender;\n\t// 针对每一个私有化的成员变量，都要提供get和set的方法\n    // set方法： 给成员变量赋值\n    // get方法： 对外提供成员变量的值\n    \n    // 作用： 给成员变量name进行赋值\n    public void setname(string n){\n        name = n;\n    }\n    // 作用： 给成员变量name\n    public string getname(){\n        return name;\n    }\n\n    public void setage(int a){\n        if (a >= 18 && a <= 50){\n            age = a;\n        }else {\n            system.out.println("非法赋值");\n        }\n    }\n    public int getage(){\n        return age;\n    }\n\n    public void setgender(string n){\n        gender = n;\n    }\n\n    public string getgender(){\n        return gender;\n    }\n\n    public void sleep(){\n        system.out.println("女朋友在睡觉");\n    }\n    public void eat(){\n        system.out.println("女朋友在吃饭");\n    }\n}\n\n\n再创建一个类，调用此类。\n\npackage com.zyh.test;\n\npublic class girlfrendtest {\n    public static void main(string[] args) {\n        girlfriend gf1 = new girlfriend();\n\n        gf1.setname("小诗诗");\n        gf1.setage(18);\n        gf1.setgender("女");\n\n        system.out.println(gf1.getname() + gf1.getage() + gf1.getgender());\n\n        gf1.eat();\n        gf1.sleep();\n    }\n}\n\n\n以上代码返回的结果：\n\n小诗诗18女\n女朋友在吃饭\n女朋友在睡觉\n\n\n\n# 🚥this关键字\n\n变量的范围：\n\n * 成员变量： 定义在类中的变量\n * 局部变量： 定义在方法中的变量\n\nthis关键字引用的变量是使用成员变量，也就是定义在方法外部的变量。\n\nthis关键字的作用就是起到区别成员变量和局部变量\n\npackage com.zyh.test;\n\npublic class girlfrend2 {\n    private string name;\n    private int age;\n\n    public void setname(string name){\n        this.name = name;\n    }\n    public string getname(){\n        return name;\n    }\n\n    public void setage(int age){\n        if (age >= 18 && age <= 50){\n            this.age = age;\n        }else {\n            system.out.println("非法参数");\n        }\n    }\n    public int getage(){\n        return age;\n    }\n}\n\n\n编写一个新的类去调用方法：\n\npackage com.zyh.test;\n\npublic class grilfrendtest {\n    public static void main(string[] args) {\n        girlfrend2 gf1 = new girlfrend2();\n        gf1.getage();\n        gf1.setname("小诗诗");\n        gf1.setage(20);\n        system.out.println(gf1.getname() + gf1.getage());\n    }\n}\n\n\n以上代码返回的结果：\n\n小诗诗20\n\n\n\n# 🚥构造方法\n\n构造方法的概述\n\n * 构造方法也叫做构造器、构造函数\n * 作用： 在创建对象的时候给成员变量进行赋值的。\n\n构造方法的格式：\n\n    public class student{\n        修饰符 类名(参数){\n            方法体;\n        }\n    }\n\n\n特点：\n\n 1. 方法名与类名相同，大小也要一致\n 2. 没有返回值类型，连void都没有\n 3. 没有具体的返回值，（不能由retrun带回结果数据）\n\n执行时机：\n\n 1. 创建对象的时候由虚拟机调用，不能手动调用构造方法\n 2. 每创建一次对象，就会调用一次构造方法\n\n构造方法注意事项：\n\n * 如果没有定义构造方法，系统将会给出一个默认的无参数构造方法\n * 如果定义了构造方法，系统将不再提供默认的构造方法\n * 构造方法的重载，带参构造方法和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载\n * 无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法\n\n如果我们自己没有写任何的构造方法，那么虚拟机会给我们加一个空参构造方法\n\npackage com.zyh.test;\n\nimport javax.swing.border.compoundborder;\n\npublic class student {\n    private string name;\n    private int age;\n\n    public student(){\n        system.out.println("在这里");\n    }\n\n    public student(string name,int age){\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname(){\n        return name;\n    }\n    public int getage(){\n        return age;\n    }\n}\n\n\n创建对象，调用的空参构造\n\npackage com.zyh.test;\n\npublic class studenttest {\n    public static void main(string[] args) {\n        student s = new student("张三",23);\n        system.out.println(s.getname());\n        system.out.println(s.getage());\n\n    }\n}\n\n\n以上代码返回的结果：\n\n张三\n23\n\n\n\n\n\n# 🚥标准的javabean类\n\n① 类名需要见名知意\n\n②成员变量使用private修饰\n\n③提供至少两个构造方法\n\n * 无参构造方法\n * 带全部参数构造方法\n\n④成员方法\n\n * 提供每一个成员变量对应的setxxx()/getxxx()\n * 如果还有其他行为，也要加上\n\n满足一个登录页面的需求：\n\n\n\npackage test6;\n\npublic class user {\n    private string username;\n    private string password;\n    private string email;\n    private string gender;\n    private int age;\n\n    public user() {\n    }\n\n    public user(string username, string password, string email, string gender, int age) {\n        this.username = username;\n        this.password = password;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return username\n     */\n    public string getusername() {\n        return username;\n    }\n\n    /**\n     * 设置\n     * @param username\n     */\n    public void setusername(string username) {\n        this.username = username;\n    }\n\n    /**\n     * 获取\n     * @return password\n     */\n    public string getpassword() {\n        return password;\n    }\n\n    /**\n     * 设置\n     * @param password\n     */\n    public void setpassword(string password) {\n        this.password = password;\n    }\n\n    /**\n     * 获取\n     * @return email\n     */\n    public string getemail() {\n        return email;\n    }\n\n    /**\n     * 设置\n     * @param email\n     */\n    public void setemail(string email) {\n        this.email = email;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public string getgender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setgender(string gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getage() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public string tostring() {\n        return "user{username = " + username + ", password = " + password + ", email = " + email + ", gender = " + gender + ", age = " + age + "}";\n    }\n\n\n技巧：\n\n 1. alt + fn + insert\n 2. idea下载ptg插件\n\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"面向对象设计总结",frontmatter:{title:"面向对象设计总结",date:"2022-12-18T18:01:56.000Z",permalink:"/pages/d7dcc5/",categories:["Java"],tags:["Java"]},regularPath:"/01.%E6%8C%87%E5%8D%97/05.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93.html",relativePath:"01.指南/05.面向对象/03.面向对象设计总结.md",key:"v-4cffe8e0",path:"/pages/d7dcc5/",headers:[{level:2,title:"OOA（面向对象）的基本概念",slug:"ooa-面向对象-的基本概念",normalizedTitle:"ooa（面向对象）的基本概念",charIndex:2},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:12},{level:3,title:"八大原则",slug:"八大原则",normalizedTitle:"八大原则",charIndex:109},{level:3,title:"设计模式的概念",slug:"设计模式的概念",normalizedTitle:"设计模式的概念",charIndex:448}],headersStr:"OOA（面向对象）的基本概念 基本概念 八大原则 设计模式的概念",content:"# OOA（面向对象）的基本概念\n\n\n# 基本概念\n\n * 对象\n * 类（实体类，边界类，控制类）\n * 抽象\n * 封装\n * 继承与泛化\n * 多态\n * 接口\n * 消息\n * 组件\n * 模式与复用\n\n\n# 八大原则\n\n面向对象的主要思想：分而治之，封装变化，高内聚，低耦合\n\n 1. 类的单一职责：设计目的单一的类，也就是一个类有且只有一个改变它的原因。\n 2. 开-闭原则：对扩展开放，对修改关闭。（增加新功能，不改变原有代码。）\n 3. 里氏替换（Liskov）原则：父类出现的地方可以被子类替换，在替换后依然保持原功能。\n 4. 依赖倒置：要依赖于抽象，而不是具体实现；\n 5. 面向接口而非面向实现编程：通过抽象操作实例，而无需关注具体类型。\n 6. 接口隔离：尽量定义小而精的接口，少定义大而全的接口。\n 7. 组合复用：要尽量使用组合，而不是继承关系达到重用的目的。\n 8. 迪米特（Demeter）原则（最小知识法则）：一个对象应当对其他对象有尽可能少的了解。\n\n\n# 设计模式的概念\n\n * 架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反应了开发软件系统过程中所作的基本设计决策。\n * 设计模式：主要关注软件系统的设计，与具体的实现语言无关。\n * 惯用法：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法。架构模式和设计模式的区别：是从全局还是从局部来分析的问题。\n * 设计模式和惯用法的区别：是否和语言相关。\n\n设计模式的分类\n\n 1. 创建型模式\n    \n    * 工厂方法（factory method）模式（定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟）\n    \n    * 抽象工厂（abstract factory）模式（提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定他们具体的类）\n    \n    * 原型（prototype）模式（用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象）\n    \n    * 单例（singleton）模式（保证一个类只有一个实例，并提供一个访问它的全局访问点）\n    \n    * 构建器（builder）模式（将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示）\n\n 2. 结构型模式\n    \n    * 适配器（adapter）模式（将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作）\n    \n    * 桥接（bridge）模式（将类的抽象部分和它的实现部分分离开来，是他们可以独立地变化）\n    \n    * 组合（composite）模式（将对象组合成树型结构以表示”整体-部分“地层次结构）\n    \n    * 装饰（decorator）模式（动态地给一个对象添加一些额外的指责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活）\n    \n    * 外观（facade）模式（定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用）\n    \n    * 亨元（flyweight）模式（提供支持大量细粒度对象共享的有效方法）\n    \n    * 代理（proxy）模式（为其他对象提供了一种代理以控制这个对象的访问）\n\n 3. **行为型模式（**主要描述类之间交互的情况）\n    \n    * 职责链（chain of reponsibility）模式（通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接受对象链接起来，在链中传递请求，直到有一个对象处理这个请求）\n    \n    * 命令（command）模式（将一个请求封装为一个对象，从而可用不同的 请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作）\n    \n    * 解释器（interpreter）模式（给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子）\n    \n    * 迭代器（iterator）模式（提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示）\n    \n    * 中介者（mediator）模式（用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互）\n    \n    * 备忘录（memento）模式（在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态）\n    \n    * 观察者（observer）模式（定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新）\n    \n    * 状态（state）模式（允许一个对象在其内部状态改变时改变它的行为）\n    \n    * 策略（strategy）模式（定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化）\n    \n    * 模板方法（template method）模式（定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤）\n    \n    * 访问者（visitor）模式（表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作）",normalizedContent:"# ooa（面向对象）的基本概念\n\n\n# 基本概念\n\n * 对象\n * 类（实体类，边界类，控制类）\n * 抽象\n * 封装\n * 继承与泛化\n * 多态\n * 接口\n * 消息\n * 组件\n * 模式与复用\n\n\n# 八大原则\n\n面向对象的主要思想：分而治之，封装变化，高内聚，低耦合\n\n 1. 类的单一职责：设计目的单一的类，也就是一个类有且只有一个改变它的原因。\n 2. 开-闭原则：对扩展开放，对修改关闭。（增加新功能，不改变原有代码。）\n 3. 里氏替换（liskov）原则：父类出现的地方可以被子类替换，在替换后依然保持原功能。\n 4. 依赖倒置：要依赖于抽象，而不是具体实现；\n 5. 面向接口而非面向实现编程：通过抽象操作实例，而无需关注具体类型。\n 6. 接口隔离：尽量定义小而精的接口，少定义大而全的接口。\n 7. 组合复用：要尽量使用组合，而不是继承关系达到重用的目的。\n 8. 迪米特（demeter）原则（最小知识法则）：一个对象应当对其他对象有尽可能少的了解。\n\n\n# 设计模式的概念\n\n * 架构模式：软件设计中的高层决策，例如c/s结构就属于架构模式，架构模式反应了开发软件系统过程中所作的基本设计决策。\n * 设计模式：主要关注软件系统的设计，与具体的实现语言无关。\n * 惯用法：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是c++语言中的一种惯用法。架构模式和设计模式的区别：是从全局还是从局部来分析的问题。\n * 设计模式和惯用法的区别：是否和语言相关。\n\n设计模式的分类\n\n 1. 创建型模式\n    \n    * 工厂方法（factory method）模式（定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟）\n    \n    * 抽象工厂（abstract factory）模式（提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定他们具体的类）\n    \n    * 原型（prototype）模式（用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象）\n    \n    * 单例（singleton）模式（保证一个类只有一个实例，并提供一个访问它的全局访问点）\n    \n    * 构建器（builder）模式（将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示）\n\n 2. 结构型模式\n    \n    * 适配器（adapter）模式（将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作）\n    \n    * 桥接（bridge）模式（将类的抽象部分和它的实现部分分离开来，是他们可以独立地变化）\n    \n    * 组合（composite）模式（将对象组合成树型结构以表示”整体-部分“地层次结构）\n    \n    * 装饰（decorator）模式（动态地给一个对象添加一些额外的指责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活）\n    \n    * 外观（facade）模式（定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用）\n    \n    * 亨元（flyweight）模式（提供支持大量细粒度对象共享的有效方法）\n    \n    * 代理（proxy）模式（为其他对象提供了一种代理以控制这个对象的访问）\n\n 3. **行为型模式（**主要描述类之间交互的情况）\n    \n    * 职责链（chain of reponsibility）模式（通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接受对象链接起来，在链中传递请求，直到有一个对象处理这个请求）\n    \n    * 命令（command）模式（将一个请求封装为一个对象，从而可用不同的 请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作）\n    \n    * 解释器（interpreter）模式（给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子）\n    \n    * 迭代器（iterator）模式（提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示）\n    \n    * 中介者（mediator）模式（用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互）\n    \n    * 备忘录（memento）模式（在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态）\n    \n    * 观察者（observer）模式（定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新）\n    \n    * 状态（state）模式（允许一个对象在其内部状态改变时改变它的行为）\n    \n    * 策略（strategy）模式（定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化）\n    \n    * 模板方法（template method）模式（定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤）\n    \n    * 访问者（visitor）模式（表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作）",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"Java面对对象(下)",frontmatter:{title:"Java面对对象(下)",date:"2022-06-24T09:14:19.000Z",category:["Java"],tag:["Java"],permalink:"/pages/a5fd33/"},regularPath:"/01.%E6%8C%87%E5%8D%97/05.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.Java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1(%E4%B8%8B).html",relativePath:"01.指南/05.面向对象/02.Java面对对象(下).md",key:"v-120c6a65",path:"/pages/a5fd33/",headers:[{level:2,title:"学习内容",slug:"学习内容",normalizedTitle:"学习内容",charIndex:17},{level:2,title:"Static",slug:"static",normalizedTitle:"static",charIndex:98},{level:3,title:"Static修饰符",slug:"static修饰符",normalizedTitle:"static修饰符",charIndex:109},{level:3,title:"Static工具类",slug:"static工具类",normalizedTitle:"static工具类",charIndex:759},{level:3,title:"Static的注意事项",slug:"static的注意事项",normalizedTitle:"static的注意事项",charIndex:2560},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:3053},{level:3,title:"封装的概述",slug:"封装的概述",normalizedTitle:"封装的概述",charIndex:3060},{level:3,title:"封装的优点",slug:"封装的优点",normalizedTitle:"封装的优点",charIndex:3280},{level:3,title:"实现Java封装",slug:"实现java封装",normalizedTitle:"实现java封装",charIndex:3358},{level:3,title:"封装的实例",slug:"封装的实例",normalizedTitle:"封装的实例",charIndex:3998},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:36},{level:3,title:"继承的概念",slug:"继承的概念",normalizedTitle:"继承的概念",charIndex:4927},{level:3,title:"继承的特性",slug:"继承的特性",normalizedTitle:"继承的特性",charIndex:5248},{level:3,title:"继承关键字",slug:"继承关键字",normalizedTitle:"继承关键字",charIndex:5670},{level:3,title:"extends关键字",slug:"extends关键字",normalizedTitle:"extends关键字",charIndex:5813},{level:3,title:"super 与 this 关键字",slug:"super-与-this-关键字",normalizedTitle:"super 与 this 关键字",charIndex:6161},{level:3,title:"方法的重写",slug:"方法的重写",normalizedTitle:"方法的重写",charIndex:6882},{level:2,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:75},{level:3,title:"多态的概念",slug:"多态的概念",normalizedTitle:"多态的概念",charIndex:11659},{level:3,title:"多态的优点",slug:"多态的优点",normalizedTitle:"多态的优点",charIndex:11890},{level:3,title:"多态的综合练习",slug:"多态的综合练习",normalizedTitle:"多态的综合练习",charIndex:13637},{level:2,title:"包和final",slug:"包和final",normalizedTitle:"包和final",charIndex:17007},{level:3,title:"包的概述",slug:"包的概述",normalizedTitle:"包的概述",charIndex:17019},{level:3,title:"使用其它类的规则",slug:"使用其它类的规则",normalizedTitle:"使用其它类的规则",charIndex:17268},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:44},{level:3,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:280},{level:2,title:"权限修饰符",slug:"权限修饰符",normalizedTitle:"权限修饰符",charIndex:18919},{level:3,title:"修饰符的概述",slug:"修饰符的概述",normalizedTitle:"修饰符的概述",charIndex:18929},{level:3,title:"权限修饰符的分类",slug:"权限修饰符的分类",normalizedTitle:"权限修饰符的分类",charIndex:19066},{level:3,title:"修饰符访问权限",slug:"修饰符访问权限",normalizedTitle:"修饰符访问权限",charIndex:19393},{level:2,title:"代码块",slug:"代码块",normalizedTitle:"代码块",charIndex:55},{level:3,title:"局部代码块",slug:"局部代码块",normalizedTitle:"局部代码块",charIndex:19755},{level:3,title:"构造代码块",slug:"构造代码块",normalizedTitle:"构造代码块",charIndex:19764},{level:3,title:"静态代码块",slug:"静态代码块",normalizedTitle:"静态代码块",charIndex:19773},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:62},{level:3,title:"抽象类概述",slug:"抽象类概述",normalizedTitle:"抽象类概述",charIndex:20868},{level:3,title:"抽象方法",slug:"抽象方法",normalizedTitle:"抽象方法",charIndex:21187},{level:3,title:"定义格式",slug:"定义格式",normalizedTitle:"定义格式",charIndex:21200},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:69},{level:3,title:"接口概述",slug:"接口概述",normalizedTitle:"接口概述",charIndex:23184},{level:3,title:"接口与类相似点",slug:"接口与类相似点",normalizedTitle:"接口与类相似点",charIndex:23508},{level:3,title:"接口与类的区别",slug:"接口与类的区别",normalizedTitle:"接口与类的区别",charIndex:23632},{level:3,title:"接口特性",slug:"接口特性",normalizedTitle:"接口特性",charIndex:23802},{level:3,title:"抽象类和接口的区别",slug:"抽象类和接口的区别",normalizedTitle:"抽象类和接口的区别",charIndex:24021},{level:3,title:"接口的使用",slug:"接口的使用",normalizedTitle:"接口的使用",charIndex:24226},{level:3,title:"接口中成员的特点",slug:"接口中成员的特点",normalizedTitle:"接口中成员的特点",charIndex:25383},{level:3,title:"接口和类之间的关系",slug:"接口和类之间的关系",normalizedTitle:"接口和类之间的关系",charIndex:25634}],headersStr:"学习内容 Static Static修饰符 Static工具类 Static的注意事项 封装 封装的概述 封装的优点 实现Java封装 封装的实例 继承 继承的概念 继承的特性 继承关键字 extends关键字 super 与 this 关键字 方法的重写 多态 多态的概念 多态的优点 多态的综合练习 包和final 包的概述 使用其它类的规则 final 常量 权限修饰符 修饰符的概述 权限修饰符的分类 修饰符访问权限 代码块 局部代码块 构造代码块 静态代码块 抽象类 抽象类概述 抽象方法 定义格式 接口 接口概述 接口与类相似点 接口与类的区别 接口特性 抽象类和接口的区别 接口的使用 接口中成员的特点 接口和类之间的关系",content:'# Java面向对象进阶\n\n\n# 学习内容\n\n * static\n * 继承\n * 包、final、权限修改、代码块\n * 抽象类\n * 接口\n * 多态\n * 内部类\n * 拼图小游戏\n\n\n# Static\n\n\n# Static修饰符\n\nstatic表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量。\n\n 1. 被static修饰的成员变量，叫做静态变量\n 2. 被static修饰的成员方法，叫做静态方法\n\n示例：\n\npublic class Stu {\n    String name;                 //在类中定义非静态常量\n    int age;                     //在类中定义非静态常量\n    static String teacherName;   //在类中定义静态常量\n\n    public void show(){\n        System.out.println(name + "," + age + ","\n                        + teacherName);\n    }\n\n    public static void method(){\n        System.out.println("这是静态方法" + teacherName);\n    }\n\n}\n\n\n静态变量\n\n特点：\n\n * 被该类所有的对象共享\n * 不属于对象，属于类\n * 随着类的加载而加载，优先于对象存在\n\n调用方式：\n\n * 类名调用（推荐）\n * 对象名调用\n\n静态方法\n\n特点：\n\n * 多用在测试类和工具类当中\n * javabean类中很少会用\n\n调用方式：\n\n * 类名调用（推荐）\n * 对象名调用\n\n\n# Static工具类\n\n有三种类，分别是以下：\n\n * Javabean类： 用来描述一类事物的类，比如，Student，Teacher，Dog，Cat等\n * 测试类： 用来检查其他类是否书写正确，带有main的方法的类，是程序的入口\n * 工具类 : 不是用来描述一类事物的，而是帮我们做一些事情的类\n\n格式规范：\n\n 1. 类名见知意\n 2. 私有化构造方法\n 3. 方法定义为静态\n\npublic class ArrUtil {\n    private ArrUtil(){\n        public static int getMax(...){...}\n        public static int getMin(...){...}\n        public static int getSum(...){...}\n    }\n}\n\n\n定义数组的工具类\n\n需求： 在实际的开发中，经常会遇到一些数组使用的工具类\n\n请按照如下的要求编写一个数组的工具类： ArrayUtil\n\n * 提供一个工具类方法printArr,用于返回整数数组的内容。\n * 返回的字符串格式如： [10,20,50,34,100] (只考虑整数数组，且只考虑一堆数组)\n * 提供这样一个工具方法getAerage,用于返回平均分。 （只考虑浮点型数组，且只考虑一堆数组）\n * 定义一个测试类TestDemo，调用该工具类的工具方法，并返回结果。\n\npackage a01staticdemo1;\n\npublic class ArrayUtil {\n    // 私有化构造方法\n    // 目的： 为了不让外界创建他的对象\n    private ArrayUtil(){\n\n    }\n\n    // 需要定义为静态，方便调用\n    public static String printArr(int[] arr){\n        StringBuilder sb = new StringBuilder();\n        sb.append("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length -1){\n                sb.append(arr[i]);\n            }else {\n                sb.append(arr[i]).append(",");\n            }\n        }\n        sb.append("]");\n        return sb.toString();\n    }\n    public static double getAverage(double[] arr){\n        double sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum = sum + arr[i];\n        }\n        return sum / arr.length;\n    }\n}\n\n\n使用TestDemo测试类：\n\npackage a01staticdemo1;\n\npublic class TestDemo {\n    public static void main(String[] args) {\n        int[] arr1 = {1,2,3,4,5};\n        String str = ArrayUtil.printArr(arr1);\n        System.out.println(str);\n\n        double[] arr2 = {1.5,3.7,4.9,5.8};\n        double avg = ArrayUtil.getAverage(arr2);\n        System.out.println(avg);\n    }\n}\n\n\n以上代码返回的结果：\n\n[1,2,3,4,5]\n3.9750000000000005\n\n\n> 注意： 工具类的作用就是帮助我们解决各种需要的事情。\n\n\n# Static的注意事项\n\n 1. 静态方法只能访问静态变量和静态方法\n 2. 非静态方法可以访问静态变量或者静态方法，也可以访问非静态成员的变量和非静态的成员方法\n 3. 静态方法中是没有this关键字\n\n总结:\n\n * 静态方法中，只能访问静态。非静态方法中可以访问所有。静态方法中没有this关键字。\n\nStatic的main方法\n\npublic class HelloWord {\n    public static void main(String[] args) {\n        System.out.println("HelloWord");\n    }\n}\n\n\n * public: 被JVM调用，访问权限足够大\n\n * static: 被JVM调用，不要创建对象，直接类名访问，因为main方法是静态的\n   \n   所以测试类中其他方法也是需要静态的。\n\n * void： 被JVM调用，不需要给JVM返回值\n\n * main: 一个通用的名称，虽然不是关键字，但是被JVM识别\n\n * String[] args: 以前用于接收键盘录入数据的，现在没用\n\n\n# 封装\n\n\n# 封装的概述\n\n在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n\n# 封装的优点\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n\n# 实现Java封装\n\n修改属性的可见性来限制对属性的访问（一般限制为private），例如：\n\npublic class Person {\n    private String name;\n    private int age;\n}\n\n\n这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。\n\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：\n\npublic class Person{\n    private String name;\n    private int age;\n    \n    public int getage(){\n      return age;\n    }\n\n    public String getName(){\n      return name;\n    }\n\n    public void setage(int age){\n      this.age = age;\n    }\n\n    public void setName(String name){\n      this.name = name;\n    }\n}\n\n\n> 注意：\n> \n> 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。\n\n\n# 封装的实例\n\npackage day13;\n\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n}\n\n\n以上实例中public方法是外部类访问该类成员变量的入口。\n\n通常情况下，这些方法被称为getter和setter方法。\n\n因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。\n\npackage day13;\n\npublic class PersonTest {\n    public static void main(String[] args) {\n        Person person = new Person("小明",12);\n        System.out.println(person.getName());\n        System.out.println(person.getage());\n        person.setage(18);\n        System.out.println(person.getage());\n    }\n}\n\n\n以上代码返回的结果：\n\n小明\n12\n18\n\n\n\n# 继承\n\n\n# 继承的概念\n\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n * Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系。public class Student extends Person { }\n * Student称为子类（派生类），Person称为父类（基类或超类）。\n\n使用继承的好处：\n\n * 可以把多个子类中的重复的代码抽取到父类中了，提高代码的复用性。\n * 子类可以在父类基础上，增加其他的功能，使子类更强大。\n\n\n# 继承的特性\n\n * 子类拥有父类非 private 的属性、方法。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n继承的特点总结：\n\n * Java只支持单继承、不支持多继承、但是支持多层继承\n * Java中所有的类都直接或者间接继承于object\n * 子类只能访问父类中非私有的成员\n\n继承中\n\n成员方法的访问特点\n\n * 直接调用满足就近原则，谁离我近，我就用谁\n * super调用，直接访问父类\n\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# extends关键字\n\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\npublic class Animal { \n    private String name;   \n    private int id; \n    public Animal(String myName, int myid) { \n        //初始化属性值\n    } \n    public void eat() {  //吃东西方法的具体实现  } \n    public void sleep() { //睡觉方法的具体实现  } \n} \n \npublic class Penguin  extends  Animal{ \n}\n\n\n\n# super 与 this 关键字\n\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：指向自己的引用。\n\nthis和supper的使用：\n\npublic class Test {\n    public static void main(String[] args) {\n        Zi zi = new Zi();\n        zi.ziShow();\n    }\n}\nclass Fu{\n    String name = "super";\n}\n\nclass Zi extends Fu{\n    String name = "this";\n    public void ziShow(){\n        String name = "ziShow";\n        System.out.println(name);\n        System.out.println(this.name);\n        System.out.println(super.name);\n    }\n}\n\n\n以上代码返回的结果：\n\nziShow\nthis\nsuper\n\n\n继承中\n\n构造方法的访问特性：\n\n * 父类中的构造方法不会被子类继承，但是可以用super调用\n * 子类构造方法的第一行，有一个默认的super()\n * 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己\n * 如果需要方法父类有参构造，必须手动书写\n\nthis、super使用总结\n\nthis： 理解为一个变量，表示当前方法调用者的地址值\n\nsuper: 代表父类存储空间\n\n\n# 方法的重写\n\n当父类的方法不能满足子类的方法要求，需要进行方法重写。\n\n在继承中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。\n\n@Override重写注解\n\n 1. @Override是放在重写后的方法上，校验子类重写时语法是否正确。\n 2. 加上注解后如果有红色波浪线，表示语法有错误\n 3. 建议重写方法都加@Override注解，代码安全，优雅！\n\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu = new Student();\n        stu.lunch();\n    }\n}\nclass Person {\n    public void eat(){\n        System.out.println("吃饭");\n    }\n    public void drink(){\n        System.out.println("喝水");\n    }\n}\n\nclass Student extends Person{\n    public void lunch(){\n        this.eat();\n        this.drink();\n\n        super.eat();\n        super.drink();\n    }\n\n    @Override\n    public void eat(){\n        System.out.println("吃意大利面");\n    }\n    @Override\n    public void drink(){\n        System.out.println("喝牛奶");\n    }\n}\n\n\n以上代码返回的结果：\n\n吃意大利面\n喝牛奶\n吃饭\n喝水\n\n\n方法重写的注意事项：\n\n 1. 重写方法的每次、形参列表必须与父类中的一致\n 2. 子类重写父类方法时候，访问权限子类必须大于等于父类\n 3. 子类重写父类方法时，返回值类型子类必须小于等于父类\n 4. 建议： 重写的方法尽量和父类的保持一致\n 5. 只有被添加到虚方法列表中的方法才能被重写\n\n利用方法的重写设计继承结构\n\n现在有三种动物：哈士奇、沙皮狗、中华田园犬\n\n暂时不考虑属性，只考虑行为\n\n请按照继承的思想特点进行继承体系的设计\n\n三种动物分别有以下行为：\n\n * 哈士奇: 吃饭（吃狗粮） 喝水 看家 拆家\n * 沙皮狗： 吃饭（吃狗粮、吃骨头） 喝水 看家\n * 中华田园犬 吃饭（吃剩饭） 喝水 看家\n\n分别写如下几个类：\n\n * Dog\n * Hasky\n * Shapidog\n * Chinadog\n\n父类的Dog如下：\n\npackage Dog;\n\npublic class Dog {\n    public void eat(){\n        System.out.println("在吃狗粮");\n    }\n\n    public void drink(){\n        System.out.println("在喝水");\n    }\n\n    public void lookHome(){\n        System.out.println("在看家");\n    }\n}\n\n\n分别写三个子类的内容：\n\npackage Dog;\n\npublic class Hasky extends Dog{\n    public void brokeHome(){\n        System.out.println("在拆家");\n    }\n}\n\n\npackage Dog;\n\npublic class ChinaDog extends Dog{\n\n    @Override\n    public void eat(){\n        System.out.println("在吃饭，吃着剩饭");\n    }\n\n}\n\n\npackage Dog;\n\npublic class Shapidog extends Dog{\n\n    @Override\n    public void eat(){\n        System.out.println("在吃饭，吃着狗粮和骨头");\n    }\n}\n\n\n创建一个测试类：\n\npackage Dog;\n\npublic class Test {\n    public static void main(String[] args) {\n        Hasky h = new Hasky();\n        h.eat();\n        h.brokeHome();\n        h.drink();\n\n        ChinaDog chinaDog = new ChinaDog();\n        chinaDog.eat();\n        chinaDog.drink();\n        chinaDog.lookHome();\n\n        Shapidog shapidog = new Shapidog();\n        shapidog.eat();\n        shapidog.drink();\n        shapidog.lookHome();\n\n    }\n}\n\n\n以上代码返回的结果：\n\n在吃狗粮\n在拆家\n在喝水\n在吃饭，吃着剩饭\n在喝水\n在看家\n在吃饭，吃着狗粮和骨头\n在喝水\n在看家\n\n\n设计继承构造方法\n\n1.经理\n\n成员变量： 工号，姓名，工资，管理奖金\n\n成员方法： 工作（管理其他人），吃饭（吃米饭）\n\n2.厨师\n\n成员变量： 工号，姓名，工资\n\n成员方法：工作（炒菜），吃饭（吃米饭）\n\n创建四个类：\n\n * Employee\n * Manager\n * Cook\n * test\n\n创建父类Employee，作为主要参数构造\n\npackage dmeo;\n\npublic class Employee {\n    // 类名见名知意\n    // 所有的成员变量都需要私有\n    // 构造方法\n\n    private String id;\n    private String name;\n    private double salary;\n\n\n    public Employee() {\n    }\n\n    public Employee(String id, String name, double salary) {\n        this.id = id;\n        this.name = name;\n        this.salary = salary;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public void work(){\n        System.out.println("在工作");\n    }\n\n    public void eat(){\n        System.out.println("在吃饭");\n    }\n}\n\n\n创建经理和厨师的子类：\n\npackage dmeo;\n\npublic class Manager extends Employee{\n    private double bouns;\n\n    public Manager() {\n    }\n\n    // 带全部参数的构造\n    // 父类 + 子类\n    public Manager(String id, String name, double salary, double bouns) {\n        super(id, name, salary);\n        this.bouns = bouns;\n    }\n\n    public double getBouns() {\n        return bouns;\n    }\n\n    public void setBouns(double bouns) {\n        this.bouns = bouns;\n    }\n\n    @Override\n    public void work(){\n        System.out.println("在管理其他人");\n    }\n}\n\n\npackage dmeo;\n\npublic class Cook extends Employee {\n    public Cook() {\n    }\n\n    public Cook(String id, String name, double salary) {\n        super(id, name, salary);\n    }\n\n    @Override\n    public void work(){\n        System.out.println("厨师正在炒菜");\n    }\n}\n\n\n创建测试类：\n\npackage dmeo;\n\npublic class test {\n    public static void main(String[] args) {\n        Manager m = new Manager("heima001","张三",15000,8000);\n        System.out.println(m.getId() + "," + m.getName() + "," + m.getSalary() + "," + m.getBouns());\n        m.work();\n        m.eat();\n\n        Cook c = new Cook();\n        c.setId("heima002");\n        c.setName("李四");\n        c.setSalary(8000);\n        System.out.println(c.getId() + "," + c.getName() + "," + c.getSalary());\n        c.work();\n        c.eat();\n\n    }\n}\n\n\n以上的代码返回的结果：\n\nheima001,张三,15000.0,8000.0\n在管理其他人\n在吃饭\nheima002,李四,8000.0\n厨师正在炒菜\n在吃饭\n\n\n\n# 多态\n\n\n# 多态的概念\n\n什么是多态？\n\n同类型的对象，表现出不同的形态。\n\n多态性是对象多种表现形式的体现。\n\n现实中，比如我们按下 F1 键这个动作：\n\n * 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；\n * 如果当前在 Word 下弹出的就是 Word 帮助；\n * 在 Windows 下弹出的就是 Windows 帮助和支持。\n\n同一个事件发生在不同的对象上会产生不同的结果。\n\n多态的表现形式：\n\n父类类型 对象名称 = 子类对象\n\n\n# 多态的优点\n\n * 消除类型之间的耦合关系\n * 可替换性\n * 可扩充性\n * 接口性\n * 灵活性\n * 简化性\n\n多态的前提：\n\n * 有继承/实现关系\n * 有父类引用指向子类对象\n * 有方法重写\n\n多态的好处：\n\n * 使用父类型作为参数，可以接受所有子类对象\n * 体现多态的扩展性与便利\n\n多态的优势\n\n * 方法中，使用父类作为参数，可以接受所有子类对象\n\n多态的弊端\n\n * 不能使用子类的特有功能\n\n引用数据类型的类型转换，有几种方式\n\n * 自动类型转换 强制类型转换\n\nPerson p = new Student();\nStudent s = (Person) p;\n\n\n强制类型转换能解决什么问题？\n\n * 可以转换成真正的子类类型，从而调用子类独有功能\n * 转换类型与真实对象类型不一致会报错\n * 转换的时候用instanceofl关键字进行判断\n\nif (animal instanceof Dog dog){\n    dog.lookHome();\n}else if (animal instanceof Cat cat){\n    cat.catchMouse();\n}\n\n\n多态的示例：\n\npackage day02;\n\npublic class TEST {\n    public static void main(String[] args) {\n        // 创建对象（多态方式）\n        // Fu a = new Dog();\n        Animal a = new Dog();\n        // 动物\n        // 调用成员变量： 编译看左边 运行也看左边\n        // 编译看左边： javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n        // 运行也看左边： java运行代码的时候，实际获取的就是左边的父类成员变量的值\n        System.out.println(a.name);  // 动物\n\n        // 调用成员方法： 编译看左边，运行看右边\n        // 编译看左边： java编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败\n        // 运行看右边： java运行代码的时候，实际上运行的是子类的方法\n        a.show(); // Dog --- show 方法\n\n        // 成员变量： 在子类的对象中，会把父类的成员变量也继承下去的 父： name  子： name\n        // 成员方法： 如果子类对方进行了重写，那么虚方法表中是会把父类的方法进行覆盖的。\n\n    }\n}\n\nclass Animal{\n    String name = "动物";\n\n    public void show(){\n        System.out.println("Animal --- show方法");\n    }\n}\n\nclass Dog extends Animal{\n    String name = "狗";\n\n    @Override\n    public void show(){\n        System.out.println("Dog --- show方法");\n    }\n}\n\n\n\n以上代码返回的结果：\n\n动物\nDog --- show方法\n\n\n如上的示例可以看出：\n\n调用成员变量\n\n * 调用成员变量： 编译看左边 运行也看左边\n * 编译看左边： javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n * 运行也看左边： java运行代码的时候，实际获取的就是左边的父类成员变量的值\n\n调用成员方法\n\n * 调用成员方法： 编译看左边，运行看右边\n * 编译看左边： java编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败\n * 运行看右边： java运行代码的时候，实际上运行的是子类的方法\n\n\n# 多态的综合练习\n\n1.定义狗类\n\n属性： 年龄、颜色\n\n行为： eat(String something)、看家lookhome的方法\n\n2.定义猫类\n\n属性： 年龄、颜色\n\n行为：eat(String something)、抓老鼠cattchMouse方法\n\n3.定义Person类/饲养员\n\n属性：姓名、年龄\n\n行为：keepPet(Dog dog,String something)、功能养宠物、something表示喂养的东西。\n\n定义Animal父类：\n\npublic class Animal {\n    private int age;\n    private String color;\n\n    public Animal() {\n    }\n\n    public Animal(int age, String color) {\n        this.age = age;\n        this.color = color;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void eat(String something){\n        System.out.println("在吃饭");\n    }\n}\n\n\n定义Dog和Cat的子类：\n\npublic class Dog extends Animal{\n    public Dog() {\n    }\n\n    public Dog(int age, String color) {\n        super(age, color);\n    }\n\n    @Override\n    public void eat(String something) {\n        System.out.println(getage() + "岁的"+ getColor() +"的狗两只前腿死死的抱住" + something +"吃");\n    }\n\n    public void lookHome(){\n        System.out.println("狗在看家");\n    }\n}\n\n\npublic class Cat extends Animal{\n    public Cat() {\n    }\n\n    public Cat(int age, String color) {\n        super(age, color);\n    }\n\n    @Override\n    public void eat(String something) {\n        System.out.println(getage() + "岁的" + getColor() + "的猫眯着眼睛侧着头吃" + something);\n    }\n    public void catchMouse(){\n        System.out.println("猫抓老鼠");\n    }\n}\n\n\n定义Person的类：\n\npublic class Person {\n    private String name;\n    private int age;\n\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    // 饲养狗\n//    public void keepPet(Dog dog,String something){\n//        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getColor() + "颜色" + dog.getage() + "岁的狗");\n//        dog.eat(something);\n//        dog.lookHome();\n//    }\n//\n//    // 饲养猫\n//    public void keepPet(Cat cat,String something){\n//        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getColor() + "颜色" + cat.getage() + "岁的猫");\n//        cat.eat(something);\n//        cat.catchMouse();\n//    }\n\n    // 想要一个方法，接受所有动物，包括猫，包括狗\n    public void keepPet(Animal animal,String something){\n        if (animal instanceof Dog dog){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getColor() + "颜色" + dog.getage() + "岁的狗");\n            dog.eat(something);\n            dog.lookHome();\n        }else if (animal instanceof Cat cat){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getColor() + "颜色" + cat.getage() + "岁的猫");\n            cat.eat(something);\n            cat.catchMouse();\n        }\n    }\n\n}\n\n\n定义一个测试类：\n\npublic class test {\n    public static void main(String[] args) {\n        // 创建对象和调用方法\n        Person  p1 = new Person("老王",30);\n        Dog d = new Dog(2,"黑色");\n        Cat c = new Cat(3,"灰色");\n        p1.keepPet(d,"骨头");\n        p1.keepPet(c,"鱼");\n\n    }\n}\n\n\n以上代码返回的结果：\n\n年龄为30岁的老王养了一只黑色颜色2岁的狗\n2岁的黑色的狗两只前腿死死的抱住骨头吃\n狗在看家\n年龄为30岁的老王养了一只灰色颜色3岁的猫\n3岁的灰色的猫眯着眼睛侧着头吃鱼\n猫抓老鼠\n\n\n\n# 包和final\n\n\n# 包的概述\n\n包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护。 包名的规则：公司域名反写+包的作用，需要全部英文小写，见名知意。com.itheima.domain\n\npackage com.itheima.com.domain;\n\npublic class Student {\n    私有化成员变量;\n    构造方法;\n    成员方法;\n}\n\n\n如下是方法的说明\n\ncom.itheima.domain.Student，全称是全类名，其中Student是全限定名。\n\n\n# 使用其它类的规则\n\n * 使用同一个包中的类时，不需要导包。\n * 使用java.lang包中的类时，不需要导包。\n * 其它情况都需要导包\n * 如果同时使用两个包中的同名类，需要用全类名。\n\n使用其他类时候，需要使用全类名。\n\nimport com.itheima.domain.Student;\n\npublic class Test {\n    public static void main(String[] args) {\n        com.itheima.domain.Student s = new com.itheima.domain.Student();\n    }\n}\n\n\n\n# final\n\nfinal 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\nfinal 修饰符通常和 static 修饰符一起使用来创建类常量。\n\n * 修饰方法: 表明该方法是最终方法，不能被重写\n * 修饰类: 表明该类是最终类，不能被继承\n * 修饰变量: 叫做常量，只能被赋值一次\n\nfinal 方法\n\n * 父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。\n\nfinal 类\n\n * final 类不能被继承，没有类能够继承 final 类的任何特性。\n\n使用方法：\n\n// 不能被继承\nfinal class Fu {\n\n    // 不能被重写\n    public final void show(){\n\n        // 不能再赋值\n        final int i = 10;\n        System.out.println(i);\n    }\n}\n\n\n\n# 常量\n\n实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。 常量的命名规范：\n\n * 单个单词: 全部大写\n * 多个单词：全部大写，单词之间用下划线隔开\n\n细节：\n\nfinal修饰的变量是基本类型，那么变量的存储的数据值不能发生改变。 final修饰的变量是引用类型，那么变量的存储地址值不能发生改变，对象内部的可以改变。\n\n提高可读性的示例：\n\npublic class StudentSystem {\n    private static final String ADD_STUDENT = "1";\n    private static final String DELETE_STUDENT = "2";\n    private static final String UPDATE_STUDENT = "3";\n    private static final String CHECK_STUDENT = "4";\n    private static final String EXIT = "5";\n\n    switch (chose){\n        case ADD_STUDENT -> addStudent(list);\n        case DELETE_STUDENT -> deleteStudent(list);\n        case UPDATE_STUDENT -> setStudent(list);\n        case CHECK_STUDENT -> getStudent(list);\n        case EXIT -> {\n            System.out.println("退出");\n            // break loop;\n            System.exit(0); // 停止虚拟机运行\n        }\n\n        default -> System.out.println("没有这个选项");\n    }\n}\n\n\n\n# 权限修饰符\n\n\n# 修饰符的概述\n\n * 权限修饰符：是用来控制一个成员能够被访问的范围的\n * 可以修饰成员变量，方法，构造方法，内部类。\n\npublic class Student{\n    private String name;\n    private int age;\n}\n\n\n\n# 权限修饰符的分类\n\n有四种作用范围由小到大（private < 空着不写 < protected < public）\n\n访问控制修饰符 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\n * default : (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n * private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\n * public : 对所有类可见。使用对象：类、接口、变量、方法\n * protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n\n# 修饰符访问权限\n\n修饰符         当前类   同一包内   子孙类(同一包)   子孙类(不同包)   其他包\npublic      Y     Y      Y          Y          Y\nprotected   Y     Y      Y          Y/N（说明）    N\ndefault     Y     Y      Y          N          N\nprivate     Y     N      N          N          N\n\n实际开发中，一般只用private和public\n\n * 成员变量私有\n * 方法公开\n\n特例：如果方法中的代码是抽取其它方法中共性代码，这个方法一般也私有\n\n\n# 代码块\n\n代码块分别有如下三种类型\n\n * 局部代码块\n * 构造代码块\n * 静态代码块\n\n\n# 局部代码块\n\n该技术已经淘汰，提前结束变量的生命周期，不够灵活\n\npublic class demo{\n    public static void main(String[] args) {\n        {\n            int a = 10;\n        }\n        // 因为当代码执行到这里的时候，变量a就从内存中消失了\n        // System.out.println(a);\n    }\n}\n\n\n\n# 构造代码块\n\n什么是构造代码块？\n\n 1. 写在成员位置的代码块\n 2. 作用是可以把多个构造方法中重复的代码取出来\n 3. 执行时机，我们在创建本类对象的时候会先执行构造代码块再执行构造方法\n\npublic class demo{\n    private String name;\n    private int age;\n    // 构造代码块\n    {\n        System.out.println("开始创建对象了");\n    }\n    public demo{\n        // this(null,0);\n    }\n\n    public demo(String name;int age){\n        System.out.println("开始创建对象了");\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n\n# 静态代码块\n\n * 格式: static{}\n * 特点: 需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次\n * 使用场景: 在类加载的时候，做一些数据初始化的时候使用。\n\n数据的初始化：\n\npublic class demo{\n    private String name;\n    private int age;\n    // 构造代码块\n    static {\n        System.out.println("开始创建对象了");\n    }\n    public demo{\n        // this(null,0);\n    }\n\n    public demo(String name;int age){\n        System.out.println("开始创建对象了");\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n\n# 抽象类\n\n\n# 抽象类概述\n\n * 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具 体的对象，这样的类就是抽象类。\n\n * 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n * 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n\n * 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n\n * 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n抽象类和抽象方法\n\n * 抽象类的定义格式\n * 抽象方法的定义格式\n * 子类继承抽象类之后，如何重写抽象方法\n\n\n# 抽象方法\n\n抽象方法：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。该方法就可以定义为抽 象方法。 抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类\n\n抽象类和抽象方法的注意事项\n\n * 抽象类不能实例化(创建对象)\n * 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n * 可以有构造方法\n * 抽象类的子类\n   * 要么重写抽象类的所有抽象方法\n   * 要么是抽象类\n\n\n# 定义格式\n\n抽象方法的定义格式：\n\npublic abstract 返回值类型 方法名(参数列表);\n\n\n抽象类的定义格式：\n\npublic abstract class 类名{}\n\n\n抽象类和抽象方法的意义\n\n编写带有抽象类的标准Javabean类 青蛙frog 属性：名字、年龄 行为：吃虫子、喝水 狗Dog 属性：名字、年龄 行为：吃骨头、喝水 山羊Sheep 属性：名字、年龄 行为：吃艹、喝水\n\n创建Animal的父类：\n\npackage demo;\n\npublic abstract class Animal {\n    private String name;\n    private int age;\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public void drink(){\n        System.out.println("动物在喝水");\n    }\n\n    public abstract void eat();\n\n}\n\n\n创建三个子类：\n\npackage demo;\n\npublic class Dog extends Animal{\n    public Dog() {\n    }\n\n    public Dog(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println("狗吃骨头");\n    }\n}\n\n\npackage demo;\n\npublic class Frog extends Animal{\n    public Frog() {\n    }\n\n    public Frog(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println("青蛙在吃虫子");\n    }\n}\n\n\npackage demo;\n\npublic class Sheep extends Animal{\n    public Sheep() {\n    }\n\n    public Sheep(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println("山羊在吃草");\n    }\n}\n\n\n创建测试类：\n\npackage demo;\n\npublic class test {\n    public static void main(String[] args) {\n        Frog f = new Frog("小绿",1);\n        f.eat();\n        f.drink();\n    }\n}\n\n\n以上代码返回的结果：\n\n青蛙在吃虫子\n动物在喝水\n\n\n\n# 接口\n\n\n# 接口概述\n\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n为什么有接口？\n\n * 接口就是一种规则。\n\n\n# 接口与类相似点\n\n * 一个接口可以有多个方法。\n * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n * 接口的字节码文件保存在 .class 结尾的文件中。\n * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n\n# 接口与类的区别\n\n * 接口不能用于实例化对象。\n * 接口没有构造方法。\n * 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。\n * 接口不能包含成员变量，除了 static 和 final 变量。\n * 接口不是被类继承了，而是要被类实现。\n * 接口支持多继承。\n\n\n# 接口特性\n\n * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n\n# 抽象类和接口的区别\n\n * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n\n# 接口的使用\n\n接口的定义设使用：\n\n * 接口用关键字interface来定义\n * public interface 接口名 {}\n * 接口不能实例化\n * 接口和类之间实现关系，通过implements关键字表示public class 类名 implements 接口名 {}\n\n定义一个父类Animal，再定义一个Swim的接口，创建Frog的子类，通过子类调用swim的接口。\n\npublic abstract class Animal {\n    private String name;\n    private int age;\n    \n    public Animal() {\n    }\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    public abstract void eat();\n}\n\n\n创建Swim的接口：\n\npublic interface Swim {\n    public void swim();\n}\n\n\n创建子类Frog：\n\npublic class Frog extends Animal implements Swim{\n\n    @Override\n    public void eat() {\n        System.out.println("青蛙吃东西");\n    }\n\n    @Override\n    public void swim() {\n        System.out.println("青蛙在游泳");\n    }\n    \n    public static void main(String[] args) {\n        Frog frog = new Frog();\n        frog.eat();\n        frog.swim();\n    }\n}\n\n\n以上代码返回的结果是：\n\n青蛙吃东西\n青蛙在游泳\n\n\n\n# 接口中成员的特点\n\n成员变量\n\n * 只能是常量\n * 默认修饰符： public static final\n\n构造方法\n\n * 没有\n\n成员方法\n\n * 只能是抽象方法\n * 默认修饰符： public abstract\n\nJDK7以前： 接口中只能定义抽象方法\n\n在JDK8以后新增了那些方法？\n\n * 默认方法： default修饰，实现类对象调用\n * 静态方法： static修饰，必须用当前接口名调用\n * 私有方法： private修饰，jdk9开始才有的，只能在接口内部被调用\n\n\n# 接口和类之间的关系\n\n类和类的关系\n\n * 继承关系，只能单继承，不能多继承，但是可以多层继承\n\n类和接口的关系\n\n * 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n接口和接口的关系',normalizedContent:'# java面向对象进阶\n\n\n# 学习内容\n\n * static\n * 继承\n * 包、final、权限修改、代码块\n * 抽象类\n * 接口\n * 多态\n * 内部类\n * 拼图小游戏\n\n\n# static\n\n\n# static修饰符\n\nstatic表示静态，是java中的一个修饰符，可以修饰成员方法，成员变量。\n\n 1. 被static修饰的成员变量，叫做静态变量\n 2. 被static修饰的成员方法，叫做静态方法\n\n示例：\n\npublic class stu {\n    string name;                 //在类中定义非静态常量\n    int age;                     //在类中定义非静态常量\n    static string teachername;   //在类中定义静态常量\n\n    public void show(){\n        system.out.println(name + "," + age + ","\n                        + teachername);\n    }\n\n    public static void method(){\n        system.out.println("这是静态方法" + teachername);\n    }\n\n}\n\n\n静态变量\n\n特点：\n\n * 被该类所有的对象共享\n * 不属于对象，属于类\n * 随着类的加载而加载，优先于对象存在\n\n调用方式：\n\n * 类名调用（推荐）\n * 对象名调用\n\n静态方法\n\n特点：\n\n * 多用在测试类和工具类当中\n * javabean类中很少会用\n\n调用方式：\n\n * 类名调用（推荐）\n * 对象名调用\n\n\n# static工具类\n\n有三种类，分别是以下：\n\n * javabean类： 用来描述一类事物的类，比如，student，teacher，dog，cat等\n * 测试类： 用来检查其他类是否书写正确，带有main的方法的类，是程序的入口\n * 工具类 : 不是用来描述一类事物的，而是帮我们做一些事情的类\n\n格式规范：\n\n 1. 类名见知意\n 2. 私有化构造方法\n 3. 方法定义为静态\n\npublic class arrutil {\n    private arrutil(){\n        public static int getmax(...){...}\n        public static int getmin(...){...}\n        public static int getsum(...){...}\n    }\n}\n\n\n定义数组的工具类\n\n需求： 在实际的开发中，经常会遇到一些数组使用的工具类\n\n请按照如下的要求编写一个数组的工具类： arrayutil\n\n * 提供一个工具类方法printarr,用于返回整数数组的内容。\n * 返回的字符串格式如： [10,20,50,34,100] (只考虑整数数组，且只考虑一堆数组)\n * 提供这样一个工具方法getaerage,用于返回平均分。 （只考虑浮点型数组，且只考虑一堆数组）\n * 定义一个测试类testdemo，调用该工具类的工具方法，并返回结果。\n\npackage a01staticdemo1;\n\npublic class arrayutil {\n    // 私有化构造方法\n    // 目的： 为了不让外界创建他的对象\n    private arrayutil(){\n\n    }\n\n    // 需要定义为静态，方便调用\n    public static string printarr(int[] arr){\n        stringbuilder sb = new stringbuilder();\n        sb.append("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length -1){\n                sb.append(arr[i]);\n            }else {\n                sb.append(arr[i]).append(",");\n            }\n        }\n        sb.append("]");\n        return sb.tostring();\n    }\n    public static double getaverage(double[] arr){\n        double sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum = sum + arr[i];\n        }\n        return sum / arr.length;\n    }\n}\n\n\n使用testdemo测试类：\n\npackage a01staticdemo1;\n\npublic class testdemo {\n    public static void main(string[] args) {\n        int[] arr1 = {1,2,3,4,5};\n        string str = arrayutil.printarr(arr1);\n        system.out.println(str);\n\n        double[] arr2 = {1.5,3.7,4.9,5.8};\n        double avg = arrayutil.getaverage(arr2);\n        system.out.println(avg);\n    }\n}\n\n\n以上代码返回的结果：\n\n[1,2,3,4,5]\n3.9750000000000005\n\n\n> 注意： 工具类的作用就是帮助我们解决各种需要的事情。\n\n\n# static的注意事项\n\n 1. 静态方法只能访问静态变量和静态方法\n 2. 非静态方法可以访问静态变量或者静态方法，也可以访问非静态成员的变量和非静态的成员方法\n 3. 静态方法中是没有this关键字\n\n总结:\n\n * 静态方法中，只能访问静态。非静态方法中可以访问所有。静态方法中没有this关键字。\n\nstatic的main方法\n\npublic class helloword {\n    public static void main(string[] args) {\n        system.out.println("helloword");\n    }\n}\n\n\n * public: 被jvm调用，访问权限足够大\n\n * static: 被jvm调用，不要创建对象，直接类名访问，因为main方法是静态的\n   \n   所以测试类中其他方法也是需要静态的。\n\n * void： 被jvm调用，不需要给jvm返回值\n\n * main: 一个通用的名称，虽然不是关键字，但是被jvm识别\n\n * string[] args: 以前用于接收键盘录入数据的，现在没用\n\n\n# 封装\n\n\n# 封装的概述\n\n在面向对象程式设计方法中，封装（英语：encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n\n# 封装的优点\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n\n# 实现java封装\n\n修改属性的可见性来限制对属性的访问（一般限制为private），例如：\n\npublic class person {\n    private string name;\n    private int age;\n}\n\n\n这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。\n\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：\n\npublic class person{\n    private string name;\n    private int age;\n    \n    public int getage(){\n      return age;\n    }\n\n    public string getname(){\n      return name;\n    }\n\n    public void setage(int age){\n      this.age = age;\n    }\n\n    public void setname(string name){\n      this.name = name;\n    }\n}\n\n\n> 注意：\n> \n> 采用 this 关键字是为了解决实例变量（private string name）和局部变量（setname(string name)中的name变量）之间发生的同名的冲突。\n\n\n# 封装的实例\n\npackage day13;\n\npublic class person {\n    private string name;\n    private int age;\n\n    public person() {\n    }\n\n    public person(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n}\n\n\n以上实例中public方法是外部类访问该类成员变量的入口。\n\n通常情况下，这些方法被称为getter和setter方法。\n\n因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。\n\npackage day13;\n\npublic class persontest {\n    public static void main(string[] args) {\n        person person = new person("小明",12);\n        system.out.println(person.getname());\n        system.out.println(person.getage());\n        person.setage(18);\n        system.out.println(person.getage());\n    }\n}\n\n\n以上代码返回的结果：\n\n小明\n12\n18\n\n\n\n# 继承\n\n\n# 继承的概念\n\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n * java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系。public class student extends person { }\n * student称为子类（派生类），person称为父类（基类或超类）。\n\n使用继承的好处：\n\n * 可以把多个子类中的重复的代码抽取到父类中了，提高代码的复用性。\n * 子类可以在父类基础上，增加其他的功能，使子类更强大。\n\n\n# 继承的特性\n\n * 子类拥有父类非 private 的属性、方法。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 b 类继承 a 类，c 类继承 b 类，所以按照关系就是 b 类是 c 类的父类，a 类是 b 类的父类，这是 java 继承区别于 c++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n继承的特点总结：\n\n * java只支持单继承、不支持多继承、但是支持多层继承\n * java中所有的类都直接或者间接继承于object\n * 子类只能访问父类中非私有的成员\n\n继承中\n\n成员方法的访问特点\n\n * 直接调用满足就近原则，谁离我近，我就用谁\n * super调用，直接访问父类\n\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# extends关键字\n\n在 java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\npublic class animal { \n    private string name;   \n    private int id; \n    public animal(string myname, int myid) { \n        //初始化属性值\n    } \n    public void eat() {  //吃东西方法的具体实现  } \n    public void sleep() { //睡觉方法的具体实现  } \n} \n \npublic class penguin  extends  animal{ \n}\n\n\n\n# super 与 this 关键字\n\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：指向自己的引用。\n\nthis和supper的使用：\n\npublic class test {\n    public static void main(string[] args) {\n        zi zi = new zi();\n        zi.zishow();\n    }\n}\nclass fu{\n    string name = "super";\n}\n\nclass zi extends fu{\n    string name = "this";\n    public void zishow(){\n        string name = "zishow";\n        system.out.println(name);\n        system.out.println(this.name);\n        system.out.println(super.name);\n    }\n}\n\n\n以上代码返回的结果：\n\nzishow\nthis\nsuper\n\n\n继承中\n\n构造方法的访问特性：\n\n * 父类中的构造方法不会被子类继承，但是可以用super调用\n * 子类构造方法的第一行，有一个默认的super()\n * 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己\n * 如果需要方法父类有参构造，必须手动书写\n\nthis、super使用总结\n\nthis： 理解为一个变量，表示当前方法调用者的地址值\n\nsuper: 代表父类存储空间\n\n\n# 方法的重写\n\n当父类的方法不能满足子类的方法要求，需要进行方法重写。\n\n在继承中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。\n\n@override重写注解\n\n 1. @override是放在重写后的方法上，校验子类重写时语法是否正确。\n 2. 加上注解后如果有红色波浪线，表示语法有错误\n 3. 建议重写方法都加@override注解，代码安全，优雅！\n\npublic class demo {\n    public static void main(string[] args) {\n        student stu = new student();\n        stu.lunch();\n    }\n}\nclass person {\n    public void eat(){\n        system.out.println("吃饭");\n    }\n    public void drink(){\n        system.out.println("喝水");\n    }\n}\n\nclass student extends person{\n    public void lunch(){\n        this.eat();\n        this.drink();\n\n        super.eat();\n        super.drink();\n    }\n\n    @override\n    public void eat(){\n        system.out.println("吃意大利面");\n    }\n    @override\n    public void drink(){\n        system.out.println("喝牛奶");\n    }\n}\n\n\n以上代码返回的结果：\n\n吃意大利面\n喝牛奶\n吃饭\n喝水\n\n\n方法重写的注意事项：\n\n 1. 重写方法的每次、形参列表必须与父类中的一致\n 2. 子类重写父类方法时候，访问权限子类必须大于等于父类\n 3. 子类重写父类方法时，返回值类型子类必须小于等于父类\n 4. 建议： 重写的方法尽量和父类的保持一致\n 5. 只有被添加到虚方法列表中的方法才能被重写\n\n利用方法的重写设计继承结构\n\n现在有三种动物：哈士奇、沙皮狗、中华田园犬\n\n暂时不考虑属性，只考虑行为\n\n请按照继承的思想特点进行继承体系的设计\n\n三种动物分别有以下行为：\n\n * 哈士奇: 吃饭（吃狗粮） 喝水 看家 拆家\n * 沙皮狗： 吃饭（吃狗粮、吃骨头） 喝水 看家\n * 中华田园犬 吃饭（吃剩饭） 喝水 看家\n\n分别写如下几个类：\n\n * dog\n * hasky\n * shapidog\n * chinadog\n\n父类的dog如下：\n\npackage dog;\n\npublic class dog {\n    public void eat(){\n        system.out.println("在吃狗粮");\n    }\n\n    public void drink(){\n        system.out.println("在喝水");\n    }\n\n    public void lookhome(){\n        system.out.println("在看家");\n    }\n}\n\n\n分别写三个子类的内容：\n\npackage dog;\n\npublic class hasky extends dog{\n    public void brokehome(){\n        system.out.println("在拆家");\n    }\n}\n\n\npackage dog;\n\npublic class chinadog extends dog{\n\n    @override\n    public void eat(){\n        system.out.println("在吃饭，吃着剩饭");\n    }\n\n}\n\n\npackage dog;\n\npublic class shapidog extends dog{\n\n    @override\n    public void eat(){\n        system.out.println("在吃饭，吃着狗粮和骨头");\n    }\n}\n\n\n创建一个测试类：\n\npackage dog;\n\npublic class test {\n    public static void main(string[] args) {\n        hasky h = new hasky();\n        h.eat();\n        h.brokehome();\n        h.drink();\n\n        chinadog chinadog = new chinadog();\n        chinadog.eat();\n        chinadog.drink();\n        chinadog.lookhome();\n\n        shapidog shapidog = new shapidog();\n        shapidog.eat();\n        shapidog.drink();\n        shapidog.lookhome();\n\n    }\n}\n\n\n以上代码返回的结果：\n\n在吃狗粮\n在拆家\n在喝水\n在吃饭，吃着剩饭\n在喝水\n在看家\n在吃饭，吃着狗粮和骨头\n在喝水\n在看家\n\n\n设计继承构造方法\n\n1.经理\n\n成员变量： 工号，姓名，工资，管理奖金\n\n成员方法： 工作（管理其他人），吃饭（吃米饭）\n\n2.厨师\n\n成员变量： 工号，姓名，工资\n\n成员方法：工作（炒菜），吃饭（吃米饭）\n\n创建四个类：\n\n * employee\n * manager\n * cook\n * test\n\n创建父类employee，作为主要参数构造\n\npackage dmeo;\n\npublic class employee {\n    // 类名见名知意\n    // 所有的成员变量都需要私有\n    // 构造方法\n\n    private string id;\n    private string name;\n    private double salary;\n\n\n    public employee() {\n    }\n\n    public employee(string id, string name, double salary) {\n        this.id = id;\n        this.name = name;\n        this.salary = salary;\n    }\n\n    public string getid() {\n        return id;\n    }\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public double getsalary() {\n        return salary;\n    }\n\n    public void setsalary(double salary) {\n        this.salary = salary;\n    }\n\n    public void work(){\n        system.out.println("在工作");\n    }\n\n    public void eat(){\n        system.out.println("在吃饭");\n    }\n}\n\n\n创建经理和厨师的子类：\n\npackage dmeo;\n\npublic class manager extends employee{\n    private double bouns;\n\n    public manager() {\n    }\n\n    // 带全部参数的构造\n    // 父类 + 子类\n    public manager(string id, string name, double salary, double bouns) {\n        super(id, name, salary);\n        this.bouns = bouns;\n    }\n\n    public double getbouns() {\n        return bouns;\n    }\n\n    public void setbouns(double bouns) {\n        this.bouns = bouns;\n    }\n\n    @override\n    public void work(){\n        system.out.println("在管理其他人");\n    }\n}\n\n\npackage dmeo;\n\npublic class cook extends employee {\n    public cook() {\n    }\n\n    public cook(string id, string name, double salary) {\n        super(id, name, salary);\n    }\n\n    @override\n    public void work(){\n        system.out.println("厨师正在炒菜");\n    }\n}\n\n\n创建测试类：\n\npackage dmeo;\n\npublic class test {\n    public static void main(string[] args) {\n        manager m = new manager("heima001","张三",15000,8000);\n        system.out.println(m.getid() + "," + m.getname() + "," + m.getsalary() + "," + m.getbouns());\n        m.work();\n        m.eat();\n\n        cook c = new cook();\n        c.setid("heima002");\n        c.setname("李四");\n        c.setsalary(8000);\n        system.out.println(c.getid() + "," + c.getname() + "," + c.getsalary());\n        c.work();\n        c.eat();\n\n    }\n}\n\n\n以上的代码返回的结果：\n\nheima001,张三,15000.0,8000.0\n在管理其他人\n在吃饭\nheima002,李四,8000.0\n厨师正在炒菜\n在吃饭\n\n\n\n# 多态\n\n\n# 多态的概念\n\n什么是多态？\n\n同类型的对象，表现出不同的形态。\n\n多态性是对象多种表现形式的体现。\n\n现实中，比如我们按下 f1 键这个动作：\n\n * 如果当前在 flash 界面下弹出的就是 as 3 的帮助文档；\n * 如果当前在 word 下弹出的就是 word 帮助；\n * 在 windows 下弹出的就是 windows 帮助和支持。\n\n同一个事件发生在不同的对象上会产生不同的结果。\n\n多态的表现形式：\n\n父类类型 对象名称 = 子类对象\n\n\n# 多态的优点\n\n * 消除类型之间的耦合关系\n * 可替换性\n * 可扩充性\n * 接口性\n * 灵活性\n * 简化性\n\n多态的前提：\n\n * 有继承/实现关系\n * 有父类引用指向子类对象\n * 有方法重写\n\n多态的好处：\n\n * 使用父类型作为参数，可以接受所有子类对象\n * 体现多态的扩展性与便利\n\n多态的优势\n\n * 方法中，使用父类作为参数，可以接受所有子类对象\n\n多态的弊端\n\n * 不能使用子类的特有功能\n\n引用数据类型的类型转换，有几种方式\n\n * 自动类型转换 强制类型转换\n\nperson p = new student();\nstudent s = (person) p;\n\n\n强制类型转换能解决什么问题？\n\n * 可以转换成真正的子类类型，从而调用子类独有功能\n * 转换类型与真实对象类型不一致会报错\n * 转换的时候用instanceofl关键字进行判断\n\nif (animal instanceof dog dog){\n    dog.lookhome();\n}else if (animal instanceof cat cat){\n    cat.catchmouse();\n}\n\n\n多态的示例：\n\npackage day02;\n\npublic class test {\n    public static void main(string[] args) {\n        // 创建对象（多态方式）\n        // fu a = new dog();\n        animal a = new dog();\n        // 动物\n        // 调用成员变量： 编译看左边 运行也看左边\n        // 编译看左边： javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n        // 运行也看左边： java运行代码的时候，实际获取的就是左边的父类成员变量的值\n        system.out.println(a.name);  // 动物\n\n        // 调用成员方法： 编译看左边，运行看右边\n        // 编译看左边： java编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败\n        // 运行看右边： java运行代码的时候，实际上运行的是子类的方法\n        a.show(); // dog --- show 方法\n\n        // 成员变量： 在子类的对象中，会把父类的成员变量也继承下去的 父： name  子： name\n        // 成员方法： 如果子类对方进行了重写，那么虚方法表中是会把父类的方法进行覆盖的。\n\n    }\n}\n\nclass animal{\n    string name = "动物";\n\n    public void show(){\n        system.out.println("animal --- show方法");\n    }\n}\n\nclass dog extends animal{\n    string name = "狗";\n\n    @override\n    public void show(){\n        system.out.println("dog --- show方法");\n    }\n}\n\n\n\n以上代码返回的结果：\n\n动物\ndog --- show方法\n\n\n如上的示例可以看出：\n\n调用成员变量\n\n * 调用成员变量： 编译看左边 运行也看左边\n * 编译看左边： javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n * 运行也看左边： java运行代码的时候，实际获取的就是左边的父类成员变量的值\n\n调用成员方法\n\n * 调用成员方法： 编译看左边，运行看右边\n * 编译看左边： java编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败\n * 运行看右边： java运行代码的时候，实际上运行的是子类的方法\n\n\n# 多态的综合练习\n\n1.定义狗类\n\n属性： 年龄、颜色\n\n行为： eat(string something)、看家lookhome的方法\n\n2.定义猫类\n\n属性： 年龄、颜色\n\n行为：eat(string something)、抓老鼠cattchmouse方法\n\n3.定义person类/饲养员\n\n属性：姓名、年龄\n\n行为：keeppet(dog dog,string something)、功能养宠物、something表示喂养的东西。\n\n定义animal父类：\n\npublic class animal {\n    private int age;\n    private string color;\n\n    public animal() {\n    }\n\n    public animal(int age, string color) {\n        this.age = age;\n        this.color = color;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public string getcolor() {\n        return color;\n    }\n\n    public void setcolor(string color) {\n        this.color = color;\n    }\n\n    public void eat(string something){\n        system.out.println("在吃饭");\n    }\n}\n\n\n定义dog和cat的子类：\n\npublic class dog extends animal{\n    public dog() {\n    }\n\n    public dog(int age, string color) {\n        super(age, color);\n    }\n\n    @override\n    public void eat(string something) {\n        system.out.println(getage() + "岁的"+ getcolor() +"的狗两只前腿死死的抱住" + something +"吃");\n    }\n\n    public void lookhome(){\n        system.out.println("狗在看家");\n    }\n}\n\n\npublic class cat extends animal{\n    public cat() {\n    }\n\n    public cat(int age, string color) {\n        super(age, color);\n    }\n\n    @override\n    public void eat(string something) {\n        system.out.println(getage() + "岁的" + getcolor() + "的猫眯着眼睛侧着头吃" + something);\n    }\n    public void catchmouse(){\n        system.out.println("猫抓老鼠");\n    }\n}\n\n\n定义person的类：\n\npublic class person {\n    private string name;\n    private int age;\n\n\n    public person() {\n    }\n\n    public person(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    // 饲养狗\n//    public void keeppet(dog dog,string something){\n//        system.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getcolor() + "颜色" + dog.getage() + "岁的狗");\n//        dog.eat(something);\n//        dog.lookhome();\n//    }\n//\n//    // 饲养猫\n//    public void keeppet(cat cat,string something){\n//        system.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getcolor() + "颜色" + cat.getage() + "岁的猫");\n//        cat.eat(something);\n//        cat.catchmouse();\n//    }\n\n    // 想要一个方法，接受所有动物，包括猫，包括狗\n    public void keeppet(animal animal,string something){\n        if (animal instanceof dog dog){\n            system.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getcolor() + "颜色" + dog.getage() + "岁的狗");\n            dog.eat(something);\n            dog.lookhome();\n        }else if (animal instanceof cat cat){\n            system.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getcolor() + "颜色" + cat.getage() + "岁的猫");\n            cat.eat(something);\n            cat.catchmouse();\n        }\n    }\n\n}\n\n\n定义一个测试类：\n\npublic class test {\n    public static void main(string[] args) {\n        // 创建对象和调用方法\n        person  p1 = new person("老王",30);\n        dog d = new dog(2,"黑色");\n        cat c = new cat(3,"灰色");\n        p1.keeppet(d,"骨头");\n        p1.keeppet(c,"鱼");\n\n    }\n}\n\n\n以上代码返回的结果：\n\n年龄为30岁的老王养了一只黑色颜色2岁的狗\n2岁的黑色的狗两只前腿死死的抱住骨头吃\n狗在看家\n年龄为30岁的老王养了一只灰色颜色3岁的猫\n3岁的灰色的猫眯着眼睛侧着头吃鱼\n猫抓老鼠\n\n\n\n# 包和final\n\n\n# 包的概述\n\n包就是文件夹。用来管理各种不同功能的java类，方便后期代码维护。 包名的规则：公司域名反写+包的作用，需要全部英文小写，见名知意。com.itheima.domain\n\npackage com.itheima.com.domain;\n\npublic class student {\n    私有化成员变量;\n    构造方法;\n    成员方法;\n}\n\n\n如下是方法的说明\n\ncom.itheima.domain.student，全称是全类名，其中student是全限定名。\n\n\n# 使用其它类的规则\n\n * 使用同一个包中的类时，不需要导包。\n * 使用java.lang包中的类时，不需要导包。\n * 其它情况都需要导包\n * 如果同时使用两个包中的同名类，需要用全类名。\n\n使用其他类时候，需要使用全类名。\n\nimport com.itheima.domain.student;\n\npublic class test {\n    public static void main(string[] args) {\n        com.itheima.domain.student s = new com.itheima.domain.student();\n    }\n}\n\n\n\n# final\n\nfinal 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\nfinal 修饰符通常和 static 修饰符一起使用来创建类常量。\n\n * 修饰方法: 表明该方法是最终方法，不能被重写\n * 修饰类: 表明该类是最终类，不能被继承\n * 修饰变量: 叫做常量，只能被赋值一次\n\nfinal 方法\n\n * 父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。\n\nfinal 类\n\n * final 类不能被继承，没有类能够继承 final 类的任何特性。\n\n使用方法：\n\n// 不能被继承\nfinal class fu {\n\n    // 不能被重写\n    public final void show(){\n\n        // 不能再赋值\n        final int i = 10;\n        system.out.println(i);\n    }\n}\n\n\n\n# 常量\n\n实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。 常量的命名规范：\n\n * 单个单词: 全部大写\n * 多个单词：全部大写，单词之间用下划线隔开\n\n细节：\n\nfinal修饰的变量是基本类型，那么变量的存储的数据值不能发生改变。 final修饰的变量是引用类型，那么变量的存储地址值不能发生改变，对象内部的可以改变。\n\n提高可读性的示例：\n\npublic class studentsystem {\n    private static final string add_student = "1";\n    private static final string delete_student = "2";\n    private static final string update_student = "3";\n    private static final string check_student = "4";\n    private static final string exit = "5";\n\n    switch (chose){\n        case add_student -> addstudent(list);\n        case delete_student -> deletestudent(list);\n        case update_student -> setstudent(list);\n        case check_student -> getstudent(list);\n        case exit -> {\n            system.out.println("退出");\n            // break loop;\n            system.exit(0); // 停止虚拟机运行\n        }\n\n        default -> system.out.println("没有这个选项");\n    }\n}\n\n\n\n# 权限修饰符\n\n\n# 修饰符的概述\n\n * 权限修饰符：是用来控制一个成员能够被访问的范围的\n * 可以修饰成员变量，方法，构造方法，内部类。\n\npublic class student{\n    private string name;\n    private int age;\n}\n\n\n\n# 权限修饰符的分类\n\n有四种作用范围由小到大（private < 空着不写 < protected < public）\n\n访问控制修饰符 java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。java 支持 4 种不同的访问权限。\n\n * default : (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n * private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\n * public : 对所有类可见。使用对象：类、接口、变量、方法\n * protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n\n# 修饰符访问权限\n\n修饰符         当前类   同一包内   子孙类(同一包)   子孙类(不同包)   其他包\npublic      y     y      y          y          y\nprotected   y     y      y          y/n（说明）    n\ndefault     y     y      y          n          n\nprivate     y     n      n          n          n\n\n实际开发中，一般只用private和public\n\n * 成员变量私有\n * 方法公开\n\n特例：如果方法中的代码是抽取其它方法中共性代码，这个方法一般也私有\n\n\n# 代码块\n\n代码块分别有如下三种类型\n\n * 局部代码块\n * 构造代码块\n * 静态代码块\n\n\n# 局部代码块\n\n该技术已经淘汰，提前结束变量的生命周期，不够灵活\n\npublic class demo{\n    public static void main(string[] args) {\n        {\n            int a = 10;\n        }\n        // 因为当代码执行到这里的时候，变量a就从内存中消失了\n        // system.out.println(a);\n    }\n}\n\n\n\n# 构造代码块\n\n什么是构造代码块？\n\n 1. 写在成员位置的代码块\n 2. 作用是可以把多个构造方法中重复的代码取出来\n 3. 执行时机，我们在创建本类对象的时候会先执行构造代码块再执行构造方法\n\npublic class demo{\n    private string name;\n    private int age;\n    // 构造代码块\n    {\n        system.out.println("开始创建对象了");\n    }\n    public demo{\n        // this(null,0);\n    }\n\n    public demo(string name;int age){\n        system.out.println("开始创建对象了");\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n\n# 静态代码块\n\n * 格式: static{}\n * 特点: 需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次\n * 使用场景: 在类加载的时候，做一些数据初始化的时候使用。\n\n数据的初始化：\n\npublic class demo{\n    private string name;\n    private int age;\n    // 构造代码块\n    static {\n        system.out.println("开始创建对象了");\n    }\n    public demo{\n        // this(null,0);\n    }\n\n    public demo(string name;int age){\n        system.out.println("开始创建对象了");\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n\n# 抽象类\n\n\n# 抽象类概述\n\n * 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具 体的对象，这样的类就是抽象类。\n\n * 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n * 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n\n * 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n\n * 在 java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n抽象类和抽象方法\n\n * 抽象类的定义格式\n * 抽象方法的定义格式\n * 子类继承抽象类之后，如何重写抽象方法\n\n\n# 抽象方法\n\n抽象方法：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。该方法就可以定义为抽 象方法。 抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类\n\n抽象类和抽象方法的注意事项\n\n * 抽象类不能实例化(创建对象)\n * 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n * 可以有构造方法\n * 抽象类的子类\n   * 要么重写抽象类的所有抽象方法\n   * 要么是抽象类\n\n\n# 定义格式\n\n抽象方法的定义格式：\n\npublic abstract 返回值类型 方法名(参数列表);\n\n\n抽象类的定义格式：\n\npublic abstract class 类名{}\n\n\n抽象类和抽象方法的意义\n\n编写带有抽象类的标准javabean类 青蛙frog 属性：名字、年龄 行为：吃虫子、喝水 狗dog 属性：名字、年龄 行为：吃骨头、喝水 山羊sheep 属性：名字、年龄 行为：吃艹、喝水\n\n创建animal的父类：\n\npackage demo;\n\npublic abstract class animal {\n    private string name;\n    private int age;\n\n    public animal() {\n    }\n\n    public animal(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public void drink(){\n        system.out.println("动物在喝水");\n    }\n\n    public abstract void eat();\n\n}\n\n\n创建三个子类：\n\npackage demo;\n\npublic class dog extends animal{\n    public dog() {\n    }\n\n    public dog(string name, int age) {\n        super(name, age);\n    }\n    @override\n    public void eat() {\n        system.out.println("狗吃骨头");\n    }\n}\n\n\npackage demo;\n\npublic class frog extends animal{\n    public frog() {\n    }\n\n    public frog(string name, int age) {\n        super(name, age);\n    }\n\n    @override\n    public void eat() {\n        system.out.println("青蛙在吃虫子");\n    }\n}\n\n\npackage demo;\n\npublic class sheep extends animal{\n    public sheep() {\n    }\n\n    public sheep(string name, int age) {\n        super(name, age);\n    }\n    @override\n    public void eat() {\n        system.out.println("山羊在吃草");\n    }\n}\n\n\n创建测试类：\n\npackage demo;\n\npublic class test {\n    public static void main(string[] args) {\n        frog f = new frog("小绿",1);\n        f.eat();\n        f.drink();\n    }\n}\n\n\n以上代码返回的结果：\n\n青蛙在吃虫子\n动物在喝水\n\n\n\n# 接口\n\n\n# 接口概述\n\n接口（英文：interface），在java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n为什么有接口？\n\n * 接口就是一种规则。\n\n\n# 接口与类相似点\n\n * 一个接口可以有多个方法。\n * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n * 接口的字节码文件保存在 .class 结尾的文件中。\n * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n\n# 接口与类的区别\n\n * 接口不能用于实例化对象。\n * 接口没有构造方法。\n * 接口中所有的方法必须是抽象方法，java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。\n * 接口不能包含成员变量，除了 static 和 final 变量。\n * 接口不是被类继承了，而是要被类实现。\n * 接口支持多继承。\n\n\n# 接口特性\n\n * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n\n# 抽象类和接口的区别\n\n * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n\n# 接口的使用\n\n接口的定义设使用：\n\n * 接口用关键字interface来定义\n * public interface 接口名 {}\n * 接口不能实例化\n * 接口和类之间实现关系，通过implements关键字表示public class 类名 implements 接口名 {}\n\n定义一个父类animal，再定义一个swim的接口，创建frog的子类，通过子类调用swim的接口。\n\npublic abstract class animal {\n    private string name;\n    private int age;\n    \n    public animal() {\n    }\n    public animal(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    public abstract void eat();\n}\n\n\n创建swim的接口：\n\npublic interface swim {\n    public void swim();\n}\n\n\n创建子类frog：\n\npublic class frog extends animal implements swim{\n\n    @override\n    public void eat() {\n        system.out.println("青蛙吃东西");\n    }\n\n    @override\n    public void swim() {\n        system.out.println("青蛙在游泳");\n    }\n    \n    public static void main(string[] args) {\n        frog frog = new frog();\n        frog.eat();\n        frog.swim();\n    }\n}\n\n\n以上代码返回的结果是：\n\n青蛙吃东西\n青蛙在游泳\n\n\n\n# 接口中成员的特点\n\n成员变量\n\n * 只能是常量\n * 默认修饰符： public static final\n\n构造方法\n\n * 没有\n\n成员方法\n\n * 只能是抽象方法\n * 默认修饰符： public abstract\n\njdk7以前： 接口中只能定义抽象方法\n\n在jdk8以后新增了那些方法？\n\n * 默认方法： default修饰，实现类对象调用\n * 静态方法： static修饰，必须用当前接口名调用\n * 私有方法： private修饰，jdk9开始才有的，只能在接口内部被调用\n\n\n# 接口和类之间的关系\n\n类和类的关系\n\n * 继承关系，只能单继承，不能多继承，但是可以多层继承\n\n类和接口的关系\n\n * 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n接口和接口的关系',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据结构基本概念",frontmatter:{title:"数据结构基本概念",date:"2022-12-18T16:49:56.000Z",category:["数据结构"],tag:["数据结构"],permalink:"/pages/2bb75b/"},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"01.指南/06.数据结构/01.数据结构基本概念.md",key:"v-fe401634",path:"/pages/2bb75b/",headers:[{level:2,title:"数据结构的基本概念",slug:"数据结构的基本概念",normalizedTitle:"数据结构的基本概念",charIndex:2},{level:3,title:"1.其他定义",slug:"_1-其他定义",normalizedTitle:"1.其他定义",charIndex:16},{level:3,title:"2.解决问题方法的效率",slug:"_2-解决问题方法的效率",normalizedTitle:"2.解决问题方法的效率",charIndex:273},{level:3,title:"3.最终定义",slug:"_3-最终定义",normalizedTitle:"3.最终定义",charIndex:332},{level:3,title:"4.抽象数据类型（Abstract Data Type）",slug:"_4-抽象数据类型-abstract-data-type",normalizedTitle:"4.抽象数据类型（abstract data type）",charIndex:427},{level:2,title:"算法的基本概念",slug:"算法的基本概念",normalizedTitle:"算法的基本概念",charIndex:616},{level:3,title:"1.定义",slug:"_1-定义",normalizedTitle:"1.定义",charIndex:628},{level:3,title:"2. 描述算法的手段",slug:"_2-描述算法的手段",normalizedTitle:"2. 描述算法的手段",charIndex:762},{level:3,title:"3. 评价",slug:"_3-评价",normalizedTitle:"3. 评价",charIndex:872},{level:3,title:"4. 复杂度的渐进表示法",slug:"_4-复杂度的渐进表示法",normalizedTitle:"4. 复杂度的渐进表示法",charIndex:923},{level:3,title:"5. 复杂度分析小窍门",slug:"_5-复杂度分析小窍门",normalizedTitle:"5. 复杂度分析小窍门",charIndex:942}],headersStr:"数据结构的基本概念 1.其他定义 2.解决问题方法的效率 3.最终定义 4.抽象数据类型（Abstract Data Type） 算法的基本概念 1.定义 2. 描述算法的手段 3. 评价 4. 复杂度的渐进表示法 5. 复杂度分析小窍门",content:"# 数据结构的基本概念\n\n\n# 1.其他定义\n\n * 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》\n * 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》\n * 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科\n\n\n# 2.解决问题方法的效率\n\n * 跟数据的组织方式有关\n * 跟空间的利用效率有关\n * 跟算法的巧妙程度有关\n\n\n# 3.最终定义\n\n * 数据对象在计算机中的组织方式\n   * 逻辑结构\n   * 物理存储结构\n * 数据对象必定与一系列加在其上的操作相关联\n * 完成这些操作所用的方法就是算法\n\n\n# 4.抽象数据类型（Abstract Data Type）\n\n * 数据类型\n   * 数据对象集\n   * 数据集合相关联的操作集\n * 抽象：描述数据类型的方法不依赖于具体实现\n   * 与存放数据的机器无关\n   * 与数据存储的物理结构无关\n   * 与实现操作的算法和编程语言均无关\n   * 只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题\n\n\n# 算法的基本概念\n\n\n# 1.定义\n\n * 一个有限指令集\n * ≥ 0 的输入\n * 0 的输出\n * 一定在有限步骤之后终止\n * 每一条指令必须\n   * 有充分明确的目标，不可以有歧义\n   * 计算机能处理范围内\n   * 描述应不依赖于任何一种计算机语言以及具体的实现手段\n\n\n# 2. 描述算法的手段\n\n 1. 空间复杂度 S(n)\n    \n    根据算法写成的程序在执行时占用存储空间的长度\n\n 2. 时间复杂度 T(n)\n    \n    根据算法写成的程序在执行时耗费的时间的长度\n\n\n# 3. 评价\n\n在分析一般算法的效率时，常常关注\n\n\n\n一般情况下更多关注的是最坏情况复杂度。\n\n\n# 4. 复杂度的渐进表示法\n\n\n\n\n# 5. 复杂度分析小窍门\n\n",normalizedContent:"# 数据结构的基本概念\n\n\n# 1.其他定义\n\n * 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——sartaj sahni 《数据结构、算法与应用》\n * 数据结构是 adt（abstract data type，数据抽象类型）的物理实现。 ——clifford a.shaffer 《数据结构与算法分析》\n * 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科\n\n\n# 2.解决问题方法的效率\n\n * 跟数据的组织方式有关\n * 跟空间的利用效率有关\n * 跟算法的巧妙程度有关\n\n\n# 3.最终定义\n\n * 数据对象在计算机中的组织方式\n   * 逻辑结构\n   * 物理存储结构\n * 数据对象必定与一系列加在其上的操作相关联\n * 完成这些操作所用的方法就是算法\n\n\n# 4.抽象数据类型（abstract data type）\n\n * 数据类型\n   * 数据对象集\n   * 数据集合相关联的操作集\n * 抽象：描述数据类型的方法不依赖于具体实现\n   * 与存放数据的机器无关\n   * 与数据存储的物理结构无关\n   * 与实现操作的算法和编程语言均无关\n   * 只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题\n\n\n# 算法的基本概念\n\n\n# 1.定义\n\n * 一个有限指令集\n * ≥ 0 的输入\n * 0 的输出\n * 一定在有限步骤之后终止\n * 每一条指令必须\n   * 有充分明确的目标，不可以有歧义\n   * 计算机能处理范围内\n   * 描述应不依赖于任何一种计算机语言以及具体的实现手段\n\n\n# 2. 描述算法的手段\n\n 1. 空间复杂度 s(n)\n    \n    根据算法写成的程序在执行时占用存储空间的长度\n\n 2. 时间复杂度 t(n)\n    \n    根据算法写成的程序在执行时耗费的时间的长度\n\n\n# 3. 评价\n\n在分析一般算法的效率时，常常关注\n\n\n\n一般情况下更多关注的是最坏情况复杂度。\n\n\n# 4. 复杂度的渐进表示法\n\n\n\n\n# 5. 复杂度分析小窍门\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"线性表",frontmatter:{title:"线性表",date:"2022-12-19T13:53:16.000Z",category:["数据结构"],tag:["数据结构"],permalink:"/pages/a46aa1/"},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E7%BA%BF%E6%80%A7%E8%A1%A8.html",relativePath:"01.指南/06.数据结构/02.线性表.md",key:"v-13cb7718",path:"/pages/a46aa1/",headers:[{level:2,title:"1. 线性表",slug:"_1-线性表",normalizedTitle:"1. 线性表",charIndex:2},{level:3,title:"1.1 线性表概述",slug:"_1-1-线性表概述",normalizedTitle:"1.1 线性表概述",charIndex:13},{level:3,title:"1.2 存储结构分类",slug:"_1-2-存储结构分类",normalizedTitle:"1.2 存储结构分类",charIndex:536},{level:3,title:"1.3 前驱和后继",slug:"_1-3-前驱和后继",normalizedTitle:"1.3 前驱和后继",charIndex:737},{level:2,title:"2.顺序表",slug:"_2-顺序表",normalizedTitle:"2.顺序表",charIndex:1096},{level:3,title:"2.1 顺序表的基本概念",slug:"_2-1-顺序表的基本概念",normalizedTitle:"2.1 顺序表的基本概念",charIndex:1106},{level:3,title:"2.2 顺序表的初始化",slug:"_2-2-顺序表的初始化",normalizedTitle:"2.2 顺序表的初始化",charIndex:1450},{level:2,title:"3.单链表",slug:"_3-单链表",normalizedTitle:"3.单链表",charIndex:3173},{level:3,title:"3.1 单链表的基本概念",slug:"_3-1-单链表的基本概念",normalizedTitle:"3.1 单链表的基本概念",charIndex:3183},{level:3,title:"3.2 链表的节点",slug:"_3-2-链表的节点",normalizedTitle:"3.2 链表的节点",charIndex:3459},{level:3,title:"3.3 头节点，头指针和首元节点",slug:"_3-3-头节点-头指针和首元节点",normalizedTitle:"3.3 头节点，头指针和首元节点",charIndex:3881},{level:3,title:"3.4 链表的创建",slug:"_3-4-链表的创建",normalizedTitle:"3.4 链表的创建",charIndex:4310},{level:2,title:"4.静态链表",slug:"_4-静态链表",normalizedTitle:"4.静态链表",charIndex:6541},{level:3,title:"4.1 静态链表的概念",slug:"_4-1-静态链表的概念",normalizedTitle:"4.1 静态链表的概念",charIndex:6552},{level:3,title:"4.2 静态链表中的节点",slug:"_4-2-静态链表中的节点",normalizedTitle:"4.2 静态链表中的节点",charIndex:7090},{level:3,title:"4.3 备用链表",slug:"_4-3-备用链表",normalizedTitle:"4.3 备用链表",charIndex:7291},{level:3,title:"4.3 静态链表的创建",slug:"_4-3-静态链表的创建",normalizedTitle:"4.3 静态链表的创建",charIndex:7731},{level:2,title:"5.双向链表",slug:"_5-双向链表",normalizedTitle:"5.双向链表",charIndex:8136},{level:3,title:"5.1 双向链表的基本概念",slug:"_5-1-双向链表的基本概念",normalizedTitle:"5.1 双向链表的基本概念",charIndex:8147}],headersStr:"1. 线性表 1.1 线性表概述 1.2 存储结构分类 1.3 前驱和后继 2.顺序表 2.1 顺序表的基本概念 2.2 顺序表的初始化 3.单链表 3.1 单链表的基本概念 3.2 链表的节点 3.3 头节点，头指针和首元节点 3.4 链表的创建 4.静态链表 4.1 静态链表的概念 4.2 静态链表中的节点 4.3 备用链表 4.3 静态链表的创建 5.双向链表 5.1 双向链表的基本概念",content:'# 1. 线性表\n\n\n# 1.1 线性表概述\n\n线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。\n\n\n\n如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。\n\n首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：\n\n\n\n图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。\n\n\n\n图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样）。因此可以认定，这两种存储方式都是正确的。\n\n使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全部都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。\n\n将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。\n\n\n# 1.2 存储结构分类\n\n线性表存储结构可细分为顺序存储结构和链式存储结构。\n\n图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：\n\n 1. 如上图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；\n 2. 如上图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；\n\n\n# 1.3 前驱和后继\n\n数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据中的一个元素。\n\n另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：\n\n * 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；\n * 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；\n\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：\n\n\n\n\n# 2.顺序表\n\n\n# 2.1 顺序表的基本概念\n\n顺序表，全名顺序存储结构，是线性表的一种。通过《什么是线性表》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。\n\n不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。\n\n例如，使用顺序表存储集合 {1,2,3,4,5}，数据最终的存储状态如图 1 所示：\n\n\n\n * 由此我们可以得出，将“具有 \'一对一\' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。\n * 通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同数组非常接近。其实，顺序表存储数据使用的就是数组。\n\n\n# 2.2 顺序表的初始化\n\n使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：\n\n 1. 顺序表申请的存储容量；\n 2. 顺序表的长度，也就是表中存储数据元素的个数；\n\n> 提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。\n\n因此，我们需要自定义顺序表，C 语言实现代码如下：\n\ntypedef struct Table{\n    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”\n    int length;//记录当前顺序表的长度\n    int size;//记录顺序表分配的存储容量\n}table;\n\n\n注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。\n\n接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：\n\n * 给 head 动态数据申请足够大小的物理空间；\n * 给 size 和 length 赋初值；\n\n因此，C 语言实现代码如下：\n\n#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小\ntable initTable(){\n    table t;\n    t.head=(int*)malloc(Size*sizeof(int));//构造一个空的顺序表，动态申请存储空间\n    if (!t.head) //如果申请失败，作出提示并直接退出程序\n    {\n        printf("初始化失败");\n        exit(0);\n    }\n    t.length=0;//空表的长度初始化为0\n    t.size=Size;//空表的初始存储空间为Size\n    return t;\n}\n\n\n我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。\n\n通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：\n\n#include <stdio.h>\n#include <stdlib.h>\n#define Size 5\ntypedef struct Table{\n    int * head;\n    int length;\n    int size;\n}table;\ntable initTable(){\n    table t;\n    t.head=(int*)malloc(Size*sizeof(int));\n    if (!t.head)\n    {\n        printf("初始化失败");\n        exit(0);\n    }\n    t.length=0;\n    t.size=Size;\n    return t;\n}\n//输出顺序表中元素的函数\nvoid displayTable(table t){\n    for (int i=0;i<t.length;i++) {\n        printf("%d ",t.head[i]);\n    }\n    printf("\\n");\n}\nint main(){\n    table t=initTable();\n    //向顺序表中添加元素\n    for (int i=1; i<=Size; i++) {\n        t.head[i-1]=i;\n        t.length++;\n    }\n    printf("顺序表中存储的元素分别是：\\n");\n    displayTable(t);\n    return 0;\n}\n\n\n程序运行结果如下：\n\n顺序表中存储的元素分别是：\n1 2 3 4 5\n\n\n\n# 3.单链表\n\n\n# 3.1 单链表的基本概念\n\n链表，别名链式存储结构或单链表，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。\n\n例如，使用链表存储 {1,2,3}，数据的物理存储状态如图 1 所示：\n\n\n\n我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：\n\n\n\n像图 2 这样，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。\n\n\n# 3.2 链表的节点\n\n从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：\n\n 1. 数据元素本身，其所在的区域称为数据域；\n 2. 指向直接后继元素的指针，所在的区域称为指针域；\n\n即链表中存储各数据元素的结构如图 3 所示：\n\n\n\n图 3 所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：\n\n\n\n因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：\n\ntypedef struct Link{\n    char elem; //代表数据域\n    struct Link * next; //代表指针域，指向直接后继元素\n}link; //link为节点名，每个节点都是一个 link 结构体\n\n\n> 提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 struct Link* 的形式）。\n\n\n# 3.3 头节点，头指针和首元节点\n\n上图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：\n\n 1. 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；\n\n 2. 节点：链表中的节点又细分为头节点,首元节点和其他节点：\n    \n    * 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；\n    * 首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；\n    * 其他节点：链表中其他的节点；\n\n因此，一个存储 {1,2,3} 的完整链表结构如图 5 所示：\n\n\n\n注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。\n\n\n\n# 3.4 链表的创建\n\n创建一个链表需要做如下工作：\n\n 1. 声明一个头指针（如果有必要，可以声明一个头节点）；\n 2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；\n\n例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码如下：\n\nlink * initLink(){\n    link * p=NULL;//创建头指针\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\n    //首元节点先初始化\n    temp->elem = 1;\n    temp->next = NULL;\n    p = temp;//头指针指向首元节点\n    //从第二个节点开始创建\n    for (int i=2; i<5; i++) {\n     //创建一个新节点并初始化\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=NULL;\n        //将temp节点与新建立的a节点建立逻辑关系\n        temp->next=a;\n        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对\n        temp=temp->next;\n    }\n    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表\n    return p;\n}\n\n\n如果想创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：\n\nlink * initLink(){\n    link * p=(link*)malloc(sizeof(link));//创建一个头结点\n    link * temp=p;//声明一个指针指向头结点，\n    //生成链表\n    for (int i=1; i<5; i++) {\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=NULL;\n        temp->next=a;\n        temp=temp->next;\n    }\n    return p;\n}\n\n\n我们只需在主函数中调用 initLink 函数，即可轻松创建一个存储 {1,2,3,4} 的链表，C 语言完整代码如下：\n\n#include <stdio.h>\n#include <stdlib.h>\n//链表中节点的结构\ntypedef struct Link{\n    int  elem;\n    struct Link *next;\n}link;\n//初始化链表的函数\nlink * initLink();\n//用于输出链表的函数\nvoid display(link *p);\nint main() {\n    //初始化链表（1，2，3，4）\n    printf("初始化链表为：\\n");\n    link *p=initLink();\n    display(p);\n    return 0;\n}\nlink * initLink(){\n    link * p=NULL;//创建头指针\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\n    //首元节点先初始化\n    temp->elem = 1;\n    temp->next = NULL;\n    p = temp;//头指针指向首元节点\n    for (int i=2; i<5; i++) {\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=NULL;\n        temp->next=a;\n        temp=temp->next;\n    }\n    return p;\n}\nvoid display(link *p){\n    link* temp=p;//将temp指针重新指向头结点\n    //只要temp指针指向的结点的next不是Null，就执行输出语句。\n    while (temp) {\n        printf("%d ",temp->elem);\n        temp=temp->next;\n    }\n    printf("\\n");\n}\n\n\n程序运行结果为：\n\n初始化链表为：\n1 2 3 4\n\n\n注意，如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：\n\nvoid display(link *p){\n    link* temp=p;//将temp指针重新指向头结点\n    //只要temp指针指向的结点的next不是Null，就执行输出语句。\n    while (temp->next) {\n        temp=temp->next;\n        printf("%d",temp->elem);\n    }\n    printf("\\n");\n}\n\n\n\n# 4.静态链表\n\n\n# 4.1 静态链表的概念\n\n静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。\n\n使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间"一对一"的逻辑关系通过一个整形变量（称为"游标"，和指针功能类似）维持（和链表类似）。\n\n例如，使用静态链表存储 {1,2,3} 的过程如下：\n\n创建一个足够大的数组，假设大小为 6，如图 1 所示：\n\n\n\n接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：\n\n\n\n> 通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。\n\n图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。\n\n类似图 2 这样，通过 "数组+游标" 的方式存储具有线性关系数据的存储结构就是静态链表。\n\n\n# 4.2 静态链表中的节点\n\n静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：\n\n * 数据域：用于存储数据元素的值；\n * 游标：其实就是数组下标，表示直接后继元素所在数组中的位置；\n\n因此，静态链表中节点的构成用 C 语言实现为：\n\ntypedef struct {\n    int data;//数据域\n    int cur;//游标\n}component;\n\n\n\n# 4.3 备用链表\n\n图 2 显示的静态链表还不够完整，静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称为备用链表。\n\n备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间。\n\n> 通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。\n\n静态链表中设置备用链表的好处是，可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用。比如，若静态链表中数组下标为 0 的位置上存有数据，则证明数组已满。\n\n使用静态链表存储 {1,2,3}，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：\n\n\n\n图 3 中，备用链表上连接的依次是 a[0]、a[2] 和 a[4]，而数据链表上连接的依次是 a[1]、a[3] 和 a[5]。\n\n\n# 4.3 静态链表的创建\n\n假设使用静态链表（数组长度为 6）存储 {1,2,3}，则需经历以下几个阶段：\n\n 1. 在数据链表未初始化之前，数组中所有位置都处于空闲状态，因此都应被链接在备用链表上，如图 4 所示：\n\n\n\n当向静态链表中添加数据时，需提前从备用链表中摘除节点，以供新数据使用。\n\n备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 O(1)。\n\n\n 2. 在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：\n\n\n\n 3. 在图 5 的基础上，添加元素 2 的过程如图 6 所示：\n\n\n\n 4. 在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：\n\n\n\n\n# 5.双向链表\n\n\n# 5.1 双向链表的基本概念\n\n无论是动态链表还是静态链表，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为单向链表（或单链表）。\n\n虽然使用单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，而 "从后往前" 找并不是它的强项。\n\n从名字上理解双向链表，即链表是 "双向" 的，如图 1 所示：\n\n\n\n双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要。\n\n从图 1 中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：\n\n 1. 指针域：用于指向当前节点的直接前驱节点；\n 2. 数据域：用于存储数据元素。\n 3. 指针域：用于指向当前节点的直接后继节点；\n\n\n\n因此，双链表的节点结构用 C 语言实现为：\n\ntypedef struct line{\n    struct line * prior; //指向直接前趋\n    int data;\n    struct line * next; //指向直接后继\n}line;\n',normalizedContent:'# 1. 线性表\n\n\n# 1.1 线性表概述\n\n线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。\n\n\n\n如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。\n\n首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：\n\n\n\n图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。\n\n\n\n图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样）。因此可以认定，这两种存储方式都是正确的。\n\n使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全部都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。\n\n将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。\n\n\n# 1.2 存储结构分类\n\n线性表存储结构可细分为顺序存储结构和链式存储结构。\n\n图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：\n\n 1. 如上图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；\n 2. 如上图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；\n\n\n# 1.3 前驱和后继\n\n数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据中的一个元素。\n\n另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：\n\n * 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；\n * 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；\n\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：\n\n\n\n\n# 2.顺序表\n\n\n# 2.1 顺序表的基本概念\n\n顺序表，全名顺序存储结构，是线性表的一种。通过《什么是线性表》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。\n\n不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。\n\n例如，使用顺序表存储集合 {1,2,3,4,5}，数据最终的存储状态如图 1 所示：\n\n\n\n * 由此我们可以得出，将“具有 \'一对一\' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。\n * 通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同数组非常接近。其实，顺序表存储数据使用的就是数组。\n\n\n# 2.2 顺序表的初始化\n\n使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：\n\n 1. 顺序表申请的存储容量；\n 2. 顺序表的长度，也就是表中存储数据元素的个数；\n\n> 提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。\n\n因此，我们需要自定义顺序表，c 语言实现代码如下：\n\ntypedef struct table{\n    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”\n    int length;//记录当前顺序表的长度\n    int size;//记录顺序表分配的存储容量\n}table;\n\n\n注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。\n\n接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：\n\n * 给 head 动态数据申请足够大小的物理空间；\n * 给 size 和 length 赋初值；\n\n因此，c 语言实现代码如下：\n\n#define size 5 //对size进行宏定义，表示顺序表申请空间的大小\ntable inittable(){\n    table t;\n    t.head=(int*)malloc(size*sizeof(int));//构造一个空的顺序表，动态申请存储空间\n    if (!t.head) //如果申请失败，作出提示并直接退出程序\n    {\n        printf("初始化失败");\n        exit(0);\n    }\n    t.length=0;//空表的长度初始化为0\n    t.size=size;//空表的初始存储空间为size\n    return t;\n}\n\n\n我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。\n\n通过在主函数中调用 inittable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，c 语言实现代码如下：\n\n#include <stdio.h>\n#include <stdlib.h>\n#define size 5\ntypedef struct table{\n    int * head;\n    int length;\n    int size;\n}table;\ntable inittable(){\n    table t;\n    t.head=(int*)malloc(size*sizeof(int));\n    if (!t.head)\n    {\n        printf("初始化失败");\n        exit(0);\n    }\n    t.length=0;\n    t.size=size;\n    return t;\n}\n//输出顺序表中元素的函数\nvoid displaytable(table t){\n    for (int i=0;i<t.length;i++) {\n        printf("%d ",t.head[i]);\n    }\n    printf("\\n");\n}\nint main(){\n    table t=inittable();\n    //向顺序表中添加元素\n    for (int i=1; i<=size; i++) {\n        t.head[i-1]=i;\n        t.length++;\n    }\n    printf("顺序表中存储的元素分别是：\\n");\n    displaytable(t);\n    return 0;\n}\n\n\n程序运行结果如下：\n\n顺序表中存储的元素分别是：\n1 2 3 4 5\n\n\n\n# 3.单链表\n\n\n# 3.1 单链表的基本概念\n\n链表，别名链式存储结构或单链表，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。\n\n例如，使用链表存储 {1,2,3}，数据的物理存储状态如图 1 所示：\n\n\n\n我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：\n\n\n\n像图 2 这样，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。\n\n\n# 3.2 链表的节点\n\n从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：\n\n 1. 数据元素本身，其所在的区域称为数据域；\n 2. 指向直接后继元素的指针，所在的区域称为指针域；\n\n即链表中存储各数据元素的结构如图 3 所示：\n\n\n\n图 3 所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：\n\n\n\n因此，链表中每个节点的具体实现，需要使用 c 语言中的结构体，具体实现代码为：\n\ntypedef struct link{\n    char elem; //代表数据域\n    struct link * next; //代表指针域，指向直接后继元素\n}link; //link为节点名，每个节点都是一个 link 结构体\n\n\n> 提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 link 类型（这里要写成 struct link* 的形式）。\n\n\n# 3.3 头节点，头指针和首元节点\n\n上图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：\n\n 1. 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；\n\n 2. 节点：链表中的节点又细分为头节点,首元节点和其他节点：\n    \n    * 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；\n    * 首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；\n    * 其他节点：链表中其他的节点；\n\n因此，一个存储 {1,2,3} 的完整链表结构如图 5 所示：\n\n\n\n注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。\n\n\n\n# 3.4 链表的创建\n\n创建一个链表需要做如下工作：\n\n 1. 声明一个头指针（如果有必要，可以声明一个头节点）；\n 2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；\n\n例如，创建一个存储 {1,2,3,4} 且无头节点的链表，c 语言实现代码如下：\n\nlink * initlink(){\n    link * p=null;//创建头指针\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\n    //首元节点先初始化\n    temp->elem = 1;\n    temp->next = null;\n    p = temp;//头指针指向首元节点\n    //从第二个节点开始创建\n    for (int i=2; i<5; i++) {\n     //创建一个新节点并初始化\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=null;\n        //将temp节点与新建立的a节点建立逻辑关系\n        temp->next=a;\n        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对\n        temp=temp->next;\n    }\n    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表\n    return p;\n}\n\n\n如果想创建一个存储 {1,2,3,4} 且含头节点的链表，则 c 语言实现代码为：\n\nlink * initlink(){\n    link * p=(link*)malloc(sizeof(link));//创建一个头结点\n    link * temp=p;//声明一个指针指向头结点，\n    //生成链表\n    for (int i=1; i<5; i++) {\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=null;\n        temp->next=a;\n        temp=temp->next;\n    }\n    return p;\n}\n\n\n我们只需在主函数中调用 initlink 函数，即可轻松创建一个存储 {1,2,3,4} 的链表，c 语言完整代码如下：\n\n#include <stdio.h>\n#include <stdlib.h>\n//链表中节点的结构\ntypedef struct link{\n    int  elem;\n    struct link *next;\n}link;\n//初始化链表的函数\nlink * initlink();\n//用于输出链表的函数\nvoid display(link *p);\nint main() {\n    //初始化链表（1，2，3，4）\n    printf("初始化链表为：\\n");\n    link *p=initlink();\n    display(p);\n    return 0;\n}\nlink * initlink(){\n    link * p=null;//创建头指针\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\n    //首元节点先初始化\n    temp->elem = 1;\n    temp->next = null;\n    p = temp;//头指针指向首元节点\n    for (int i=2; i<5; i++) {\n        link *a=(link*)malloc(sizeof(link));\n        a->elem=i;\n        a->next=null;\n        temp->next=a;\n        temp=temp->next;\n    }\n    return p;\n}\nvoid display(link *p){\n    link* temp=p;//将temp指针重新指向头结点\n    //只要temp指针指向的结点的next不是null，就执行输出语句。\n    while (temp) {\n        printf("%d ",temp->elem);\n        temp=temp->next;\n    }\n    printf("\\n");\n}\n\n\n程序运行结果为：\n\n初始化链表为：\n1 2 3 4\n\n\n注意，如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：\n\nvoid display(link *p){\n    link* temp=p;//将temp指针重新指向头结点\n    //只要temp指针指向的结点的next不是null，就执行输出语句。\n    while (temp->next) {\n        temp=temp->next;\n        printf("%d",temp->elem);\n    }\n    printf("\\n");\n}\n\n\n\n# 4.静态链表\n\n\n# 4.1 静态链表的概念\n\n静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。\n\n使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间"一对一"的逻辑关系通过一个整形变量（称为"游标"，和指针功能类似）维持（和链表类似）。\n\n例如，使用静态链表存储 {1,2,3} 的过程如下：\n\n创建一个足够大的数组，假设大小为 6，如图 1 所示：\n\n\n\n接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：\n\n\n\n> 通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。\n\n图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。\n\n类似图 2 这样，通过 "数组+游标" 的方式存储具有线性关系数据的存储结构就是静态链表。\n\n\n# 4.2 静态链表中的节点\n\n静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：\n\n * 数据域：用于存储数据元素的值；\n * 游标：其实就是数组下标，表示直接后继元素所在数组中的位置；\n\n因此，静态链表中节点的构成用 c 语言实现为：\n\ntypedef struct {\n    int data;//数据域\n    int cur;//游标\n}component;\n\n\n\n# 4.3 备用链表\n\n图 2 显示的静态链表还不够完整，静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称为备用链表。\n\n备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间。\n\n> 通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。\n\n静态链表中设置备用链表的好处是，可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用。比如，若静态链表中数组下标为 0 的位置上存有数据，则证明数组已满。\n\n使用静态链表存储 {1,2,3}，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：\n\n\n\n图 3 中，备用链表上连接的依次是 a[0]、a[2] 和 a[4]，而数据链表上连接的依次是 a[1]、a[3] 和 a[5]。\n\n\n# 4.3 静态链表的创建\n\n假设使用静态链表（数组长度为 6）存储 {1,2,3}，则需经历以下几个阶段：\n\n 1. 在数据链表未初始化之前，数组中所有位置都处于空闲状态，因此都应被链接在备用链表上，如图 4 所示：\n\n\n\n当向静态链表中添加数据时，需提前从备用链表中摘除节点，以供新数据使用。\n\n备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 o(1)。\n\n\n 2. 在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：\n\n\n\n 3. 在图 5 的基础上，添加元素 2 的过程如图 6 所示：\n\n\n\n 4. 在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：\n\n\n\n\n# 5.双向链表\n\n\n# 5.1 双向链表的基本概念\n\n无论是动态链表还是静态链表，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为单向链表（或单链表）。\n\n虽然使用单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，而 "从后往前" 找并不是它的强项。\n\n从名字上理解双向链表，即链表是 "双向" 的，如图 1 所示：\n\n\n\n双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要。\n\n从图 1 中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：\n\n 1. 指针域：用于指向当前节点的直接前驱节点；\n 2. 数据域：用于存储数据元素。\n 3. 指针域：用于指向当前节点的直接后继节点；\n\n\n\n因此，双链表的节点结构用 c 语言实现为：\n\ntypedef struct line{\n    struct line * prior; //指向直接前趋\n    int data;\n    struct line * next; //指向直接后继\n}line;\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"队列",frontmatter:{title:"队列",date:"2022-12-19T14:19:23.000Z",permalink:"/pages/3e284b/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E9%98%9F%E5%88%97.html",relativePath:"01.指南/06.数据结构/04.队列.md",key:"v-665fe5c9",path:"/pages/3e284b/",headers:[{level:2,title:"1.什么是队列",slug:"_1-什么是队列",normalizedTitle:"1.什么是队列",charIndex:2},{level:3,title:"1.1 队列的基本概念",slug:"_1-1-队列的基本概念",normalizedTitle:"1.1 队列的基本概念",charIndex:14},{level:2,title:"2.顺序队列",slug:"_2-顺序队列",normalizedTitle:"2.顺序队列",charIndex:579},{level:3,title:"2.1 顺序队列的介绍",slug:"_2-1-顺序队列的介绍",normalizedTitle:"2.1 顺序队列的介绍",charIndex:590},{level:3,title:"2.2 顺序队列简单实现",slug:"_2-2-顺序队列简单实现",normalizedTitle:"2.2 顺序队列简单实现",charIndex:742},{level:3,title:"2.3 顺序队列另一种实现方法",slug:"_2-3-顺序队列另一种实现方法",normalizedTitle:"2.3 顺序队列另一种实现方法",charIndex:2081},{level:2,title:"3.链式队列及基本操作",slug:"_3-链式队列及基本操作",normalizedTitle:"3.链式队列及基本操作",charIndex:3644},{level:3,title:"3.1 链式队列的介绍",slug:"_3-1-链式队列的介绍",normalizedTitle:"3.1 链式队列的介绍",charIndex:3660},{level:3,title:"3.2 链式队列数据入队",slug:"_3-2-链式队列数据入队",normalizedTitle:"3.2 链式队列数据入队",charIndex:4150},{level:3,title:"3.3 链式队列数据出队",slug:"_3-3-链式队列数据出队",normalizedTitle:"3.3 链式队列数据出队",charIndex:4690}],headersStr:"1.什么是队列 1.1 队列的基本概念 2.顺序队列 2.1 顺序队列的介绍 2.2 顺序队列简单实现 2.3 顺序队列另一种实现方法 3.链式队列及基本操作 3.1 链式队列的介绍 3.2 链式队列数据入队 3.3 链式队列数据出队",content:'# 1.什么是队列\n\n\n# 1.1 队列的基本概念\n\n队列，和栈一样，也是一种对数据的"存"和"取"有严格要求的线性存储结构。\n\n与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出，如图 1 所示：\n\n\n\n通常，称进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。\n\n\n不仅如此，队列中数据的进出要遵循 "先进先出" 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 "先进先出" 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。\n\n栈和队列不要混淆，栈结构是一端封口，特点是"先进后出"；而队列的两端全是开口，特点是"先进先出"。\n\n\n因此，数据从表的一端进，从另一端出，且遵循 "先进先出" 原则的线性存储结构就是队列。\n\n队列存储结构的实现有以下两种方式：\n\n 1. 顺序队列：在顺序表的基础上实现的队列结构；\n 2. 链队列：在链表的基础上实现的队列结构；\n\n> 两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。\n\n\n# 2.顺序队列\n\n\n# 2.1 顺序队列的介绍\n\n顺序队列，即采用顺序表模拟实现的队列结构。\n\n我们知道，队列具有以下两个特点：\n\n 1. 数据从队列的一端进，另一端出；\n 2. 数据的入队和出队遵循"先进先出"的原则；\n\n因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。\n\n\n# 2.2 顺序队列简单实现\n\n由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如图 1 所示：\n\n\n\n由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。\n\n在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。\n\n例如，在图 1 基础上将 {1,2,3,4} 用顺序队列存储的实现操作如图 2 所示：\n\n\n\n在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：\n\n\n\n因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：\n\n#include <stdio.h>\nint enQueue(int *a,int rear,int data){\n    a[rear]=data;\n    rear++;\n    return rear;\n}\nvoid deQueue(int *a,int front,int rear){\n    //如果 front==rear，表示队列为空\n    while (front!=rear) {\n        printf("出队元素：%d\\n",a[front]);\n        front++;\n    }\n}\nint main() {\n    int a[100];\n    int front,rear;\n    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址\n    front=rear=0;\n    //入队\n    rear=enQueue(a, rear, 1);\n    rear=enQueue(a, rear, 2);\n    rear=enQueue(a, rear, 3);\n    rear=enQueue(a, rear, 4);\n    //出队\n    deQueue(a, front, rear);\n    return 0;\n}\n\n\n程序输出结果：\n\n出队元素：1\n出队元素：2\n出队元素：3\n出队元素：4\n\n\n此方法存在的问题\n\n先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。\n\n顺序队列整体后移造成的影响是：\n\n * 顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；\n * 如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；\n\n为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。\n\n\n# 2.3 顺序队列另一种实现方法\n\n既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。\n\n为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如图 4 所示：\n\n\n\n图 4 只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：\n\n#include <stdio.h>\n#define max 5//表示顺序表申请的空间大小\nint enQueue(int *a,int front,int rear,int data){\n    //添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满\n    if ((rear+1)%max==front) {\n        printf("空间已满");\n        return rear;\n    }\n    a[rear%max]=data;\n    rear++;\n    return rear;\n}\nint  deQueue(int *a,int front,int rear){\n    //如果front==rear，表示队列为空\n    if(front==rear%max) {\n        printf("队列为空");\n        return front;\n    }\n    printf("%d ",a[front]);\n    //front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]\n    front=(front+1)%max;\n    return front;\n}\nint main() {\n    int a[max];\n    int front,rear;\n    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址\n    front=rear=0;\n    //入队\n    rear=enQueue(a,front,rear, 1);\n    rear=enQueue(a,front,rear, 2);\n    rear=enQueue(a,front,rear, 3);\n    rear=enQueue(a,front,rear, 4);\n    //出队\n    front=deQueue(a, front, rear);\n    //再入队\n    rear=enQueue(a,front,rear, 5);\n    //再出队\n    front=deQueue(a, front, rear);\n    //再入队\n    rear=enQueue(a,front,rear, 6);\n    //再出队\n    front=deQueue(a, front, rear);\n    front=deQueue(a, front, rear);\n    front=deQueue(a, front, rear);\n    front=deQueue(a, front, rear);\n    return 0;\n}\n\n\n程序运行结果：\n\n1 2 3 4 5 6\n\n\n使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：\n\n * 当队列为空时，队列的头指针等于队列的尾指针；\n * 当数组满员时，队列的头指针等于队列的尾指针；\n\n顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。\n\n\n# 3.链式队列及基本操作\n\n\n# 3.1 链式队列的介绍\n\n链式队列，简称"链队列"，即使用链表实现的队列存储结构。\n\n链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如图 1 所示:\n\n\n\n图 1 所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。\n\n在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。\n\n\n由此，我们可以编写出创建链式队列的 C 语言实现代码为:\n\n//链表中的节点结构\ntypedef struct QNode{\n    int data;\n    struct QNode * next;\n}QNode;\n//创建链式队列的函数\nQNode * initQueue(){\n    //创建一个头节点\n    QNode * queue=(QNode*)malloc(sizeof(QNode));\n    //对头节点进行初始化\n    queue->next=NULL;\n    return queue;\n}\n\n\n\n# 3.2 链式队列数据入队\n\n链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：\n\n 1. 将该数据元素用节点包裹，例如新节点名称为 elem；\n 2. 与 rear 指针指向的节点建立逻辑关系，即执行 rear->next=elem；\n 3. 最后移动 rear 指针指向该新节点，即 rear=elem；\n\n由此，新节点就入队成功了。\n\n例如，在图 1 的基础上，我们依次将 {1,2,3} 依次入队，各个数据元素入队的过程如图 2 所示:\n\n\n\n数据元素入链式队列的 C 语言实现代码为：\n\nQNode* enQueue(QNode * rear,int data){\n    //1、用节点包裹入队元素\n    QNode * enElem=(QNode*)malloc(sizeof(QNode));\n    enElem->data=data;\n    enElem->next=NULL;\n    //2、新节点与rear节点建立逻辑关系\n    rear->next=enElem;\n    //3、rear指向新节点\n    rear=enElem;\n    //返回新的rear，为后续新元素入队做准备\n    return rear;\n}\n\n\n\n# 3.3 链式队列数据出队\n\n当链式队列中，有数据元素需要出队时，按照 "先进先出" 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。\n\n链式队列中队头元素出队，需要做以下 3 步操作：\n\n 1. 通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；\n 2. 将 p 节点（即要出队的队头节点）从链表中摘除；\n 3. 释放节点 p，回收其所占的内存空间；\n\n例如，在图 2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如图 3 所示：\n\n\n\n链式队列中队头元素出队的 C 语言实现代码为：\n\nvoid DeQueue(QNode * top,QNode * rear){\n    if (top->next==NULL) {\n        printf("队列为空");\n        return ;\n    }\n    // 1、\n    QNode * p=top->next;\n    printf("%d",p->data);\n    top->next=p->next;\n    if (rear==p) {\n        rear=top;\n    }\n    free(p);\n}\n\n\n注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。',normalizedContent:'# 1.什么是队列\n\n\n# 1.1 队列的基本概念\n\n队列，和栈一样，也是一种对数据的"存"和"取"有严格要求的线性存储结构。\n\n与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出，如图 1 所示：\n\n\n\n通常，称进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。\n\n\n不仅如此，队列中数据的进出要遵循 "先进先出" 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 "先进先出" 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。\n\n栈和队列不要混淆，栈结构是一端封口，特点是"先进后出"；而队列的两端全是开口，特点是"先进先出"。\n\n\n因此，数据从表的一端进，从另一端出，且遵循 "先进先出" 原则的线性存储结构就是队列。\n\n队列存储结构的实现有以下两种方式：\n\n 1. 顺序队列：在顺序表的基础上实现的队列结构；\n 2. 链队列：在链表的基础上实现的队列结构；\n\n> 两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。\n\n\n# 2.顺序队列\n\n\n# 2.1 顺序队列的介绍\n\n顺序队列，即采用顺序表模拟实现的队列结构。\n\n我们知道，队列具有以下两个特点：\n\n 1. 数据从队列的一端进，另一端出；\n 2. 数据的入队和出队遵循"先进先出"的原则；\n\n因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。\n\n\n# 2.2 顺序队列简单实现\n\n由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如图 1 所示：\n\n\n\n由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。\n\n在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。\n\n例如，在图 1 基础上将 {1,2,3,4} 用顺序队列存储的实现操作如图 2 所示：\n\n\n\n在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：\n\n\n\n因此，使用顺序表实现顺序队列最简单方法的 c 语言实现代码为：\n\n#include <stdio.h>\nint enqueue(int *a,int rear,int data){\n    a[rear]=data;\n    rear++;\n    return rear;\n}\nvoid dequeue(int *a,int front,int rear){\n    //如果 front==rear，表示队列为空\n    while (front!=rear) {\n        printf("出队元素：%d\\n",a[front]);\n        front++;\n    }\n}\nint main() {\n    int a[100];\n    int front,rear;\n    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址\n    front=rear=0;\n    //入队\n    rear=enqueue(a, rear, 1);\n    rear=enqueue(a, rear, 2);\n    rear=enqueue(a, rear, 3);\n    rear=enqueue(a, rear, 4);\n    //出队\n    dequeue(a, front, rear);\n    return 0;\n}\n\n\n程序输出结果：\n\n出队元素：1\n出队元素：2\n出队元素：3\n出队元素：4\n\n\n此方法存在的问题\n\n先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。\n\n顺序队列整体后移造成的影响是：\n\n * 顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；\n * 如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；\n\n为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。\n\n\n# 2.3 顺序队列另一种实现方法\n\n既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。\n\n为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如图 4 所示：\n\n\n\n图 4 只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：\n\n#include <stdio.h>\n#define max 5//表示顺序表申请的空间大小\nint enqueue(int *a,int front,int rear,int data){\n    //添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满\n    if ((rear+1)%max==front) {\n        printf("空间已满");\n        return rear;\n    }\n    a[rear%max]=data;\n    rear++;\n    return rear;\n}\nint  dequeue(int *a,int front,int rear){\n    //如果front==rear，表示队列为空\n    if(front==rear%max) {\n        printf("队列为空");\n        return front;\n    }\n    printf("%d ",a[front]);\n    //front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]\n    front=(front+1)%max;\n    return front;\n}\nint main() {\n    int a[max];\n    int front,rear;\n    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址\n    front=rear=0;\n    //入队\n    rear=enqueue(a,front,rear, 1);\n    rear=enqueue(a,front,rear, 2);\n    rear=enqueue(a,front,rear, 3);\n    rear=enqueue(a,front,rear, 4);\n    //出队\n    front=dequeue(a, front, rear);\n    //再入队\n    rear=enqueue(a,front,rear, 5);\n    //再出队\n    front=dequeue(a, front, rear);\n    //再入队\n    rear=enqueue(a,front,rear, 6);\n    //再出队\n    front=dequeue(a, front, rear);\n    front=dequeue(a, front, rear);\n    front=dequeue(a, front, rear);\n    front=dequeue(a, front, rear);\n    return 0;\n}\n\n\n程序运行结果：\n\n1 2 3 4 5 6\n\n\n使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：\n\n * 当队列为空时，队列的头指针等于队列的尾指针；\n * 当数组满员时，队列的头指针等于队列的尾指针；\n\n顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。\n\n\n# 3.链式队列及基本操作\n\n\n# 3.1 链式队列的介绍\n\n链式队列，简称"链队列"，即使用链表实现的队列存储结构。\n\n链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如图 1 所示:\n\n\n\n图 1 所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。\n\n在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。\n\n\n由此，我们可以编写出创建链式队列的 c 语言实现代码为:\n\n//链表中的节点结构\ntypedef struct qnode{\n    int data;\n    struct qnode * next;\n}qnode;\n//创建链式队列的函数\nqnode * initqueue(){\n    //创建一个头节点\n    qnode * queue=(qnode*)malloc(sizeof(qnode));\n    //对头节点进行初始化\n    queue->next=null;\n    return queue;\n}\n\n\n\n# 3.2 链式队列数据入队\n\n链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：\n\n 1. 将该数据元素用节点包裹，例如新节点名称为 elem；\n 2. 与 rear 指针指向的节点建立逻辑关系，即执行 rear->next=elem；\n 3. 最后移动 rear 指针指向该新节点，即 rear=elem；\n\n由此，新节点就入队成功了。\n\n例如，在图 1 的基础上，我们依次将 {1,2,3} 依次入队，各个数据元素入队的过程如图 2 所示:\n\n\n\n数据元素入链式队列的 c 语言实现代码为：\n\nqnode* enqueue(qnode * rear,int data){\n    //1、用节点包裹入队元素\n    qnode * enelem=(qnode*)malloc(sizeof(qnode));\n    enelem->data=data;\n    enelem->next=null;\n    //2、新节点与rear节点建立逻辑关系\n    rear->next=enelem;\n    //3、rear指向新节点\n    rear=enelem;\n    //返回新的rear，为后续新元素入队做准备\n    return rear;\n}\n\n\n\n# 3.3 链式队列数据出队\n\n当链式队列中，有数据元素需要出队时，按照 "先进先出" 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。\n\n链式队列中队头元素出队，需要做以下 3 步操作：\n\n 1. 通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；\n 2. 将 p 节点（即要出队的队头节点）从链表中摘除；\n 3. 释放节点 p，回收其所占的内存空间；\n\n例如，在图 2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如图 3 所示：\n\n\n\n链式队列中队头元素出队的 c 语言实现代码为：\n\nvoid dequeue(qnode * top,qnode * rear){\n    if (top->next==null) {\n        printf("队列为空");\n        return ;\n    }\n    // 1、\n    qnode * p=top->next;\n    printf("%d",p->data);\n    top->next=p->next;\n    if (rear==p) {\n        rear=top;\n    }\n    free(p);\n}\n\n\n注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"树的定义",frontmatter:{title:"树的定义",date:"2022-12-19T14:31:36.000Z",permalink:"/pages/925cd5/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"01.指南/06.数据结构/05.树的定义.md",key:"v-3c3508ee",path:"/pages/925cd5/",headers:[{level:2,title:"1.树的定义",slug:"_1-树的定义",normalizedTitle:"1.树的定义",charIndex:2},{level:3,title:"1.1 树的特征",slug:"_1-1-树的特征",normalizedTitle:"1.1 树的特征",charIndex:13},{level:3,title:"1.2 树的基本术语",slug:"_1-2-树的基本术语",normalizedTitle:"1.2 树的基本术语",charIndex:255},{level:3,title:"1.3 树的表示",slug:"_1-3-树的表示",normalizedTitle:"1.3 树的表示",charIndex:717},{level:2,title:"2.二叉树",slug:"_2-二叉树",normalizedTitle:"2.二叉树",charIndex:804},{level:3,title:"2.1 二叉树的概述",slug:"_2-1-二叉树的概述",normalizedTitle:"2.1 二叉树的概述",charIndex:814},{level:3,title:"2.2 二叉树的定义",slug:"_2-2-二叉树的定义",normalizedTitle:"2.2 二叉树的定义",charIndex:1129},{level:3,title:"2.3 二叉树的五种形态",slug:"_2-3-二叉树的五种形态",normalizedTitle:"2.3 二叉树的五种形态",charIndex:1250},{level:3,title:"2.3 二叉树的特殊形态",slug:"_2-3-二叉树的特殊形态",normalizedTitle:"2.3 二叉树的特殊形态",charIndex:1269},{level:3,title:"2.4 二叉树的性质",slug:"_2-4-二叉树的性质",normalizedTitle:"2.4 二叉树的性质",charIndex:1441},{level:3,title:"2.5 抽象的数据类型定义",slug:"_2-5-抽象的数据类型定义",normalizedTitle:"2.5 抽象的数据类型定义",charIndex:1462},{level:3,title:"2.6 顺序存储结构",slug:"_2-6-顺序存储结构",normalizedTitle:"2.6 顺序存储结构",charIndex:1925},{level:3,title:"2.7 链表存储",slug:"_2-7-链表存储",normalizedTitle:"2.7 链表存储",charIndex:2112}],headersStr:"1.树的定义 1.1 树的特征 1.2 树的基本术语 1.3 树的表示 2.二叉树 2.1 二叉树的概述 2.2 二叉树的定义 2.3 二叉树的五种形态 2.3 二叉树的特殊形态 2.4 二叉树的性质 2.5 抽象的数据类型定义 2.6 顺序存储结构 2.7 链表存储",content:'# 1.树的定义\n\n\n# 1.1 树的特征\n\n树（Tree）：n（n≥0）个结点构成的有限集合,当 n=0 时，称为空树\n\n对于任一棵非空树（n＞0），它具备以下特征：\n\n * 树中有个称为“根（Root）”的特殊结点，用 r 表示\n * 其余结点可分为 m(m>0) 个互不相交的有限集 T1 , T2 ,…, Tm ,其中每个集合本身又是一棵树，称为原来树的"子树（SubTree）"\n * 子树是不相交的\n * 除根结点外，每个结点有且仅有一个父结点\n * 一棵 N 个结点的树有 N-1 条边\n\n\n# 1.2 树的基本术语\n\n * 结点的度（Degree） ：结点的子树个数\n * 树的度 ：树的所有结点中最大的度数\n * 叶结点（Leaf） ：度为 0 的结点\n * 父结点（Parent） ：有子树的结点是其子树的根结点的父结点\n * 子结点（Child） ：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子结点，也称孩子结点\n * 兄弟结点（Sibling） ：具有同一父结点的各个结点彼此是兄弟结点\n * 路径 ：从结点 n1 到 nk 的路径为一个结点序列,n1,n2,…,nk，ni是 ni+1的父结点\n * 路径长度 ：路径所包含边的个数\n * 祖先结点（Ancestor） ：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点\n * 子孙结点（Descendant） ：某一结点的子树中的所有结点是这个结点的子孙\n * 结点的层次（Level） ：规定根结点在 1 层，其他任一结点的层数是其父结点的层数加一\n * 树的深度（Depth） ：树中所有结点中的最大层次是这棵树的深度\n\n\n# 1.3 树的表示\n\n儿子-兄弟表示法\n\n\n\n * Element 存值\n * FirstChild 指向第一个儿子\n * NextSibling 指向下一个兄弟\n\n\n\n\n# 2.二叉树\n\n\n# 2.1 二叉树的概述\n\n二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分 。\n\n二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。\n\n即度为 2 的树\n\n\n\n * Element 存值\n * Left 指向左子树\n * Right 指向右子树\n\n\n# 2.2 二叉树的定义\n\n 1. 二叉树 T：一个有穷的结点集合\n\n 2. 这个集合可以为空\n\n 3. 若不为空，则它是由根结点和称为其左子树TL 和右子树TR\n\n 4. 的两个不相交的二叉树组成\n\n 5. 二叉树的子树有左右顺序之分\n\n\n# 2.3 二叉树的五种形态\n\n\n\n\n# 2.3 二叉树的特殊形态\n\n斜二叉树,\n\n * 有左儿子或只有右儿子\n\n\n\n完美二叉树（满二叉树）\n\n * 除最后一层叶结点外，每个结点都有两个子结点\n\n\n\n完全二叉树\n\n * 有 n 个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号\n * 编号为 i（1 ≤ i ≤ n）结点与满二叉树中编号为 i 结点在二叉树中位置相同\n\n\n# 2.4 二叉树的性质\n\n\n\n\n\n\n\n\n# 2.5 抽象的数据类型定义\n\n * 类型名称：二叉树\n * 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成\n * 操作集：BT ∈ BinTree，Item ∈ ElementType\n\n主要操作有：\n\n * Boolean IsEmpty(BinTree BT)：判别 BT 是否为空\n * void Traversal(BinTree BT)：遍历，按某顺序访问每个结点\n * BinTree CreatBinTree()：创建一个二叉树\n\n常用的遍历方法有：\n\n * void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树\n * void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树\n * void PostOrderTraversal(BinTree BT)：后序——左子树、右子树、根\n * void LevelOrderTraversal(BinTree BT)：层次遍历，从上到下、从左到右\n\n\n# 2.6 顺序存储结构\n\n按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：\n\n * 非根结点（序号 i > 1）的父结点的序号是 ⌊i/2⌋（向下取整）\n * 结点（序号为 i）的左孩子结点的序号是 2i（若 2 i ≤ n，否则没有左孩子\n * 结点（序号为 i）的右孩子结点的序号是 2i+1（若 2 i +1 ≤ n，否则没有右孩子\n\n\n\n\n\n\n# 2.7 链表存储\n\ntypedef struct TreeNode *BinTree;\nstruct TreeNode{\n\tElement Data;  // 存值 \n\tBinTree Left;    // 左儿子结点 \n\tBinTree Right;   // 右儿子结点 \n};\n',normalizedContent:'# 1.树的定义\n\n\n# 1.1 树的特征\n\n树（tree）：n（n≥0）个结点构成的有限集合,当 n=0 时，称为空树\n\n对于任一棵非空树（n＞0），它具备以下特征：\n\n * 树中有个称为“根（root）”的特殊结点，用 r 表示\n * 其余结点可分为 m(m>0) 个互不相交的有限集 t1 , t2 ,…, tm ,其中每个集合本身又是一棵树，称为原来树的"子树（subtree）"\n * 子树是不相交的\n * 除根结点外，每个结点有且仅有一个父结点\n * 一棵 n 个结点的树有 n-1 条边\n\n\n# 1.2 树的基本术语\n\n * 结点的度（degree） ：结点的子树个数\n * 树的度 ：树的所有结点中最大的度数\n * 叶结点（leaf） ：度为 0 的结点\n * 父结点（parent） ：有子树的结点是其子树的根结点的父结点\n * 子结点（child） ：若 a 结点是 b 结点的父结点，则称 b 结点是 a 结点的子结点，也称孩子结点\n * 兄弟结点（sibling） ：具有同一父结点的各个结点彼此是兄弟结点\n * 路径 ：从结点 n1 到 nk 的路径为一个结点序列,n1,n2,…,nk，ni是 ni+1的父结点\n * 路径长度 ：路径所包含边的个数\n * 祖先结点（ancestor） ：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点\n * 子孙结点（descendant） ：某一结点的子树中的所有结点是这个结点的子孙\n * 结点的层次（level） ：规定根结点在 1 层，其他任一结点的层数是其父结点的层数加一\n * 树的深度（depth） ：树中所有结点中的最大层次是这棵树的深度\n\n\n# 1.3 树的表示\n\n儿子-兄弟表示法\n\n\n\n * element 存值\n * firstchild 指向第一个儿子\n * nextsibling 指向下一个兄弟\n\n\n\n\n# 2.二叉树\n\n\n# 2.1 二叉树的概述\n\n二叉树（binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分 。\n\n二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。\n\n即度为 2 的树\n\n\n\n * element 存值\n * left 指向左子树\n * right 指向右子树\n\n\n# 2.2 二叉树的定义\n\n 1. 二叉树 t：一个有穷的结点集合\n\n 2. 这个集合可以为空\n\n 3. 若不为空，则它是由根结点和称为其左子树tl 和右子树tr\n\n 4. 的两个不相交的二叉树组成\n\n 5. 二叉树的子树有左右顺序之分\n\n\n# 2.3 二叉树的五种形态\n\n\n\n\n# 2.3 二叉树的特殊形态\n\n斜二叉树,\n\n * 有左儿子或只有右儿子\n\n\n\n完美二叉树（满二叉树）\n\n * 除最后一层叶结点外，每个结点都有两个子结点\n\n\n\n完全二叉树\n\n * 有 n 个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号\n * 编号为 i（1 ≤ i ≤ n）结点与满二叉树中编号为 i 结点在二叉树中位置相同\n\n\n# 2.4 二叉树的性质\n\n\n\n\n\n\n\n\n# 2.5 抽象的数据类型定义\n\n * 类型名称：二叉树\n * 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成\n * 操作集：bt ∈ bintree，item ∈ elementtype\n\n主要操作有：\n\n * boolean isempty(bintree bt)：判别 bt 是否为空\n * void traversal(bintree bt)：遍历，按某顺序访问每个结点\n * bintree creatbintree()：创建一个二叉树\n\n常用的遍历方法有：\n\n * void preordertraversal(bintree bt)：先序——根、左子树、右子树\n * void inordertraversal(bintree bt)：中序——左子树、根、右子树\n * void postordertraversal(bintree bt)：后序——左子树、右子树、根\n * void levelordertraversal(bintree bt)：层次遍历，从上到下、从左到右\n\n\n# 2.6 顺序存储结构\n\n按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：\n\n * 非根结点（序号 i > 1）的父结点的序号是 ⌊i/2⌋（向下取整）\n * 结点（序号为 i）的左孩子结点的序号是 2i（若 2 i ≤ n，否则没有左孩子\n * 结点（序号为 i）的右孩子结点的序号是 2i+1（若 2 i +1 ≤ n，否则没有右孩子\n\n\n\n\n\n\n# 2.7 链表存储\n\ntypedef struct treenode *bintree;\nstruct treenode{\n\telement data;  // 存值 \n\tbintree left;    // 左儿子结点 \n\tbintree right;   // 右儿子结点 \n};\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"二叉查找树",frontmatter:{title:"二叉查找树",date:"2022-12-19T16:24:59.000Z",permalink:"/pages/a7d8d3/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",relativePath:"01.指南/06.数据结构/07.二叉查找树.md",key:"v-0185fa5e",path:"/pages/a7d8d3/",headers:[{level:2,title:"1.二叉查找树",slug:"_1-二叉查找树",normalizedTitle:"1.二叉查找树",charIndex:2},{level:3,title:"1.1 二叉查找树的定义",slug:"_1-1-二叉查找树的定义",normalizedTitle:"1.1 二叉查找树的定义",charIndex:14},{level:3,title:"1.2 特殊函数",slug:"_1-2-特殊函数",normalizedTitle:"1.2 特殊函数",charIndex:221},{level:3,title:"1.3 二叉查找树创建",slug:"_1-3-二叉查找树创建",normalizedTitle:"1.3 二叉查找树创建",charIndex:545},{level:2,title:"2.二叉查找树实现",slug:"_2-二叉查找树实现",normalizedTitle:"2.二叉查找树实现",charIndex:927},{level:3,title:"2.1 插入方法(put)实现思想",slug:"_2-1-插入方法-put-实现思想",normalizedTitle:"2.1 插入方法(put)实现思想",charIndex:941},{level:3,title:"2.4 查询(get)实现思想",slug:"_2-4-查询-get-实现思想",normalizedTitle:"2.4 查询(get)实现思想",charIndex:1156},{level:3,title:"2.5 删除方法(delete)实现思想",slug:"_2-5-删除方法-delete-实现思想",normalizedTitle:"2.5 删除方法(delete)实现思想",charIndex:1423}],headersStr:"1.二叉查找树 1.1 二叉查找树的定义 1.2 特殊函数 1.3 二叉查找树创建 2.二叉查找树实现 2.1 插入方法(put)实现思想 2.4 查询(get)实现思想 2.5 删除方法(delete)实现思想",content:'# 1.二叉查找树\n\n\n# 1.1 二叉查找树的定义\n\n若一个结点的左子树不为空，则它左子树上所有的结点都小于该结点；若一个结点的右子树的不为空，则它右子树上所有的结点都大于该结点.\n\n二叉搜索树（BST）也称二叉排序树或二叉查找树\n\n二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：\n\n 1. 非空左子树的所有键值小于其根结点的键值\n 2. 非空右子树的所有键值大于其根结点的键值\n 3. 左、右子树都是二叉搜索树\n\n\n\n\n# 1.2 特殊函数\n\n * BinTree Find(ElementType X,BinTree BST)：从二叉搜索树 BST 中查找元素 X，返回其所在结点地址\n * BinTree FindMin(BinTree BST)：从二叉搜索树 BST 中查找并返回最小元素所在结点的地址\n * BinTree FindMax(BinTree BST)：从二叉搜索树 BST 中查找并返回最大元素所在结点的地址\n * BinTree Insert(ElementType X,BinTree BST)：插入一个元素进 BST\n * BinTree Delete(ElementType X,BinTree BST)：从 BST 中删除一个元素\n\n\n# 1.3 二叉查找树创建\n\npublic class Node{\n        public Key key;//存储键\n        private Value value;//存储值\n        \n        public Node left;//记录左子结点\n        \n        public Node right;//记录右子结点\n        \n        public Node(Key key,Value value,Node left,Node right) {\n        \tthis.key = key;\n        \tthis.value = value;\n        \tthis.left = left;\n        \tthis.right = right;\n        }\n}\n\n\n\n# 2.二叉查找树实现\n\n\n# 2.1 插入方法(put)实现思想\n\n 1. 如果当前书中没有任何一个结点，则直接把新节点当做根节点使用\n 2. 如果当前树不为空，则从根节点开始：\n 3. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点\n 4. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点\n 5. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值\n\n流程图如下：\n\n\n\n\n# 2.4 查询(get)实现思想\n\n * 查找从根结点开始，如果树为空，返回 NULL\n * 若搜索树不为空，则根结点键值和想要查找的key进行比较，并进行不同处理：\n   1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点\n   2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点\n   3. 如果要查询的key等于当前结点的key，则返回当前结点的value\n\n查找最大和最小元素\n\n * 最大元素一定是在树的最右分支的端结点上\n * 最小元素一定是在树的最左分支的端结点上\n\n\n\n\n# 2.5 删除方法(delete)实现思想\n\n 1. 找到被删除结点\n 2. 找到被删除结点右子树的最小结点minNode\n 3. 删除右子树中的最小结点\n 4. 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树\n 5. 让被删除结点的父节点指向最小结点minNode\n\n\n\n完整代码实现:\n\n \n \n//二叉树代码\nclass BinaryTree<Key extends Comparable<Key>, Value> {\n  //记录根结点\n  private Node root;\n  //记录树中元素的个数\n  private int N;\n  //获取树中元素的个数\n  public int size() {\n      return N;\n  }\n  //向树中添加元素key-value\n  public void put(Key key, Value value) {\n      root = put(root, key, value);\n  }\n  //向指定的树x中添加key-value,并返回添加元素后新的树\n  private Node put(Node x, Key key, Value value) {\n      if (x == null) {\n          //个数+1\n          N++;\n          return new Node(key, value, null, null);\n      }\n      int cmp = key.compareTo(x.key);\n      if (cmp > 0) {\n          //新结点的key大于当前结点的key，继续找当前结点的右子结点\n          x.right = put(x.right, key, value);\n      } else if (cmp < 0) {\n          //新结点的key小于当前结点的key，继续找当前结点的左子结点\n          x.left = put(x.left, key, value);\n      } else {\n          //新结点的key等于当前结点的key，把当前结点的value进行替换\n          x.value = value;\n      }\n      return x;\n  }\n  //查询树中指定key对应的value\n  public Value get(Key key) {\n      return get(root, key);\n  }\n  //从指定的树x中，查找key对应的值\n  public Value get(Node x, Key key) {\n      if (x == null) {\n          return null;\n      }\n      int cmp = key.compareTo(x.key);\n      if (cmp > 0) {\n          //如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；\n          return get(x.right, key);\n      } else if (cmp < 0) {\n          //如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；\n          return get(x.left, key);\n      } else {\n          //如果要查询的key等于当前结点的key，则树中返回当前结点的value。\n          return x.value;\n      }\n  }\n  //删除树中key对应的value\n  public void delete(Key key) {\n      root = delete(root, key);\n  }\n  //删除指定树x中的key对应的value，并返回删除后的新树\n  public Node delete(Node x, Key key) {\n      if (x == null) {\n          return null;\n      }\n      int cmp = key.compareTo(x.key);\n      if (cmp > 0) {\n          //新结点的key大于当前结点的key，继续找当前结点的右子结点\n          x.right = delete(x.right, key);\n      } else if (cmp < 0) {\n          //新结点的key小于当前结点的key，继续找当前结点的左子结点\n          x.left = delete(x.left, key);\n      } else {\n          //新结点的key等于当前结点的key,当前x就是要删除的结点\n          //1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点\n          if (x.right == null) {\n              return x.left;\n          }\n          //2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点\n          if (x.left == null) {\n              return x.right;\n          }\n          //3.当前结点的左右子树都存在\n          //3.1找到右子树中最小的结点\n          Node minNode = x.right;\n          while (minNode.left != null) {\n              minNode = minNode.left;\n          }\n          //3.2删除右子树中最小的结点\n          Node n = x.right;\n          while (n.left != null) {\n              if (n.left.left == null) {\n                  n.left = null;\n              } else {\n                  n = n.left;\n              }\n          }\n          //3.3让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树\n          minNode.left = x.left;\n          minNode.right = x.right;\n          //3.4让被删除结点的父节点指向最小结点minNode\n          x = minNode;\n          //个数-1\n          N--;\n      }\n      return x;\n  }\n  private class Node {\n      //存储键\n      public Key key;\n      //存储值\n      private Value value;\n      //记录左子结点\n      public Node left;\n      //记录右子结点\n      public Node right;\n      public Node(Key key, Value value, Node left, Node right) {\n          this.key = key;\n          this.value = value;\n          this.left = left;\n          this.right = right;\n      }\n  }\n}\n//测试代码\npublic class Test {\n  public static void main(String[] args) throws Exception {\n      BinaryTree<Integer, String> bt = new BinaryTree<>();\n      bt.put(4, "二哈");\n      bt.put(1, "张三");\n      bt.put(3, "李四");\n      bt.put(5, "王五");\n      System.out.println(bt.size());\n      bt.put(1,"老三");\n      System.out.println(bt.get(4));\n      bt.put(2, "小屋");\n      System.out.println(bt.size());\n      bt.delete(2);\n      System.out.println(bt.size());\n  }\n}\n',normalizedContent:'# 1.二叉查找树\n\n\n# 1.1 二叉查找树的定义\n\n若一个结点的左子树不为空，则它左子树上所有的结点都小于该结点；若一个结点的右子树的不为空，则它右子树上所有的结点都大于该结点.\n\n二叉搜索树（bst）也称二叉排序树或二叉查找树\n\n二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：\n\n 1. 非空左子树的所有键值小于其根结点的键值\n 2. 非空右子树的所有键值大于其根结点的键值\n 3. 左、右子树都是二叉搜索树\n\n\n\n\n# 1.2 特殊函数\n\n * bintree find(elementtype x,bintree bst)：从二叉搜索树 bst 中查找元素 x，返回其所在结点地址\n * bintree findmin(bintree bst)：从二叉搜索树 bst 中查找并返回最小元素所在结点的地址\n * bintree findmax(bintree bst)：从二叉搜索树 bst 中查找并返回最大元素所在结点的地址\n * bintree insert(elementtype x,bintree bst)：插入一个元素进 bst\n * bintree delete(elementtype x,bintree bst)：从 bst 中删除一个元素\n\n\n# 1.3 二叉查找树创建\n\npublic class node{\n        public key key;//存储键\n        private value value;//存储值\n        \n        public node left;//记录左子结点\n        \n        public node right;//记录右子结点\n        \n        public node(key key,value value,node left,node right) {\n        \tthis.key = key;\n        \tthis.value = value;\n        \tthis.left = left;\n        \tthis.right = right;\n        }\n}\n\n\n\n# 2.二叉查找树实现\n\n\n# 2.1 插入方法(put)实现思想\n\n 1. 如果当前书中没有任何一个结点，则直接把新节点当做根节点使用\n 2. 如果当前树不为空，则从根节点开始：\n 3. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点\n 4. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点\n 5. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值\n\n流程图如下：\n\n\n\n\n# 2.4 查询(get)实现思想\n\n * 查找从根结点开始，如果树为空，返回 null\n * 若搜索树不为空，则根结点键值和想要查找的key进行比较，并进行不同处理：\n   1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点\n   2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点\n   3. 如果要查询的key等于当前结点的key，则返回当前结点的value\n\n查找最大和最小元素\n\n * 最大元素一定是在树的最右分支的端结点上\n * 最小元素一定是在树的最左分支的端结点上\n\n\n\n\n# 2.5 删除方法(delete)实现思想\n\n 1. 找到被删除结点\n 2. 找到被删除结点右子树的最小结点minnode\n 3. 删除右子树中的最小结点\n 4. 让被删除结点的左子树称为最小结点minnode的左子树，让被删除结点的右子树称为最小结点minnode的右子树\n 5. 让被删除结点的父节点指向最小结点minnode\n\n\n\n完整代码实现:\n\n \n \n//二叉树代码\nclass binarytree<key extends comparable<key>, value> {\n  //记录根结点\n  private node root;\n  //记录树中元素的个数\n  private int n;\n  //获取树中元素的个数\n  public int size() {\n      return n;\n  }\n  //向树中添加元素key-value\n  public void put(key key, value value) {\n      root = put(root, key, value);\n  }\n  //向指定的树x中添加key-value,并返回添加元素后新的树\n  private node put(node x, key key, value value) {\n      if (x == null) {\n          //个数+1\n          n++;\n          return new node(key, value, null, null);\n      }\n      int cmp = key.compareto(x.key);\n      if (cmp > 0) {\n          //新结点的key大于当前结点的key，继续找当前结点的右子结点\n          x.right = put(x.right, key, value);\n      } else if (cmp < 0) {\n          //新结点的key小于当前结点的key，继续找当前结点的左子结点\n          x.left = put(x.left, key, value);\n      } else {\n          //新结点的key等于当前结点的key，把当前结点的value进行替换\n          x.value = value;\n      }\n      return x;\n  }\n  //查询树中指定key对应的value\n  public value get(key key) {\n      return get(root, key);\n  }\n  //从指定的树x中，查找key对应的值\n  public value get(node x, key key) {\n      if (x == null) {\n          return null;\n      }\n      int cmp = key.compareto(x.key);\n      if (cmp > 0) {\n          //如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；\n          return get(x.right, key);\n      } else if (cmp < 0) {\n          //如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；\n          return get(x.left, key);\n      } else {\n          //如果要查询的key等于当前结点的key，则树中返回当前结点的value。\n          return x.value;\n      }\n  }\n  //删除树中key对应的value\n  public void delete(key key) {\n      root = delete(root, key);\n  }\n  //删除指定树x中的key对应的value，并返回删除后的新树\n  public node delete(node x, key key) {\n      if (x == null) {\n          return null;\n      }\n      int cmp = key.compareto(x.key);\n      if (cmp > 0) {\n          //新结点的key大于当前结点的key，继续找当前结点的右子结点\n          x.right = delete(x.right, key);\n      } else if (cmp < 0) {\n          //新结点的key小于当前结点的key，继续找当前结点的左子结点\n          x.left = delete(x.left, key);\n      } else {\n          //新结点的key等于当前结点的key,当前x就是要删除的结点\n          //1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点\n          if (x.right == null) {\n              return x.left;\n          }\n          //2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点\n          if (x.left == null) {\n              return x.right;\n          }\n          //3.当前结点的左右子树都存在\n          //3.1找到右子树中最小的结点\n          node minnode = x.right;\n          while (minnode.left != null) {\n              minnode = minnode.left;\n          }\n          //3.2删除右子树中最小的结点\n          node n = x.right;\n          while (n.left != null) {\n              if (n.left.left == null) {\n                  n.left = null;\n              } else {\n                  n = n.left;\n              }\n          }\n          //3.3让被删除结点的左子树称为最小结点minnode的左子树，让被删除结点的右子树称为最小结点minnode的右子树\n          minnode.left = x.left;\n          minnode.right = x.right;\n          //3.4让被删除结点的父节点指向最小结点minnode\n          x = minnode;\n          //个数-1\n          n--;\n      }\n      return x;\n  }\n  private class node {\n      //存储键\n      public key key;\n      //存储值\n      private value value;\n      //记录左子结点\n      public node left;\n      //记录右子结点\n      public node right;\n      public node(key key, value value, node left, node right) {\n          this.key = key;\n          this.value = value;\n          this.left = left;\n          this.right = right;\n      }\n  }\n}\n//测试代码\npublic class test {\n  public static void main(string[] args) throws exception {\n      binarytree<integer, string> bt = new binarytree<>();\n      bt.put(4, "二哈");\n      bt.put(1, "张三");\n      bt.put(3, "李四");\n      bt.put(5, "王五");\n      system.out.println(bt.size());\n      bt.put(1,"老三");\n      system.out.println(bt.get(4));\n      bt.put(2, "小屋");\n      system.out.println(bt.size());\n      bt.delete(2);\n      system.out.println(bt.size());\n  }\n}\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"二叉树的遍历",frontmatter:{title:"二叉树的遍历",date:"2022-12-19T16:17:25.000Z",permalink:"/pages/75c23c/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html",relativePath:"01.指南/06.数据结构/06.二叉树的遍历.md",key:"v-86be2110",path:"/pages/75c23c/",headers:[{level:2,title:"二叉树的遍历",slug:"二叉树的遍历",normalizedTitle:"二叉树的遍历",charIndex:2},{level:3,title:"1.先序遍历",slug:"_1-先序遍历",normalizedTitle:"1.先序遍历",charIndex:13},{level:4,title:"1. 1 递归实现",slug:"_1-1-递归实现",normalizedTitle:"1. 1 递归实现",charIndex:69},{level:4,title:"1.2 非递归实现",slug:"_1-2-非递归实现",normalizedTitle:"1.2 非递归实现",charIndex:254},{level:3,title:"2.中序遍历",slug:"_2-中序遍历",normalizedTitle:"2.中序遍历",charIndex:625},{level:4,title:"2.1 递归实现",slug:"_2-1-递归实现",normalizedTitle:"2.1 递归实现",charIndex:681},{level:4,title:"2.2 非递归实现",slug:"_2-2-非递归实现",normalizedTitle:"2.2 非递归实现",charIndex:862},{level:3,title:"3. 后序遍历",slug:"_3-后序遍历",normalizedTitle:"3. 后序遍历",charIndex:1212},{level:4,title:"3.1. 递归实现",slug:"_3-1-递归实现",normalizedTitle:"3.1. 递归实现",charIndex:1269},{level:4,title:"3.2 非递归实现",slug:"_3-2-非递归实现",normalizedTitle:"3.2 非递归实现",charIndex:1458},{level:3,title:"4. 层序遍历",slug:"_4-层序遍历",normalizedTitle:"4. 层序遍历",charIndex:2018}],headersStr:"二叉树的遍历 1.先序遍历 1. 1 递归实现 1.2 非递归实现 2.中序遍历 2.1 递归实现 2.2 非递归实现 3. 后序遍历 3.1. 递归实现 3.2 非递归实现 4. 层序遍历",content:'# 二叉树的遍历\n\n\n# 1.先序遍历\n\n遍历过程：\n\n 1. 访问根结点\n 2. 先序遍历其左子树\n 3. 先序遍历其右子树\n\n\n\n# 1. 1 递归实现\n\nvoid  PreOrderTraversal(BinTree BT){\n\tif(BT){\n\t\tprintf("%d",BT->Data);  // 打印根 \n\t\tPreOrderTraversal(BT->Left);  // 进入左子树 \n\t\tPreOrderTraversal(BT->Right);  // 进入右子树 \n\t}\n}\n\n\n# 1.2 非递归实现\n\nvoid PreOrderTraversal(BinTree BT){\n\tBinTree T = BT;\n\tStack S = CreateStack();  // 创建并初始化堆栈 S\n\twhile(T || !IsEmpty(S)){  // 当树不为空或堆栈不空 \n\t\twhile(T){     \n\t\t\tPush(S,T);    // 压栈，第一次遇到该结点 \n\t\t\tprintf("%d",T->Data);  // 访问结点\n\t\t\tT = T->Left;   // 遍历左子树 \n\t\t}\n\t\tif(!IsEmpty(S)){  // 当堆栈不空 \n\t\t\tT = Pop(S);    // 出栈，第二次遇到该结点 \n\t\t\tT = T->Right;  // 访问右结点 \n\t\t}\n\t} \n} \n\n\n\n# 2.中序遍历\n\n递归过程：\n\n 1. 中序遍历其左子树\n 2. 访问根结点\n 3. 中序遍历其右子树\n\n\n\n# 2.1 递归实现\n\nvoid InOrderTraversal(BinTree BT){\n\tif(BT){\n\t\tInOrderTraversal(BT->Left);  // 进入左子树 \n\t\tprintf("%d",BT->Data);  // 打印根 \n\t\tInOrderTraversal(BT->Right);  // 进入右子树 \n\t} \n}\n\n\n# 2.2 非递归实现\n\nvoid InOrderTraversal(BinTree BT){\n\tBinTree T = BT;\n\tStack S = CreateStack();  // 创建并初始化堆栈 S\n\twhile(T || !IsEmpty(S)){  // 当树不为空或堆栈不空 \n\t\twhile(T){     \n\t\t\tPush(S,T);    // 压栈\n\t\t\tT = T->Left;   // 遍历左子树 \n\t\t}\n\t\tif(!IsEmpty(S)){  // 当堆栈不空 \n\t\t\tT = Pop(S);    // 出栈\n\t\t\tprintf("%d",T->Data);  // 访问结点\n\t\t\tT = T->Right;  // 访问右结点 \n\t\t}\n\t} \n} \n\n\n\n# 3. 后序遍历\n\n遍历过程：\n\n 1. 后序遍历其左子树\n 2. 后序遍历其右子树\n 3. 访问根结点\n\n\n\n# 3.1. 递归实现\n\nvoid PostOrderTraversal(BinTree BT){\n\tif(BT){\n\t\tPostOrderTraversal(BT->Left);  // 进入左子树 \n\t\tPostOrderTraversal(BT->Right);  // 进入右子树 \n\t\tprintf("%d",BT->Data);  // 打印根 \n\t} \n}\n\n\n\n# 3.2 非递归实现\n\nvoid PostOrderTraversal(BinTree BT){\n\tBinTree T = BT;\n\tStack S = CreateStack();  // 创建并初始化堆栈 S\n\tvector<BinTree> v;   // 创建存储树结点的动态数组\n\tPush(S,T);\n\twhile(!IsEmpty(S)){  // 当树不为空或堆栈不空 \n\t\tT = Pop(S);\n\t\tv.push_back(T);  // 出栈元素进数组\n\t\tif(T->Left)\n\t\t\tPush(S,T->Left);\n\t\tif(T->Right)\n\t\t\tPush(S,T->Right);\n\t}\n\treverse(v.begin(),v.end());  // 逆转 \n\tfor(int i=0;i<v.size();i++)  // 输出数组元素\n\t\tprintf("%d",v[i]->Data);\n} \n\n\n先序、中序和后序遍历过程：遍历过程中经过结点的路线一样，只是访问各结点的时机不同，即：\n\n * 先序遍历是第一次"遇到"该结点时访问\n * 中序遍历是第二次"遇到"该结点（此时该结点从左子树返回）时访问\n * 后序遍历是第三次"遇到"该结点（此时该结点从右子树返回）时访问\n\n\n# 4. 层序遍历\n\n遍历过程：从上至下，从左至右访问所有结点\n\n队列实现过程：\n\n 1. 根结点入队\n 2. 从队列中取出一个元素\n 3. 访问该元素所指结点\n 4. 若该元素所指结点的左孩子结点非空，左孩子结点入队\n 5. 若该元素所指结点的右孩子结点非空，右孩子结点入队\n 6. 循环 1 - 4，直到队列中为空\n\nvoid LevelOrderTraversal(BinTree BT){\n\tqueue<BinTree> q;   // 创建队列\n\tBinTree T;\n\tif(!BT)\n\t\treturn;\n\tq.push(BT);  // BT 入队 \n\twhile(!q.empty()){\n\t\tT = q.front();  // 访问队首元素 \n\t\tq.pop();  // 出队\n\t\tprintf("%d",T->Data);\n\t\tif(T->Left)  // 如果存在左儿子结点\n\t\t\tq.push(T->Left);  // 入队\n\t \tif(T->Right)\n\t \t\tq.push(T->Right);\n\t}\n}\n',normalizedContent:'# 二叉树的遍历\n\n\n# 1.先序遍历\n\n遍历过程：\n\n 1. 访问根结点\n 2. 先序遍历其左子树\n 3. 先序遍历其右子树\n\n\n\n# 1. 1 递归实现\n\nvoid  preordertraversal(bintree bt){\n\tif(bt){\n\t\tprintf("%d",bt->data);  // 打印根 \n\t\tpreordertraversal(bt->left);  // 进入左子树 \n\t\tpreordertraversal(bt->right);  // 进入右子树 \n\t}\n}\n\n\n# 1.2 非递归实现\n\nvoid preordertraversal(bintree bt){\n\tbintree t = bt;\n\tstack s = createstack();  // 创建并初始化堆栈 s\n\twhile(t || !isempty(s)){  // 当树不为空或堆栈不空 \n\t\twhile(t){     \n\t\t\tpush(s,t);    // 压栈，第一次遇到该结点 \n\t\t\tprintf("%d",t->data);  // 访问结点\n\t\t\tt = t->left;   // 遍历左子树 \n\t\t}\n\t\tif(!isempty(s)){  // 当堆栈不空 \n\t\t\tt = pop(s);    // 出栈，第二次遇到该结点 \n\t\t\tt = t->right;  // 访问右结点 \n\t\t}\n\t} \n} \n\n\n\n# 2.中序遍历\n\n递归过程：\n\n 1. 中序遍历其左子树\n 2. 访问根结点\n 3. 中序遍历其右子树\n\n\n\n# 2.1 递归实现\n\nvoid inordertraversal(bintree bt){\n\tif(bt){\n\t\tinordertraversal(bt->left);  // 进入左子树 \n\t\tprintf("%d",bt->data);  // 打印根 \n\t\tinordertraversal(bt->right);  // 进入右子树 \n\t} \n}\n\n\n# 2.2 非递归实现\n\nvoid inordertraversal(bintree bt){\n\tbintree t = bt;\n\tstack s = createstack();  // 创建并初始化堆栈 s\n\twhile(t || !isempty(s)){  // 当树不为空或堆栈不空 \n\t\twhile(t){     \n\t\t\tpush(s,t);    // 压栈\n\t\t\tt = t->left;   // 遍历左子树 \n\t\t}\n\t\tif(!isempty(s)){  // 当堆栈不空 \n\t\t\tt = pop(s);    // 出栈\n\t\t\tprintf("%d",t->data);  // 访问结点\n\t\t\tt = t->right;  // 访问右结点 \n\t\t}\n\t} \n} \n\n\n\n# 3. 后序遍历\n\n遍历过程：\n\n 1. 后序遍历其左子树\n 2. 后序遍历其右子树\n 3. 访问根结点\n\n\n\n# 3.1. 递归实现\n\nvoid postordertraversal(bintree bt){\n\tif(bt){\n\t\tpostordertraversal(bt->left);  // 进入左子树 \n\t\tpostordertraversal(bt->right);  // 进入右子树 \n\t\tprintf("%d",bt->data);  // 打印根 \n\t} \n}\n\n\n\n# 3.2 非递归实现\n\nvoid postordertraversal(bintree bt){\n\tbintree t = bt;\n\tstack s = createstack();  // 创建并初始化堆栈 s\n\tvector<bintree> v;   // 创建存储树结点的动态数组\n\tpush(s,t);\n\twhile(!isempty(s)){  // 当树不为空或堆栈不空 \n\t\tt = pop(s);\n\t\tv.push_back(t);  // 出栈元素进数组\n\t\tif(t->left)\n\t\t\tpush(s,t->left);\n\t\tif(t->right)\n\t\t\tpush(s,t->right);\n\t}\n\treverse(v.begin(),v.end());  // 逆转 \n\tfor(int i=0;i<v.size();i++)  // 输出数组元素\n\t\tprintf("%d",v[i]->data);\n} \n\n\n先序、中序和后序遍历过程：遍历过程中经过结点的路线一样，只是访问各结点的时机不同，即：\n\n * 先序遍历是第一次"遇到"该结点时访问\n * 中序遍历是第二次"遇到"该结点（此时该结点从左子树返回）时访问\n * 后序遍历是第三次"遇到"该结点（此时该结点从右子树返回）时访问\n\n\n# 4. 层序遍历\n\n遍历过程：从上至下，从左至右访问所有结点\n\n队列实现过程：\n\n 1. 根结点入队\n 2. 从队列中取出一个元素\n 3. 访问该元素所指结点\n 4. 若该元素所指结点的左孩子结点非空，左孩子结点入队\n 5. 若该元素所指结点的右孩子结点非空，右孩子结点入队\n 6. 循环 1 - 4，直到队列中为空\n\nvoid levelordertraversal(bintree bt){\n\tqueue<bintree> q;   // 创建队列\n\tbintree t;\n\tif(!bt)\n\t\treturn;\n\tq.push(bt);  // bt 入队 \n\twhile(!q.empty()){\n\t\tt = q.front();  // 访问队首元素 \n\t\tq.pop();  // 出队\n\t\tprintf("%d",t->data);\n\t\tif(t->left)  // 如果存在左儿子结点\n\t\t\tq.push(t->left);  // 入队\n\t \tif(t->right)\n\t \t\tq.push(t->right);\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"平衡二叉树",frontmatter:{title:"平衡二叉树",date:"2022-12-19T16:24:59.000Z",permalink:"/pages/bf255e/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/08.%E5%B9%B3%E8%A1%A1%E5%B9%B3%E8%A1%A1%E6%A0%91.html",relativePath:"01.指南/06.数据结构/08.平衡平衡树.md",key:"v-e8336c5e",path:"/pages/bf255e/",headers:[{level:2,title:"1.平衡二叉树",slug:"_1-平衡二叉树",normalizedTitle:"1.平衡二叉树",charIndex:2},{level:3,title:"1.1 平衡二叉树的定义",slug:"_1-1-平衡二叉树的定义",normalizedTitle:"1.1 平衡二叉树的定义",charIndex:14},{level:3,title:"1.2 平衡二叉树的视图",slug:"_1-2-平衡二叉树的视图",normalizedTitle:"1.2 平衡二叉树的视图",charIndex:454},{level:3,title:"1.3 失衡二叉排序树的分析与调整",slug:"_1-3-失衡二叉排序树的分析与调整",normalizedTitle:"1.3 失衡二叉排序树的分析与调整",charIndex:546}],headersStr:"1.平衡二叉树 1.1 平衡二叉树的定义 1.2 平衡二叉树的视图 1.3 失衡二叉排序树的分析与调整",content:"# 1.平衡二叉树\n\n\n# 1.1 平衡二叉树的定义\n\n平衡二叉搜索树(Self-balancing binary search tree)又被称为AVL树(有别于AVL算法)，且具有以下性质:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点总数的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。\n\n一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：\n\n * 左子树与右子树的高度之差的绝对值小于等于１\n * 左子树和右子树也是平衡二叉排序树\n\n为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差．这个数字称为结点的平衡因子（ＢＦ）\n\n平衡因子＝结点左子树的高度－结点右子树的高度\n\n\n# 1.2 平衡二叉树的视图\n\n根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是-1,0,或1\n\n\n\n对于一棵有n个结点的AVL树，其高度保持在O(log2^n)数量级\n\n\n# 1.3 失衡二叉排序树的分析与调整\n\n当我们在一个平衡二叉排序树上插入一个结点时，有可能导致失衡，不再是一个平衡二叉排序树，即出现平衡因子绝对值大于１的结点\n\n\n\n如果在一棵ＡＶＬ树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡平衡调整的四种类型：\n\n\n\n具体的调整为：\n\n\n\n调整原则为：\n\n * 降低高度\n * 保持二叉排序树的性质\n\n规律：按照二叉排序树的性质，挑选３个值的中间值作为调整后的根结点，最小值为根结点的左孩子，最大值为根结点的右孩子．\n\n----------------------------------------\n\n> 例：LL型\n\n\n\n> 例：ＲＬ型\n\n\n\nＲＲ型和ＬＲ型和上面类似，就不多介绍了，总之，一个总的原则，就是调整后必须保证\n\n * 降低高度\n * 保持二叉排序树的性质",normalizedContent:"# 1.平衡二叉树\n\n\n# 1.1 平衡二叉树的定义\n\n平衡二叉搜索树(self-balancing binary search tree)又被称为avl树(有别于avl算法)，且具有以下性质:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、avl、替罪羊树、treap、伸展树等。 最小二叉平衡树的节点总数的公式如下 f(n)=f(n-1)+f(n-2)+1 这个类似于一个递归的数列，可以参考fibonacci(斐波那契)数列，1是根节点，f(n-1)是左子树的节点数量，f(n-2)是右子树的节点数量。\n\n一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：\n\n * 左子树与右子树的高度之差的绝对值小于等于１\n * 左子树和右子树也是平衡二叉排序树\n\n为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差．这个数字称为结点的平衡因子（ｂｆ）\n\n平衡因子＝结点左子树的高度－结点右子树的高度\n\n\n# 1.2 平衡二叉树的视图\n\n根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是-1,0,或1\n\n\n\n对于一棵有n个结点的avl树，其高度保持在o(log2^n)数量级\n\n\n# 1.3 失衡二叉排序树的分析与调整\n\n当我们在一个平衡二叉排序树上插入一个结点时，有可能导致失衡，不再是一个平衡二叉排序树，即出现平衡因子绝对值大于１的结点\n\n\n\n如果在一棵ａｖｌ树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡平衡调整的四种类型：\n\n\n\n具体的调整为：\n\n\n\n调整原则为：\n\n * 降低高度\n * 保持二叉排序树的性质\n\n规律：按照二叉排序树的性质，挑选３个值的中间值作为调整后的根结点，最小值为根结点的左孩子，最大值为根结点的右孩子．\n\n----------------------------------------\n\n> 例：ll型\n\n\n\n> 例：ｒｌ型\n\n\n\nｒｒ型和ｌｒ型和上面类似，就不多介绍了，总之，一个总的原则，就是调整后必须保证\n\n * 降低高度\n * 保持二叉排序树的性质",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"堆",frontmatter:{title:"堆",date:"2022-12-19T16:26:22.000Z",permalink:"/pages/830399/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09.%E5%A0%86.html",relativePath:"01.指南/06.数据结构/09.堆.md",key:"v-24edf572",path:"/pages/830399/",headers:[{level:2,title:"1.堆",slug:"_1-堆",normalizedTitle:"1.堆",charIndex:2},{level:3,title:"1.1 堆的定义",slug:"_1-1-堆的定义",normalizedTitle:"1.1 堆的定义",charIndex:10},{level:3,title:"1.2 堆的特性",slug:"_1-2-堆的特性",normalizedTitle:"1.2 堆的特性",charIndex:284},{level:3,title:"1.3 堆的抽象数据类型描述",slug:"_1-3-堆的抽象数据类型描述",normalizedTitle:"1.3 堆的抽象数据类型描述",charIndex:420},{level:3,title:"1.4 插入",slug:"_1-4-插入",normalizedTitle:"1.4 插入",charIndex:803},{level:3,title:"1.5 删除",slug:"_1-5-删除",normalizedTitle:"1.5 删除",charIndex:837},{level:3,title:"1.6 最小堆的建立",slug:"_1-6-最小堆的建立",normalizedTitle:"1.6 最小堆的建立",charIndex:3533},{level:3,title:"1.7 调整建堆",slug:"_1-7-调整建堆",normalizedTitle:"1.7 调整建堆",charIndex:4792}],headersStr:"1.堆 1.1 堆的定义 1.2 堆的特性 1.3 堆的抽象数据类型描述 1.4 插入 1.5 删除 1.6 最小堆的建立 1.7 调整建堆",content:'# 1.堆\n\n\n# 1.1 堆的定义\n\n优先队列（priority Queue）：特殊的"队列"，取出元素的顺序是依照元素的优先级（关键字）大小，而不是元素进入队列的先后顺序，以完全二叉树存储\n\n堆（heap）分为二叉堆、二项式堆、斐波那契堆，堆是非线性数据结构，相当于一维数组，有两个直接后继。堆又被称为优先队列，尽管名为优先队列，但堆并不是队列。因为队列遵循First in, First out，但是堆是按照元素的优先级取出元素。所以“堆”是实现调度器的理想数据结构。\n\n堆排序与快速排序、归并排序一样都是时间复杂度为O(N*logN)的排序方法。\n\n\n\n\n# 1.2 堆的特性\n\n堆有两个特性:\n\n * 结构性：用数组表示的完全二叉树\n * 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）\n\n“最大堆(MaxHeap)”，也称"大顶堆"：最大值\n\n\n\n“最小堆(MinHeap)”，也称"小顶堆"：最小值\n\n\n\n\n# 1.3 堆的抽象数据类型描述\n\n * 数据名称：最大堆（MaxHeap）\n * 数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值\n * 操作集：最大堆 H ∈ MaxHeap，元素 item ∈ ElementType\n * 主要操作有：\n   * MaxHeap Create(int MaxSize)：创建一个空的最大堆\n   * Boolean IsFull(MaxHeap H)：判断最大堆 H 是否已满\n   * Boolean Insert(MaxHeap H,ElementType item)：将元素 item 插入最大堆 H\n   * Boolean IsEmpty(MaxHeap H)：判断最大堆 H 是否为空\n   * ElementType DeleteMax(MaxHeap H)：返回 H 中最大元素（高优先级）\n\n\n# 1.4 插入\n\n插入数组最后一个位置，再从下往上找合适地方\n\n\n# 1.5 删除\n\n删除根结点，将数组最后一个位置的数取到根结点，从上往下找合适地方\n\n#include<stdio.h>\n#include<malloc.h>\n#define MaxData 100000\n#define ERROR -1\ntypedef int ElementType;\ntypedef struct HeapStruct *MaxHeap;\nstruct HeapStruct{\n\tElementType *Elements;   // 存储堆元素的数组 \n\tint Size;      // 堆的当前元素个数 \n\tint Capacity;  // 堆的最大容量 \n};\n\nMaxHeap Create(int MaxSize);  // 建堆 \nbool IsFull(MaxHeap H);    // 判断堆是否满\nbool Insert(MaxHeap H,ElementType item);   // 插入元素\nbool IsEmpty(MaxHeap H);    //  判断堆是否为空\nElementType DeleteMax(MaxHeap H);  // 删除并返回堆中最大元素\nvoid LevelOrderTraversal(MaxHeap H);  // 层序遍历 \n\n// 建堆 \nMaxHeap Create(int MaxSize){\n\tMaxHeap H = (MaxHeap)malloc(sizeof(struct HeapStruct));\n\t// Elements[0] 作为哨兵，堆元素从  Elements[1] 开始存放 \n\tH->Elements = (ElementType *)malloc((MaxSize+1) * sizeof(ElementType));\n\tH->Size = 0;\n\tH->Capacity = MaxSize;\n\t// "哨兵"大于堆中所有可能的值 \n\tH->Elements[0] = MaxData;\n\treturn H;\n} \n\n// 插入，从完全二叉树的最后一个位置插入 \nbool Insert(MaxHeap H,ElementType item){\n\tif(IsFull(H)){\n\t\tprintf("堆已满，无法插入！\\n");\n\t\treturn false;\n\t}\n\tint i = ++H->Size;  // 指向堆中最后一个位置 \n\tfor(;H->Elements[i/2] < item;i/=2)    // 向上找比 item 大的结点 \n\t\tH->Elements[i] = H->Elements[i/2];  //  向下赋值 \n\tH->Elements[i] = item;  // 找到了，把 item 值放进去 \n\treturn true;\n}\n\n// 删除，从根结点删除 \nElementType DeleteMax(MaxHeap H){\n\tint parent,child;\n\tElementType Max,tmp;\n\tif(IsEmpty(H)){\n\t\tprintf("堆为空，无法删除！\\n");\n\t\treturn ERROR;\n\t}\n\tMax = H->Elements[1];  // 拿到最大值\n\ttmp = H->Elements[H->Size--];  // 拿到完全二叉树最后一个值 \n\t// 判别条件：parent 是否有左孩子结点 \n\tfor(parent=1;parent*2<=H->Size;parent=child){\n\t\t// 左右孩子结点中找较大的值 \n\t\tchild = 2 * parent;  // 左孩子结点 \n\t\t// child!=H->Size 表示 child 不为当前最后一个结点，即 parent 有右孩子结点 \n\t\tif((child!=H->Size) &&(H->Elements[child] < H->Elements[child+1]))\n\t\t\tchild++;  \n\t\t// 给 tmp 找个合适的位置 \n\t\t// 如果当前左右孩子结点比 tmp 都小，说明 tmp 位置已经合适 \n\t\tif(H->Elements[child] <= tmp)\n\t\t\tbreak;\n\t\telse    // 否则把较大的孩子结点提上来，自己继续下去找 \n\t\t\tH->Elements[parent] = H->Elements[child];\n\t}\n\tH->Elements[parent] = tmp;  // 在合适的位置把 tmp 放进去 \n\treturn Max;\n} \n\n// 判断是否已经满 \nbool IsFull(MaxHeap H){\n\treturn (H->Size == H->Capacity);\n}\n\n// 判断是否为空\nbool IsEmpty(MaxHeap H){\n\treturn !H->Size;\n}\n\n// 层序遍历\nvoid LevelOrderTraversal(MaxHeap H){\n\tint i;\n\tprintf("层序遍历的结果是：");\n\tfor(i = 1;i<=H->Size;i++){\n\t\tprintf("%d ",H->Elements[i]);\n\t} \n\tprintf("\\n"); \n} \n\nint main(){\n\tMaxHeap H;\n\tint MaxSize = 100;\n\tH = Create(MaxSize);\n\tInsert(H,55);\n\tInsert(H,66);\n\tInsert(H,44);\n\tInsert(H,33);\n\tInsert(H,11);\n\tInsert(H,22);\n\tInsert(H,88);\n\tInsert(H,99);\n\t/*\n\t\t 99\n\t\t/  \\\n\t   88  66\n\t  / \\  / \\\n\t 55 11 22 44\n\t/ \n   33\t  \n\t*/\n\tLevelOrderTraversal(H);\n\tDeleteMax(H);\n\tLevelOrderTraversal(H);\n\tDeleteMax(H);\n\tLevelOrderTraversal(H);\n\tDeleteMax(H);\n\tLevelOrderTraversal(H);\n\tDeleteMax(H);\n\tLevelOrderTraversal(H);\n\treturn 0;\n}\n\n\n\n# 1.6 最小堆的建立\n\n堆的建立：将已经存在的 N 个元素按最小堆的要求存放在一个一维数组中\n\n * 对于一组相同数据，插入建堆和调整建堆建出来的堆也许不一样\n * 通过插入，将 N 个元素一个一个相继插入到一个初始为空的堆中去，其时间代价最大是 O(N*logN)(每次插入是 logN，总共 N 次）\n\n#include<iostream>\n#include<malloc.h>\nconst int MinData = -100000;  // 哨兵值\nconst int MaxSize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct HeapStruct *Heap;\nstruct HeapStruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\n#include<iostream>\n#include<malloc.h>\nconst int MinData = -100000;  // 哨兵值\nconst int MaxSize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct HeapStruct *Heap;\nstruct HeapStruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\nHeap Create(){\n\tHeap H;\n\tH = (Heap)malloc(sizeof(struct HeapStruct));\n\tH->data = (int *)malloc(sizeof(int) * (MaxSize+1));\n\tH->size = 0;\n\tH->capacity = MaxSize;\n\tH->data[0] = MinData;\n\treturn H;\n} \n\n// 插入\nvoid Insert(Heap H,int x){\n\tint i = ++H->size;  // 指向数组最后一个 \n\tfor(;H->data[i/2]>x;i/=2)\n\t\tH->data[i] = H->data[i/2];\n\tH->data[i] = x;\n} \n\n// 遍历 \nvoid bl(Heap H){\n\tfor(int i=1;i<=H->size;i++)\n\t\tcout<<H->data[i]<<" ";\n}\n\nint main(){\n\tHeap H;\n\tH = Create();\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tInsert(H,t);\n\t}\n\tbl(H);\n\treturn 0;\n} \n\n\n\n\n# 1.7 调整建堆\n\n将 N 个元素直接按顺序存入，再调整各结点的位置（简单说来，对于从最后一个有孩子结点的结点来说，其本身结点和孩子结点共同构成"子最小堆"，借助前面删除的想法，对每个"子最小堆"排序，当排序完成，整个最小堆也建立成功），时间代价是 O(n)\n\n#include<iostream>\n#include<malloc.h>\nconst int MinData = -100000;  // 哨兵值\nconst int MaxSize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct HeapStruct *Heap;\nstruct HeapStruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\nHeap Create(){\n\tHeap H;\n\tH = (Heap)malloc(sizeof(struct HeapStruct));\n\tH->data = (int *)malloc(sizeof(int) * (MaxSize+1));\n\tH->size = 0;\n\tH->capacity = MaxSize;\n\tH->data[0] = MinData;\n\treturn H;\n} \n\n// 排序，类似堆的"删除操作" \nvoid sort(Heap H,int i){\n\tint child,parent;\n\tint tmp = H->data[i];  // 拿到当前"根结点的值" \n\tfor(parent = i;parent*2<=H->size;parent = child){\n\t\tchild = 2 * parent;\n\t\tif((child!=H->size) && (H->data[child+1] < H->data[child]))\n\t\t\tchild++;\n\t\tif(H->data[child] >= tmp)\n\t\t\tbreak;\n\t\telse\n\t\t\tH->data[parent] = H->data[child]; \n\t}\n\tH->data[parent] = tmp;\n}\n// 调整\nvoid adjust(Heap H){\n\tint i= H->size/2;\n\tfor(;i>0;i--){\n\t\t// 以每个有孩子结点的结点作为根结点，对其子树进行堆排序 \n\t\tsort(H,i);\n\t}\n} \n\n// 遍历 \nvoid bl(Heap H){\n\tfor(int i=1;i<=H->size;i++){\n\t\tcout<<H->data[i]<<" ";\n\t}\n\tcout<<endl;\n}\n\n\nint main(){\n\tHeap H;\n\tH = Create();\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>H->data[++H->size];\n\tadjust(H);\n\tbl(H); \n\treturn 0;\n}\n',normalizedContent:'# 1.堆\n\n\n# 1.1 堆的定义\n\n优先队列（priority queue）：特殊的"队列"，取出元素的顺序是依照元素的优先级（关键字）大小，而不是元素进入队列的先后顺序，以完全二叉树存储\n\n堆（heap）分为二叉堆、二项式堆、斐波那契堆，堆是非线性数据结构，相当于一维数组，有两个直接后继。堆又被称为优先队列，尽管名为优先队列，但堆并不是队列。因为队列遵循first in, first out，但是堆是按照元素的优先级取出元素。所以“堆”是实现调度器的理想数据结构。\n\n堆排序与快速排序、归并排序一样都是时间复杂度为o(n*logn)的排序方法。\n\n\n\n\n# 1.2 堆的特性\n\n堆有两个特性:\n\n * 结构性：用数组表示的完全二叉树\n * 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）\n\n“最大堆(maxheap)”，也称"大顶堆"：最大值\n\n\n\n“最小堆(minheap)”，也称"小顶堆"：最小值\n\n\n\n\n# 1.3 堆的抽象数据类型描述\n\n * 数据名称：最大堆（maxheap）\n * 数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值\n * 操作集：最大堆 h ∈ maxheap，元素 item ∈ elementtype\n * 主要操作有：\n   * maxheap create(int maxsize)：创建一个空的最大堆\n   * boolean isfull(maxheap h)：判断最大堆 h 是否已满\n   * boolean insert(maxheap h,elementtype item)：将元素 item 插入最大堆 h\n   * boolean isempty(maxheap h)：判断最大堆 h 是否为空\n   * elementtype deletemax(maxheap h)：返回 h 中最大元素（高优先级）\n\n\n# 1.4 插入\n\n插入数组最后一个位置，再从下往上找合适地方\n\n\n# 1.5 删除\n\n删除根结点，将数组最后一个位置的数取到根结点，从上往下找合适地方\n\n#include<stdio.h>\n#include<malloc.h>\n#define maxdata 100000\n#define error -1\ntypedef int elementtype;\ntypedef struct heapstruct *maxheap;\nstruct heapstruct{\n\telementtype *elements;   // 存储堆元素的数组 \n\tint size;      // 堆的当前元素个数 \n\tint capacity;  // 堆的最大容量 \n};\n\nmaxheap create(int maxsize);  // 建堆 \nbool isfull(maxheap h);    // 判断堆是否满\nbool insert(maxheap h,elementtype item);   // 插入元素\nbool isempty(maxheap h);    //  判断堆是否为空\nelementtype deletemax(maxheap h);  // 删除并返回堆中最大元素\nvoid levelordertraversal(maxheap h);  // 层序遍历 \n\n// 建堆 \nmaxheap create(int maxsize){\n\tmaxheap h = (maxheap)malloc(sizeof(struct heapstruct));\n\t// elements[0] 作为哨兵，堆元素从  elements[1] 开始存放 \n\th->elements = (elementtype *)malloc((maxsize+1) * sizeof(elementtype));\n\th->size = 0;\n\th->capacity = maxsize;\n\t// "哨兵"大于堆中所有可能的值 \n\th->elements[0] = maxdata;\n\treturn h;\n} \n\n// 插入，从完全二叉树的最后一个位置插入 \nbool insert(maxheap h,elementtype item){\n\tif(isfull(h)){\n\t\tprintf("堆已满，无法插入！\\n");\n\t\treturn false;\n\t}\n\tint i = ++h->size;  // 指向堆中最后一个位置 \n\tfor(;h->elements[i/2] < item;i/=2)    // 向上找比 item 大的结点 \n\t\th->elements[i] = h->elements[i/2];  //  向下赋值 \n\th->elements[i] = item;  // 找到了，把 item 值放进去 \n\treturn true;\n}\n\n// 删除，从根结点删除 \nelementtype deletemax(maxheap h){\n\tint parent,child;\n\telementtype max,tmp;\n\tif(isempty(h)){\n\t\tprintf("堆为空，无法删除！\\n");\n\t\treturn error;\n\t}\n\tmax = h->elements[1];  // 拿到最大值\n\ttmp = h->elements[h->size--];  // 拿到完全二叉树最后一个值 \n\t// 判别条件：parent 是否有左孩子结点 \n\tfor(parent=1;parent*2<=h->size;parent=child){\n\t\t// 左右孩子结点中找较大的值 \n\t\tchild = 2 * parent;  // 左孩子结点 \n\t\t// child!=h->size 表示 child 不为当前最后一个结点，即 parent 有右孩子结点 \n\t\tif((child!=h->size) &&(h->elements[child] < h->elements[child+1]))\n\t\t\tchild++;  \n\t\t// 给 tmp 找个合适的位置 \n\t\t// 如果当前左右孩子结点比 tmp 都小，说明 tmp 位置已经合适 \n\t\tif(h->elements[child] <= tmp)\n\t\t\tbreak;\n\t\telse    // 否则把较大的孩子结点提上来，自己继续下去找 \n\t\t\th->elements[parent] = h->elements[child];\n\t}\n\th->elements[parent] = tmp;  // 在合适的位置把 tmp 放进去 \n\treturn max;\n} \n\n// 判断是否已经满 \nbool isfull(maxheap h){\n\treturn (h->size == h->capacity);\n}\n\n// 判断是否为空\nbool isempty(maxheap h){\n\treturn !h->size;\n}\n\n// 层序遍历\nvoid levelordertraversal(maxheap h){\n\tint i;\n\tprintf("层序遍历的结果是：");\n\tfor(i = 1;i<=h->size;i++){\n\t\tprintf("%d ",h->elements[i]);\n\t} \n\tprintf("\\n"); \n} \n\nint main(){\n\tmaxheap h;\n\tint maxsize = 100;\n\th = create(maxsize);\n\tinsert(h,55);\n\tinsert(h,66);\n\tinsert(h,44);\n\tinsert(h,33);\n\tinsert(h,11);\n\tinsert(h,22);\n\tinsert(h,88);\n\tinsert(h,99);\n\t/*\n\t\t 99\n\t\t/  \\\n\t   88  66\n\t  / \\  / \\\n\t 55 11 22 44\n\t/ \n   33\t  \n\t*/\n\tlevelordertraversal(h);\n\tdeletemax(h);\n\tlevelordertraversal(h);\n\tdeletemax(h);\n\tlevelordertraversal(h);\n\tdeletemax(h);\n\tlevelordertraversal(h);\n\tdeletemax(h);\n\tlevelordertraversal(h);\n\treturn 0;\n}\n\n\n\n# 1.6 最小堆的建立\n\n堆的建立：将已经存在的 n 个元素按最小堆的要求存放在一个一维数组中\n\n * 对于一组相同数据，插入建堆和调整建堆建出来的堆也许不一样\n * 通过插入，将 n 个元素一个一个相继插入到一个初始为空的堆中去，其时间代价最大是 o(n*logn)(每次插入是 logn，总共 n 次）\n\n#include<iostream>\n#include<malloc.h>\nconst int mindata = -100000;  // 哨兵值\nconst int maxsize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct heapstruct *heap;\nstruct heapstruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\n#include<iostream>\n#include<malloc.h>\nconst int mindata = -100000;  // 哨兵值\nconst int maxsize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct heapstruct *heap;\nstruct heapstruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\nheap create(){\n\theap h;\n\th = (heap)malloc(sizeof(struct heapstruct));\n\th->data = (int *)malloc(sizeof(int) * (maxsize+1));\n\th->size = 0;\n\th->capacity = maxsize;\n\th->data[0] = mindata;\n\treturn h;\n} \n\n// 插入\nvoid insert(heap h,int x){\n\tint i = ++h->size;  // 指向数组最后一个 \n\tfor(;h->data[i/2]>x;i/=2)\n\t\th->data[i] = h->data[i/2];\n\th->data[i] = x;\n} \n\n// 遍历 \nvoid bl(heap h){\n\tfor(int i=1;i<=h->size;i++)\n\t\tcout<<h->data[i]<<" ";\n}\n\nint main(){\n\theap h;\n\th = create();\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tinsert(h,t);\n\t}\n\tbl(h);\n\treturn 0;\n} \n\n\n\n\n# 1.7 调整建堆\n\n将 n 个元素直接按顺序存入，再调整各结点的位置（简单说来，对于从最后一个有孩子结点的结点来说，其本身结点和孩子结点共同构成"子最小堆"，借助前面删除的想法，对每个"子最小堆"排序，当排序完成，整个最小堆也建立成功），时间代价是 o(n)\n\n#include<iostream>\n#include<malloc.h>\nconst int mindata = -100000;  // 哨兵值\nconst int maxsize = 1005;   // 最大个数 \nusing namespace std;\ntypedef struct heapstruct *heap;\nstruct heapstruct{\n\tint *data;   // 存值的数组 \n\tint size;   // 当前元素个数 \n\tint capacity;  // 最大容量 \n};\n\n// 初始化堆\nheap create(){\n\theap h;\n\th = (heap)malloc(sizeof(struct heapstruct));\n\th->data = (int *)malloc(sizeof(int) * (maxsize+1));\n\th->size = 0;\n\th->capacity = maxsize;\n\th->data[0] = mindata;\n\treturn h;\n} \n\n// 排序，类似堆的"删除操作" \nvoid sort(heap h,int i){\n\tint child,parent;\n\tint tmp = h->data[i];  // 拿到当前"根结点的值" \n\tfor(parent = i;parent*2<=h->size;parent = child){\n\t\tchild = 2 * parent;\n\t\tif((child!=h->size) && (h->data[child+1] < h->data[child]))\n\t\t\tchild++;\n\t\tif(h->data[child] >= tmp)\n\t\t\tbreak;\n\t\telse\n\t\t\th->data[parent] = h->data[child]; \n\t}\n\th->data[parent] = tmp;\n}\n// 调整\nvoid adjust(heap h){\n\tint i= h->size/2;\n\tfor(;i>0;i--){\n\t\t// 以每个有孩子结点的结点作为根结点，对其子树进行堆排序 \n\t\tsort(h,i);\n\t}\n} \n\n// 遍历 \nvoid bl(heap h){\n\tfor(int i=1;i<=h->size;i++){\n\t\tcout<<h->data[i]<<" ";\n\t}\n\tcout<<endl;\n}\n\n\nint main(){\n\theap h;\n\th = create();\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>h->data[++h->size];\n\tadjust(h);\n\tbl(h); \n\treturn 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"哈夫曼树",frontmatter:{title:"哈夫曼树",date:"2022-12-19T16:25:56.000Z",permalink:"/pages/41b93a/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.html",relativePath:"01.指南/06.数据结构/10.哈夫曼树.md",key:"v-9abc4948",path:"/pages/41b93a/",headers:[{level:2,title:"1.哈夫曼树",slug:"_1-哈夫曼树",normalizedTitle:"1.哈夫曼树",charIndex:2},{level:3,title:"1.1 哈夫曼树的定义",slug:"_1-1-哈夫曼树的定义",normalizedTitle:"1.1 哈夫曼树的定义",charIndex:13},{level:3,title:"1.2 构建哈夫曼的过程",slug:"_1-2-构建哈夫曼的过程",normalizedTitle:"1.2 构建哈夫曼的过程",charIndex:629},{level:3,title:"1.4 哈弗曼树中结点结构",slug:"_1-4-哈弗曼树中结点结构",normalizedTitle:"1.4 哈弗曼树中结点结构",charIndex:1040},{level:3,title:"1.5 构建哈弗曼树的算法实现",slug:"_1-5-构建哈弗曼树的算法实现",normalizedTitle:"1.5 构建哈弗曼树的算法实现",charIndex:1332}],headersStr:"1.哈夫曼树 1.1 哈夫曼树的定义 1.2 构建哈夫曼的过程 1.4 哈弗曼树中结点结构 1.5 构建哈弗曼树的算法实现",content:"# 1.哈夫曼树\n\n\n# 1.1 哈夫曼树的定义\n\n当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。\n\n在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。\n\n哈夫曼树相关的几个名词\n\n * 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。\n * 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。\n * 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。\n * 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。\n\n树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：\n\nWPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3\n\n\n\n\n\n# 1.2 构建哈夫曼的过程\n\n对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：\n\n 1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；\n 2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；\n 3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。\n\n\n\n图 2 中:\n\n * （A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；\n * （B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；\n * （C）重复之前的步骤。\n * （D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。\n\n\n# 1.4 哈弗曼树中结点结构\n\n构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。\n\n所以，哈夫曼树中结点构成用代码表示为：\n\n//哈夫曼树结点结构\ntypedef struct {\n    int weight;//结点权重\n    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标\n}HTNode, *HuffmanTree;\n\n\n\n# 1.5 构建哈弗曼树的算法实现\n\n构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。\n\n查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：\n\n * 如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；\n * 如果介于两个结点权重值之间，替换原来较大的结点；\n\n实现代码：\n\n//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置\nvoid Select(HuffmanTree HT, int end, int *s1, int *s2)\n{\n    int min1, min2;\n    //遍历数组初始下标为 1\n    int i = 1;\n    //找到还没构建树的结点\n    while(HT[i].parent != 0 && i <= end){\n        i++;\n    }\n    min1 = HT[i].weight;\n    *s1 = i;\n   \n    i++;\n    while(HT[i].parent != 0 && i <= end){\n        i++;\n    }\n    //对找到的两个结点比较大小，min2为大的，min1为小的\n    if(HT[i].weight < min1){\n        min2 = min1;\n        *s2 = *s1;\n        min1 = HT[i].weight;\n        *s1 = i;\n    }else{\n        min2 = HT[i].weight;\n        *s2 = i;\n    }\n    //两个结点和后续的所有未构建成树的结点做比较\n    for(int j=i+1; j <= end; j++)\n    {\n        //如果有父结点，直接跳过，进行下一个\n        if(HT[j].parent != 0){\n            continue;\n        }\n        //如果比最小的还小，将min2=min1，min1赋值新的结点的下标\n        if(HT[j].weight < min1){\n            min2 = min1;\n            min1 = HT[j].weight;\n            *s2 = *s1;\n            *s1 = j;\n        }\n        //如果介于两者之间，min2赋值为新的结点的位置下标\n        else if(HT[j].weight >= min1 && HT[j].weight < min2){\n            min2 = HT[j].weight;\n            *s2 = j;\n        }\n    }\n}\n\n\n> 注意：s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。\n\n构建哈弗曼树的代码实现如下：\n\n//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数\nvoid CreateHuffmanTree(HuffmanTree *HT, int *w, int n)\n{\n    if(n<=1) return; // 如果只有一个编码就相当于0\n    int m = 2*n-1; // 哈夫曼树总节点数，n就是叶子结点\n    *HT = (HuffmanTree) malloc((m+1) * sizeof(HTNode)); // 0号位置不用\n    HuffmanTree p = *HT;\n    // 初始化哈夫曼树中的所有结点\n    for(int i = 1; i <= n; i++)\n    {\n        (p+i)->weight = *(w+i-1);\n        (p+i)->parent = 0;\n        (p+i)->left = 0;\n        (p+i)->right = 0;\n    }\n    //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点\n    for(int i = n+1; i <= m; i++)\n    {\n        (p+i)->weight = 0;\n        (p+i)->parent = 0;\n        (p+i)->left = 0;\n        (p+i)->right = 0;\n    }\n    //构建哈夫曼树\n    for(int i = n+1; i <= m; i++)\n    {\n        int s1, s2;\n        Select(*HT, i-1, &s1, &s2);\n        (*HT)[s1].parent = (*HT)[s2].parent = i;\n        (*HT)[i].left = s1;\n        (*HT)[i].right = s2;\n        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;\n    }\n}\n\n\n注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(A) 所示。但其实，图 4(B) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。\n\n",normalizedContent:"# 1.哈夫曼树\n\n\n# 1.1 哈夫曼树的定义\n\n当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。\n\n在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。\n\n哈夫曼树相关的几个名词\n\n * 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。\n * 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。\n * 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。\n * 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。\n\n树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “wpl” 。例如图 1 中所示的这颗树的带权路径长度为：\n\nwpl = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3\n\n\n\n\n\n# 1.2 构建哈夫曼的过程\n\n对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：\n\n 1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；\n 2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；\n 3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。\n\n\n\n图 2 中:\n\n * （a）给定了四个结点a，b，c，d，权值分别为7，5，2，4；\n * （b）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；\n * （c）重复之前的步骤。\n * （d）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。\n\n\n# 1.4 哈弗曼树中结点结构\n\n构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。\n\n所以，哈夫曼树中结点构成用代码表示为：\n\n//哈夫曼树结点结构\ntypedef struct {\n    int weight;//结点权重\n    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标\n}htnode, *huffmantree;\n\n\n\n# 1.5 构建哈弗曼树的算法实现\n\n构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。\n\n查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：\n\n * 如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；\n * 如果介于两个结点权重值之间，替换原来较大的结点；\n\n实现代码：\n\n//ht数组中存放的哈夫曼树，end表示ht数组中存放结点的最终位置，s1和s2传递的是ht数组中权重值最小的两个结点在数组中的位置\nvoid select(huffmantree ht, int end, int *s1, int *s2)\n{\n    int min1, min2;\n    //遍历数组初始下标为 1\n    int i = 1;\n    //找到还没构建树的结点\n    while(ht[i].parent != 0 && i <= end){\n        i++;\n    }\n    min1 = ht[i].weight;\n    *s1 = i;\n   \n    i++;\n    while(ht[i].parent != 0 && i <= end){\n        i++;\n    }\n    //对找到的两个结点比较大小，min2为大的，min1为小的\n    if(ht[i].weight < min1){\n        min2 = min1;\n        *s2 = *s1;\n        min1 = ht[i].weight;\n        *s1 = i;\n    }else{\n        min2 = ht[i].weight;\n        *s2 = i;\n    }\n    //两个结点和后续的所有未构建成树的结点做比较\n    for(int j=i+1; j <= end; j++)\n    {\n        //如果有父结点，直接跳过，进行下一个\n        if(ht[j].parent != 0){\n            continue;\n        }\n        //如果比最小的还小，将min2=min1，min1赋值新的结点的下标\n        if(ht[j].weight < min1){\n            min2 = min1;\n            min1 = ht[j].weight;\n            *s2 = *s1;\n            *s1 = j;\n        }\n        //如果介于两者之间，min2赋值为新的结点的位置下标\n        else if(ht[j].weight >= min1 && ht[j].weight < min2){\n            min2 = ht[j].weight;\n            *s2 = j;\n        }\n    }\n}\n\n\n> 注意：s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。\n\n构建哈弗曼树的代码实现如下：\n\n//ht为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数\nvoid createhuffmantree(huffmantree *ht, int *w, int n)\n{\n    if(n<=1) return; // 如果只有一个编码就相当于0\n    int m = 2*n-1; // 哈夫曼树总节点数，n就是叶子结点\n    *ht = (huffmantree) malloc((m+1) * sizeof(htnode)); // 0号位置不用\n    huffmantree p = *ht;\n    // 初始化哈夫曼树中的所有结点\n    for(int i = 1; i <= n; i++)\n    {\n        (p+i)->weight = *(w+i-1);\n        (p+i)->parent = 0;\n        (p+i)->left = 0;\n        (p+i)->right = 0;\n    }\n    //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点\n    for(int i = n+1; i <= m; i++)\n    {\n        (p+i)->weight = 0;\n        (p+i)->parent = 0;\n        (p+i)->left = 0;\n        (p+i)->right = 0;\n    }\n    //构建哈夫曼树\n    for(int i = n+1; i <= m; i++)\n    {\n        int s1, s2;\n        select(*ht, i-1, &s1, &s2);\n        (*ht)[s1].parent = (*ht)[s2].parent = i;\n        (*ht)[i].left = s1;\n        (*ht)[i].right = s2;\n        (*ht)[i].weight = (*ht)[s1].weight + (*ht)[s2].weight;\n    }\n}\n\n\n注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(a) 所示。但其实，图 4(b) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"图",frontmatter:{title:"图",date:"2022-12-19T17:59:53.000Z",permalink:"/pages/9640b5/"},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.%E5%9B%BE.html",relativePath:"01.指南/06.数据结构/11.图.md",key:"v-28e2e596",path:"/pages/9640b5/",headers:[{level:2,title:"1.图的定义",slug:"_1-图的定义",normalizedTitle:"1.图的定义",charIndex:2},{level:3,title:"1.1 什么是图?",slug:"_1-1-什么是图",normalizedTitle:"1.1 什么是图?",charIndex:13},{level:3,title:"1.2 常见术语",slug:"_1-2-常见术语",normalizedTitle:"1.2 常见术语",charIndex:199},{level:3,title:"1.3 抽象数据类型定义",slug:"_1-3-抽象数据类型定义",normalizedTitle:"1.3 抽象数据类型定义",charIndex:414},{level:3,title:"1.4 邻接矩阵表示",slug:"_1-4-邻接矩阵表示",normalizedTitle:"1.4 邻接矩阵表示",charIndex:756},{level:3,title:"1.5 邻接表表示",slug:"_1-5-邻接表表示",normalizedTitle:"1.5 邻接表表示",charIndex:976},{level:2,title:"2.图的遍历",slug:"_2-图的遍历",normalizedTitle:"2.图的遍历",charIndex:1132},{level:3,title:"2.1 DFS 深度优先",slug:"_2-1-dfs-深度优先",normalizedTitle:"2.1 dfs 深度优先",charIndex:1171},{level:3,title:"2.2 BFS 广度优先",slug:"_2-2-bfs-广度优先",normalizedTitle:"2.2 bfs 广度优先",charIndex:1508},{level:3,title:"2.3 总结",slug:"_2-3-总结",normalizedTitle:"2.3 总结",charIndex:1945},{level:2,title:"3.最短路问题",slug:"_3-最短路问题",normalizedTitle:"3.最短路问题",charIndex:2077},{level:3,title:"3.1 最短路径的概述",slug:"_3-1-最短路径的概述",normalizedTitle:"3.1 最短路径的概述",charIndex:2089},{level:3,title:"3.2 分类：",slug:"_3-2-分类",normalizedTitle:"3.2 分类：",charIndex:2228},{level:2,title:"4.最小生成树",slug:"_4-最小生成树",normalizedTitle:"4.最小生成树",charIndex:2328},{level:3,title:"4.1 基本概念",slug:"_4-1-基本概念",normalizedTitle:"4.1 基本概念",charIndex:2340},{level:3,title:"4.2 最小生成树的做法",slug:"_4-2-最小生成树的做法",normalizedTitle:"4.2 最小生成树的做法",charIndex:2551}],headersStr:"1.图的定义 1.1 什么是图? 1.2 常见术语 1.3 抽象数据类型定义 1.4 邻接矩阵表示 1.5 邻接表表示 2.图的遍历 2.1 DFS 深度优先 2.2 BFS 广度优先 2.3 总结 3.最短路问题 3.1 最短路径的概述 3.2 分类： 4.最小生成树 4.1 基本概念 4.2 最小生成树的做法",content:'# 1.图的定义\n\n\n# 1.1 什么是图?\n\n * 表示”多对多”的关系\n * 包含\n   * 一组顶点：通常用 V（Vertex）表示顶点集合\n   * 一组边：通常用 E（Edge）表示边的集合\n     * 边是顶点对：（v,w）∈ E，其中 v,w ∈ V v—w\n     * 有向边 <v,w> 表示从 v 指向 w 的边（单行线） v→w\n     * 不考虑重边和自回路\n\n\n# 1.2 常见术语\n\n * 无向图：图中所有的边无所谓方向\n * 有向图：图中的边可能是双向，也可能是单向的，方向是很重要的\n * 权值：给图中每条边赋予的值，可能有各种各样的现实意义\n * 网络：带权值的图\n * 邻接点：有边直接相连的顶点\n * 出度：从某顶点发出的边数\n * 入度：指向某顶点的边数\n * 稀疏图：顶点很多而边很少的图\n * 稠密图：顶点多边也多的图\n * 完全图：对于给定的一组顶点，顶点间都存在边\n\n\n# 1.3 抽象数据类型定义\n\n * 类型名称：图（Graph）\n * 数据对象集：G（V，E）由一个非空的有限顶点集合 V 和一个有限边集合 E 组成\n * 操作集：对于任意图 G ∈ Graph，以及 v ∈ V，e ∈ E\n\n主要操作有：\n\n * Graph Create()：建立并返回空图\n * Graph InsertVertex(Graph G,Vertex v)：将 v 插入 G\n * Graph InsertEdge(Graph G,Edge e)：将 e 插入 G\n * void DFS(Graph G,Vertex v)：从顶点 v 出发深度优先遍历图 G\n * void BFS(Graph G,Vertex v)：从顶点 v 出发宽度优先遍历图 G\n\n\n# 1.4 邻接矩阵表示\n\n特征：\n\n * 对角线元素全 0\n * 关于对角线对称\n\n优点：\n\n * 直观、简单、好理解\n * 方便检查任意一对顶点间是否存在边\n * 方便找任一顶点的所有邻接点\n * 方便计算任一顶点的度\n   * 无向图：对应行（或列）非 0 元素的个数\n   * 有向图：对应行非 0 元素的个数是出度；对应列非 0 元素的个数是入度\n\n缺点：\n\n * 浪费空间——存稀疏图\n * 浪费时间——统计稀疏图的边\n\n\n\n\n# 1.5 邻接表表示\n\n特点：\n\n * 方便找任一顶点的所有邻接顶点\n * 节省稀疏图的空间\n   * 需要 N 个头指针 + 2E 个结点（每个结点至少 2 个域）\n * 对于是否方便计算任一顶点的度\n   * 无向图：方便\n   * 有向图：只能计算出度\n * 不方便检查任意一对顶点间是否存在边\n\n\n\n\n# 2.图的遍历\n\n图的遍历分为两种:\n\n * 广度优先\n * 深度优先\n\n\n# 2.1 DFS 深度优先\n\n深度优先搜索（Depth First Search)，类似于树的先序遍历\n\n若有 N 个顶点、E 条边，时间复杂度是\n\n * 用邻接表存储，O(N + E)\n * 用邻接矩阵存储，O(N2^2)\n\n深度优先遍历的步骤\n\n * 访问顶点V\n * 依次从顶点V的未被访问的邻节点出发，进行深度优先搜索，直至和V有路径相通的顶点都被访问到。\n * 对于连通图进行遍历时，从一个顶点出发即可访问图中所有的顶点。\n * 对于非连通图进行遍历时，若图中尚有顶点未被访问，则另选一未曾访问的顶点作为起始点，进行深度优先搜索，直至所有顶点都被访问\n\n\n\n访问过程如图所示:\n\n\n\n遍历结果：v1,v2,v4,v8,v5,v3,v6,v7,v9,v10\n\n\n\n# 2.2 BFS 广度优先\n\n广度优先搜索（Breadth First Search)，相当于树的层序遍历\n\n若有 N 个顶点、E 条边，时间复杂度是\n\n * 用邻接表存储，O(N + E)\n * 用邻接矩阵存储，O(N2 ^2 )\n\n广度优先遍历的步骤\n\n从顶点V出发广度优先搜索的步骤\n\n * 访问顶点V\n * 依次访问顶点V的各个未被访问的临接点（横向访问）\n * 从V的这些邻接点出发依次访问他们的邻接点，致使“先被访问的顶点的邻接点先于"后访问的顶点的邻接点"被访问，直至图中所有已被访问的顶点的邻接点均被访问。\n * 对于非连通图进行遍历时，若图中尚有顶点未被访问，则另选一未曾访问的顶点作为起始点，进行广度优先搜索，直至所有顶点都被访问\n\n\n\n如上图所示，顶点A作为第一层，A的所有边顶点BF作为第二层，BF的所有边顶点CIGE作为第三层，依次类推。\n\n示例遍历的过程：\n\n\n\n遍历的结果：V1,V2,V3,V4,V5,V6,V7,V8,V9,V10\n\n\n\n# 2.3 总结\n\n两种遍历时间复杂度是相同的，不同的是对顶点的访问顺序不同。\n\n两种算法没有优劣之分，视不同的情况选择不同的算法。\n\n * 深度优先更适合目标比较明确，以找到目标为主要目的的情况\n * 广度优先更适合在不断扩大遍历范围时找到相对最优解的情况\n\n\n# 3.最短路问题\n\n\n# 3.1 最短路径的概述\n\n在网络（带权图）中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径\n\n * 这条路径就是两点之间的最短路径（ShorttestPath）\n * 第一个顶点为源点（Source）\n * 最后一个顶点为终点（Destination）\n\n\n# 3.2 分类：\n\n * 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径\n   * （有向）无权图\n   * （有向）有权图\n * 多源最短路径问题：求任意两顶点间的最短路径\n\n\n# 4.最小生成树\n\n\n# 4.1 基本概念\n\n最小生成树（minimum spanning tree）其实就是一个生成树，不过它不同于一般的生成树，它的边权之和是最小的，即边权和最小的生成树，准确的来说，同一个图的最小生成树也可以有很多个，但是其边权和肯定是一样的\n\n这个图的最小生成树是什么呢？\n\n是如下这样：\n\n这是这张图的最小生成树，它的边权和是10。\n\n而最小生成树作为一个问题，一般都会询问最小生成树的边权的最大值或者边权之和。\n\n\n# 4.2 最小生成树的做法\n\nKruscal（克鲁斯卡尔）算法\n\nKruscal的思路呢，其实是基于贪心的。Kruskal的时间复杂度为O(mlogm)，其主要的时间花费在给边排序上，其中m为边数，所以在使用的时候要注意下数据范围。\n\n具体做法呢，就是按照下面几个步骤来\n\n 1. 把图上的每一条边存在一个数组里，数组的每个元素应有（起点，边权，终点）三个数据\n 2. 将该边数组按边权从小到大排序\n 3. 依次按边的边权从小到大枚举每一条边，如果边的两个端点已经连通了，那就跳过这条边（通过并查集判断）\n 4. 否则把总答案累计上这条边\n 5. 用并查集merge这条边的两个端点\n 6. 返回第3步\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 110; // 最大顶点数\nconst int maxm = 10010; // 最大边数\nstruct Edge {// 使用结构体储存每一条边，便于排序\n    int u, v, w; // 表示有一条 (u,v) 的无向边，边权为 w\n} e[maxm];\nint ecnt;// 用于边表计数\nvoid addEdge(int u, int v, int w){ // 加入一条无向边\n    ++ecnt;\n    e[ecnt].u = u;\n    e[ecnt].v = v;\n    e[ecnt].w = w;\n}\nint fa[maxn]; // 并查集相关\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]); // 路径压缩\n}\nint n; // 顶点数\nbool cmp(const Edge &a, const Edge &b){\n    return a.w < b.w;\n}\nint Kruskal() { // Kruskal 算法核心过程\n    for (int i = 1; i <= n; i++) {\n        fa[i] = i; // 初始化并查集\n    }\n    sort (e + 1, e + ecnt + 1, cmp);\n    int sum = 0;\n    for (int i = 1; i <= ecnt; i++) {\n        int u = e[i].u;\n        int v = e[i].v;\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            fa[u] = v;\n            sum += e[i].w;\n        }\n    }\n    return sum;\n}\nint main(){\n    scanf("%d",&n);\n    int w;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            scanf("%d", &w);\n            addEdge(i, j, w);\n        }\n    }\n    int ans = Kruskal();\n    printf("%d\\n", ans);\n    return 0;\n}\n\n\n这个代码的输入一个整数表示节点个数，而后面则输入一个邻接矩阵。输出的是该图的最小生成树的边权和。',normalizedContent:'# 1.图的定义\n\n\n# 1.1 什么是图?\n\n * 表示”多对多”的关系\n * 包含\n   * 一组顶点：通常用 v（vertex）表示顶点集合\n   * 一组边：通常用 e（edge）表示边的集合\n     * 边是顶点对：（v,w）∈ e，其中 v,w ∈ v v—w\n     * 有向边 <v,w> 表示从 v 指向 w 的边（单行线） v→w\n     * 不考虑重边和自回路\n\n\n# 1.2 常见术语\n\n * 无向图：图中所有的边无所谓方向\n * 有向图：图中的边可能是双向，也可能是单向的，方向是很重要的\n * 权值：给图中每条边赋予的值，可能有各种各样的现实意义\n * 网络：带权值的图\n * 邻接点：有边直接相连的顶点\n * 出度：从某顶点发出的边数\n * 入度：指向某顶点的边数\n * 稀疏图：顶点很多而边很少的图\n * 稠密图：顶点多边也多的图\n * 完全图：对于给定的一组顶点，顶点间都存在边\n\n\n# 1.3 抽象数据类型定义\n\n * 类型名称：图（graph）\n * 数据对象集：g（v，e）由一个非空的有限顶点集合 v 和一个有限边集合 e 组成\n * 操作集：对于任意图 g ∈ graph，以及 v ∈ v，e ∈ e\n\n主要操作有：\n\n * graph create()：建立并返回空图\n * graph insertvertex(graph g,vertex v)：将 v 插入 g\n * graph insertedge(graph g,edge e)：将 e 插入 g\n * void dfs(graph g,vertex v)：从顶点 v 出发深度优先遍历图 g\n * void bfs(graph g,vertex v)：从顶点 v 出发宽度优先遍历图 g\n\n\n# 1.4 邻接矩阵表示\n\n特征：\n\n * 对角线元素全 0\n * 关于对角线对称\n\n优点：\n\n * 直观、简单、好理解\n * 方便检查任意一对顶点间是否存在边\n * 方便找任一顶点的所有邻接点\n * 方便计算任一顶点的度\n   * 无向图：对应行（或列）非 0 元素的个数\n   * 有向图：对应行非 0 元素的个数是出度；对应列非 0 元素的个数是入度\n\n缺点：\n\n * 浪费空间——存稀疏图\n * 浪费时间——统计稀疏图的边\n\n\n\n\n# 1.5 邻接表表示\n\n特点：\n\n * 方便找任一顶点的所有邻接顶点\n * 节省稀疏图的空间\n   * 需要 n 个头指针 + 2e 个结点（每个结点至少 2 个域）\n * 对于是否方便计算任一顶点的度\n   * 无向图：方便\n   * 有向图：只能计算出度\n * 不方便检查任意一对顶点间是否存在边\n\n\n\n\n# 2.图的遍历\n\n图的遍历分为两种:\n\n * 广度优先\n * 深度优先\n\n\n# 2.1 dfs 深度优先\n\n深度优先搜索（depth first search)，类似于树的先序遍历\n\n若有 n 个顶点、e 条边，时间复杂度是\n\n * 用邻接表存储，o(n + e)\n * 用邻接矩阵存储，o(n2^2)\n\n深度优先遍历的步骤\n\n * 访问顶点v\n * 依次从顶点v的未被访问的邻节点出发，进行深度优先搜索，直至和v有路径相通的顶点都被访问到。\n * 对于连通图进行遍历时，从一个顶点出发即可访问图中所有的顶点。\n * 对于非连通图进行遍历时，若图中尚有顶点未被访问，则另选一未曾访问的顶点作为起始点，进行深度优先搜索，直至所有顶点都被访问\n\n\n\n访问过程如图所示:\n\n\n\n遍历结果：v1,v2,v4,v8,v5,v3,v6,v7,v9,v10\n\n\n\n# 2.2 bfs 广度优先\n\n广度优先搜索（breadth first search)，相当于树的层序遍历\n\n若有 n 个顶点、e 条边，时间复杂度是\n\n * 用邻接表存储，o(n + e)\n * 用邻接矩阵存储，o(n2 ^2 )\n\n广度优先遍历的步骤\n\n从顶点v出发广度优先搜索的步骤\n\n * 访问顶点v\n * 依次访问顶点v的各个未被访问的临接点（横向访问）\n * 从v的这些邻接点出发依次访问他们的邻接点，致使“先被访问的顶点的邻接点先于"后访问的顶点的邻接点"被访问，直至图中所有已被访问的顶点的邻接点均被访问。\n * 对于非连通图进行遍历时，若图中尚有顶点未被访问，则另选一未曾访问的顶点作为起始点，进行广度优先搜索，直至所有顶点都被访问\n\n\n\n如上图所示，顶点a作为第一层，a的所有边顶点bf作为第二层，bf的所有边顶点cige作为第三层，依次类推。\n\n示例遍历的过程：\n\n\n\n遍历的结果：v1,v2,v3,v4,v5,v6,v7,v8,v9,v10\n\n\n\n# 2.3 总结\n\n两种遍历时间复杂度是相同的，不同的是对顶点的访问顺序不同。\n\n两种算法没有优劣之分，视不同的情况选择不同的算法。\n\n * 深度优先更适合目标比较明确，以找到目标为主要目的的情况\n * 广度优先更适合在不断扩大遍历范围时找到相对最优解的情况\n\n\n# 3.最短路问题\n\n\n# 3.1 最短路径的概述\n\n在网络（带权图）中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径\n\n * 这条路径就是两点之间的最短路径（shorttestpath）\n * 第一个顶点为源点（source）\n * 最后一个顶点为终点（destination）\n\n\n# 3.2 分类：\n\n * 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径\n   * （有向）无权图\n   * （有向）有权图\n * 多源最短路径问题：求任意两顶点间的最短路径\n\n\n# 4.最小生成树\n\n\n# 4.1 基本概念\n\n最小生成树（minimum spanning tree）其实就是一个生成树，不过它不同于一般的生成树，它的边权之和是最小的，即边权和最小的生成树，准确的来说，同一个图的最小生成树也可以有很多个，但是其边权和肯定是一样的\n\n这个图的最小生成树是什么呢？\n\n是如下这样：\n\n这是这张图的最小生成树，它的边权和是10。\n\n而最小生成树作为一个问题，一般都会询问最小生成树的边权的最大值或者边权之和。\n\n\n# 4.2 最小生成树的做法\n\nkruscal（克鲁斯卡尔）算法\n\nkruscal的思路呢，其实是基于贪心的。kruskal的时间复杂度为o(mlogm)，其主要的时间花费在给边排序上，其中m为边数，所以在使用的时候要注意下数据范围。\n\n具体做法呢，就是按照下面几个步骤来\n\n 1. 把图上的每一条边存在一个数组里，数组的每个元素应有（起点，边权，终点）三个数据\n 2. 将该边数组按边权从小到大排序\n 3. 依次按边的边权从小到大枚举每一条边，如果边的两个端点已经连通了，那就跳过这条边（通过并查集判断）\n 4. 否则把总答案累计上这条边\n 5. 用并查集merge这条边的两个端点\n 6. 返回第3步\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 110; // 最大顶点数\nconst int maxm = 10010; // 最大边数\nstruct edge {// 使用结构体储存每一条边，便于排序\n    int u, v, w; // 表示有一条 (u,v) 的无向边，边权为 w\n} e[maxm];\nint ecnt;// 用于边表计数\nvoid addedge(int u, int v, int w){ // 加入一条无向边\n    ++ecnt;\n    e[ecnt].u = u;\n    e[ecnt].v = v;\n    e[ecnt].w = w;\n}\nint fa[maxn]; // 并查集相关\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]); // 路径压缩\n}\nint n; // 顶点数\nbool cmp(const edge &a, const edge &b){\n    return a.w < b.w;\n}\nint kruskal() { // kruskal 算法核心过程\n    for (int i = 1; i <= n; i++) {\n        fa[i] = i; // 初始化并查集\n    }\n    sort (e + 1, e + ecnt + 1, cmp);\n    int sum = 0;\n    for (int i = 1; i <= ecnt; i++) {\n        int u = e[i].u;\n        int v = e[i].v;\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            fa[u] = v;\n            sum += e[i].w;\n        }\n    }\n    return sum;\n}\nint main(){\n    scanf("%d",&n);\n    int w;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            scanf("%d", &w);\n            addedge(i, j, w);\n        }\n    }\n    int ans = kruskal();\n    printf("%d\\n", ans);\n    return 0;\n}\n\n\n这个代码的输入一个整数表示节点个数，而后面则输入一个邻接矩阵。输出的是该图的最小生成树的边权和。',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"堆栈",frontmatter:{title:"堆栈",date:"2022-12-19T13:53:16.000Z",permalink:"/pages/6e4306/",category:["数据结构"],tag:["数据结构"]},regularPath:"/01.%E6%8C%87%E5%8D%97/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E5%A0%86%E6%A0%88.html",relativePath:"01.指南/06.数据结构/03.堆栈.md",key:"v-5f4b4e88",path:"/pages/6e4306/",headers:[{level:2,title:"1.堆栈的基本概念",slug:"_1-堆栈的基本概念",normalizedTitle:"1.堆栈的基本概念",charIndex:2},{level:3,title:"1.1 什么是堆栈",slug:"_1-1-什么是堆栈",normalizedTitle:"1.1 什么是堆栈",charIndex:16},{level:3,title:"1.2 进栈和出栈",slug:"_1-2-进栈和出栈",normalizedTitle:"1.2 进栈和出栈",charIndex:490},{level:3,title:"1.3 栈的具体实现",slug:"_1-3-栈的具体实现",normalizedTitle:"1.3 栈的具体实现",charIndex:599},{level:3,title:"1.4 栈堆的操作",slug:"_1-4-栈堆的操作",normalizedTitle:"1.4 栈堆的操作",charIndex:797},{level:3,title:"1.5 堆栈的抽象数据类型描述",slug:"_1-5-堆栈的抽象数据类型描述",normalizedTitle:"1.5 堆栈的抽象数据类型描述",charIndex:923},{level:2,title:"2.顺序栈及基本操作",slug:"_2-顺序栈及基本操作",normalizedTitle:"2.顺序栈及基本操作",charIndex:1283},{level:3,title:"2.1 顺序表存储数据",slug:"_2-1-顺序表存储数据",normalizedTitle:"2.1 顺序表存储数据",charIndex:1298},{level:3,title:'2.2 顺序栈元素"入栈"',slug:"_2-2-顺序栈元素-入栈",normalizedTitle:"2.2 顺序栈元素&quot;入栈&quot;",charIndex:null},{level:3,title:'2.3 顺序栈元素"出栈"',slug:"_2-3-顺序栈元素-出栈",normalizedTitle:"2.3 顺序栈元素&quot;出栈&quot;",charIndex:null},{level:2,title:"3.链栈及基本操作",slug:"_3-链栈及基本操作",normalizedTitle:"3.链栈及基本操作",charIndex:2798},{level:3,title:"3.1 链栈元素入栈",slug:"_3-1-链栈元素入栈",normalizedTitle:"3.1 链栈元素入栈",charIndex:3043},{level:3,title:"3.2 链栈元素出栈",slug:"_3-2-链栈元素出栈",normalizedTitle:"3.2 链栈元素出栈",charIndex:3479}],headersStr:'1.堆栈的基本概念 1.1 什么是堆栈 1.2 进栈和出栈 1.3 栈的具体实现 1.4 栈堆的操作 1.5 堆栈的抽象数据类型描述 2.顺序栈及基本操作 2.1 顺序表存储数据 2.2 顺序栈元素"入栈" 2.3 顺序栈元素"出栈" 3.链栈及基本操作 3.1 链栈元素入栈 3.2 链栈元素出栈',content:'# 1.堆栈的基本概念\n\n\n# 1.1 什么是堆栈\n\n同顺序表和链表一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构，如图 1 所示。\n\n\n\n从图 1我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 "存" 和 "取" 的过程有特殊的要求：\n\n 1. 栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；\n 2. 在栈中，无论是存数据还是取数据，都必须遵循"先进后出"的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据"先进后出"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。\n 3. 因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。\n\n通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。\n\n\n\n\n# 1.2 进栈和出栈\n\n基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：\n\n * 向栈中添加元素，此过程被称为"进栈"（入栈或压栈）；\n * 从栈中提取出指定元素，此过程被称为"出栈"（或弹栈）；\n\n\n# 1.3 栈的具体实现\n\n栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：\n\n 1. 顺序栈：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；\n 2. 链栈：采用链式存储结构实现栈结构；\n\n两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。\n\n\n# 1.4 栈堆的操作\n\n堆栈（Stack）：具有一定操作约束的线性表\n\n * 只在一端（栈顶，Top）做插入、删除\n * 插入数据：入栈（Push）\n * 删除数据：出栈（Pop）\n * 后入先出：Last In First Out（LIFO）\n\n\n# 1.5 堆栈的抽象数据类型描述\n\n类型名称：堆栈（Stack）\n\n数据对象集：一个有 0 个或多个元素的有穷线性表\n\n操作集：长度为 MaxSize 的堆栈 S ∈ Stack，堆栈元素 item ∈ ElementType\n\n堆栈的基本操作主要有：\n\n * Stack CreateStack(int MaxSize)：生成空堆栈，其最大长度为 MaxSize\n * int IsFull(Stack S,int MaxSize)：判断堆栈 S 是否已满\n * void Push(Stack S,ElementType item)：将元素 item 压入堆栈\n * int IsEmpty(Stack S)：判断堆栈 S 是否为空\n * ElementType Pop(Stack S)：删除并返回栈顶元素\n\n\n# 2.顺序栈及基本操作\n\n\n# 2.1 顺序表存储数据\n\n如果你仔细观察顺序表（底层实现是数组）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。\n\n例如，我们先使用顺序表（a 数组）存储 {1,2,3,4}，存储状态如图 1 所示：\n\n\n\n同样，使用栈存储结构存储 {1,2,3,4}，其存储状态如图 2 所示：\n\n\n\n通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。\n\n从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。\n\n\n了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有"先进后出"的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。\n\n这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是"空栈"。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。\n\n\n# 2.2 顺序栈元素"入栈"\n\n比如，还是模拟栈存储 {1,2,3,4} 的过程。最初，栈是"空栈"，即数组是空的，top 值为初始值 -1，如图 3 所示：\n\n\n\n首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：\n\n\n\n采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：\n\n\n\n因此，C 语言实现代码为：\n\n//元素elem进栈，a为数组，top值为当前栈的栈顶位置\nint push(int* a,int top,int elem){\n    a[++top]=elem;\n    return top;\n}\n\n\n\n# 2.3 顺序栈元素"出栈"\n\n其实，top 变量的设置对模拟数据的 "入栈" 操作没有实际的帮助，它是为实现数据的 "出栈" 操作做准备的。\n\n比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：\n\n\n\n> 注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。\n\n元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：\n\n//数据元素出栈\nint pop(int * a,int top){\n    if (top==-1) {\n        printf("空栈");\n        return -1;\n    }\n    printf("弹栈元素：%d\\n",a[top]);\n    top--;\n    return top;\n}\n\n\n代码中的 if 语句是为了防止用户做 "栈中已无数据却还要数据出栈" 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。\n\n\n# 3.链栈及基本操作\n\n链栈，即用链表实现栈存储结构。\n\n链栈的实现思路同顺序栈类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图 1 所示：\n\n\n\n将链表头部作为栈顶的一端，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。\n\n链表的头部作为栈顶，意味着：\n\n * 在实现数据"入栈"操作时，需要将数据从链表的头部插入；\n * 在实现数据"出栈"操作时，需要删除链表头部的首元节点；\n\n\n# 3.1 链栈元素入栈\n\n例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：\n\n\n\nC语言实现代码为：\n\n//链表中的节点结构\ntypedef struct lineStack{\n    int data;\n    struct lineStack * next;\n}lineStack;\n//stack为当前的链栈，a表示入栈元素\nlineStack* push(lineStack * stack,int a){\n    //创建存储新元素的节点\n    lineStack * line=(lineStack*)malloc(sizeof(lineStack));\n    line->data=a;\n    //新节点与头节点建立逻辑关系\n    line->next=stack;\n    //更新头指针的指向\n    stack=line;\n    return stack;\n}\n\n\n\n# 3.2 链栈元素出栈\n\n例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据"先进后出"的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：\n\n\n\n因此，实现栈顶元素出链栈的 C 语言实现代码为：\n\n//栈顶元素出链栈的实现函数\nlineStack * pop(lineStack * stack){\n    if (stack) {\n        //声明一个新指针指向栈顶节点\n        lineStack * p=stack;\n        //更新头指针\n        stack=stack->next;\n        printf("出栈元素：%d ",p->data);\n        if (stack) {\n            printf("新栈顶元素：%d\\n",stack->data);\n        }else{\n            printf("栈已空\\n");\n        }\n        free(p);\n    }else{\n        printf("栈内没有元素");\n        return stack;\n    }\n    return stack;\n}\n',normalizedContent:'# 1.堆栈的基本概念\n\n\n# 1.1 什么是堆栈\n\n同顺序表和链表一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构，如图 1 所示。\n\n\n\n从图 1我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 "存" 和 "取" 的过程有特殊的要求：\n\n 1. 栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；\n 2. 在栈中，无论是存数据还是取数据，都必须遵循"先进后出"的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据"先进后出"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。\n 3. 因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。\n\n通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。\n\n\n\n\n# 1.2 进栈和出栈\n\n基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：\n\n * 向栈中添加元素，此过程被称为"进栈"（入栈或压栈）；\n * 从栈中提取出指定元素，此过程被称为"出栈"（或弹栈）；\n\n\n# 1.3 栈的具体实现\n\n栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：\n\n 1. 顺序栈：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；\n 2. 链栈：采用链式存储结构实现栈结构；\n\n两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。\n\n\n# 1.4 栈堆的操作\n\n堆栈（stack）：具有一定操作约束的线性表\n\n * 只在一端（栈顶，top）做插入、删除\n * 插入数据：入栈（push）\n * 删除数据：出栈（pop）\n * 后入先出：last in first out（lifo）\n\n\n# 1.5 堆栈的抽象数据类型描述\n\n类型名称：堆栈（stack）\n\n数据对象集：一个有 0 个或多个元素的有穷线性表\n\n操作集：长度为 maxsize 的堆栈 s ∈ stack，堆栈元素 item ∈ elementtype\n\n堆栈的基本操作主要有：\n\n * stack createstack(int maxsize)：生成空堆栈，其最大长度为 maxsize\n * int isfull(stack s,int maxsize)：判断堆栈 s 是否已满\n * void push(stack s,elementtype item)：将元素 item 压入堆栈\n * int isempty(stack s)：判断堆栈 s 是否为空\n * elementtype pop(stack s)：删除并返回栈顶元素\n\n\n# 2.顺序栈及基本操作\n\n\n# 2.1 顺序表存储数据\n\n如果你仔细观察顺序表（底层实现是数组）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。\n\n例如，我们先使用顺序表（a 数组）存储 {1,2,3,4}，存储状态如图 1 所示：\n\n\n\n同样，使用栈存储结构存储 {1,2,3,4}，其存储状态如图 2 所示：\n\n\n\n通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。\n\n从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。\n\n\n了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有"先进后出"的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。\n\n这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是"空栈"。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。\n\n\n# 2.2 顺序栈元素"入栈"\n\n比如，还是模拟栈存储 {1,2,3,4} 的过程。最初，栈是"空栈"，即数组是空的，top 值为初始值 -1，如图 3 所示：\n\n\n\n首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：\n\n\n\n采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：\n\n\n\n因此，c 语言实现代码为：\n\n//元素elem进栈，a为数组，top值为当前栈的栈顶位置\nint push(int* a,int top,int elem){\n    a[++top]=elem;\n    return top;\n}\n\n\n\n# 2.3 顺序栈元素"出栈"\n\n其实，top 变量的设置对模拟数据的 "入栈" 操作没有实际的帮助，它是为实现数据的 "出栈" 操作做准备的。\n\n比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：\n\n\n\n> 注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。\n\n元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 c 语言实现代码为：\n\n//数据元素出栈\nint pop(int * a,int top){\n    if (top==-1) {\n        printf("空栈");\n        return -1;\n    }\n    printf("弹栈元素：%d\\n",a[top]);\n    top--;\n    return top;\n}\n\n\n代码中的 if 语句是为了防止用户做 "栈中已无数据却还要数据出栈" 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。\n\n\n# 3.链栈及基本操作\n\n链栈，即用链表实现栈存储结构。\n\n链栈的实现思路同顺序栈类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图 1 所示：\n\n\n\n将链表头部作为栈顶的一端，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。\n\n链表的头部作为栈顶，意味着：\n\n * 在实现数据"入栈"操作时，需要将数据从链表的头部插入；\n * 在实现数据"出栈"操作时，需要删除链表头部的首元节点；\n\n\n# 3.1 链栈元素入栈\n\n例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：\n\n\n\nc语言实现代码为：\n\n//链表中的节点结构\ntypedef struct linestack{\n    int data;\n    struct linestack * next;\n}linestack;\n//stack为当前的链栈，a表示入栈元素\nlinestack* push(linestack * stack,int a){\n    //创建存储新元素的节点\n    linestack * line=(linestack*)malloc(sizeof(linestack));\n    line->data=a;\n    //新节点与头节点建立逻辑关系\n    line->next=stack;\n    //更新头指针的指向\n    stack=line;\n    return stack;\n}\n\n\n\n# 3.2 链栈元素出栈\n\n例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据"先进后出"的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：\n\n\n\n因此，实现栈顶元素出链栈的 c 语言实现代码为：\n\n//栈顶元素出链栈的实现函数\nlinestack * pop(linestack * stack){\n    if (stack) {\n        //声明一个新指针指向栈顶节点\n        linestack * p=stack;\n        //更新头指针\n        stack=stack->next;\n        printf("出栈元素：%d ",p->data);\n        if (stack) {\n            printf("新栈顶元素：%d\\n",stack->data);\n        }else{\n            printf("栈已空\\n");\n        }\n        free(p);\n    }else{\n        printf("栈内没有元素");\n        return stack;\n    }\n    return stack;\n}\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"知识产权标准化",frontmatter:{title:"知识产权标准化",date:"2022-12-18T18:14:41.000Z",permalink:"/pages/9e10e0/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/07.%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/01.%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E6%A0%87%E5%87%86%E5%8C%96.html",relativePath:"01.指南/07.知识产权/01.知识产权标准化.md",key:"v-db48104a",path:"/pages/9e10e0/",headers:[{level:2,title:"1.1 知识产权",slug:"_1-1-知识产权",normalizedTitle:"1.1 知识产权",charIndex:15},{level:2,title:"1.2 保护期限",slug:"_1-2-保护期限",normalizedTitle:"1.2 保护期限",charIndex:277},{level:2,title:"1.3 知识产权人的确定",slug:"_1-3-知识产权人的确定",normalizedTitle:"1.3 知识产权人的确定",charIndex:294},{level:3,title:"1.3.1 职务作品",slug:"_1-3-1-职务作品",normalizedTitle:"1.3.1 职务作品",charIndex:311},{level:3,title:"1.3.2 委托开发、合作开发、商标、专利",slug:"_1-3-2-委托开发、合作开发、商标、专利",normalizedTitle:"1.3.2 委托开发、合作开发、商标、专利",charIndex:328},{level:2,title:"1.4 侵权判定",slug:"_1-4-侵权判定",normalizedTitle:"1.4 侵权判定",charIndex:356}],headersStr:"1.1 知识产权 1.2 保护期限 1.3 知识产权人的确定 1.3.1 职务作品 1.3.2 委托开发、合作开发、商标、专利 1.4 侵权判定",content:"# 1.法律法规知识\n\n\n# 1.1 知识产权\n\n软件知识产权是计算机软件人员对自己的研发成果依法享有的权利。由于软件属于高新科技范畴，目前国际上对软件知识产权的保护法律还不是很健全，大多数国家都是通过著作权法来保护软件知识产权的，与硬件相关密切的软件设计原理还可以申请专利保护。\n\n软件知识产权的内容主要包括著作权、专利权与商标权。\n\n 1. 著作权指软件的表达(如程序代码、文档等)方面的权利。\n 2. 专利权包括软件的技术设计，如程序设计方案、处理问题的方法、各项有关技术信息等方面的权利。\n 3. 商标权则是指软件的名称标识方面的权利。\n\n\n# 1.2 保护期限\n\n\n\n\n\n\n# 1.3 知识产权人的确定\n\n\n# 1.3.1 职务作品\n\n\n\n\n# 1.3.2 委托开发、合作开发、商标、专利\n\n\n\n\n# 1.4 侵权判定\n\n中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。 开发软件所用的思想、处理过程、操作方法或者数学概念不受保护 著作权法不适用于下列情形\n\n * 法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文\n * 时事新闻\n * 历法、通用数表、通用表格和公式\n\n> 如下✔️表示允许，❌表示不允许。\n\n怎样才算不侵权\n\n✔️个人学习、研究或者欣赏\n\n✔️适当引用\n\n✔️公开演讲内容\n\n✔️用于教学或科学研究\n\n✔️是制馆藏作品\n\n✔️免费表演他人作品\n\n✔️室外公共场所艺术品临挛、绘画、摄影、录像\n\n✔️将汉语作品译成少数民族语言作品或盲文出版\n\n怎么样是算侵权\n\n❌未经许可，发表他人作品\n\n❌未经合作作者许可，将与他人合作创作的作品当作自己单独创作的作品发表的\n\n❌未参加创作，在他人作品署名\n\n❌歪曲、篡改他人作品的\n\n❌剽窃他人作品的\n\n❌使用他人作品，未付报酬\n\n❌未经出版者许可，使用其出版的图书期刊的版式没计的\n\n\n# 2.标准化基础知识\n\n标准化分类有如下：\n\n * 国际标准:ISO、IEC等国际标准化组织\n * 国家标准:GB一中国、ANSI一美国、BS一英国JIS一日本\n * 区域标准:又称为地区标准，如PASC一太平洋地区标准会议、CEN一欧洲标准委员会、ASAC一亚洲标准咨询委员会、ARSO一非洲地区标准化组织\n * 行业标准:GJB一中国军用标准、MIT-S一美国军用标准、IEEE一美国电气电子工程师协会\n * 地方标准:国家的地方一级行政机构制订的标准\n * 企业标准\n * 项目规范\n\n标准化代号如下：\n\n * 国际、国外标准代号 : 标准代号+专业类号+顺序号+年代号\n * 我国国家标准代号: 强制性标准代号为GB、推荐性标准代号为GB/T指导性标准代号为GB/Z、实物标准代号GSB\n * 行业标准代号: 由汉语拼音大写字母组成( 如电子行业为SJ )\n * 地方标准代号: 由DB加上省级行政区划代码的前两位\n * 企业标准代号 : 由Q加上企业代号组成",normalizedContent:"# 1.法律法规知识\n\n\n# 1.1 知识产权\n\n软件知识产权是计算机软件人员对自己的研发成果依法享有的权利。由于软件属于高新科技范畴，目前国际上对软件知识产权的保护法律还不是很健全，大多数国家都是通过著作权法来保护软件知识产权的，与硬件相关密切的软件设计原理还可以申请专利保护。\n\n软件知识产权的内容主要包括著作权、专利权与商标权。\n\n 1. 著作权指软件的表达(如程序代码、文档等)方面的权利。\n 2. 专利权包括软件的技术设计，如程序设计方案、处理问题的方法、各项有关技术信息等方面的权利。\n 3. 商标权则是指软件的名称标识方面的权利。\n\n\n# 1.2 保护期限\n\n\n\n\n\n\n# 1.3 知识产权人的确定\n\n\n# 1.3.1 职务作品\n\n\n\n\n# 1.3.2 委托开发、合作开发、商标、专利\n\n\n\n\n# 1.4 侵权判定\n\n中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。 开发软件所用的思想、处理过程、操作方法或者数学概念不受保护 著作权法不适用于下列情形\n\n * 法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文\n * 时事新闻\n * 历法、通用数表、通用表格和公式\n\n> 如下✔️表示允许，❌表示不允许。\n\n怎样才算不侵权\n\n✔️个人学习、研究或者欣赏\n\n✔️适当引用\n\n✔️公开演讲内容\n\n✔️用于教学或科学研究\n\n✔️是制馆藏作品\n\n✔️免费表演他人作品\n\n✔️室外公共场所艺术品临挛、绘画、摄影、录像\n\n✔️将汉语作品译成少数民族语言作品或盲文出版\n\n怎么样是算侵权\n\n❌未经许可，发表他人作品\n\n❌未经合作作者许可，将与他人合作创作的作品当作自己单独创作的作品发表的\n\n❌未参加创作，在他人作品署名\n\n❌歪曲、篡改他人作品的\n\n❌剽窃他人作品的\n\n❌使用他人作品，未付报酬\n\n❌未经出版者许可，使用其出版的图书期刊的版式没计的\n\n\n# 2.标准化基础知识\n\n标准化分类有如下：\n\n * 国际标准:iso、iec等国际标准化组织\n * 国家标准:gb一中国、ansi一美国、bs一英国jis一日本\n * 区域标准:又称为地区标准，如pasc一太平洋地区标准会议、cen一欧洲标准委员会、asac一亚洲标准咨询委员会、arso一非洲地区标准化组织\n * 行业标准:gjb一中国军用标准、mit-s一美国军用标准、ieee一美国电气电子工程师协会\n * 地方标准:国家的地方一级行政机构制订的标准\n * 企业标准\n * 项目规范\n\n标准化代号如下：\n\n * 国际、国外标准代号 : 标准代号+专业类号+顺序号+年代号\n * 我国国家标准代号: 强制性标准代号为gb、推荐性标准代号为gb/t指导性标准代号为gb/z、实物标准代号gsb\n * 行业标准代号: 由汉语拼音大写字母组成( 如电子行业为sj )\n * 地方标准代号: 由db加上省级行政区划代码的前两位\n * 企业标准代号 : 由q加上企业代号组成",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"程序语言设计(上)",frontmatter:{title:"程序语言设计(上)",date:"2022-12-18T18:29:37.000Z",permalink:"/pages/beda9a/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/08.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1(%E4%B8%8A).html",relativePath:"01.指南/08.程序语言设计/01.程序语言设计(上).md",key:"v-4ba6b42a",path:"/pages/beda9a/",headers:[{level:2,title:"程序设计语言（上）",slug:"程序设计语言-上",normalizedTitle:"程序设计语言（上）",charIndex:2},{level:3,title:"1.程序设计语言及其构成",slug:"_1-程序设计语言及其构成",normalizedTitle:"1.程序设计语言及其构成",charIndex:16},{level:4,title:"1.1 程序语言发展阶段",slug:"_1-1-程序语言发展阶段",normalizedTitle:"1.1 程序语言发展阶段",charIndex:32},{level:4,title:"1.2 高级程序设计语言划分",slug:"_1-2-高级程序设计语言划分",normalizedTitle:"1.2 高级程序设计语言划分",charIndex:234},{level:4,title:"1.3 常见的高级程序设计语言",slug:"_1-3-常见的高级程序设计语言",normalizedTitle:"1.3 常见的高级程序设计语言",charIndex:627},{level:4,title:"1.4 标记语言",slug:"_1-4-标记语言",normalizedTitle:"1.4 标记语言",charIndex:1076},{level:4,title:"1.5 程序设计语言及其构成",slug:"_1-5-程序设计语言及其构成",normalizedTitle:"1.5 程序设计语言及其构成",charIndex:1259},{level:3,title:"2.表达式",slug:"_2-表达式",normalizedTitle:"2.表达式",charIndex:1355},{level:3,title:"3.传值和传址调用",slug:"_3-传值和传址调用",normalizedTitle:"3.传值和传址调用",charIndex:1933},{level:3,title:"4.语言处理程序",slug:"_4-语言处理程序",normalizedTitle:"4.语言处理程序",charIndex:2789},{level:3,title:"5.编译程序",slug:"_5-编译程序",normalizedTitle:"5.编译程序",charIndex:3428},{level:3,title:"6.有限自动机和正规式",slug:"_6-有限自动机和正规式",normalizedTitle:"6.有限自动机和正规式",charIndex:4034},{level:4,title:"6.1 正规式",slug:"_6-1-正规式",normalizedTitle:"6.1 正规式",charIndex:4049},{level:4,title:"6.2 正规式与有限自动机的状态转换",slug:"_6-2-正规式与有限自动机的状态转换",normalizedTitle:"6.2 正规式与有限自动机的状态转换",charIndex:4455},{level:4,title:"6.3 有限自动机",slug:"_6-3-有限自动机",normalizedTitle:"6.3 有限自动机",charIndex:4499},{level:4,title:"6.4 非确定的有限自动机(NFA)",slug:"_6-4-非确定的有限自动机-nfa",normalizedTitle:"6.4 非确定的有限自动机(nfa)",charIndex:4806}],headersStr:"程序设计语言（上） 1.程序设计语言及其构成 1.1 程序语言发展阶段 1.2 高级程序设计语言划分 1.3 常见的高级程序设计语言 1.4 标记语言 1.5 程序设计语言及其构成 2.表达式 3.传值和传址调用 4.语言处理程序 5.编译程序 6.有限自动机和正规式 6.1 正规式 6.2 正规式与有限自动机的状态转换 6.3 有限自动机 6.4 非确定的有限自动机(NFA)",content:'# 程序设计语言（上）\n\n\n# 1.程序设计语言及其构成\n\n# 1.1 程序语言发展阶段\n\n计算机要通过程序或指令来控制才能完成各种任务。 程序设计语言（计算机语言）：人与机器交换信息的语言。\n\n阶段：\n\n 1. 机器语言（低级语言）：二进制指令代码，直观性差，容易出错，计算机直接执行\n 2. 汇编语言（低级语言）：用简单的符号代替部分指令，推广移植困难，需经汇编程序转化后执行\n 3. 高级语言：更符号人的思维，易读易记，便于推广，有解释和编译两种执行方式\n\n# 1.2 高级程序设计语言划分\n\n从客观系统描述划分：\n\n * 面向过程语言：\n   * 命令式语言：FORTRAN、ALGOL、COBOL、C和Pascal等\n   * 结构化语言（也属于命令式）：C、Pascal 等\n   * 函数式语言： Lisp 等\n   * 逻辑式编程语言：Prolog 等\n * 面向对象语言：PHP、Delphi、Java、C++、Smalltalk、Python、C# 等\n\n----------------------------------------\n\n从程序执行角度划分：\n\n * 编译类程序设计语言：C、C++、Delphi、Java\n * 解释类程序设计语言：Python、PHP、Ruby、JavaScript\n * 脚本语言：通常为解释执行。JavaScript为客户端脚本语言，Python、Ruby、PHP 为服务器端脚本语言\n\n# 1.3 常见的高级程序设计语言\n\n * Fortran语言：第一个高级程序设计语言，用于并行计算、科学计算和高性能计算。\n * Lisp语言：函数式程序语言，符号处理，人工智能\n * Prolog ：逻辑式语言，建造专家系统、自然语言理解、智能知识库等\n * SQL：结构化查询语言，特殊目的的编程语言，用于查询、更新和管理关系数据库\n\n通用的程序设计语言：C、C#、C++、Java、PHP、Python、JavaScript 等。\n\n * C语言：通用、结构化程序设计语言，简洁丰富可移植，能访问操作系统和底层硬件。\n * C#语言：面向对象，运行于 .NET Framework\n * C++语言：C语言基础上增加了类机制，面向对象，高效\n * Java语言：面向对象，跨平台，通用的程序设计语言\n * Php：服务端执行、嵌入HTML文档的脚本语言，制作动态网页\n * Python：面向对象，解释型程序设计语言，通用的脚本语言\n * JavaScript 语言：为网页添加动态功能\n\n# 1.4 标记语言\n\n非编程语言，不包含任何逻辑或算法\n\n常见有：\n\n * HTML ： HyperText Markup Language，超文本标记语言\n * XML ： Extensible Markup Language，可扩展标记语言\n * XHTML ：Extensible HyperText Markup Language，扩展的超文本标记语言\n\n# 1.5 程序设计语言及其构成\n\n数据成分： 常量、变量、全局量、局部量以及数据类型。\n\n运算成分：程序语言允许使用运算符号及运算规则。\n\n控制成分：顺序结构、选择结构、循环结构。\n\n\n\n\n# 2.表达式\n\n表达式的分类有如下：\n\n * 前缀表达式 +ab\n * 中缀表达式 a+b\n * 后缀表达式（逆波兰式） ab+\n\n示例： \n\n将中缀表达式(a-b)*(c+5)转为后缀表达式\n首先注意计算的顺序 a-b 、c+5、最后是 *\n得到结果 ab- c5+ *\n\n\n后缀表达式的运算过程（转为中缀表达式）\n\n使用栈可以很方便的进行运算，运算过程如下：\n\n 1. 遇到运算对象压入到栈里面\n 2. 遇到运算符从栈中取出两个对象，并进行计算\n 3. 将计算的结果再压入到栈里面\n 4. 重复上述过程，直到结束\n\n上面的例子 (a-b)*(c+5)，转为后缀表达式 ab- c5+ *\n\n将a、b入栈\n遇到运算符*-* ⇒ 进行 a-b 运算 ⇒ 计算结果x压入栈\n将 c、5如入栈\n遇到 + ⇒ 进行 c-5 运算 ⇒ 将计算结果 y 压入栈\n遇到 * ⇒ 进行 x*y 运算 ⇒ 将计算结果 压入栈\n\n\n> 金典练习：\n\n算术表达式采用后缀式表示时不需要使用括号，使用（）就可以方便地进行求值。a－b*（c＋d）的后缀式为（）。\n\nA. 队列 \nB. 数组 \nC.栈 \nD. 广义表\n\nA. a b c d- * +\nB. a b c d * + -\nC. a b – c * d +\nD. a b c d + * -\n\n答案 C 、D\n\n\n\n# 3.传值和传址调用\n\n▶数据类型：\n\n数据值是否改变：\n\n * 常量：只有右值，值不能改变\n * 变量：有左值和右值，值可改变\n\n作用域：\n\n * 全局变量：存储空间一般不变\n * 局部变量：存储空间动态变化\n\n数据类型：\n\n * 基本类型： int、char、float、double、bool\n * 特殊类型：void\n * 用于定义类型：enum\n * 构造类型：数组、结构、联合\n * 指针类型：type *\n * 抽象数据类型：类类型\n\n传递方式       主要特点\n传值调用       形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变\n引用（传址）调用   形参取的是实参的地址，即相当于实参存储的是地址引用，因此其值的改变同时改变了实参的值。\n           参数的左值为地址，右值为具体的值。\n\n1.传值调用示例：\n\nvoid swap( int x, int y) {\n    int t;\n    t=x;x=y;y=t;\n    printf("%d %d", x, y);\n}\n \nmain() {\n    int a=3,b=4;\n    swap(a,b);\n    printf("%d %d", a, b);\n}\n\n\n// 刚刚开始调用的时候 a=3, b=4, x=3, y=4\n// 执行完之后，a=3, b=4, x=4, y=3\n\n\n2.传址调用示例：\n\nvoid swap( int *x, int *y) {\n    int a, *t = &a;\n    *t=*x;*x=*y;*y=*t;\n    printf("%d %d", *x, *y);\n}\n \nmain() {\n    int a=3,b=4;\n    swap(&a, &b);\n    printf("%d %d", a, b);\n}\n\n// 刚刚开始调用的时候 a=3, b=4, x=3, y=4\n// 执行完之后，a=4, 3=4, x=4, y=3\n\n\n\n# 4.语言处理程序\n\n * 语言处理程序：将高级语言转换成计算机可执行的机器语言，分为汇编、编译和解释程序\n * 汇编程序：翻译由汇编语言编写的程序\n * 解释程序：针对高级编写的源程序，直接解释执行源程序\n * 编译程序：源程序翻译成目标语言程序，然后执行目标程序\n\n\n\n▶汇编程序\n\n把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。\n\n汇编程序输入的是用汇编语言书写的源程序，输出的是用机器语言表示的目标程序。\n\n汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。\n\n * **第一次扫描：**定义符号的值并创建符号表 ST。汇编器中，利用了LC（地址跟踪计数器）。LC是汇编语言的指针，每识别出1个指令，LC就增加1。\n * 第二次扫描：生成机器语言，产生目标程序。第一次扫描已经生成了符号表，第二次扫描时即可利用汇编器的“指令表”将对应的指令翻译成机器指令，同时将LC执行的内存地址填入机器码或数值。\n\n▶解释程序\n\n解释程序是一种语言处理程序。\n\n在词法、语法和语义分析方面与编译程序的工作原理基本相同。\n\n但在运行用户程序时，它直接执行源程序或源程序的内部形式（中间代码）。\n\n解释程序并不产生目标程序，这是它和编译程序的主要区别。\n\n▶高级语言执行过程\n\n用高级语言编写出的程序要能在计算机上运行时，由于计算机识别二进制，因此需要对源程序依次进行预处理、编译和链接的过程，才能确保源程序正确被执行。\n\n\n\n\n# 5.编译程序\n\n▶编译过程\n\n编译程序的功能是把某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言程序或机器语言程序）。编译程序的工作可分为6个阶段，如下图所示，实际的编辑可能会将其中的某些阶段结合在一起进行处理。\n\n\n\n> 注意：在编译阶段，语义检查属于静态语义检查。动态语义检查是在运行阶段进行的。\n\n\n\n▶词法分析\n\n词法分析：从左到右逐个扫码源程序中的字符，识别其中的关键字（或保留字）、标识符、常数、运算符、分隔符（标点符号和括号）等\n\n▶语法分析\n\n语法分析：根据语法规则将单词符号分解成各类语法单位，并分析源程序是否存在语法上的错误。包括：语言结构错误、if...end不匹配、缺少分号、括号不匹配、表达式缺少操作数等。\n\n▶语义分析\n\n语义分析：进行类型分析和检查，主要检测程序是否存在静态语义错误。包括：运算符和运算类型不符合，如取余时用浮点数。\n\n▶出错处理\n\n静态错误：\n\n * 编译时所发现的程序错误（编译正确的程序没有静态错误）\n * 分为语法错误和静态语义错误。\n * 语法错误包括：单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。\n * 静态语义错误：运算符和运算类型不符合等错误。\n\n动态错误：\n\n * 发生在程序运行时（程序可通过编译）\n * 也叫动态语义错误\n * 包括：陷入死循环、变量取零时做除数、引用数组下标越界等错误。\n\n\n# 6.有限自动机和正规式\n\n# 6.1 正规式\n\n正规式：由正规文法转换而来，通常正规文法等价于正规式。\n\n文法产生式   正规式         \n规则1     A→xB, B→y   A=xy\n规则2     A→xA|y      A=x*y\n规则3     A→x, A→y    A=x|y\n\n> *表示可以出现0次或任意多次\n> \n> x|y表示可能x、也可能是y\n\n正规式         正规集\nab          符号串ab构成的集合\na|b         字符串a、b构成的集合\na*          由0个或多个a构成的符号串集合\n(a|b)*      所有字符a和b构成的串的集合\na(a|b)*     a为首字符的a、b字符串集合\n(a|b)*abb   以abb结尾的a、b字符串的集合\n\n> ab：只有一种情况，就是 ab\n> \n> a|b：有两种情况，a或者b\n> \n> a*：有无数种情况\n\n# 6.2 正规式与有限自动机的状态转换\n\n正规式与有限自动机的状态转换图的关系\n\n\n\n# 6.3 有限自动机\n\n有限自动机是在词法分析阶段使用的，它分为确定的有限自动机（DFA）和非确定的有限自动机（NDFA）\n\n> 任何一个有穷的序列，经过有穷步转移后，都能落到一个具体的状态上，有穷自动机能够判断是接受还是拒绝。\n\nDFA的定义\n\nDFA定义，M = ( S, ∑, f, q₀, Z )，其中\n\nS：有穷状态集\n\n∑：输入字母表；\n\nf ：S × ∑ → S 转移函数，表示一个状态的后续状态有若干个\n\n(S × ∑* → S 转移函数，扩展转移函数)\n\nq₀ ∈ S ：初始状态\n\nZ ⊆ S ：接受状态（终结状态）集合\n\nL(M) = { w ∈ ∑* | f(q₀,w) ∈ Z }\n\n\n# 6.4 非确定的有限自动机(NFA)\n\n确定的有限自动机，它所有的状态的下一个状态是唯一确定的。\n\n非确定的有限自动机的下一个状态是可以不唯一确定\n\n * ε移动：不需要任何输入符号，就可以从一个状态转到另一个状态。例如下图的 q2 可以不输入符号直接转成 q3\n * 多种选择（含0种选择）：比如下图的中 q1状态下，输入1时可以转成q2，也可以原地不动（2种选择）；q3状态下输入0，无路可走，没有选择（0种选择）。\n\n\n\n> 原文出自：\n> \n> https://blog.csdn.net/chenjian723122704/article/details/124516183',normalizedContent:'# 程序设计语言（上）\n\n\n# 1.程序设计语言及其构成\n\n# 1.1 程序语言发展阶段\n\n计算机要通过程序或指令来控制才能完成各种任务。 程序设计语言（计算机语言）：人与机器交换信息的语言。\n\n阶段：\n\n 1. 机器语言（低级语言）：二进制指令代码，直观性差，容易出错，计算机直接执行\n 2. 汇编语言（低级语言）：用简单的符号代替部分指令，推广移植困难，需经汇编程序转化后执行\n 3. 高级语言：更符号人的思维，易读易记，便于推广，有解释和编译两种执行方式\n\n# 1.2 高级程序设计语言划分\n\n从客观系统描述划分：\n\n * 面向过程语言：\n   * 命令式语言：fortran、algol、cobol、c和pascal等\n   * 结构化语言（也属于命令式）：c、pascal 等\n   * 函数式语言： lisp 等\n   * 逻辑式编程语言：prolog 等\n * 面向对象语言：php、delphi、java、c++、smalltalk、python、c# 等\n\n----------------------------------------\n\n从程序执行角度划分：\n\n * 编译类程序设计语言：c、c++、delphi、java\n * 解释类程序设计语言：python、php、ruby、javascript\n * 脚本语言：通常为解释执行。javascript为客户端脚本语言，python、ruby、php 为服务器端脚本语言\n\n# 1.3 常见的高级程序设计语言\n\n * fortran语言：第一个高级程序设计语言，用于并行计算、科学计算和高性能计算。\n * lisp语言：函数式程序语言，符号处理，人工智能\n * prolog ：逻辑式语言，建造专家系统、自然语言理解、智能知识库等\n * sql：结构化查询语言，特殊目的的编程语言，用于查询、更新和管理关系数据库\n\n通用的程序设计语言：c、c#、c++、java、php、python、javascript 等。\n\n * c语言：通用、结构化程序设计语言，简洁丰富可移植，能访问操作系统和底层硬件。\n * c#语言：面向对象，运行于 .net framework\n * c++语言：c语言基础上增加了类机制，面向对象，高效\n * java语言：面向对象，跨平台，通用的程序设计语言\n * php：服务端执行、嵌入html文档的脚本语言，制作动态网页\n * python：面向对象，解释型程序设计语言，通用的脚本语言\n * javascript 语言：为网页添加动态功能\n\n# 1.4 标记语言\n\n非编程语言，不包含任何逻辑或算法\n\n常见有：\n\n * html ： hypertext markup language，超文本标记语言\n * xml ： extensible markup language，可扩展标记语言\n * xhtml ：extensible hypertext markup language，扩展的超文本标记语言\n\n# 1.5 程序设计语言及其构成\n\n数据成分： 常量、变量、全局量、局部量以及数据类型。\n\n运算成分：程序语言允许使用运算符号及运算规则。\n\n控制成分：顺序结构、选择结构、循环结构。\n\n\n\n\n# 2.表达式\n\n表达式的分类有如下：\n\n * 前缀表达式 +ab\n * 中缀表达式 a+b\n * 后缀表达式（逆波兰式） ab+\n\n示例： \n\n将中缀表达式(a-b)*(c+5)转为后缀表达式\n首先注意计算的顺序 a-b 、c+5、最后是 *\n得到结果 ab- c5+ *\n\n\n后缀表达式的运算过程（转为中缀表达式）\n\n使用栈可以很方便的进行运算，运算过程如下：\n\n 1. 遇到运算对象压入到栈里面\n 2. 遇到运算符从栈中取出两个对象，并进行计算\n 3. 将计算的结果再压入到栈里面\n 4. 重复上述过程，直到结束\n\n上面的例子 (a-b)*(c+5)，转为后缀表达式 ab- c5+ *\n\n将a、b入栈\n遇到运算符*-* ⇒ 进行 a-b 运算 ⇒ 计算结果x压入栈\n将 c、5如入栈\n遇到 + ⇒ 进行 c-5 运算 ⇒ 将计算结果 y 压入栈\n遇到 * ⇒ 进行 x*y 运算 ⇒ 将计算结果 压入栈\n\n\n> 金典练习：\n\n算术表达式采用后缀式表示时不需要使用括号，使用（）就可以方便地进行求值。a－b*（c＋d）的后缀式为（）。\n\na. 队列 \nb. 数组 \nc.栈 \nd. 广义表\n\na. a b c d- * +\nb. a b c d * + -\nc. a b – c * d +\nd. a b c d + * -\n\n答案 c 、d\n\n\n\n# 3.传值和传址调用\n\n▶数据类型：\n\n数据值是否改变：\n\n * 常量：只有右值，值不能改变\n * 变量：有左值和右值，值可改变\n\n作用域：\n\n * 全局变量：存储空间一般不变\n * 局部变量：存储空间动态变化\n\n数据类型：\n\n * 基本类型： int、char、float、double、bool\n * 特殊类型：void\n * 用于定义类型：enum\n * 构造类型：数组、结构、联合\n * 指针类型：type *\n * 抽象数据类型：类类型\n\n传递方式       主要特点\n传值调用       形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变\n引用（传址）调用   形参取的是实参的地址，即相当于实参存储的是地址引用，因此其值的改变同时改变了实参的值。\n           参数的左值为地址，右值为具体的值。\n\n1.传值调用示例：\n\nvoid swap( int x, int y) {\n    int t;\n    t=x;x=y;y=t;\n    printf("%d %d", x, y);\n}\n \nmain() {\n    int a=3,b=4;\n    swap(a,b);\n    printf("%d %d", a, b);\n}\n\n\n// 刚刚开始调用的时候 a=3, b=4, x=3, y=4\n// 执行完之后，a=3, b=4, x=4, y=3\n\n\n2.传址调用示例：\n\nvoid swap( int *x, int *y) {\n    int a, *t = &a;\n    *t=*x;*x=*y;*y=*t;\n    printf("%d %d", *x, *y);\n}\n \nmain() {\n    int a=3,b=4;\n    swap(&a, &b);\n    printf("%d %d", a, b);\n}\n\n// 刚刚开始调用的时候 a=3, b=4, x=3, y=4\n// 执行完之后，a=4, 3=4, x=4, y=3\n\n\n\n# 4.语言处理程序\n\n * 语言处理程序：将高级语言转换成计算机可执行的机器语言，分为汇编、编译和解释程序\n * 汇编程序：翻译由汇编语言编写的程序\n * 解释程序：针对高级编写的源程序，直接解释执行源程序\n * 编译程序：源程序翻译成目标语言程序，然后执行目标程序\n\n\n\n▶汇编程序\n\n把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。\n\n汇编程序输入的是用汇编语言书写的源程序，输出的是用机器语言表示的目标程序。\n\n汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。\n\n * **第一次扫描：**定义符号的值并创建符号表 st。汇编器中，利用了lc（地址跟踪计数器）。lc是汇编语言的指针，每识别出1个指令，lc就增加1。\n * 第二次扫描：生成机器语言，产生目标程序。第一次扫描已经生成了符号表，第二次扫描时即可利用汇编器的“指令表”将对应的指令翻译成机器指令，同时将lc执行的内存地址填入机器码或数值。\n\n▶解释程序\n\n解释程序是一种语言处理程序。\n\n在词法、语法和语义分析方面与编译程序的工作原理基本相同。\n\n但在运行用户程序时，它直接执行源程序或源程序的内部形式（中间代码）。\n\n解释程序并不产生目标程序，这是它和编译程序的主要区别。\n\n▶高级语言执行过程\n\n用高级语言编写出的程序要能在计算机上运行时，由于计算机识别二进制，因此需要对源程序依次进行预处理、编译和链接的过程，才能确保源程序正确被执行。\n\n\n\n\n# 5.编译程序\n\n▶编译过程\n\n编译程序的功能是把某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言程序或机器语言程序）。编译程序的工作可分为6个阶段，如下图所示，实际的编辑可能会将其中的某些阶段结合在一起进行处理。\n\n\n\n> 注意：在编译阶段，语义检查属于静态语义检查。动态语义检查是在运行阶段进行的。\n\n\n\n▶词法分析\n\n词法分析：从左到右逐个扫码源程序中的字符，识别其中的关键字（或保留字）、标识符、常数、运算符、分隔符（标点符号和括号）等\n\n▶语法分析\n\n语法分析：根据语法规则将单词符号分解成各类语法单位，并分析源程序是否存在语法上的错误。包括：语言结构错误、if...end不匹配、缺少分号、括号不匹配、表达式缺少操作数等。\n\n▶语义分析\n\n语义分析：进行类型分析和检查，主要检测程序是否存在静态语义错误。包括：运算符和运算类型不符合，如取余时用浮点数。\n\n▶出错处理\n\n静态错误：\n\n * 编译时所发现的程序错误（编译正确的程序没有静态错误）\n * 分为语法错误和静态语义错误。\n * 语法错误包括：单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。\n * 静态语义错误：运算符和运算类型不符合等错误。\n\n动态错误：\n\n * 发生在程序运行时（程序可通过编译）\n * 也叫动态语义错误\n * 包括：陷入死循环、变量取零时做除数、引用数组下标越界等错误。\n\n\n# 6.有限自动机和正规式\n\n# 6.1 正规式\n\n正规式：由正规文法转换而来，通常正规文法等价于正规式。\n\n文法产生式   正规式         \n规则1     a→xb, b→y   a=xy\n规则2     a→xa|y      a=x*y\n规则3     a→x, a→y    a=x|y\n\n> *表示可以出现0次或任意多次\n> \n> x|y表示可能x、也可能是y\n\n正规式         正规集\nab          符号串ab构成的集合\na|b         字符串a、b构成的集合\na*          由0个或多个a构成的符号串集合\n(a|b)*      所有字符a和b构成的串的集合\na(a|b)*     a为首字符的a、b字符串集合\n(a|b)*abb   以abb结尾的a、b字符串的集合\n\n> ab：只有一种情况，就是 ab\n> \n> a|b：有两种情况，a或者b\n> \n> a*：有无数种情况\n\n# 6.2 正规式与有限自动机的状态转换\n\n正规式与有限自动机的状态转换图的关系\n\n\n\n# 6.3 有限自动机\n\n有限自动机是在词法分析阶段使用的，它分为确定的有限自动机（dfa）和非确定的有限自动机（ndfa）\n\n> 任何一个有穷的序列，经过有穷步转移后，都能落到一个具体的状态上，有穷自动机能够判断是接受还是拒绝。\n\ndfa的定义\n\ndfa定义，m = ( s, ∑, f, q₀, z )，其中\n\ns：有穷状态集\n\n∑：输入字母表；\n\nf ：s × ∑ → s 转移函数，表示一个状态的后续状态有若干个\n\n(s × ∑* → s 转移函数，扩展转移函数)\n\nq₀ ∈ s ：初始状态\n\nz ⊆ s ：接受状态（终结状态）集合\n\nl(m) = { w ∈ ∑* | f(q₀,w) ∈ z }\n\n\n# 6.4 非确定的有限自动机(nfa)\n\n确定的有限自动机，它所有的状态的下一个状态是唯一确定的。\n\n非确定的有限自动机的下一个状态是可以不唯一确定\n\n * ε移动：不需要任何输入符号，就可以从一个状态转到另一个状态。例如下图的 q2 可以不输入符号直接转成 q3\n * 多种选择（含0种选择）：比如下图的中 q1状态下，输入1时可以转成q2，也可以原地不动（2种选择）；q3状态下输入0，无路可走，没有选择（0种选择）。\n\n\n\n> 原文出自：\n> \n> https://blog.csdn.net/chenjian723122704/article/details/124516183',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"程序设计语言(下)",frontmatter:{title:"程序设计语言(下)",date:"2022-12-18T18:28:45.000Z",permalink:"/pages/76f52a/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/08.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/02.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1(%E4%B8%8B).html",relativePath:"01.指南/08.程序语言设计/02.程序语言设计(下).md",key:"v-fba7452c",path:"/pages/76f52a/",headers:[{level:2,title:"文章目录",slug:"文章目录",normalizedTitle:"文章目录",charIndex:16},{level:2,title:"1.低级语言和高级语言",slug:"_1-低级语言和高级语言",normalizedTitle:"1.低级语言和高级语言",charIndex:37},{level:2,title:"2.编译程序和解释程序",slug:"_2-编译程序和解释程序",normalizedTitle:"2.编译程序和解释程序",charIndex:54},{level:2,title:"3.程序设计语言的数据成分",slug:"_3-程序设计语言的数据成分",normalizedTitle:"3.程序设计语言的数据成分",charIndex:71},{level:2,title:"4.传值调用与传地址调用",slug:"_4-传值调用与传地址调用",normalizedTitle:"4.传值调用与传地址调用",charIndex:90},{level:2,title:"5.编译、解释程序翻译阶段",slug:"_5-编译、解释程序翻译阶段",normalizedTitle:"5.编译、解释程序翻译阶段",charIndex:108},{level:2,title:"6.符号表",slug:"_6-符号表",normalizedTitle:"6.符号表",charIndex:127},{level:2,title:"7.词法分析、语法分析与语义分析",slug:"_7-词法分析、语法分析与语义分析",normalizedTitle:"7.词法分析、语法分析与语义分析",charIndex:138},{level:2,title:"8.目标代码的生成",slug:"_8-目标代码的生成",normalizedTitle:"8.目标代码的生成",charIndex:160},{level:2,title:"9.中间代码",slug:"_9-中间代码",normalizedTitle:"9.中间代码",charIndex:175},{level:2,title:"10.正规式",slug:"_10-正规式",normalizedTitle:"10.正规式",charIndex:187},{level:2,title:"11.有限自动机",slug:"_11-有限自动机",normalizedTitle:"11.有限自动机",charIndex:199},{level:2,title:"12.上下文无关文法",slug:"_12-上下文无关文法",normalizedTitle:"12.上下文无关文法",charIndex:213},{level:2,title:"13.中缀、后缀表达式及转换",slug:"_13-中缀、后缀表达式及转换",normalizedTitle:"13.中缀、后缀表达式及转换",charIndex:229}],headersStr:"文章目录 1.低级语言和高级语言 2.编译程序和解释程序 3.程序设计语言的数据成分 4.传值调用与传地址调用 5.编译、解释程序翻译阶段 6.符号表 7.词法分析、语法分析与语义分析 8.目标代码的生成 9.中间代码 10.正规式 11.有限自动机 12.上下文无关文法 13.中缀、后缀表达式及转换",content:"# 程序设计语言（下）\n\n\n# 文章目录\n\n * 程序设计语言\n * * 1.低级语言和高级语言\n   * 2.编译程序和解释程序\n   * 3.程序设计语言的数据成分\n   * 4.传值调用与传地址调用\n   * 5.编译、解释程序翻译阶段\n   * 6.符号表\n   * 7.词法分析、语法分析与语义分析\n   * 8.目标代码的生成\n   * 9.中间代码\n   * 10.正规式\n   * 11.有限自动机\n   * 12.上下文无关文法\n   * 13.中缀、后缀表达式及转换\n\n\n# 1.低级语言和高级语言\n\n\n\n----------------------------------------\n\n\n# 2.编译程序和解释程序\n\n\n\n----------------------------------------\n\n\n# 3.程序设计语言的数据成分\n\n\n\n----------------------------------------\n\n\n# 4.传值调用与传地址调用\n\n\n\n----------------------------------------\n\n\n# 5.编译、解释程序翻译阶段\n\n\n\n----------------------------------------\n\n\n# 6.符号表\n\n\n\n----------------------------------------\n\n\n# 7.词法分析、语法分析与语义分析\n\n\n\n\n\n\n\n\n\n----------------------------------------\n\n\n# 8.目标代码的生成\n\n\n\n----------------------------------------\n\n\n# 9.中间代码\n\n\n\n----------------------------------------\n\n\n# 10.正规式\n\n\n\n----------------------------------------\n\n\n# 11.有限自动机\n\n\n\n\n\n----------------------------------------\n\n\n# 12.上下文无关文法\n\n\n\n----------------------------------------\n\n\n# 13.中缀、后缀表达式及转换\n\n",normalizedContent:"# 程序设计语言（下）\n\n\n# 文章目录\n\n * 程序设计语言\n * * 1.低级语言和高级语言\n   * 2.编译程序和解释程序\n   * 3.程序设计语言的数据成分\n   * 4.传值调用与传地址调用\n   * 5.编译、解释程序翻译阶段\n   * 6.符号表\n   * 7.词法分析、语法分析与语义分析\n   * 8.目标代码的生成\n   * 9.中间代码\n   * 10.正规式\n   * 11.有限自动机\n   * 12.上下文无关文法\n   * 13.中缀、后缀表达式及转换\n\n\n# 1.低级语言和高级语言\n\n\n\n----------------------------------------\n\n\n# 2.编译程序和解释程序\n\n\n\n----------------------------------------\n\n\n# 3.程序设计语言的数据成分\n\n\n\n----------------------------------------\n\n\n# 4.传值调用与传地址调用\n\n\n\n----------------------------------------\n\n\n# 5.编译、解释程序翻译阶段\n\n\n\n----------------------------------------\n\n\n# 6.符号表\n\n\n\n----------------------------------------\n\n\n# 7.词法分析、语法分析与语义分析\n\n\n\n\n\n\n\n\n\n----------------------------------------\n\n\n# 8.目标代码的生成\n\n\n\n----------------------------------------\n\n\n# 9.中间代码\n\n\n\n----------------------------------------\n\n\n# 10.正规式\n\n\n\n----------------------------------------\n\n\n# 11.有限自动机\n\n\n\n\n\n----------------------------------------\n\n\n# 12.上下文无关文法\n\n\n\n----------------------------------------\n\n\n# 13.中缀、后缀表达式及转换\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"软件工程基础知识",frontmatter:{title:"软件工程基础知识",date:"2022-12-18T19:31:03.000Z",permalink:"/pages/52aecc/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/09.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/01.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"01.指南/09.软件工程/01.软件工程基础知识.md",key:"v-6faa9299",path:"/pages/52aecc/",headers:[{level:2,title:"1.软件工程基础知识",slug:"_1-软件工程基础知识",normalizedTitle:"1.软件工程基础知识",charIndex:2},{level:3,title:"1.1 软件过程",slug:"_1-1-软件过程",normalizedTitle:"1.1 软件过程",charIndex:17},{level:3,title:"1.2 软件过程开发模型",slug:"_1-2-软件过程开发模型",normalizedTitle:"1.2 软件过程开发模型",charIndex:558},{level:4,title:"1.2.1 开发模型",slug:"_1-2-1-开发模型",normalizedTitle:"1.2.1 开发模型",charIndex:574},{level:4,title:"1.2.2 统一过程",slug:"_1-2-2-统一过程",normalizedTitle:"1.2.2 统一过程",charIndex:1751},{level:4,title:"1.2.3 敏捷方法",slug:"_1-2-3-敏捷方法",normalizedTitle:"1.2.3 敏捷方法",charIndex:2248},{level:3,title:"1.4  软件开发方法",slug:"_1-4-软件开发方法",normalizedTitle:"1.4  软件开发方法",charIndex:null},{level:4,title:"1.4.1 开发方法分类",slug:"_1-4-1-开发方法分类",normalizedTitle:"1.4.1 开发方法分类",charIndex:2813},{level:4,title:"1.4.2 需求分析",slug:"_1-4-2-需求分析",normalizedTitle:"1.4.2 需求分析",charIndex:3209},{level:4,title:"1.4.3 系统设计",slug:"_1-4-3-系统设计",normalizedTitle:"1.4.3 系统设计",charIndex:3246},{level:3,title:"1.5 软件设计的原则",slug:"_1-5-软件设计的原则",normalizedTitle:"1.5 软件设计的原则",charIndex:3640},{level:3,title:"1.6 系统和软件测试",slug:"_1-6-系统和软件测试",normalizedTitle:"1.6 系统和软件测试",charIndex:4262},{level:4,title:"1.6.1系统测试",slug:"_1-6-1系统测试",normalizedTitle:"1.6.1系统测试",charIndex:4277},{level:4,title:"1.6.2 软件测试",slug:"_1-6-2-软件测试",normalizedTitle:"1.6.2 软件测试",charIndex:5067},{level:3,title:"1.7 环路复杂度",slug:"_1-7-环路复杂度",normalizedTitle:"1.7 环路复杂度",charIndex:5747},{level:3,title:"1.8 软件维护类型",slug:"_1-8-软件维护类型",normalizedTitle:"1.8 软件维护类型",charIndex:5910},{level:3,title:"1.9 软件质量特性",slug:"_1-9-软件质量特性",normalizedTitle:"1.9 软件质量特性",charIndex:6229},{level:3,title:"1.10 软件项目管理",slug:"_1-10-软件项目管理",normalizedTitle:"1.10 软件项目管理",charIndex:6275},{level:3,title:"1.11 项目进度管理",slug:"_1-11-项目进度管理",normalizedTitle:"1.11 项目进度管理",charIndex:6615},{level:3,title:"1.12 软件风险",slug:"_1-12-软件风险",normalizedTitle:"1.12 软件风险",charIndex:7213}],headersStr:"1.软件工程基础知识 1.1 软件过程 1.2 软件过程开发模型 1.2.1 开发模型 1.2.2 统一过程 1.2.3 敏捷方法 1.4  软件开发方法 1.4.1 开发方法分类 1.4.2 需求分析 1.4.3 系统设计 1.5 软件设计的原则 1.6 系统和软件测试 1.6.1系统测试 1.6.2 软件测试 1.7 环路复杂度 1.8 软件维护类型 1.9 软件质量特性 1.10 软件项目管理 1.11 项目进度管理 1.12 软件风险",content:"# 1.软件工程基础知识\n\n\n# 1.1 软件过程\n\n能力成熟度模型（CMM）：对软件组织进化阶段的描述。CMM将软件过程分为5个成熟度级别。\n\n 1. 初始级：软件过程的特点是杂乱无章。\n 2. 可重复级：建立了基本的项目管理过程和实践来跟踪项目费用、进度等，有必要的过程准则。\n 3. 已定义级：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。\n 4. 已管理级：制定了软件过程和产品质量的详细度量标准。\n 5. 优化级：加强了定量分析。通过过程质量反馈等不断持续更新地改进。\n 6. 能力成熟度模型集成（CMMI）：若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能提高过程质量和工作效率。CMMI提供的两种表示方法：\n\n阶段式模型：类似CMM，关注组织的成熟度。\n\n 1. 初始的 ：过程不可预测且缺乏控制\n 2. 已管理的：过程为项目服务。\n 3. 已定义的：过程为组织服务\n 4. 定量管理的：过程已度量和控制\n 5. 优化的：集中于过程改进。\n\n连续式模型：关注每个过程域的能力。6个过程域能力等级。CL0（未完成的）、CL1（已执行的）、CL2（已管理的）、CL3（已定义的）、CL4（已定量管理的）、CL5（优化的）\n\n\n# 1.2 软件过程开发模型\n\n# 1.2.1 开发模型\n\n模型          要点\n瀑布模型        适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目。\nV模型         强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。\n原型模型        典型的原型开发方法模型。适用于需求不明确的场景，构造简易系统，可以帮助用户明确需求。\n增量模型        融合了瀑布模型的基本成分和原型实现的迭代特征，可以有多个可用版本的发布，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。\n螺旋模型        典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。属于面向对象开发模型，强调风险引入。\n喷泉模型        典型的面向对象的模型。特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交义。\n统一过程模型      典型特点是用例驱动、以架构为中心、迭代和增量。统一过程把一个项目分为四个不同的阶段：\n            构思阶段：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。\n            细化阶段：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。\n            构建阶段：将设计转化为实现，并进行集成和测试。\n            移交阶段：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善\n敏捷开发        敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。\n            (1）极限编程是一种轻量级的开发方法，它提出了四大价值观:沟通、简单、反馈、勇气。五大原则:快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践:计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。\n            (2）水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。\n            (3）并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。\n            (4）自适应软件开发的核心是三个非线性的，重叠的开发阶段:猜测、合作、学习。\n基于构件的开发模型   构件的复用\n\n# 1.2.2 统一过程\n\n（在软件设计师考试中UP、RUP都指统一过程）：典型特点是用例和风险驱动、以架构为中心、迭代和增量的开发过程。由UML方法和工具支持。统一过程把一个项目分为四个不同的阶段：\n\n 1. 构思（起始）阶段 ：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型，产生的主要工作产品有构想文档、初始用例模型、起始风险评估、项目计划（阶段及迭代）、业务模型等。\n 2. 细化（精化）阶段 ：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示，对最初的领域范围进行需求分析和架构演进，产生的主要工作产品：用例模型、补充需求，分析模型，软件体系结构描述，项目计划（迭代计划，调整的工作流，里程碑和技术产品）和初始用户手册。\n 3. 构建阶段 ：将设计转化为实现，并进行集成和测试，产生的产品：集成的软件增量、测试计划和步骤，测试用例和支持文档（用户手册，安装手册等）。\n 4. 移交阶段 ：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。产生的主要工作产品：提交的软件增量、测试报告，用户反馈。\n\n# 1.2.3 敏捷方法\n\n敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想，敏捷方法使用户能够在开发周期的后期增加或改变需求。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。\n\n 1. 极限编程（XP）是一种轻量级、高效、低风险、柔性、可预测的、科学的开发方法，由价值观、原则、实践、行为组成，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结队编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。\n 2. 水晶法（Crystal，最少纪律约束）：强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。\n 3. 并列争求法（Scrum，明确定义可重复的方法过程）：核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件，协调是通过简短的日常情况会议来进行。\n 4. 自适应软件开发（ASD）：核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。有一个使命作为指导，重做与做同样关键。变化被视为对软件开发实际情况的调整，开发人员认真考虑每个版本的关键需求。\n\n\n# 1.4 软件开发方法\n\n# 1.4.1 开发方法分类\n\n✨结构化开发方法\n\n 1. 用户至上\n 2. 严格区分工作阶段，每阶段有任务与成果\n 3. 强调系统开发过程的整体性和全局性\n 4. 系统开发过程工程化，文档资料标准化\n 5. 自顶向下，逐步分解（求精）\n\n✨原型开发方法\n\n 1. 适用于需求不明确的开发\n 2. 包括抛弃式原型和演化式原型\n 3. 面向对象的开发方法\n\n✨更好的复用性\n\n 1. 关键在于建立一个全面、合理、统一的模型\n 2. 分析、设计、实现三个阶段,界限不明确\n\n✨面向服务的开发方法\n\n 1. 面向对象更高标准的抽象。\n 2. SO方法有三个主要的抽象级别：操作、服务、业务流程\n 3. SOAD分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口和服务级协定）和业务组织层（业务流程建模和服务流程编排）\n 4. 服务建模：分为服务发现、服务规约和服务实现三个阶段\n\n# 1.4.2 需求分析\n\n需求的分类：功能需求、非功能需求、设计约束\n\n# 1.4.3 系统设计\n\n大体上可分为概要设计和详细设计软件 设计工具：IPO图（输入处理输出图）、PDL（程序描述语言）、PAD（问题分析图）、程序流程图、N/S盒图\n\n（1）概要设计：\n\n * 设计软件系统总体结构：将一个复杂的系统按功能划分为模块，确定每个模块的功能等。\n * 数据结构及数据库设计：逐步细化的方法也适用于数据结构设计，对需求分析阶段的数据字典加以细化，宜使用抽象的数据类型。数据库的设计是指数据存储文件的设计，包括概要设计、逻辑设计、物理设计。\n * 编写概要设计文档：概要设计说明书、数据库设计说明书、用户手册及修订测试计划\n * 评审\n\n（2）详细设计：\n\n * 对每个模块进行详细的算法设计\n * 对模块内的数据结构进行设计\n * 对数据库进行物理设计\n * 其他设计：代码设计、用户界面设计、输入输出格式设计。\n * 编写详细设计说明书\n * 评审\n\n\n# 1.5 软件设计的原则\n\n> 软件设计的原则：高内聚、低耦合\n\n内聚类型   描述\n偶然聚合   模块完成的动作之间没有任何关系，或者仅仅是一种非常松散的关系。\n逻辑聚合   模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。\n时间聚合   模块内部的各个组成部分所包含的处理动作必须在同一时间内执行。\n过程聚合   模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。\n通信聚合   模块的各个组成部分所完成的动作都使用了同一个数据或产生同一输出数据。\n顺序聚合   模块内部的各个部分，前一部分处理动作的最后输出是后一部分处理动作的输入。\n功能聚合   模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都必不可少\n\n耦合类型    描述\n非直接耦合   两个模块之间没有直接关系，它们的联系完全是通过主模块的控制和调用来实现的。\n数据耦合    两个模块彼此间通过数据参数交换信息。\n标记耦合    一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。\n控制耦合    两个模块彼此间传递的信息中有控制信息。\n外部耦合    一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息。\n公共耦合    两个模块之间通过一个公共的数据区域传递信息。\n内容耦合    一个模块需要涉及到另一个模块的内部信息。\n\n\n# 1.6 系统和软件测试\n\n# 1.6.1系统测试\n\n有效的软件测试分为4步进行，即单元测试、集成测试、确认测试、系统测试.\n\n * 单元测试：也称为模块测试，侧重于模块中的内部处理逻辑和数据结构。如果用机器测试一般采用白盒测试。主要检查模块的以下5个特征：模块接口、局部数据结构、边界条件、独立的路径（重要的执行路径）、错误处理。 单元测试过程：驱动模块（相当于主程序，接收测试例子的数据）、桩模块（也称为存根模块，用来代替测试模块中调用的子模块）\n * 集成测试：模块间的接口和通信，旨在发现于接口相关的错误测试。集成测试方法：非增量集成（并行工作，不过容易混乱）、增量集成。下面是几种增量集成策略。\n * 确认测试（验收测试）：在进行确认测试或系统测试时，传统软件、面对对象软件及WebApp之间的差别已经消失，测试集中于用户可见的动作和用户可识别的系统输出。包括确认测试准则、配置评审、验收测试（由最终用户进行，有a测试，β测试）\n * 系统测试：通常与系统的需求相比较。有恢复测试、安全性测试、压力测试、性能测试、部署测试\n\n集成测试有如下几种：\n\n 1. 自顶向下集成测试：可采用深度优先或广度优先的集成方法，可以执行回归测试\n 2. 自底向上集成测试：从原子模块开始进行构造和测试。\n 3. 回归测试：重新执行已测试过的某些子集，修改软件后进行的测试，以确保变更没有传播不期望的副作用。\n 4. 冒烟测试：常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。包括活动有：把软件构建集成在构件中；设计一系列测试；每天将该构建与其它构建或软件产品集成进行冒烟测试。可以自顶向下也可以自底向上。\n\n确认测试有如下几种：\n\n 1. a测试：由由代表性的最终用户在开发者场所进行，开发者在场，在受控环境进行。\n 2. β测试：在一个或多个最终用户场所进行，开发者不在场。\n\n# 1.6.2 软件测试\n\n\n\n软件测试的分类：\n\n黑盒测试：等价类划分、边界值分析、错误推测、因果图。\n\n白盒测试：语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。\n\n灰盒测试\n\n常见的黑盒测试方法：不考虑软件内部结构和特性，测试软件外部特性。\n\n * 等价类划分：将输入域划分为若干个等价类。分为有效等价类和无效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。\n * 边界值分析：处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值。\n\n常见的白盒测试方法：根据程序内部结构和逻辑设计测试用例，对程序的路径和过程进行测试。\n\n * 语句覆盖：语句覆盖是指选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次。【最弱覆盖】\n * 判定覆盖：判定覆盖又称为分支覆盖，它的含义是，不仅每个语句至少执行一次，而且每个判定的每种可能的结果（分支）都至少执行一次。\n * 条件覆盖：条件覆盖的含义是，不仅每个语句至少执行一次，而且使得判定表达式中的每个条件都取得各种可能的结果。【条件不一定包含判定，反之亦然】\n * 判定/条件覆盖：同时满足判定覆盖和条件覆盖的逻辑覆盖。\n * 条件组合覆盖：使判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例一定满足判断覆盖、条件覆盖、判定/条件覆盖。\n * 路径覆盖：它的含义是，选取足够多的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）【包含判定覆盖，但不包含条件覆盖】\n\n\n# 1.7 环路复杂度\n\nMcCabe复杂度（至少需要多少个测试用例）计算公式：V(G)=m-n+2，其中m是有向弧的条数，n是结点数。也可用封闭区域+1来算\n\n对于伪代码可以先转换为程序流程图，对程序流程图可以最终转换为结点图处理，转换时注意将交点的地方标注为新的结点，以最终的结点图带入公式结算其McCabe复杂度。\n\n\n# 1.8 软件维护类型\n\n1.系统可维护性的评价指标：可理解性、可测试性、可修改性。\n\n2.系统维护主要硬件维护、软件维护、数据维护。软件维护包括下面几方面：\n\n维护类型    描述\n正确性维护   针对真实存在并已经发生的错误进行的维护行为。\n预防性维护   针对真实存在但还未发生的错误进行的维护。\n适应性维护   指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。\n完善性维护   扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。\n\n3.软件文档管理：分为开发文档、产品文档、管理文档\n\n\n# 1.9 软件质量特性\n\n图中的可移植性：包括适应性，易安装性，一致性，易替换性\n\n\n\n\n# 1.10 软件项目管理\n\n 1. 有效的项目管理集中在4P上，人员、产品、过程、项目\n 2. 软件项目估算：\n    * COCOMO模型：分为基本COCOMO模型（静态单变量模型，对整个软件系统进行估算）、中级COCOMO模型（静态多变量模型，将软件系统模型分为系统和部件两个层次）、详细COCOMO模型（将软件系统分为系统、子系统、模块三部分）\n    * COCOMOⅡ：层次结构的估算模型，分为三个阶段：应用组装模型：使用的是对象点。早期设计阶段模型：在需求稳定，建立基本体系结构时使用，使用的时功能点，功能点可以转换为代码行。体系结构阶段模型：在软件的构造过程使用。\n    * Putnam模型：动态多变量模型，假设软件开发在整个生产周期工作量有特定的分布。\n\n\n# 1.11 项目进度管理\n\n 1. 甘特图（Gantt）：以日历为基准描述项目任务。能够消晰描述每个任务的开始/结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，但难以反映多个任务之间存在的逻辑关系。\n 2. PERT图：是一个有向图，利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，给出了开始结束时间和完成任务所需时间，但不能反映任务之间的并行性，以及项目的当前进展情况，虚箭头表示两个任务存在制约或依赖关系。\n 3. 关键路径法是图中源点至汇点的最长路径，关键路径的时间称之为项目工期，也表述为项目完成所需的最少时间。\n 4. 总时差：在不延误总工期的前提下，该活动的机动时间。一般在图中，以最晚结束时间减去最早结束时间求取，或以最晚开始时间减去最早开始时间求取。\n 5. 对于网络图我们一般采用关键路径分析法处理，关键路径法是利用进度模型时使用的一种进度网络分析技术。沿着项目进度网络路线进行正向与反向分析，从而计算出所有计划活动理论上的最早开始与完成日期、最迟开始与完成日期，不考虑任何资源限制。\n 6. 松弛度：不影响整个工期的前提下，完成该任务有多少机动余地，EF-LF\n 7. 单代号网络图：结点表示活动，箭线表示活动与活动间的依赖关系。\n\n\n\n 8. 双代号网络图：结点表示里程碑，箭线表示活动。\n\n\n\n\n# 1.12 软件风险\n\n 1. 风险的特性：具有不确定性，可能会造成损失。\n 2. 风险的类别：项目风险涉及到各种形式的预算、进度、人员、资源以及客户相关的问题，并且可能导致项目损失。技术风险涉及到技术相关的可能会导致项目损失的问题。商业风险与市场因素相关。社会风险涉及到政策、法规等因素。\n 3. 风险暴露又称风险曝光度，测量的是资产的整个安全性风险，它将表示实际损失的可能性与表示大量可能损失的资讯结合到单一数字评估中。在形式最简单的定量性风险分析中，风险曝光度可透过将风险可能性及影响相乘算出。风险曝光度（RiskExposure）=错误出现率（风险出现率）X错误造成损失（风险损失）。\n 4. 风险控制：风险避免、风险监控、RMMM计划（将所有风险分析工作文档化）",normalizedContent:"# 1.软件工程基础知识\n\n\n# 1.1 软件过程\n\n能力成熟度模型（cmm）：对软件组织进化阶段的描述。cmm将软件过程分为5个成熟度级别。\n\n 1. 初始级：软件过程的特点是杂乱无章。\n 2. 可重复级：建立了基本的项目管理过程和实践来跟踪项目费用、进度等，有必要的过程准则。\n 3. 已定义级：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。\n 4. 已管理级：制定了软件过程和产品质量的详细度量标准。\n 5. 优化级：加强了定量分析。通过过程质量反馈等不断持续更新地改进。\n 6. 能力成熟度模型集成（cmmi）：若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能提高过程质量和工作效率。cmmi提供的两种表示方法：\n\n阶段式模型：类似cmm，关注组织的成熟度。\n\n 1. 初始的 ：过程不可预测且缺乏控制\n 2. 已管理的：过程为项目服务。\n 3. 已定义的：过程为组织服务\n 4. 定量管理的：过程已度量和控制\n 5. 优化的：集中于过程改进。\n\n连续式模型：关注每个过程域的能力。6个过程域能力等级。cl0（未完成的）、cl1（已执行的）、cl2（已管理的）、cl3（已定义的）、cl4（已定量管理的）、cl5（优化的）\n\n\n# 1.2 软件过程开发模型\n\n# 1.2.1 开发模型\n\n模型          要点\n瀑布模型        适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目。\nv模型         强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。\n原型模型        典型的原型开发方法模型。适用于需求不明确的场景，构造简易系统，可以帮助用户明确需求。\n增量模型        融合了瀑布模型的基本成分和原型实现的迭代特征，可以有多个可用版本的发布，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。\n螺旋模型        典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。属于面向对象开发模型，强调风险引入。\n喷泉模型        典型的面向对象的模型。特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交义。\n统一过程模型      典型特点是用例驱动、以架构为中心、迭代和增量。统一过程把一个项目分为四个不同的阶段：\n            构思阶段：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。\n            细化阶段：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。\n            构建阶段：将设计转化为实现，并进行集成和测试。\n            移交阶段：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善\n敏捷开发        敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。\n            (1）极限编程是一种轻量级的开发方法，它提出了四大价值观:沟通、简单、反馈、勇气。五大原则:快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践:计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。\n            (2）水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。\n            (3）并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。\n            (4）自适应软件开发的核心是三个非线性的，重叠的开发阶段:猜测、合作、学习。\n基于构件的开发模型   构件的复用\n\n# 1.2.2 统一过程\n\n（在软件设计师考试中up、rup都指统一过程）：典型特点是用例和风险驱动、以架构为中心、迭代和增量的开发过程。由uml方法和工具支持。统一过程把一个项目分为四个不同的阶段：\n\n 1. 构思（起始）阶段 ：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型，产生的主要工作产品有构想文档、初始用例模型、起始风险评估、项目计划（阶段及迭代）、业务模型等。\n 2. 细化（精化）阶段 ：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示，对最初的领域范围进行需求分析和架构演进，产生的主要工作产品：用例模型、补充需求，分析模型，软件体系结构描述，项目计划（迭代计划，调整的工作流，里程碑和技术产品）和初始用户手册。\n 3. 构建阶段 ：将设计转化为实现，并进行集成和测试，产生的产品：集成的软件增量、测试计划和步骤，测试用例和支持文档（用户手册，安装手册等）。\n 4. 移交阶段 ：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。产生的主要工作产品：提交的软件增量、测试报告，用户反馈。\n\n# 1.2.3 敏捷方法\n\n敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想，敏捷方法使用户能够在开发周期的后期增加或改变需求。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。\n\n 1. 极限编程（xp）是一种轻量级、高效、低风险、柔性、可预测的、科学的开发方法，由价值观、原则、实践、行为组成，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结队编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。\n 2. 水晶法（crystal，最少纪律约束）：强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。\n 3. 并列争求法（scrum，明确定义可重复的方法过程）：核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件，协调是通过简短的日常情况会议来进行。\n 4. 自适应软件开发（asd）：核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。有一个使命作为指导，重做与做同样关键。变化被视为对软件开发实际情况的调整，开发人员认真考虑每个版本的关键需求。\n\n\n# 1.4 软件开发方法\n\n# 1.4.1 开发方法分类\n\n✨结构化开发方法\n\n 1. 用户至上\n 2. 严格区分工作阶段，每阶段有任务与成果\n 3. 强调系统开发过程的整体性和全局性\n 4. 系统开发过程工程化，文档资料标准化\n 5. 自顶向下，逐步分解（求精）\n\n✨原型开发方法\n\n 1. 适用于需求不明确的开发\n 2. 包括抛弃式原型和演化式原型\n 3. 面向对象的开发方法\n\n✨更好的复用性\n\n 1. 关键在于建立一个全面、合理、统一的模型\n 2. 分析、设计、实现三个阶段,界限不明确\n\n✨面向服务的开发方法\n\n 1. 面向对象更高标准的抽象。\n 2. so方法有三个主要的抽象级别：操作、服务、业务流程\n 3. soad分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口和服务级协定）和业务组织层（业务流程建模和服务流程编排）\n 4. 服务建模：分为服务发现、服务规约和服务实现三个阶段\n\n# 1.4.2 需求分析\n\n需求的分类：功能需求、非功能需求、设计约束\n\n# 1.4.3 系统设计\n\n大体上可分为概要设计和详细设计软件 设计工具：ipo图（输入处理输出图）、pdl（程序描述语言）、pad（问题分析图）、程序流程图、n/s盒图\n\n（1）概要设计：\n\n * 设计软件系统总体结构：将一个复杂的系统按功能划分为模块，确定每个模块的功能等。\n * 数据结构及数据库设计：逐步细化的方法也适用于数据结构设计，对需求分析阶段的数据字典加以细化，宜使用抽象的数据类型。数据库的设计是指数据存储文件的设计，包括概要设计、逻辑设计、物理设计。\n * 编写概要设计文档：概要设计说明书、数据库设计说明书、用户手册及修订测试计划\n * 评审\n\n（2）详细设计：\n\n * 对每个模块进行详细的算法设计\n * 对模块内的数据结构进行设计\n * 对数据库进行物理设计\n * 其他设计：代码设计、用户界面设计、输入输出格式设计。\n * 编写详细设计说明书\n * 评审\n\n\n# 1.5 软件设计的原则\n\n> 软件设计的原则：高内聚、低耦合\n\n内聚类型   描述\n偶然聚合   模块完成的动作之间没有任何关系，或者仅仅是一种非常松散的关系。\n逻辑聚合   模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。\n时间聚合   模块内部的各个组成部分所包含的处理动作必须在同一时间内执行。\n过程聚合   模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。\n通信聚合   模块的各个组成部分所完成的动作都使用了同一个数据或产生同一输出数据。\n顺序聚合   模块内部的各个部分，前一部分处理动作的最后输出是后一部分处理动作的输入。\n功能聚合   模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都必不可少\n\n耦合类型    描述\n非直接耦合   两个模块之间没有直接关系，它们的联系完全是通过主模块的控制和调用来实现的。\n数据耦合    两个模块彼此间通过数据参数交换信息。\n标记耦合    一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。\n控制耦合    两个模块彼此间传递的信息中有控制信息。\n外部耦合    一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息。\n公共耦合    两个模块之间通过一个公共的数据区域传递信息。\n内容耦合    一个模块需要涉及到另一个模块的内部信息。\n\n\n# 1.6 系统和软件测试\n\n# 1.6.1系统测试\n\n有效的软件测试分为4步进行，即单元测试、集成测试、确认测试、系统测试.\n\n * 单元测试：也称为模块测试，侧重于模块中的内部处理逻辑和数据结构。如果用机器测试一般采用白盒测试。主要检查模块的以下5个特征：模块接口、局部数据结构、边界条件、独立的路径（重要的执行路径）、错误处理。 单元测试过程：驱动模块（相当于主程序，接收测试例子的数据）、桩模块（也称为存根模块，用来代替测试模块中调用的子模块）\n * 集成测试：模块间的接口和通信，旨在发现于接口相关的错误测试。集成测试方法：非增量集成（并行工作，不过容易混乱）、增量集成。下面是几种增量集成策略。\n * 确认测试（验收测试）：在进行确认测试或系统测试时，传统软件、面对对象软件及webapp之间的差别已经消失，测试集中于用户可见的动作和用户可识别的系统输出。包括确认测试准则、配置评审、验收测试（由最终用户进行，有a测试，β测试）\n * 系统测试：通常与系统的需求相比较。有恢复测试、安全性测试、压力测试、性能测试、部署测试\n\n集成测试有如下几种：\n\n 1. 自顶向下集成测试：可采用深度优先或广度优先的集成方法，可以执行回归测试\n 2. 自底向上集成测试：从原子模块开始进行构造和测试。\n 3. 回归测试：重新执行已测试过的某些子集，修改软件后进行的测试，以确保变更没有传播不期望的副作用。\n 4. 冒烟测试：常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。包括活动有：把软件构建集成在构件中；设计一系列测试；每天将该构建与其它构建或软件产品集成进行冒烟测试。可以自顶向下也可以自底向上。\n\n确认测试有如下几种：\n\n 1. a测试：由由代表性的最终用户在开发者场所进行，开发者在场，在受控环境进行。\n 2. β测试：在一个或多个最终用户场所进行，开发者不在场。\n\n# 1.6.2 软件测试\n\n\n\n软件测试的分类：\n\n黑盒测试：等价类划分、边界值分析、错误推测、因果图。\n\n白盒测试：语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。\n\n灰盒测试\n\n常见的黑盒测试方法：不考虑软件内部结构和特性，测试软件外部特性。\n\n * 等价类划分：将输入域划分为若干个等价类。分为有效等价类和无效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。\n * 边界值分析：处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值。\n\n常见的白盒测试方法：根据程序内部结构和逻辑设计测试用例，对程序的路径和过程进行测试。\n\n * 语句覆盖：语句覆盖是指选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次。【最弱覆盖】\n * 判定覆盖：判定覆盖又称为分支覆盖，它的含义是，不仅每个语句至少执行一次，而且每个判定的每种可能的结果（分支）都至少执行一次。\n * 条件覆盖：条件覆盖的含义是，不仅每个语句至少执行一次，而且使得判定表达式中的每个条件都取得各种可能的结果。【条件不一定包含判定，反之亦然】\n * 判定/条件覆盖：同时满足判定覆盖和条件覆盖的逻辑覆盖。\n * 条件组合覆盖：使判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例一定满足判断覆盖、条件覆盖、判定/条件覆盖。\n * 路径覆盖：它的含义是，选取足够多的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）【包含判定覆盖，但不包含条件覆盖】\n\n\n# 1.7 环路复杂度\n\nmccabe复杂度（至少需要多少个测试用例）计算公式：v(g)=m-n+2，其中m是有向弧的条数，n是结点数。也可用封闭区域+1来算\n\n对于伪代码可以先转换为程序流程图，对程序流程图可以最终转换为结点图处理，转换时注意将交点的地方标注为新的结点，以最终的结点图带入公式结算其mccabe复杂度。\n\n\n# 1.8 软件维护类型\n\n1.系统可维护性的评价指标：可理解性、可测试性、可修改性。\n\n2.系统维护主要硬件维护、软件维护、数据维护。软件维护包括下面几方面：\n\n维护类型    描述\n正确性维护   针对真实存在并已经发生的错误进行的维护行为。\n预防性维护   针对真实存在但还未发生的错误进行的维护。\n适应性维护   指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。\n完善性维护   扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。\n\n3.软件文档管理：分为开发文档、产品文档、管理文档\n\n\n# 1.9 软件质量特性\n\n图中的可移植性：包括适应性，易安装性，一致性，易替换性\n\n\n\n\n# 1.10 软件项目管理\n\n 1. 有效的项目管理集中在4p上，人员、产品、过程、项目\n 2. 软件项目估算：\n    * cocomo模型：分为基本cocomo模型（静态单变量模型，对整个软件系统进行估算）、中级cocomo模型（静态多变量模型，将软件系统模型分为系统和部件两个层次）、详细cocomo模型（将软件系统分为系统、子系统、模块三部分）\n    * cocomoⅱ：层次结构的估算模型，分为三个阶段：应用组装模型：使用的是对象点。早期设计阶段模型：在需求稳定，建立基本体系结构时使用，使用的时功能点，功能点可以转换为代码行。体系结构阶段模型：在软件的构造过程使用。\n    * putnam模型：动态多变量模型，假设软件开发在整个生产周期工作量有特定的分布。\n\n\n# 1.11 项目进度管理\n\n 1. 甘特图（gantt）：以日历为基准描述项目任务。能够消晰描述每个任务的开始/结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，但难以反映多个任务之间存在的逻辑关系。\n 2. pert图：是一个有向图，利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，给出了开始结束时间和完成任务所需时间，但不能反映任务之间的并行性，以及项目的当前进展情况，虚箭头表示两个任务存在制约或依赖关系。\n 3. 关键路径法是图中源点至汇点的最长路径，关键路径的时间称之为项目工期，也表述为项目完成所需的最少时间。\n 4. 总时差：在不延误总工期的前提下，该活动的机动时间。一般在图中，以最晚结束时间减去最早结束时间求取，或以最晚开始时间减去最早开始时间求取。\n 5. 对于网络图我们一般采用关键路径分析法处理，关键路径法是利用进度模型时使用的一种进度网络分析技术。沿着项目进度网络路线进行正向与反向分析，从而计算出所有计划活动理论上的最早开始与完成日期、最迟开始与完成日期，不考虑任何资源限制。\n 6. 松弛度：不影响整个工期的前提下，完成该任务有多少机动余地，ef-lf\n 7. 单代号网络图：结点表示活动，箭线表示活动与活动间的依赖关系。\n\n\n\n 8. 双代号网络图：结点表示里程碑，箭线表示活动。\n\n\n\n\n# 1.12 软件风险\n\n 1. 风险的特性：具有不确定性，可能会造成损失。\n 2. 风险的类别：项目风险涉及到各种形式的预算、进度、人员、资源以及客户相关的问题，并且可能导致项目损失。技术风险涉及到技术相关的可能会导致项目损失的问题。商业风险与市场因素相关。社会风险涉及到政策、法规等因素。\n 3. 风险暴露又称风险曝光度，测量的是资产的整个安全性风险，它将表示实际损失的可能性与表示大量可能损失的资讯结合到单一数字评估中。在形式最简单的定量性风险分析中，风险曝光度可透过将风险可能性及影响相乘算出。风险曝光度（riskexposure）=错误出现率（风险出现率）x错误造成损失（风险损失）。\n 4. 风险控制：风险避免、风险监控、rmmm计划（将所有风险分析工作文档化）",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"软件工程题目",frontmatter:{title:"软件工程题目",date:"2022-12-18T20:09:27.000Z",permalink:"/pages/4e3563/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/09.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%A2%98%E7%9B%AE.html",relativePath:"01.指南/09.软件工程/02.软件工程题目.md",key:"v-c1e4cbf0",path:"/pages/4e3563/",headers:[{level:2,title:"软件工程题目",slug:"软件工程题目",normalizedTitle:"软件工程题目",charIndex:2}],headersStr:"软件工程题目",content:'# 软件工程题目\n\n 1.  若用户需求不清晰且经常发生变化，但系统规模不太大且不太复杂，则最适宜采用（）开发方法，对于数据处理领域的问题，若系统规模不太大且不太复杂，需求变化也不大，则最适宜采用（）开发方法。\n     \n     问题一 A. 结构化\n     \n     B. Jackson\n     \n     C. 原型化\n     \n     D. 面向对象\n     \n     问题二\n     \n     A. 结构化\n     \n     B. Jackson\n     \n     C. 原型化\n     \n     D. 面向对象\n     \n     【试题解析】∶在本题的两个空中，第1个空比较容易，由于题目明确说明"用户需求不清晰且经常发生变化"所以只有原型化方法适用。而第2空需求变化不大的情况下，其实多种模型都可用，所以另一条线索成为解题关键，即"数据处理领域问题"。结构化方法的基本特征是:自顶向下，逐层分解，也适合于大型的数据处理系统，所以用他最合适。\n\n 2.  以下关于结构化开发方法的叙述中，不正确的是（）。\n     \n     A. 总的指导思想是自顶向下，逐层分解\n     \n     B. 基本原则是功能的分解与抽象\n     \n     C. 与面向对象开发方法相比，更适合于大规模、特别复杂的项目\n     \n     D. 特别适合于数据处理领域的项目\n     \n     【试题解析】∶结构化开发方法是一种面向数据流的开发方法，其基本思想是软件功能的分解和抽象。结构化开发方法又称生命周期法，是迄今为止最传统、应用最广泛的一种信息系统开发方法。结构化开发方法采用系统工程的思想和工程化的方法，按用户至上的原则，结构化、模块化、自顶向下地对信息系统进行分析与设计。该方法严格按照信息系统开发的阶段性开展设计工作，每个阶段都产生一定的设计成果，通过评估后再进入下一阶段开发工作。因此，结构化开发方法具有以下优点：\n     \n     * 开发工作的顺序性、阶段性适合初学者参与软件的开发\n     \n     * 开发工作的阶段性评估可以减少开发工作重复性和提高开发的成功率\n     \n     * 该方法有利于提高系统开发的正确性、可靠性和可维护性\n     \n     * 具有完整的开发质量保证措施\n     \n     * 结构化开发方法存在的不足主要是开发周期太长，个性化开发阶段的文档编写工作量过大或过于烦琐，无法发挥开发人员的个性化开发能力。一般来说，结构化开发方法主要适用于组织规模较大、组织结构相对稳定的企业，这些大型企业往往业务处理过程规范、信息系统数据需求非常明确，在一定时期内需求变化不大。\n\n 3.  以下关于结构化开发方法的叙述中，不正确的是（）。\n     \n     A. 将数据流映射为软件系统的模块结构\n     \n     B. —般情况下，数据流类型包括变换流型和事务流型\n     \n     C. 不同类型的数据流有不同的映射方法\n     \n     D. 一个软件系统只有一种数据流类型\n     \n     【试题解析】∶面向数据流的设计是以需求分析阶段产生的数据流图为基础，按一定的步骤映射成软件结构，因此又称结构化设计。该方法由美国IBM公司L.Constantine和E.Yourdon等人于1974年提出，与结构化分析(SA)衔接，构成了完整的结构化分析与设计技术，是目前使用最广泛的软件设计方法之一。 各种软件系统，不论DFD如何庞大和复杂，一般可分为变换型和事务型，一个软件系统既可以只有一种数据流类型，也可以是两种数据流类型。在结构化设计中，可以将数据流映射为软件系统的模块结构，不同类型的数据流有不同的映射方法。\n\n 4.  极限编程(extreme Programming）是一种轻量级软件开发方法，（）不是它强调的准则。\n     \n     A. 持续的交流和沟通\n     \n     B. 用最简单的设计实现用户需求\n     \n     C. 用测试驱动开发\n     \n     D. 关注用户反馈\n     \n     【试题解析】∶极限编程（ extreme Programming.XP)是1998年由Kent Beck首先提出的一种轻量级的软件开发方法，同时也是一种非常严谨和周密的方法。这种方法强调交流、简单、反馈和勇气4项原则，也就是说一个软件项目可以从4个方面进行改善:加强交流;从简单做起;寻求反饿;勇于实事求是。XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期。通过积极的交流、反馈以及其他一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和可能存在的困难等，并根据实际情况及时地调整开发过程。\n\n 5.  面向对象开发方法的基本思想是尽可能按照人类认识客观世界的方法来分析和解决问题，（）方法不属于面向对象方法。\n     \n     A. Booch\n     \n     B. Coad\n     \n     C. OMT\n     \n     D. Jackson\n     \n     【试题解析】∶本题考查面向对象开发方法。面向对象开发方法有Booch方法、Coad方法和OMT方法。Jackson方法是一种面向数据结构的开发方法。\n\n 6.  若某模块内所有处理元素都在同一个数据结构上操作，则该模块的内聚类型为（）。\n     \n     A. 逻辑\n     \n     B. 过程\n     \n     C. 通信\n     \n     D. 功能\n     \n     【试题解析】∶\n     \n     \n\n 7.  某模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一处理元素的输出就是下一处理元素的输入，则该模块的内聚类型为（）内聚。\n     \n     A. 过程\n     \n     B. 时间\n     \n     C. 顺序\n     \n     D. 逻辑\n     \n     【试题解析】∶A选项过程内聚。如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。 B选项时间内聚。如果一个模块完成的功能必须在同一时间内执行(如系统初始化)，但这些功能只是因为时间因素关联在一起，则称为时间内聚。 C选项顺序内聚。如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。本题描述的是C选项。 D选项逻辑内聚。几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。如一个模块读取各种不同类型外设的输入。尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。\n\n 8.  某模块内涉及多个功能，这些功能必须以特定的次序执行，则该模块的内聚类型为（）内聚。\n     \n     A. 过程\n     \n     B. 时间\n     \n     C. 信息\n     \n     D. 功能\n     \n     【试题解析】∶要求功能是以特定的次序执行，所以是过程内聚。\n\n 9.  模块A、B和C有相同的程序块，块内的语句之间没有任何联系，现把该程序块取出来，形成新的模块D，则模块D的内聚类型为（）内聚。以下关于该内聚类型的叙述中，不正确的是（）。\n     \n     问题一\n     \n     A. 巧合\n     \n     B. 逻辑\n     \n     C. 时间\n     \n     D. 过程\n     \n     问题二\n     \n     A. 具有最低的内聚性\n     \n     B. 不易修改和维护\n     \n     C. 不易理解\n     \n     D. 不影响模块间的耦合关系\n     \n     【试题解析】∶功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。 顺序内聚：处理元素相关，而且必须顺序执行。 通信内聚：所有处理元素集中在一个数据结构的区域上。 过程内聚：处理元素相关，而且必须按特定的次序执行。 瞬时内聚：所包含的任务必须在同一时间间隔内执行(如初始化模块)。 逻辑内聚：完成逻辑上相关的一组任务。 偶然内聚：完成一组没有关系或松散关系的任务。 巧合内聚就是偶然内聚。偶然内聚由于内容都是不相关的，所以必然导致它与外界多个模块有关联，这也使得模块间的耦合度增加。\n\n 10. 某模块中有两个处理 A 和 B，分别对数据结构X写数据和读数据，则该模块的内聚类型为（）内聚。\n     \n     A. 逻辑\n     \n     B. 过程\n     \n     C. 通信\n     \n     D. 内容\n     \n     【试题解析】∶如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。本题为通信内聚。 逻辑聚合：模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。 过程聚合：模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。 内容耦合：—个模块需要涉及另一个模块的内部信息。\n\n 11. 模块A执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，则该模块具有（）内聚\n     \n     A. 顺序\n     \n     B. 过程\n     \n     C. 逻辑\n     \n     D. 功能\n     \n     【试题解析】∶内聚是指模块内部各元素之间联系的紧密程度，模块的内聚类型通常可以分为7种，根据内聚度从高到低排序分别如下： 功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。 顺序内聚：处理元素相关，而且必须顺序执行。 通信内聚：所有处理元素集中在一个数据结构的区域上。 过程内聚：处理元素相关，而且必须按特定的次序执行。 瞬时内聚：所包含的任务必须在同一时间间隔内执行(如初始化模块)。 逻辑内聚：完成逻辑上相关的一组任务。 偶然内聚：完成一组没有关系或松散关系的任务。\n\n 12. 内聚是—种指标，表示一个模块（）。\n     \n     A. 代码优化的程度\n     \n     B. 代码功能的集中程度\n     \n     C. 完成任务的及时程度\n     \n     D. 为了与其他模块连接所要完成的工作量\n     \n     【试题解析】∶本题考查软件模块化的基本概念。 模块的内聚性表现了模块内部各个子成分功能的集中程度，分为6级，如下图所示:\n\n 13. 模块A通过非正常入口转入模块B内部，则这两个模块之间是（）耦合。\n     \n     A. 数据\n     \n     B. 公共\n     \n     C. 外部\n     \n     D. 内容\n     \n     【试题解析】∶数据耦合是通过参数表传递简单信息。 公共耦合是多个模块访问同一个公共数据环境。 外部耦合是一组模块访问同一个全局简单变量而没有通过参数表传递。 内容耦合是一个模块直接访问另一个模块的内部数据;一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠;一个模块有多个入口。本题描述的是内容耦合。\n     \n     \n\n 14. 已知模块 A 给模块 B 传递数据结构 X，则这两个模块的耦合类型为（）。\n     \n     A. 数据耦合\n     \n     B. 公共耦合\n     \n     C. 外部耦合\n     \n     D. 标记耦合\n     \n     【试题解析】∶数据耦合:一个模块访问另一个模块时，彼此之间是通过简单数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的。 公共耦合:若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 外部耦合:一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 标记耦合︰一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。本题描述的是标记耦合。\n\n 15. 某企业管理信息系统中，采购子系统根据材料价格、数量等信息计算采购的金额，并给财务子系统传递采购金额、收款方和采购日期等信息，则这两个子系统之间的耦合类型为（）耦合。\n     \n     A. 数据\n     \n     B. 标记\n     \n     C. 控制\n     \n     D. 外部\n     \n     【试题解析】∶非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的。 标记耦合：一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。其实传递的是这个数据结构的地址; 控制耦合：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 内容耦合：如果发生下列情形，两个模块之间就发生了内容耦合。 (1）一个模块直接访问另一个模块的内部数据; (2）一个模块不通过正常入口转到另一模块内部; (3）两个模块有一部分程序代码重叠(只可能出现在汇编语言中)； (4）一个模块有多个入口。 根据本题题干描述，采购子系统"给财务子系统传递采购金额、收款方和采购日期等信息”，传递时应将这些数据包装在数据结构中，因此二者之间是标记耦合。\n\n 16. 耦合是模块之间的相对独立性(互相连接的紧密程度）的度量。耦合程度不取决于（）。\n     \n     A. 调用模块的方式\n     \n     B. 各个模块之间接口的复杂程度\n     \n     C. 通过接口的信息类型\n     \n     D. 模块提供的功能数\n     \n     【试题解析】∶耦合性也叫块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块之间越独立则越差，模块间耦合的高低取决于模块间接口的复杂性，调用的方式以及传递的信息。\n\n 17. 模块A将学生信息，即学生姓名、学号、手机号等放到一个结构体中，传递给模块B。模块A和B之间的耦合类型为（）耦合。\n     \n     A. 数据\n     \n     B. 标记\n     \n     C. 控制\n     \n     D. 内容\n     \n     【试题解析】∶数据耦合：两个模块彼此间通过数据参数交换信息。 标记耦合：一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。 控制耦合：两个模块彼此间传递的信息中有控制信息。 内容耦合：一个模块需要涉及另一个模块的内部信息。 本题应该选择B选项。\n\n 18. 模块A直接访问模块B的内部数据，则模块A和模块B的耦合类型为（）。\n     \n     A. 数据耦合\n     \n     B. 标记耦合\n     \n     C. 公共耦合\n     \n     D. 内容耦合\n     \n     【试题解析】∶耦合是指两个或两个以上的模块相互依赖于对方的一个量度。它可以分为非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合及内容耦合等。 当一个模块直接修改或操作另一个模块的数据或者直接转入另一个模块时，就发生了内容耦合。所以本题的答案选D。\n\n 19. 下图中的程序由A、B、C、D、E5个模块组成，下表中描述了这些模块之间的接口，每一个接口有一个编号。此外，模块A、D和E都要引用一个专用数据区。那么 A 和 E 之间耦合关系是（）。\n     \n     \n\nA. 公共耦合\n\nB. 数据耦合\n\nC. 内容耦合\n\nD. 无耦合\n\n【试题解析】∶由于模块A和模块E都引用了专用数据区的内容，所以是公共耦合。\n\n 20. 耦合度描述了（）。\n     \n     A. 模块内各种元素结合的程度\n     \n     B. 模块内多个功能之间的接口\n     \n     C. 模块之间公共数据的数量\n     \n     D. 模块之间相互关联的程度\n     \n     【试题解析】∶本题考查软件模块化的基本概念。 模块的耦合度表现了模块之间相互关联的程度，分为b级，如下图所示:\n\n 21. 以下关于软件设计原则的叙述中，不正确的是（）。\n     \n     A. 将系统划分为相对独立的模块\n     \n     B. 模块之间的耦合尽可能小\n     \n     C. 模块规模越小越好\n     \n     D. 模块的扇入系数和扇出系数合理\n     \n     【试题解析】∶软件设计原则始终强调高内聚、低耦合的设计原则。具体包括: 保持模块的大小适中 尽可能减少调用的深度 多扇入，少扇出。 单入口，单出口 模块的作用域应该在模块之内 功能应该是可以被预测的。 综上所述，仅有C选项模块规模越小越好是不符合设计原则的。\n\n 22. 在软件设计阶段进行模块划分时，一个模块的（）。\n     \n     A. 控制范围应该在其作用范围之内\n     \n     B. 作用范围应该在其控制范围之内\n     \n     C. 作用范围与控制范围互不包含\n     \n     D. 作用范围与控制范围不受任何限制\n     \n     【试题解析】∶模块控制域：这个模块本身以及所有直接或间接从属于它的模块的集合。 模块作用域：指受该模块内一个判定所影响的所有模块的集合。 模块的作用域应该在控制域范围之内，本题选择B选项。\n\n 23. 良好的启发式设计原则上不包括（）。\n     \n     A. 提高模块独立性\n     \n     B. 模块规模越小越好\n     \n     C. 模块作用域在其控制域之内\n     \n     D. 降低模块接口复杂性\n     \n     【试题解析】∶1、模块化设计要求高内聚、低耦合，模块独立体现的就是高内聚低耦合。A选项正确。 2、在结构化设计中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则: (1）模块的大小要适中。系统分解时需要考虑模块的规模，过大的模块可能导致系统分解不充分，其内部可能包括不同类型的功能，需要进一步划分，尽量使得各个模块的功能单一;过小的模块将导致系统的复杂度增加，模块之间的调用过于频繁，反而降低了模块的独立性。不是越小越好。B选项错误。 (2）模块的扇入和扇出要合理。模块的扇入指模块直接上级模块的个数。模块的直属下级模块个数即为模块的扇出。 (3）深度和宽度适当。深度表示软件结构中模块的层数，如果层数过多，则应考虑是否有些模块设计过于简单，看能否适当合并。宽度是软件结构中同一个层次上的模块总数的最大值，一般说来，宽度越大系统越复杂，对宽度影响最大的因素是模块的扇出。在系统设计时，需要权衡系统的深度和宽度，尽量降低系统的复杂性，减少实施过程的难度，提高开发和维护的效率。需要控制模块接口的复杂性。D选项正确。 3、尽力使模块的作用域在其控制域之内。模块控制域:这个模块本身以及所有直接或间接从属于它的模块的集合。模块作用域:指受该模块内一个判定所影响的所有模块的集合。C选项正确。\n\n 24. 在设计软件的模块结构时，（）不能改进设计质量。\n     \n     A. 尽量减少高扇出结构\n     \n     B. 模块的大小适中\n     \n     C. 将具有相似功能的模块合并\n     \n     D. 完善模块的功能\n     \n     【试题解析】∶在结构化设计中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则: (1）模块的大小要适中。系统分解时需要考虑模块的规模，过大的模块可能导致系统分解不充分，其内部可能包括不同类型的功能，需要进一步划分，尽量使得各个模块的功能单一;过小的模块将导致系统的复杂度增加，模块之间的调用过于频繁，反而降低了模块的独立性。一般来说，一个模块的大小使其实现代码在1~2页纸之内，或者其实现代码行数在50～200行之间，这种规模的模块易于实现和维护。 (2）模块的扇入和扇出要合理。一个模块的扇出是指该模块直接调用的下级模块的个数;扇出大表示模块的复杂度高，需要控制和协调过多的下级模块。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的控制模块;扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。一个模块的扇入是指直接调用该模块的上级模块的个数;扇入大表示模块的复用程度高。设计良好的软件结构通常顶层扇出比较大，中间扇出较少，底层模块则有大扇入。一般来说，系统的平均扇入和扇出系数为3或4，不应该超过7，否则会增大出错的概率。 (3）深度和宽度适当。深度表示软件结构中模块的层数，如果层数过多，则应考虑是否有些模块设计过于简单，看能否适当合并。宽度是软件结构中同一个层次上的模块总数的最大值，一般说来，宽度越大系统越复杂，对宽度影响最大的因素是模块的扇出。在系统设计时，需要权衡系统的深度和宽度，尽量降低系统的复杂性，减少实施过程的难度，提高开发和维护的效率。\n\n 25. 在设计软件的模块结构时，（）不能改进设计质量。\n     \n     A. 模块的作用范围应在其控制范围之内\n     \n     B. 模块的大小适中\n     \n     C. 避免或减少使用病态连接(从中部进入或访问一个模块)\n     \n     D. 模块的功能越单纯越好\n     \n     【试题解析】∶高内聚是使模块的功能要相对独立和单一，这个功能单纯意思有出入。 对于单一，是指尽量只做一件事，而功能单纯，并不能说明模块能且仅能完成一个功能。 相对其他选项而言，D选项的说法并不合适。\n\n 26. 在划分模块时，一个模块的作用范围应该在其控制范围之内。若发现其作用范围不在其控制范围内，则（）不是适当的处理方法。\n     \n     A. 将判定所在模块合并到父模块中，使判定处于较高层次\n     \n     B. 将受判定影响的模块下移到控制范围内\n     \n     C. 将判定上移到层次较高的位置\n     \n     D. 将父模块下移，使判定处于较高层次\n     \n     【试题解析】∶一个模块的作用范围(或称影响范围）指受该模块内一个判定影响的所有模块的集合。 一个模块的控制范围指模块本身以及其所有下属模块（(直接或间接从属于它的模块）的集合。 一个模块的作用范围应在其控制范围之内，且判定所在的模块应在其影响的模块在层次上尽量靠近。如果再设计过程中，发现模块作用范围不在其控制范围之内，可以用"上移判点"或下移受判断影响的模块，将它下移到判断所在模块的控制范围内"的方法加以改进。\n\n 27. Theo Mandel 在其关于界面设计所提出的三条"黄金准则"中，不包括（）。\n     \n     A. 用户操纵控制\n     \n     B. 界面美观整洁\n     \n     C. 减轻用户的记忆负担\n     \n     D. 保持界面一致\n     \n     【试题解析】∶人机交互"黄金三原则"包括：用户操纵控制、减轻用户的记忆负担、保持界面的一致性。 用户操纵控制：以不强迫用户进入不必要或不希望的动作的方式来定义交互模式；提供灵活的交互；允许中断和撤销用户交互；当技能级别增长时可以使交互流线化并允许定制交互；使用户与内部技术细节隔离开来；设计应允许用户与出现在屏幕上的对象直接交互。 减轻用户的记忆负担：减少对短期记忆的要求；建立有意义的默认；定义直观的快捷方式；界面的视觉布局应该基于真实世界的象征；以不断进展的方式揭示信息。 保持界面的一致性：允许用户将当前任务放入有意义的环境中；在应用系统家族中保持一致；如果过去的交互模型已经建立起了用户期望，除非有不得已的理由，否则不要改变它。\n\n 28. 在软件开发过程中，系统测试阶段的测试目标来自于（）阶段。\n     \n     A. 需求分析\n     \n     B. 概要设计\n     \n     C. 详细设计\n     \n     D. 软件实现\n     \n     【试题解析】∶其中系统测试和验收测试是针对于需求分析，集成测试针对于概要设计，单元测试针对于详细设计，软件实现应该是针对于编码部分。\n\n 29. 以下关于测试的叙述中，正确的是（）。\n     \n     A. 实际上，可以采用穷举测试来发现软件中的所有错误\n     \n     B. 错误很多的程序段在修改后错误─般会非常少\n     \n     C. 测试可以用来证明软件没有错误\n     \n     D. 白盒测试技术中，路径覆盖法往往能比语句覆盖法发现更多的错误\n     \n     【试题解析】∶一个高效的测试是指用少量的测试用例，发现被测软件尽可能多的错误。软件测试不能说明软件中不存在错误，不能用穷举法来进行测试。A选项错误。 经验表明，测试中存在集群规律，即未发现的错误数量与已发现的错误数量成正比，已发现的错误数量越多，则该模块未被发现的错误也就越多。B选项错误。 软件测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件产品(主要是指程序）中的错误和缺陷。C选项错误。 D选项的描述是正确的，白盒测试中语句覆盖是覆盖度最弱的，所以路径覆盖往往能比语句覆盖发现更多的错误。\n\n 30. 软件调试的任务就是根据测试时所发现的错误，找出原因和具体的位置，进行改正。其常用的方法中，(）是指从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。\n     \n     A. 试探法\n     \n     B. 回溯法\n     \n     C. 归纳法\n     \n     D. 演绎法\n     \n     【试题解析】∶无论哪种调试方法，其目的都是为了对错误进行定位。目前常用的调试方法有试探法、回溯法、对分查找法、演绎法和归纳法。 试探法:调试人员分析错误的症状，猜测问题所在的位置，利用在程序中设置输出语句，分析寄存器、存储器的内容等手段获得错误的线索，一步一步地试探和分析出错误所在。这种方法效率都很低，适合于错误比较简单的程序。 回溯法:调试人员从发现错误症状的位置开始，人工沿着程序的控制流程往回跟踪代码，直到找出错误根源为止。这种方法适合于小型程序，对于大规模程序，由于其需要回溯的路径太多而变得不可操作。 对分查找法:这种方法主要用来缩小错误的范围，如果已经知道程序中的变量在若干位置的正确取值，可以在这些位置给这些变量以正确值，观察程序运行的输出结果，如果没有发现问题，则说明从赋予变量一个正确值开始到输出结果之间的程序没有错误，问题可能在除此以外的程序中。否则错误就在所观察的这部分程序中，对含有错误的程序段再使用这种方法，直到把故障范围缩小到比较容易诊断为止。 归纳法:归纳法就是从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。本题题干描述的是归纳法。 演绎法:演绎法根据测试结果，列出所有可能的错误原因;分析已有数据，排除不可能和彼此矛盾的原因;对其余原因，选择可能性最大的，利用已有的数据完善该假设，使假设更具体;用假设来解释所有的原始测试结果，如果能解释这一切，则假设得以证实，也就是找出错误，否则，要么是假设不完备或不成立，要么有多个错误同时存在，需要重新分析，提出新的假设，直到发现错误为止。\n\n 31. 以下关于软件测试的叙述中，不正确的是（）。\n     \n     A. 在设计测试用例时应考虑输入数据和预期输出结果\n     \n     B. 软件测试的目的是证明软件的正确性\n     \n     C. 在设计测试用例时，应该包括合理的输入条件\n     \n     D. 在设计测试用例时，应该包括不合理的输入条件\n     \n     【试题解析】∶软件测试的目的是为了发现尽可能多的缺陷。\n\n 32. 在设计测试用例时，应遵循（）原则。\n     \n     A. 仅确定测试用例的输入数据，无需考虑输出结果\n     \n     B. 只需检验程是否执行应有的功能，不需要考虑程序是否做了多余的功能\n     \n     C. 不仅要设计有效合理输入，也要包含不合理、失效的输入\n     \n     D. 测试用例应设计得尽可能复杂\n     \n     【试题解析】∶测试用例要包括欲测试的功能、应输入的数据和预期的输出结果。测试用例应覆盖有效合理输入，也要包含不合理、失效的输入。\n\n 33. 以下关于软件测试的叙述中，正确的是（）。\n     \n     A. 软件测试不仅能表明软件中存在错误，也能说明软件中不存在错误\n     \n     B. 软件测试活动应从编码阶段开始\n     \n     C. —个成功的测试能发现至今未发现的错误\n     \n     D. 在一个被测程序段中，若已发现的错误越多，则残存的错误数越少\n     \n     【试题解析】∶软件测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件产品(主要是指程序）中的错误和缺陷。软件测试是软件质量保证的主要手段之一，软件测试应该尽可能早地计划和设计测试用例，而不是从编码阶段开始。 一个好的测试用例是极有可能发现至今为止尚未发现的错误的测试用例。一次成功的测试是发现了至今为止尚未发现的错误的测试。一个高效的测试是指用少量的测试用例，发现被测软件尽可能多的错误。软件测试不能说明软件中不存在错误。 经验表明，测试中存在集群规律，即未发现的错误数量与已发现的错误数量成正比，已发现的错误数量越多，则该模块未被发现的错误也就越多。\n\n 34. 下面有关测试的说法正确的是（）。\n     \n     A. 测试人员应该在软件开发结束后开始介入\n     \n     B. 测试主要是软件开发人员的工作\n     \n     C. 要根据软件详细设计中设计的各种合理数据设计测试用例\n     \n     D. 严格按照测试计划进行，避免测试的随意性\n     \n     【试题解析】∶测试人员应该在系统设计阶段介入，根据概要设计说明书开始制定测试计划:测试过程要求用户参与，特别是提交阶段要通过用户的验收测试;设计测试用例时不但要选择合理的输入数据作为测试用例，还要选择不合理的输入数据作为测试用例。\n\n 35. 两个小组独立地测试同一个程序，第一组发现25个错误，第二组发现30个错误，在两个小组发现的错误中有15个是共同的，那么可以估计程序中的错误总数是（）个。\n     \n     A. 25\n     \n     B. 30\n     \n     C. 50\n     \n     D. 60\n     \n     【试题解析】∶对于第一小组：发现了第二组发现的错误的15/30=0。5=50% 对于第二小组：发现了第一组发现的错误的15/25=0。6=60% 根据第一组的发现的错误数和第一组的效率得到：25÷50%=50 根据第二组的发现的错误数和第二组的效率得到：30÷60%=50 由于两个小组是独立进行测试的，所以可以估计：程序中的错误总数为50个。\n\n 36. 在某大学学生学籍管理信息系统中，假设学生年龄的输入范围为16~40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（）。\n     \n     A. 可划分为2个有效等价类，2个无效等价类\n     \n     B. 可划分为1个有效等价类，2个无效等价类\n     \n     C. 可划分为2个有效等价类，1个无效等价类\n     \n     D. 可划分为1个有效等价类，1个无效等价类\n     \n     【试题解析】∶根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16s年龄≤40，两个无效等价类为年龄>40或年龄<16。\n\n 37. 在模拟环境下，常采用黑盒测试检验所开发的软件是否与需求规格说明书一致。其中有效性测试属于（）中的一个步骤。\n     \n     A. 单元测试\n     \n     B. 集成测试\n     \n     C. 确认测试\n     \n     D. 系统测试\n     \n     【试题解析】∶本题考查系统测试中的确认测试。确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。\n\n 38. 某程序根据输入的三条线段长度，判断这三条线段能否构成三角形。以下6个测试用例中，（）两个用例属于同一个等价类。 ①6、7、13; ②4、7、10; ③39、20、35; ④9、11、21; ⑤5、5、4;⑥4、4、4。\n\nA. ①②\n\nB. ③④\n\nC. ⑤⑥\n\nD. ①④\n\n【试题解析】∶本题考查黑盒测试技术的等价类划分。①为前两边之和等于第三边;②为三边不等且任意两边之和大于第三边;③④前两边之 和小于第三边;⑤为其中有两边相等且可构成等腰三角形;⑥为三边相等且可构成等边三角形。\n\n 39. 软件测试是软件开发中不可缺少的活动，通常()在代码编写阶段进行。检查软件的功能是否与用户要求一致是（）的任务。\n     \n     问题一\n     \n     A. 验收测试\n     \n     B. 系统测试\n     \n     C. 单元测试\n     \n     D. 集成测试\n     \n     问题二\n     \n     A. 验收测试\n     \n     B. 系统测试\n     \n     C. 单元测试\n     \n     D. 集成测试\n     \n     【试题解析】∶本题考查软件开发阶段与测试的对应关系。通过单元测试,(也称为模块测试）消除程序模块内部存在的错误和缺陷，这类测试在代码编写阶段完成，通过集成测试(也称为组装测试）检测和排除子系统结构上的错误和缺陷，通过确认验收测试，验证软件功能是否满足用户要求，通过系统测试，在已确认的计算机软硬件环境下，通过与系统需求对比，发现系统与用户需求不符或矛盾的地方。\n\n 40. 软件可维护性是一个系统在特定的时间间隔内可以正常进行维护活动的概率。用MTTF和MTTR分别表示平均无故障时间和平均故障修复时间，则软件可维护性计算公式为（）。\n     \n     A. MTTF/(1+MTTF)\n     \n     B. 1/(1+MTTF)\n     \n     C. MTTR/(1+MTTR)\n     \n     D. 1/(1+MTTR)\n     \n     【试题解析】∶在软件外部，可以用 MTTR 来度量软件的可维护性，它指出处理一个有错误的软件需要花费的平均时间。如果用M表示可维护性指标，那么 M=1/(1+MTTR)。本题选择 D 选项。 A选项一般用来表示可靠性或可用性指标。\n\n 41. 以下关于软件维护的叙述中，不正确的是（）。\n     \n     A. 软件维护解决软件产品交付用户之后进行中发生的各种问题\n     \n     B. 软件维护期通常比开发期长得多，投入也大得多\n     \n     C. 软件的可维护性是软件开发阶段各个时期的关键目标\n     \n     D. 相对于软件开发任务而言，软件维护工作要简单得多\n     \n     【试题解析】∶软件维护是软件生命周期最长的一段，相对于软件开发任务而言，软件维护工作要更加复杂，D选项描述不正确。\n\n 42. 软件维护工具不包括（）工具。\n     \n     A. 版本控制\n     \n     B. 配置管理\n     \n     C. 文档分析\n     \n     D. 逆向工程\n     \n     【试题解析】∶辅助软件维护过程中的活动的软件称为"软件维护工具”，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：1、版本控制工具；2、文档分析工具；3、开发信息库工具；4、逆向工程工具；5、再工程工具；6、配置管理支持工具。\n\n 43. 以下关于软件维护和可维护性的叙述中，不正确的是（）。\n     \n     A. 软件维护要解决软件产品交付用户之后运行中发生的各种问题\n     \n     B. 软件的维护期通常比开发期长得多，其投入也大得多\n     \n     C. 进行质量保证审查可以提高软件产品的可维护性\n     \n     D. 提高可维护性是在软件维护阶段考虑的问题\n     \n     【试题解析】∶在软件开发的各个阶段都需考虑软件的可维护性。\n\n 44. 某搜索引擎在交付后，开发人员修改了其中的索引方法，使得用户可以更快地得到搜索结果。这种修改属于（）维护。\n     \n     A. 正确性\n     \n     B. 适应性\n     \n     C. 完善性\n     \n     D. 预防性\n     \n     【试题解析】∶在软件开发的各个阶段都需考虑软件的可维护性。\n\n 45. 某商场的销售系统所使用的信用卡公司信息系统的数据格式发生了更改，因此对该销售系统进行的修改属于（）维护。\n     \n     A. 改正性\n     \n     B. 适应性\n     \n     C. 改善性\n     \n     D. 预防性\n     \n     【试题解析】∶在系统运行过程中，软件需要维护的原因是多样的，根据维护的原因不同，可以将软件维护分为以下四种: (1)改正性维护。为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程就称为改正性维护。 (2)适应性维护。在使用过程中，外部环境(新的硬、软件配置)、数据环境(数据库、数据格式、数据输入/输出方式、数据存储介质)可能发生变化。为使软件适应这种变化，而去修改软件的过程就称为适应性维护。 (3)改善性维护。在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动称为改善性维护。 (4)预防性维护。这是指预先提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础。本题对该销售系统的修改是为了应对数据格式的变化而作出的修改。\n\n 46. 进行防错性程序设计，可以有效地控制（）维护成本。\n     \n     A. 正确性\n     \n     B. 适应性\n     \n     C. 完善性\n     \n     D. 预防性\n     \n     【试题解析】∶改正性维护也叫正确性维护，是指在使用过程中发现了隐蔽的错误后，为了诊断和改正这些隐蔽错误而修改软件的活动。 适应性维护是指为了适应变化了的环境而修改软件的活动。 完善性维护是指为了扩充或完善原有软件的功能或性能而修改软件的活动。 预防性维护是指为了提高软件的可维护性和可靠性、为未来的进一步改进打下基础而修改软件的活动。 防错性的程序设计，可以减少在系统运行时发生错误，有效地控制正确性维护的成本。\n\n 47. 改正在软件系统开发阶段已经发生而系统测试阶段还没有发现的错误，属于（）维护。\n     \n     A. 正确性\n     \n     B. 适应性\n     \n     C. 完善性\n     \n     D. 预防性\n     \n     【试题解析】∶软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。\n\n 48. ISO/IEC软件质量模型中，易使用性是指与使用所需的努力和由一组规定或隐含的用户对这样使用所作的个别评价有关的一组属性，其子特性不包括（）。\n     \n     A. 易理解性\n     \n     B. 易学性\n     \n     C. 易分析性\n     \n     D. 易操作性\n     \n     【试题解析】∶易用性的自特性包括易理解性、易学性、易操作性，其中C选项易分析性属于可维护性的子特性。\n\n 49. 在ISO/IEC 9126软件质量模型中，可靠性质量特性是指在规定的一段时间内和规定的条件下，软件维持在其性能水平有关的能力，其质量子特性不包括（）。\n     \n     A. 安全性\n     \n     B. 成熟性\n     \n     C. 容错性\n     \n     D. 易恢复性\n     \n     【试题解析】∶\n     \n     \n\n 50. 根据ISOIEC 9126软件质量模型中对软件质量特性的定义，可维护性质量特性的（）子特性是指与为确认经修改软件所需努力有关的软件属性。\n     \n     A. 易测试性\n     \n     B. 易分析性\n     \n     C. 稳定性\n     \n     D. 易改变性\n     \n     【试题解析】∶可维护性质量特性是指与软件维护的难易程度相关的一组软件属性，它包含了易分析性、稳定性、易测试性和易改变性4个子特性。其中: 易分析性是描述诊断缺陷或失效原因、判定待修改程度的难易程度的特性。 稳定性是描述修改造成难以预料的后果的风险程度，风险程度越低，稳定性越好。 易测试性是描述测试已修改软件的难易程度的特性。 易改变性是描述修改、排错或适应环境变化的难易程度。 本题中，是说与为确认经修改软件所需努力有关的软件属性，也就是说要确认修改后的软件是否正确所要付出的努力，这应该是易测试性所描述的内容，因此本题答案选A。',normalizedContent:'# 软件工程题目\n\n 1.  若用户需求不清晰且经常发生变化，但系统规模不太大且不太复杂，则最适宜采用（）开发方法，对于数据处理领域的问题，若系统规模不太大且不太复杂，需求变化也不大，则最适宜采用（）开发方法。\n     \n     问题一 a. 结构化\n     \n     b. jackson\n     \n     c. 原型化\n     \n     d. 面向对象\n     \n     问题二\n     \n     a. 结构化\n     \n     b. jackson\n     \n     c. 原型化\n     \n     d. 面向对象\n     \n     【试题解析】∶在本题的两个空中，第1个空比较容易，由于题目明确说明"用户需求不清晰且经常发生变化"所以只有原型化方法适用。而第2空需求变化不大的情况下，其实多种模型都可用，所以另一条线索成为解题关键，即"数据处理领域问题"。结构化方法的基本特征是:自顶向下，逐层分解，也适合于大型的数据处理系统，所以用他最合适。\n\n 2.  以下关于结构化开发方法的叙述中，不正确的是（）。\n     \n     a. 总的指导思想是自顶向下，逐层分解\n     \n     b. 基本原则是功能的分解与抽象\n     \n     c. 与面向对象开发方法相比，更适合于大规模、特别复杂的项目\n     \n     d. 特别适合于数据处理领域的项目\n     \n     【试题解析】∶结构化开发方法是一种面向数据流的开发方法，其基本思想是软件功能的分解和抽象。结构化开发方法又称生命周期法，是迄今为止最传统、应用最广泛的一种信息系统开发方法。结构化开发方法采用系统工程的思想和工程化的方法，按用户至上的原则，结构化、模块化、自顶向下地对信息系统进行分析与设计。该方法严格按照信息系统开发的阶段性开展设计工作，每个阶段都产生一定的设计成果，通过评估后再进入下一阶段开发工作。因此，结构化开发方法具有以下优点：\n     \n     * 开发工作的顺序性、阶段性适合初学者参与软件的开发\n     \n     * 开发工作的阶段性评估可以减少开发工作重复性和提高开发的成功率\n     \n     * 该方法有利于提高系统开发的正确性、可靠性和可维护性\n     \n     * 具有完整的开发质量保证措施\n     \n     * 结构化开发方法存在的不足主要是开发周期太长，个性化开发阶段的文档编写工作量过大或过于烦琐，无法发挥开发人员的个性化开发能力。一般来说，结构化开发方法主要适用于组织规模较大、组织结构相对稳定的企业，这些大型企业往往业务处理过程规范、信息系统数据需求非常明确，在一定时期内需求变化不大。\n\n 3.  以下关于结构化开发方法的叙述中，不正确的是（）。\n     \n     a. 将数据流映射为软件系统的模块结构\n     \n     b. —般情况下，数据流类型包括变换流型和事务流型\n     \n     c. 不同类型的数据流有不同的映射方法\n     \n     d. 一个软件系统只有一种数据流类型\n     \n     【试题解析】∶面向数据流的设计是以需求分析阶段产生的数据流图为基础，按一定的步骤映射成软件结构，因此又称结构化设计。该方法由美国ibm公司l.constantine和e.yourdon等人于1974年提出，与结构化分析(sa)衔接，构成了完整的结构化分析与设计技术，是目前使用最广泛的软件设计方法之一。 各种软件系统，不论dfd如何庞大和复杂，一般可分为变换型和事务型，一个软件系统既可以只有一种数据流类型，也可以是两种数据流类型。在结构化设计中，可以将数据流映射为软件系统的模块结构，不同类型的数据流有不同的映射方法。\n\n 4.  极限编程(extreme programming）是一种轻量级软件开发方法，（）不是它强调的准则。\n     \n     a. 持续的交流和沟通\n     \n     b. 用最简单的设计实现用户需求\n     \n     c. 用测试驱动开发\n     \n     d. 关注用户反馈\n     \n     【试题解析】∶极限编程（ extreme programming.xp)是1998年由kent beck首先提出的一种轻量级的软件开发方法，同时也是一种非常严谨和周密的方法。这种方法强调交流、简单、反馈和勇气4项原则，也就是说一个软件项目可以从4个方面进行改善:加强交流;从简单做起;寻求反饿;勇于实事求是。xp是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期。通过积极的交流、反馈以及其他一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和可能存在的困难等，并根据实际情况及时地调整开发过程。\n\n 5.  面向对象开发方法的基本思想是尽可能按照人类认识客观世界的方法来分析和解决问题，（）方法不属于面向对象方法。\n     \n     a. booch\n     \n     b. coad\n     \n     c. omt\n     \n     d. jackson\n     \n     【试题解析】∶本题考查面向对象开发方法。面向对象开发方法有booch方法、coad方法和omt方法。jackson方法是一种面向数据结构的开发方法。\n\n 6.  若某模块内所有处理元素都在同一个数据结构上操作，则该模块的内聚类型为（）。\n     \n     a. 逻辑\n     \n     b. 过程\n     \n     c. 通信\n     \n     d. 功能\n     \n     【试题解析】∶\n     \n     \n\n 7.  某模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一处理元素的输出就是下一处理元素的输入，则该模块的内聚类型为（）内聚。\n     \n     a. 过程\n     \n     b. 时间\n     \n     c. 顺序\n     \n     d. 逻辑\n     \n     【试题解析】∶a选项过程内聚。如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。 b选项时间内聚。如果一个模块完成的功能必须在同一时间内执行(如系统初始化)，但这些功能只是因为时间因素关联在一起，则称为时间内聚。 c选项顺序内聚。如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。本题描述的是c选项。 d选项逻辑内聚。几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。如一个模块读取各种不同类型外设的输入。尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。\n\n 8.  某模块内涉及多个功能，这些功能必须以特定的次序执行，则该模块的内聚类型为（）内聚。\n     \n     a. 过程\n     \n     b. 时间\n     \n     c. 信息\n     \n     d. 功能\n     \n     【试题解析】∶要求功能是以特定的次序执行，所以是过程内聚。\n\n 9.  模块a、b和c有相同的程序块，块内的语句之间没有任何联系，现把该程序块取出来，形成新的模块d，则模块d的内聚类型为（）内聚。以下关于该内聚类型的叙述中，不正确的是（）。\n     \n     问题一\n     \n     a. 巧合\n     \n     b. 逻辑\n     \n     c. 时间\n     \n     d. 过程\n     \n     问题二\n     \n     a. 具有最低的内聚性\n     \n     b. 不易修改和维护\n     \n     c. 不易理解\n     \n     d. 不影响模块间的耦合关系\n     \n     【试题解析】∶功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。 顺序内聚：处理元素相关，而且必须顺序执行。 通信内聚：所有处理元素集中在一个数据结构的区域上。 过程内聚：处理元素相关，而且必须按特定的次序执行。 瞬时内聚：所包含的任务必须在同一时间间隔内执行(如初始化模块)。 逻辑内聚：完成逻辑上相关的一组任务。 偶然内聚：完成一组没有关系或松散关系的任务。 巧合内聚就是偶然内聚。偶然内聚由于内容都是不相关的，所以必然导致它与外界多个模块有关联，这也使得模块间的耦合度增加。\n\n 10. 某模块中有两个处理 a 和 b，分别对数据结构x写数据和读数据，则该模块的内聚类型为（）内聚。\n     \n     a. 逻辑\n     \n     b. 过程\n     \n     c. 通信\n     \n     d. 内容\n     \n     【试题解析】∶如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。本题为通信内聚。 逻辑聚合：模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。 过程聚合：模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。 内容耦合：—个模块需要涉及另一个模块的内部信息。\n\n 11. 模块a执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，则该模块具有（）内聚\n     \n     a. 顺序\n     \n     b. 过程\n     \n     c. 逻辑\n     \n     d. 功能\n     \n     【试题解析】∶内聚是指模块内部各元素之间联系的紧密程度，模块的内聚类型通常可以分为7种，根据内聚度从高到低排序分别如下： 功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。 顺序内聚：处理元素相关，而且必须顺序执行。 通信内聚：所有处理元素集中在一个数据结构的区域上。 过程内聚：处理元素相关，而且必须按特定的次序执行。 瞬时内聚：所包含的任务必须在同一时间间隔内执行(如初始化模块)。 逻辑内聚：完成逻辑上相关的一组任务。 偶然内聚：完成一组没有关系或松散关系的任务。\n\n 12. 内聚是—种指标，表示一个模块（）。\n     \n     a. 代码优化的程度\n     \n     b. 代码功能的集中程度\n     \n     c. 完成任务的及时程度\n     \n     d. 为了与其他模块连接所要完成的工作量\n     \n     【试题解析】∶本题考查软件模块化的基本概念。 模块的内聚性表现了模块内部各个子成分功能的集中程度，分为6级，如下图所示:\n\n 13. 模块a通过非正常入口转入模块b内部，则这两个模块之间是（）耦合。\n     \n     a. 数据\n     \n     b. 公共\n     \n     c. 外部\n     \n     d. 内容\n     \n     【试题解析】∶数据耦合是通过参数表传递简单信息。 公共耦合是多个模块访问同一个公共数据环境。 外部耦合是一组模块访问同一个全局简单变量而没有通过参数表传递。 内容耦合是一个模块直接访问另一个模块的内部数据;一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠;一个模块有多个入口。本题描述的是内容耦合。\n     \n     \n\n 14. 已知模块 a 给模块 b 传递数据结构 x，则这两个模块的耦合类型为（）。\n     \n     a. 数据耦合\n     \n     b. 公共耦合\n     \n     c. 外部耦合\n     \n     d. 标记耦合\n     \n     【试题解析】∶数据耦合:一个模块访问另一个模块时，彼此之间是通过简单数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的。 公共耦合:若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 外部耦合:一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 标记耦合︰一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。本题描述的是标记耦合。\n\n 15. 某企业管理信息系统中，采购子系统根据材料价格、数量等信息计算采购的金额，并给财务子系统传递采购金额、收款方和采购日期等信息，则这两个子系统之间的耦合类型为（）耦合。\n     \n     a. 数据\n     \n     b. 标记\n     \n     c. 控制\n     \n     d. 外部\n     \n     【试题解析】∶非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的。 标记耦合：一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。其实传递的是这个数据结构的地址; 控制耦合：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 内容耦合：如果发生下列情形，两个模块之间就发生了内容耦合。 (1）一个模块直接访问另一个模块的内部数据; (2）一个模块不通过正常入口转到另一模块内部; (3）两个模块有一部分程序代码重叠(只可能出现在汇编语言中)； (4）一个模块有多个入口。 根据本题题干描述，采购子系统"给财务子系统传递采购金额、收款方和采购日期等信息”，传递时应将这些数据包装在数据结构中，因此二者之间是标记耦合。\n\n 16. 耦合是模块之间的相对独立性(互相连接的紧密程度）的度量。耦合程度不取决于（）。\n     \n     a. 调用模块的方式\n     \n     b. 各个模块之间接口的复杂程度\n     \n     c. 通过接口的信息类型\n     \n     d. 模块提供的功能数\n     \n     【试题解析】∶耦合性也叫块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块之间越独立则越差，模块间耦合的高低取决于模块间接口的复杂性，调用的方式以及传递的信息。\n\n 17. 模块a将学生信息，即学生姓名、学号、手机号等放到一个结构体中，传递给模块b。模块a和b之间的耦合类型为（）耦合。\n     \n     a. 数据\n     \n     b. 标记\n     \n     c. 控制\n     \n     d. 内容\n     \n     【试题解析】∶数据耦合：两个模块彼此间通过数据参数交换信息。 标记耦合：一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。 控制耦合：两个模块彼此间传递的信息中有控制信息。 内容耦合：一个模块需要涉及另一个模块的内部信息。 本题应该选择b选项。\n\n 18. 模块a直接访问模块b的内部数据，则模块a和模块b的耦合类型为（）。\n     \n     a. 数据耦合\n     \n     b. 标记耦合\n     \n     c. 公共耦合\n     \n     d. 内容耦合\n     \n     【试题解析】∶耦合是指两个或两个以上的模块相互依赖于对方的一个量度。它可以分为非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合及内容耦合等。 当一个模块直接修改或操作另一个模块的数据或者直接转入另一个模块时，就发生了内容耦合。所以本题的答案选d。\n\n 19. 下图中的程序由a、b、c、d、e5个模块组成，下表中描述了这些模块之间的接口，每一个接口有一个编号。此外，模块a、d和e都要引用一个专用数据区。那么 a 和 e 之间耦合关系是（）。\n     \n     \n\na. 公共耦合\n\nb. 数据耦合\n\nc. 内容耦合\n\nd. 无耦合\n\n【试题解析】∶由于模块a和模块e都引用了专用数据区的内容，所以是公共耦合。\n\n 20. 耦合度描述了（）。\n     \n     a. 模块内各种元素结合的程度\n     \n     b. 模块内多个功能之间的接口\n     \n     c. 模块之间公共数据的数量\n     \n     d. 模块之间相互关联的程度\n     \n     【试题解析】∶本题考查软件模块化的基本概念。 模块的耦合度表现了模块之间相互关联的程度，分为b级，如下图所示:\n\n 21. 以下关于软件设计原则的叙述中，不正确的是（）。\n     \n     a. 将系统划分为相对独立的模块\n     \n     b. 模块之间的耦合尽可能小\n     \n     c. 模块规模越小越好\n     \n     d. 模块的扇入系数和扇出系数合理\n     \n     【试题解析】∶软件设计原则始终强调高内聚、低耦合的设计原则。具体包括: 保持模块的大小适中 尽可能减少调用的深度 多扇入，少扇出。 单入口，单出口 模块的作用域应该在模块之内 功能应该是可以被预测的。 综上所述，仅有c选项模块规模越小越好是不符合设计原则的。\n\n 22. 在软件设计阶段进行模块划分时，一个模块的（）。\n     \n     a. 控制范围应该在其作用范围之内\n     \n     b. 作用范围应该在其控制范围之内\n     \n     c. 作用范围与控制范围互不包含\n     \n     d. 作用范围与控制范围不受任何限制\n     \n     【试题解析】∶模块控制域：这个模块本身以及所有直接或间接从属于它的模块的集合。 模块作用域：指受该模块内一个判定所影响的所有模块的集合。 模块的作用域应该在控制域范围之内，本题选择b选项。\n\n 23. 良好的启发式设计原则上不包括（）。\n     \n     a. 提高模块独立性\n     \n     b. 模块规模越小越好\n     \n     c. 模块作用域在其控制域之内\n     \n     d. 降低模块接口复杂性\n     \n     【试题解析】∶1、模块化设计要求高内聚、低耦合，模块独立体现的就是高内聚低耦合。a选项正确。 2、在结构化设计中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则: (1）模块的大小要适中。系统分解时需要考虑模块的规模，过大的模块可能导致系统分解不充分，其内部可能包括不同类型的功能，需要进一步划分，尽量使得各个模块的功能单一;过小的模块将导致系统的复杂度增加，模块之间的调用过于频繁，反而降低了模块的独立性。不是越小越好。b选项错误。 (2）模块的扇入和扇出要合理。模块的扇入指模块直接上级模块的个数。模块的直属下级模块个数即为模块的扇出。 (3）深度和宽度适当。深度表示软件结构中模块的层数，如果层数过多，则应考虑是否有些模块设计过于简单，看能否适当合并。宽度是软件结构中同一个层次上的模块总数的最大值，一般说来，宽度越大系统越复杂，对宽度影响最大的因素是模块的扇出。在系统设计时，需要权衡系统的深度和宽度，尽量降低系统的复杂性，减少实施过程的难度，提高开发和维护的效率。需要控制模块接口的复杂性。d选项正确。 3、尽力使模块的作用域在其控制域之内。模块控制域:这个模块本身以及所有直接或间接从属于它的模块的集合。模块作用域:指受该模块内一个判定所影响的所有模块的集合。c选项正确。\n\n 24. 在设计软件的模块结构时，（）不能改进设计质量。\n     \n     a. 尽量减少高扇出结构\n     \n     b. 模块的大小适中\n     \n     c. 将具有相似功能的模块合并\n     \n     d. 完善模块的功能\n     \n     【试题解析】∶在结构化设计中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则: (1）模块的大小要适中。系统分解时需要考虑模块的规模，过大的模块可能导致系统分解不充分，其内部可能包括不同类型的功能，需要进一步划分，尽量使得各个模块的功能单一;过小的模块将导致系统的复杂度增加，模块之间的调用过于频繁，反而降低了模块的独立性。一般来说，一个模块的大小使其实现代码在1~2页纸之内，或者其实现代码行数在50～200行之间，这种规模的模块易于实现和维护。 (2）模块的扇入和扇出要合理。一个模块的扇出是指该模块直接调用的下级模块的个数;扇出大表示模块的复杂度高，需要控制和协调过多的下级模块。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的控制模块;扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。一个模块的扇入是指直接调用该模块的上级模块的个数;扇入大表示模块的复用程度高。设计良好的软件结构通常顶层扇出比较大，中间扇出较少，底层模块则有大扇入。一般来说，系统的平均扇入和扇出系数为3或4，不应该超过7，否则会增大出错的概率。 (3）深度和宽度适当。深度表示软件结构中模块的层数，如果层数过多，则应考虑是否有些模块设计过于简单，看能否适当合并。宽度是软件结构中同一个层次上的模块总数的最大值，一般说来，宽度越大系统越复杂，对宽度影响最大的因素是模块的扇出。在系统设计时，需要权衡系统的深度和宽度，尽量降低系统的复杂性，减少实施过程的难度，提高开发和维护的效率。\n\n 25. 在设计软件的模块结构时，（）不能改进设计质量。\n     \n     a. 模块的作用范围应在其控制范围之内\n     \n     b. 模块的大小适中\n     \n     c. 避免或减少使用病态连接(从中部进入或访问一个模块)\n     \n     d. 模块的功能越单纯越好\n     \n     【试题解析】∶高内聚是使模块的功能要相对独立和单一，这个功能单纯意思有出入。 对于单一，是指尽量只做一件事，而功能单纯，并不能说明模块能且仅能完成一个功能。 相对其他选项而言，d选项的说法并不合适。\n\n 26. 在划分模块时，一个模块的作用范围应该在其控制范围之内。若发现其作用范围不在其控制范围内，则（）不是适当的处理方法。\n     \n     a. 将判定所在模块合并到父模块中，使判定处于较高层次\n     \n     b. 将受判定影响的模块下移到控制范围内\n     \n     c. 将判定上移到层次较高的位置\n     \n     d. 将父模块下移，使判定处于较高层次\n     \n     【试题解析】∶一个模块的作用范围(或称影响范围）指受该模块内一个判定影响的所有模块的集合。 一个模块的控制范围指模块本身以及其所有下属模块（(直接或间接从属于它的模块）的集合。 一个模块的作用范围应在其控制范围之内，且判定所在的模块应在其影响的模块在层次上尽量靠近。如果再设计过程中，发现模块作用范围不在其控制范围之内，可以用"上移判点"或下移受判断影响的模块，将它下移到判断所在模块的控制范围内"的方法加以改进。\n\n 27. theo mandel 在其关于界面设计所提出的三条"黄金准则"中，不包括（）。\n     \n     a. 用户操纵控制\n     \n     b. 界面美观整洁\n     \n     c. 减轻用户的记忆负担\n     \n     d. 保持界面一致\n     \n     【试题解析】∶人机交互"黄金三原则"包括：用户操纵控制、减轻用户的记忆负担、保持界面的一致性。 用户操纵控制：以不强迫用户进入不必要或不希望的动作的方式来定义交互模式；提供灵活的交互；允许中断和撤销用户交互；当技能级别增长时可以使交互流线化并允许定制交互；使用户与内部技术细节隔离开来；设计应允许用户与出现在屏幕上的对象直接交互。 减轻用户的记忆负担：减少对短期记忆的要求；建立有意义的默认；定义直观的快捷方式；界面的视觉布局应该基于真实世界的象征；以不断进展的方式揭示信息。 保持界面的一致性：允许用户将当前任务放入有意义的环境中；在应用系统家族中保持一致；如果过去的交互模型已经建立起了用户期望，除非有不得已的理由，否则不要改变它。\n\n 28. 在软件开发过程中，系统测试阶段的测试目标来自于（）阶段。\n     \n     a. 需求分析\n     \n     b. 概要设计\n     \n     c. 详细设计\n     \n     d. 软件实现\n     \n     【试题解析】∶其中系统测试和验收测试是针对于需求分析，集成测试针对于概要设计，单元测试针对于详细设计，软件实现应该是针对于编码部分。\n\n 29. 以下关于测试的叙述中，正确的是（）。\n     \n     a. 实际上，可以采用穷举测试来发现软件中的所有错误\n     \n     b. 错误很多的程序段在修改后错误─般会非常少\n     \n     c. 测试可以用来证明软件没有错误\n     \n     d. 白盒测试技术中，路径覆盖法往往能比语句覆盖法发现更多的错误\n     \n     【试题解析】∶一个高效的测试是指用少量的测试用例，发现被测软件尽可能多的错误。软件测试不能说明软件中不存在错误，不能用穷举法来进行测试。a选项错误。 经验表明，测试中存在集群规律，即未发现的错误数量与已发现的错误数量成正比，已发现的错误数量越多，则该模块未被发现的错误也就越多。b选项错误。 软件测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件产品(主要是指程序）中的错误和缺陷。c选项错误。 d选项的描述是正确的，白盒测试中语句覆盖是覆盖度最弱的，所以路径覆盖往往能比语句覆盖发现更多的错误。\n\n 30. 软件调试的任务就是根据测试时所发现的错误，找出原因和具体的位置，进行改正。其常用的方法中，(）是指从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。\n     \n     a. 试探法\n     \n     b. 回溯法\n     \n     c. 归纳法\n     \n     d. 演绎法\n     \n     【试题解析】∶无论哪种调试方法，其目的都是为了对错误进行定位。目前常用的调试方法有试探法、回溯法、对分查找法、演绎法和归纳法。 试探法:调试人员分析错误的症状，猜测问题所在的位置，利用在程序中设置输出语句，分析寄存器、存储器的内容等手段获得错误的线索，一步一步地试探和分析出错误所在。这种方法效率都很低，适合于错误比较简单的程序。 回溯法:调试人员从发现错误症状的位置开始，人工沿着程序的控制流程往回跟踪代码，直到找出错误根源为止。这种方法适合于小型程序，对于大规模程序，由于其需要回溯的路径太多而变得不可操作。 对分查找法:这种方法主要用来缩小错误的范围，如果已经知道程序中的变量在若干位置的正确取值，可以在这些位置给这些变量以正确值，观察程序运行的输出结果，如果没有发现问题，则说明从赋予变量一个正确值开始到输出结果之间的程序没有错误，问题可能在除此以外的程序中。否则错误就在所观察的这部分程序中，对含有错误的程序段再使用这种方法，直到把故障范围缩小到比较容易诊断为止。 归纳法:归纳法就是从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。本题题干描述的是归纳法。 演绎法:演绎法根据测试结果，列出所有可能的错误原因;分析已有数据，排除不可能和彼此矛盾的原因;对其余原因，选择可能性最大的，利用已有的数据完善该假设，使假设更具体;用假设来解释所有的原始测试结果，如果能解释这一切，则假设得以证实，也就是找出错误，否则，要么是假设不完备或不成立，要么有多个错误同时存在，需要重新分析，提出新的假设，直到发现错误为止。\n\n 31. 以下关于软件测试的叙述中，不正确的是（）。\n     \n     a. 在设计测试用例时应考虑输入数据和预期输出结果\n     \n     b. 软件测试的目的是证明软件的正确性\n     \n     c. 在设计测试用例时，应该包括合理的输入条件\n     \n     d. 在设计测试用例时，应该包括不合理的输入条件\n     \n     【试题解析】∶软件测试的目的是为了发现尽可能多的缺陷。\n\n 32. 在设计测试用例时，应遵循（）原则。\n     \n     a. 仅确定测试用例的输入数据，无需考虑输出结果\n     \n     b. 只需检验程是否执行应有的功能，不需要考虑程序是否做了多余的功能\n     \n     c. 不仅要设计有效合理输入，也要包含不合理、失效的输入\n     \n     d. 测试用例应设计得尽可能复杂\n     \n     【试题解析】∶测试用例要包括欲测试的功能、应输入的数据和预期的输出结果。测试用例应覆盖有效合理输入，也要包含不合理、失效的输入。\n\n 33. 以下关于软件测试的叙述中，正确的是（）。\n     \n     a. 软件测试不仅能表明软件中存在错误，也能说明软件中不存在错误\n     \n     b. 软件测试活动应从编码阶段开始\n     \n     c. —个成功的测试能发现至今未发现的错误\n     \n     d. 在一个被测程序段中，若已发现的错误越多，则残存的错误数越少\n     \n     【试题解析】∶软件测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件产品(主要是指程序）中的错误和缺陷。软件测试是软件质量保证的主要手段之一，软件测试应该尽可能早地计划和设计测试用例，而不是从编码阶段开始。 一个好的测试用例是极有可能发现至今为止尚未发现的错误的测试用例。一次成功的测试是发现了至今为止尚未发现的错误的测试。一个高效的测试是指用少量的测试用例，发现被测软件尽可能多的错误。软件测试不能说明软件中不存在错误。 经验表明，测试中存在集群规律，即未发现的错误数量与已发现的错误数量成正比，已发现的错误数量越多，则该模块未被发现的错误也就越多。\n\n 34. 下面有关测试的说法正确的是（）。\n     \n     a. 测试人员应该在软件开发结束后开始介入\n     \n     b. 测试主要是软件开发人员的工作\n     \n     c. 要根据软件详细设计中设计的各种合理数据设计测试用例\n     \n     d. 严格按照测试计划进行，避免测试的随意性\n     \n     【试题解析】∶测试人员应该在系统设计阶段介入，根据概要设计说明书开始制定测试计划:测试过程要求用户参与，特别是提交阶段要通过用户的验收测试;设计测试用例时不但要选择合理的输入数据作为测试用例，还要选择不合理的输入数据作为测试用例。\n\n 35. 两个小组独立地测试同一个程序，第一组发现25个错误，第二组发现30个错误，在两个小组发现的错误中有15个是共同的，那么可以估计程序中的错误总数是（）个。\n     \n     a. 25\n     \n     b. 30\n     \n     c. 50\n     \n     d. 60\n     \n     【试题解析】∶对于第一小组：发现了第二组发现的错误的15/30=0。5=50% 对于第二小组：发现了第一组发现的错误的15/25=0。6=60% 根据第一组的发现的错误数和第一组的效率得到：25÷50%=50 根据第二组的发现的错误数和第二组的效率得到：30÷60%=50 由于两个小组是独立进行测试的，所以可以估计：程序中的错误总数为50个。\n\n 36. 在某大学学生学籍管理信息系统中，假设学生年龄的输入范围为16~40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（）。\n     \n     a. 可划分为2个有效等价类，2个无效等价类\n     \n     b. 可划分为1个有效等价类，2个无效等价类\n     \n     c. 可划分为2个有效等价类，1个无效等价类\n     \n     d. 可划分为1个有效等价类，1个无效等价类\n     \n     【试题解析】∶根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16s年龄≤40，两个无效等价类为年龄>40或年龄<16。\n\n 37. 在模拟环境下，常采用黑盒测试检验所开发的软件是否与需求规格说明书一致。其中有效性测试属于（）中的一个步骤。\n     \n     a. 单元测试\n     \n     b. 集成测试\n     \n     c. 确认测试\n     \n     d. 系统测试\n     \n     【试题解析】∶本题考查系统测试中的确认测试。确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。\n\n 38. 某程序根据输入的三条线段长度，判断这三条线段能否构成三角形。以下6个测试用例中，（）两个用例属于同一个等价类。 ①6、7、13; ②4、7、10; ③39、20、35; ④9、11、21; ⑤5、5、4;⑥4、4、4。\n\na. ①②\n\nb. ③④\n\nc. ⑤⑥\n\nd. ①④\n\n【试题解析】∶本题考查黑盒测试技术的等价类划分。①为前两边之和等于第三边;②为三边不等且任意两边之和大于第三边;③④前两边之 和小于第三边;⑤为其中有两边相等且可构成等腰三角形;⑥为三边相等且可构成等边三角形。\n\n 39. 软件测试是软件开发中不可缺少的活动，通常()在代码编写阶段进行。检查软件的功能是否与用户要求一致是（）的任务。\n     \n     问题一\n     \n     a. 验收测试\n     \n     b. 系统测试\n     \n     c. 单元测试\n     \n     d. 集成测试\n     \n     问题二\n     \n     a. 验收测试\n     \n     b. 系统测试\n     \n     c. 单元测试\n     \n     d. 集成测试\n     \n     【试题解析】∶本题考查软件开发阶段与测试的对应关系。通过单元测试,(也称为模块测试）消除程序模块内部存在的错误和缺陷，这类测试在代码编写阶段完成，通过集成测试(也称为组装测试）检测和排除子系统结构上的错误和缺陷，通过确认验收测试，验证软件功能是否满足用户要求，通过系统测试，在已确认的计算机软硬件环境下，通过与系统需求对比，发现系统与用户需求不符或矛盾的地方。\n\n 40. 软件可维护性是一个系统在特定的时间间隔内可以正常进行维护活动的概率。用mttf和mttr分别表示平均无故障时间和平均故障修复时间，则软件可维护性计算公式为（）。\n     \n     a. mttf/(1+mttf)\n     \n     b. 1/(1+mttf)\n     \n     c. mttr/(1+mttr)\n     \n     d. 1/(1+mttr)\n     \n     【试题解析】∶在软件外部，可以用 mttr 来度量软件的可维护性，它指出处理一个有错误的软件需要花费的平均时间。如果用m表示可维护性指标，那么 m=1/(1+mttr)。本题选择 d 选项。 a选项一般用来表示可靠性或可用性指标。\n\n 41. 以下关于软件维护的叙述中，不正确的是（）。\n     \n     a. 软件维护解决软件产品交付用户之后进行中发生的各种问题\n     \n     b. 软件维护期通常比开发期长得多，投入也大得多\n     \n     c. 软件的可维护性是软件开发阶段各个时期的关键目标\n     \n     d. 相对于软件开发任务而言，软件维护工作要简单得多\n     \n     【试题解析】∶软件维护是软件生命周期最长的一段，相对于软件开发任务而言，软件维护工作要更加复杂，d选项描述不正确。\n\n 42. 软件维护工具不包括（）工具。\n     \n     a. 版本控制\n     \n     b. 配置管理\n     \n     c. 文档分析\n     \n     d. 逆向工程\n     \n     【试题解析】∶辅助软件维护过程中的活动的软件称为"软件维护工具”，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：1、版本控制工具；2、文档分析工具；3、开发信息库工具；4、逆向工程工具；5、再工程工具；6、配置管理支持工具。\n\n 43. 以下关于软件维护和可维护性的叙述中，不正确的是（）。\n     \n     a. 软件维护要解决软件产品交付用户之后运行中发生的各种问题\n     \n     b. 软件的维护期通常比开发期长得多，其投入也大得多\n     \n     c. 进行质量保证审查可以提高软件产品的可维护性\n     \n     d. 提高可维护性是在软件维护阶段考虑的问题\n     \n     【试题解析】∶在软件开发的各个阶段都需考虑软件的可维护性。\n\n 44. 某搜索引擎在交付后，开发人员修改了其中的索引方法，使得用户可以更快地得到搜索结果。这种修改属于（）维护。\n     \n     a. 正确性\n     \n     b. 适应性\n     \n     c. 完善性\n     \n     d. 预防性\n     \n     【试题解析】∶在软件开发的各个阶段都需考虑软件的可维护性。\n\n 45. 某商场的销售系统所使用的信用卡公司信息系统的数据格式发生了更改，因此对该销售系统进行的修改属于（）维护。\n     \n     a. 改正性\n     \n     b. 适应性\n     \n     c. 改善性\n     \n     d. 预防性\n     \n     【试题解析】∶在系统运行过程中，软件需要维护的原因是多样的，根据维护的原因不同，可以将软件维护分为以下四种: (1)改正性维护。为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程就称为改正性维护。 (2)适应性维护。在使用过程中，外部环境(新的硬、软件配置)、数据环境(数据库、数据格式、数据输入/输出方式、数据存储介质)可能发生变化。为使软件适应这种变化，而去修改软件的过程就称为适应性维护。 (3)改善性维护。在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动称为改善性维护。 (4)预防性维护。这是指预先提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础。本题对该销售系统的修改是为了应对数据格式的变化而作出的修改。\n\n 46. 进行防错性程序设计，可以有效地控制（）维护成本。\n     \n     a. 正确性\n     \n     b. 适应性\n     \n     c. 完善性\n     \n     d. 预防性\n     \n     【试题解析】∶改正性维护也叫正确性维护，是指在使用过程中发现了隐蔽的错误后，为了诊断和改正这些隐蔽错误而修改软件的活动。 适应性维护是指为了适应变化了的环境而修改软件的活动。 完善性维护是指为了扩充或完善原有软件的功能或性能而修改软件的活动。 预防性维护是指为了提高软件的可维护性和可靠性、为未来的进一步改进打下基础而修改软件的活动。 防错性的程序设计，可以减少在系统运行时发生错误，有效地控制正确性维护的成本。\n\n 47. 改正在软件系统开发阶段已经发生而系统测试阶段还没有发现的错误，属于（）维护。\n     \n     a. 正确性\n     \n     b. 适应性\n     \n     c. 完善性\n     \n     d. 预防性\n     \n     【试题解析】∶软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。\n\n 48. iso/iec软件质量模型中，易使用性是指与使用所需的努力和由一组规定或隐含的用户对这样使用所作的个别评价有关的一组属性，其子特性不包括（）。\n     \n     a. 易理解性\n     \n     b. 易学性\n     \n     c. 易分析性\n     \n     d. 易操作性\n     \n     【试题解析】∶易用性的自特性包括易理解性、易学性、易操作性，其中c选项易分析性属于可维护性的子特性。\n\n 49. 在iso/iec 9126软件质量模型中，可靠性质量特性是指在规定的一段时间内和规定的条件下，软件维持在其性能水平有关的能力，其质量子特性不包括（）。\n     \n     a. 安全性\n     \n     b. 成熟性\n     \n     c. 容错性\n     \n     d. 易恢复性\n     \n     【试题解析】∶\n     \n     \n\n 50. 根据isoiec 9126软件质量模型中对软件质量特性的定义，可维护性质量特性的（）子特性是指与为确认经修改软件所需努力有关的软件属性。\n     \n     a. 易测试性\n     \n     b. 易分析性\n     \n     c. 稳定性\n     \n     d. 易改变性\n     \n     【试题解析】∶可维护性质量特性是指与软件维护的难易程度相关的一组软件属性，它包含了易分析性、稳定性、易测试性和易改变性4个子特性。其中: 易分析性是描述诊断缺陷或失效原因、判定待修改程度的难易程度的特性。 稳定性是描述修改造成难以预料的后果的风险程度，风险程度越低，稳定性越好。 易测试性是描述测试已修改软件的难易程度的特性。 易改变性是描述修改、排错或适应环境变化的难易程度。 本题中，是说与为确认经修改软件所需努力有关的软件属性，也就是说要确认修改后的软件是否正确所要付出的努力，这应该是易测试性所描述的内容，因此本题答案选a。',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"UML详解",frontmatter:{title:"UML详解",date:"2022-12-18T23:56:06.000Z",permalink:"/pages/3cb6ac/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/10.UML/02.UML%E8%AF%A6%E8%A7%A3.html",relativePath:"01.指南/10.UML/02.UML详解.md",key:"v-41b1c054",path:"/pages/3cb6ac/",headers:[{level:2,title:"UML详解",slug:"uml详解",normalizedTitle:"uml详解",charIndex:2},{level:2,title:"1.UML概述",slug:"_1-uml概述",normalizedTitle:"1.uml概述",charIndex:12},{level:3,title:"1.1.什么是UML",slug:"_1-1-什么是uml",normalizedTitle:"1.1.什么是uml",charIndex:24},{level:3,title:"1.2.UML的目标",slug:"_1-2-uml的目标",normalizedTitle:"1.2.uml的目标",charIndex:188},{level:3,title:"1.3.UML的应用范围",slug:"_1-3-uml的应用范围",normalizedTitle:"1.3.uml的应用范围",charIndex:353},{level:3,title:"1.4.UML的构造块",slug:"_1-4-uml的构造块",normalizedTitle:"1.4.uml的构造块",charIndex:372},{level:2,title:"2.用例图",slug:"_2-用例图",normalizedTitle:"2.用例图",charIndex:407},{level:3,title:"2.1.用例图基本概念",slug:"_2-1-用例图基本概念",normalizedTitle:"2.1.用例图基本概念",charIndex:417},{level:4,title:"2.1.1.使用范围——需求分析",slug:"_2-1-1-使用范围-需求分析",normalizedTitle:"2.1.1.使用范围——需求分析",charIndex:509},{level:4,title:"2.1.2.基本概念",slug:"_2-1-2-基本概念",normalizedTitle:"2.1.2.基本概念",charIndex:586},{level:4,title:"2.1.3.用例图示例",slug:"_2-1-3-用例图示例",normalizedTitle:"2.1.3.用例图示例",charIndex:865},{level:3,title:"2.2.参与者",slug:"_2-2-参与者",normalizedTitle:"2.2.参与者",charIndex:883},{level:4,title:"2.2.1.参与者概念",slug:"_2-2-1-参与者概念",normalizedTitle:"2.2.1.参与者概念",charIndex:894},{level:4,title:"2.2.2.如何确认参与者",slug:"_2-2-2-如何确认参与者",normalizedTitle:"2.2.2.如何确认参与者",charIndex:1044},{level:4,title:"2.2.3. 参与者分类",slug:"_2-2-3-参与者分类",normalizedTitle:"2.2.3. 参与者分类",charIndex:1238},{level:4,title:"2.2.4.参与者的泛化关系",slug:"_2-2-4-参与者的泛化关系",normalizedTitle:"2.2.4.参与者的泛化关系",charIndex:1377},{level:3,title:"2.3.用例",slug:"_2-3-用例",normalizedTitle:"2.3.用例",charIndex:1514},{level:4,title:"2.3.1.用例的概念",slug:"_2-3-1-用例的概念",normalizedTitle:"2.3.1.用例的概念",charIndex:1524},{level:4,title:"2.3.2.用例与参与者的关系",slug:"_2-3-2-用例与参与者的关系",normalizedTitle:"2.3.2.用例与参与者的关系",charIndex:1725},{level:4,title:"2.3.4.用例的特征",slug:"_2-3-4-用例的特征",normalizedTitle:"2.3.4.用例的特征",charIndex:1843},{level:3,title:"2.4.用例之间的关系",slug:"_2-4-用例之间的关系",normalizedTitle:"2.4.用例之间的关系",charIndex:1971},{level:4,title:"2.4.1.泛化关系",slug:"_2-4-1-泛化关系",normalizedTitle:"2.4.1.泛化关系",charIndex:2013},{level:4,title:"2.4.2.依赖关系——包含",slug:"_2-4-2-依赖关系-包含",normalizedTitle:"2.4.2.依赖关系——包含",charIndex:2160},{level:4,title:"2.4.3.依赖关系——扩展",slug:"_2-4-3-依赖关系-扩展",normalizedTitle:"2.4.3.依赖关系——扩展",charIndex:2371},{level:4,title:"2.4.4.包含、扩展的区别",slug:"_2-4-4-包含、扩展的区别",normalizedTitle:"2.4.4.包含、扩展的区别",charIndex:2682},{level:3,title:"2.5.用例描述与文档",slug:"_2-5-用例描述与文档",normalizedTitle:"2.5.用例描述与文档",charIndex:3171},{level:4,title:"2.5.1用例描述概述",slug:"_2-5-1用例描述概述",normalizedTitle:"2.5.1用例描述概述",charIndex:3186},{level:4,title:"2.5.2.前置条件与后置条件",slug:"_2-5-2-前置条件与后置条件",normalizedTitle:"2.5.2.前置条件与后置条件",charIndex:3601},{level:4,title:"2.5.3.事件流",slug:"_2-5-3-事件流",normalizedTitle:"2.5.3.事件流",charIndex:3814},{level:4,title:"2.5.4.补充约束",slug:"_2-5-4-补充约束",normalizedTitle:"2.5.4.补充约束",charIndex:3967},{level:2,title:"3.类图",slug:"_3-类图",normalizedTitle:"3.类图",charIndex:4109},{level:3,title:"3.1.类图简介",slug:"_3-1-类图简介",normalizedTitle:"3.1.类图简介",charIndex:4118},{level:3,title:"3.2.类",slug:"_3-2-类",normalizedTitle:"3.2.类",charIndex:4242},{level:4,title:"3.2.1.类——属性",slug:"_3-2-1-类-属性",normalizedTitle:"3.2.1.类——属性",charIndex:4412},{level:4,title:"3.2.2.类——操作",slug:"_3-2-2-类-操作",normalizedTitle:"3.2.2.类——操作",charIndex:4689},{level:4,title:"3.2.3.类——职责",slug:"_3-2-3-类-职责",normalizedTitle:"3.2.3.类——职责",charIndex:4853},{level:3,title:"3.3.接口",slug:"_3-3-接口",normalizedTitle:"3.3.接口",charIndex:4997},{level:3,title:"3.4.类图中的关系",slug:"_3-4-类图中的关系",normalizedTitle:"3.4.类图中的关系",charIndex:5165},{level:4,title:"3.4.1.类图中的关系——关联关系",slug:"_3-4-1-类图中的关系-关联关系",normalizedTitle:"3.4.1.类图中的关系——关联关系",charIndex:5215},{level:4,title:"3.4.2.类图中的关系——泛化关系",slug:"_3-4-2-类图中的关系-泛化关系",normalizedTitle:"3.4.2.类图中的关系——泛化关系",charIndex:6370},{level:4,title:"3.4.3.类图中的关系——依赖关系",slug:"_3-4-3-类图中的关系-依赖关系",normalizedTitle:"3.4.3.类图中的关系——依赖关系",charIndex:6744},{level:4,title:"3.4.4.类图中的关系——实现关系",slug:"_3-4-4-类图中的关系-实现关系",normalizedTitle:"3.4.4.类图中的关系——实现关系",charIndex:7005},{level:2,title:"4.综合例子",slug:"_4-综合例子",normalizedTitle:"4.综合例子",charIndex:7180}],headersStr:"UML详解 1.UML概述 1.1.什么是UML 1.2.UML的目标 1.3.UML的应用范围 1.4.UML的构造块 2.用例图 2.1.用例图基本概念 2.1.1.使用范围——需求分析 2.1.2.基本概念 2.1.3.用例图示例 2.2.参与者 2.2.1.参与者概念 2.2.2.如何确认参与者 2.2.3. 参与者分类 2.2.4.参与者的泛化关系 2.3.用例 2.3.1.用例的概念 2.3.2.用例与参与者的关系 2.3.4.用例的特征 2.4.用例之间的关系 2.4.1.泛化关系 2.4.2.依赖关系——包含 2.4.3.依赖关系——扩展 2.4.4.包含、扩展的区别 2.5.用例描述与文档 2.5.1用例描述概述 2.5.2.前置条件与后置条件 2.5.3.事件流 2.5.4.补充约束 3.类图 3.1.类图简介 3.2.类 3.2.1.类——属性 3.2.2.类——操作 3.2.3.类——职责 3.3.接口 3.4.类图中的关系 3.4.1.类图中的关系——关联关系 3.4.2.类图中的关系——泛化关系 3.4.3.类图中的关系——依赖关系 3.4.4.类图中的关系——实现关系 4.综合例子",content:"# UML详解\n\n\n# 1.UML概述\n\n\n# 1.1.什么是UML\n\n统一建模语言（UML）是一种通用的可视化建模语言，可以用来描述、可视化、构造和文档化软件密集型系统的各种工件。\n\nUML是独立于过程的，它适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具。\n\n> 注：UML不是一种程序设计语言，其描述的模型可以和各种编程语言相联系。\n\n\n# 1.2.UML的目标\n\n 1. 为建模者提供可用的、富有表达力的、可视化的建模语言，以开发和交换有意义的模型。\n 2. 提供可扩展性和特殊化机制以延伸核心概念。\n 3. 支持独立于编程语言和开发过程的规范。\n 4. 为理解建模语言提供正式的基础。\n 5. 推动面向对象建模工具市场的成长。\n 6. 支持更高级的开发概念。\n\n\n# 1.3.UML的应用范围\n\n\n\n\n# 1.4.UML的构造块\n\nUML的构造块：事物、关系、图\n\n\n\n\n# 2.用例图\n\n\n# 2.1.用例图基本概念\n\n用例图是用来描述系统功能的技术，表示一个系统中用例与参与者及其关系的图，主要用于需求分析阶段。\n\n用例图的基本组成元素：参与者、用例、元素之间的关系。\n\n# 2.1.1.使用范围——需求分析\n\n 1. 捕获需求。描述功能需求、行为需求（系统要完成什么任务）\n 2. 分析需求。明确类和对象，建立之间的关系\n\n# 2.1.2.基本概念\n\n 1. 用例图是表示一个系统中用例与参与者关系之间的图。它描述了系统中相关的用户和系统对不同用户提供的功能和服务。 用例图相当于从用户的视角来描述和建模整个系统，分析系统的功能与行为。 用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图还可以包括注解和约束，也可以使用包将图中的元素组合成模块。\n\n 2. 用例图相当于从用户的视角来描述和建模整个系统，分析系统的功能与行为。\n\n 3. 用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图还可以包括注解和约束，也可以使用包将图中的元素组合成模块。\n\n# 2.1.3.用例图示例\n\n\n\n\n# 2.2.参与者\n\n# 2.2.1.参与者概念\n\n 1. 参与者是与系统主体交互的外部实体的类元，描述了一个或一组与系统产生交互的外部用户或外部事物。\n 2. 参与者位于系统边界之外，而不是系统的一部分。\n 3. 参与者是从现实世界中抽象出来的一种形式，却不一定确切对应的现实中的某个特定对象。\n\n参与者的表示：\n\n\n\n# 2.2.2.如何确认参与者\n\n通过对参与者进行关注和分析，我们可以把重点放在如何与系统交互这一问题上，便于进一步确定系统的边界。另外，参与者也决定了系统需求的完整性。\n\n确定参与者可以从以下几个角度来考虑：\n\n 1. 为系统提供输入的人或事物\n 2. 接收系统输出的人或事物\n 3. 需要接入的第三方系统或设备\n 4. 时间是否会触发某些事件\n 5. 负责支持或维护系统中信息的人\n\n# 2.2.3. 参与者分类\n\n主要业务参与者：主要从用例的执行中获得好处的关联人员。\n\n主要系统参与者：直接同系统交互以发起或触发业务或系统事件的关联人员。\n\n外部服务参与者：响应来自用例的请求的关联人员。\n\n外部接收参与者：从用例中接收某些价值或输出的非主要的关联人员。\n\n# 2.2.4.参与者的泛化关系\n\n当系统中的几个参与者既扮演自身的角色，同时也有更一般化的角色时，可以通过建立泛化关系来进行描述。\n\n与类相似，父参与者可以是抽象的，即不能创建一个父参与者的直接实例，这就要求属于抽象父参与者的外部对象一定能够属于其子参与者之一。\n\n\n\n\n# 2.3.用例\n\n# 2.3.1.用例的概念\n\n用例是类元提供的一个内聚的的功能单元，表明系统与一个或多个参与者之间信息交换的顺序，也表明了系统执行的动作。\n\n简单来说，用例就是某一个参与者在系统中做某件事从开始到结束的一系列活动的集合，以及结束时应该返回的可观测、有意义的结果，其中也包含可能的各种分支情况。\n\n用例与用例图被广泛使用于系统的需求建模阶段，并在系统的整个生命周期中被不断细化。\n\n用例表示如下：\n\n\n\n# 2.3.2.用例与参与者的关系\n\n一个用例可以隶属一个或多个参与者，一个参与者也可以参与一个或多个用例。用例与参与者之间存在关联关系。\n\n主参与者与次参与者：通常来说主参与者是用例的重要服务对象，而次参与者处于一种协作地位。\n\n\n\n# 2.3.4.用例的特征\n\n用例的特征保证用例能够正确地捕捉功能性需求，同时也是判断用例是否准确的依据。\n\n 1. 用例是动宾短语\n 2. 用例是相对独立的\n 3. 用例是由参与者启动的\n 4. 用例要有可观测的执行结果\n 5. 一个用例是一个单元\n\n\n# 2.4.用例之间的关系\n\n用例之间的关系有：泛化关系、依赖关系（包含、扩展）\n\n# 2.4.1.泛化关系\n\n与参与者的泛化关系相似，用例的泛化关系将特化的用例与一般化的用例联系起来。子用例继承了父用例的属性、操作和行为序列，并且可以增加属于自己的附加属性和操作。父用例同样可以定义为抽象用例。\n\n用例之间的泛化关系表示为一根实线三角箭头，箭头指向父用例一方。如下图：\n\n\n\n# 2.4.2.依赖关系——包含\n\n包含指的是一个用例（基用例）可以包含其他用例（包含用例）具有的行为，其中包含用例中定义的行为将被插入基用例定义的行为中。\n\n包含的两个基本约束：\n\n 1. 基用例可以看到包含用例，并需要依赖于包含用例的执行结果，但是它对包含用例的内部结构没有了解；\n 2. 基用例一定会要求包含用例执行。\n\n包含表示为一个虚线箭头附加上《include》的构造型，箭头从基用例指向包含用例。\n\n\n\n\n\n# 2.4.3.依赖关系——扩展\n\n扩展指的是一个用例（扩展用例）对另一个用例（基用例）行为的增强。\n\n扩展使用一个附加了《enxtend》构造型的虚线箭头表示，箭头指向基用例。\n\n注意：扩展与包含的箭头方向是相反的，这表明扩展取决于扩展用例而非基用例，扩展用例决定扩展的执行时机，基用例对此一无所知。\n\n\n\n\n\n扩展用例的使用包括四个部分：\n\n 1. 基用例：需要被扩展的用例，“注册”用例。\n 2. 扩展用例：提供所添加的行为序列的用例。\n 3. 扩展关系：使用虚线箭头表示，箭头指向基用例。\n 4. 扩展点：基用例中的一个或多个位置，表示在该位置会根据某条件来决定是否要中断基用例的执行从而执行扩展用例中的片段。\n\n# 2.4.4.包含、扩展的区别\n\n根本区别，包含是无条件执行，扩展是有条件执行。图的起点不同，终点也不同。\n\n特性                   INCLUDE                      EXTEND\n作用                   增强基用例的行为                     增强基用例的行为\n执行过程                 包含用例一定会执行                    扩展用例可能被执行\n对基用例的要求              在没有包含用例的情况下，基用例可以是也可以不是良构的   在没有扩展用例的情况下，基用例一定是良构的\n表示法                  箭头指向包含用例                     箭头指向基用例\n基用例对增强行为的可见性         基用例可以看到包含用例，并决定包含用例的执行       基用例对扩展用例一无所知\n基用例每执行一次，增强行为的执行次数   只执行一次                        取决于条件（0到多次）\n\n\n# 2.5.用例描述与文档\n\n# 2.5.1用例描述概述\n\n一个完整的用例模型应该不仅仅包括用例图部分，还要有完整的用例描述部分。\n\n一般的用例描述主要包括以下几部分内容：\n\n * 用例名称：描述用例的意图或实现的目标，一般为动词或动宾短语。\n * 用例编号：用例的唯一标识符，在其他位置可以使用该标识符来引用用例。\n * 参与者：描述用例的参与者，包括主要参与者和其他参与者。\n * 用例描述：对用例的一段简单的概括描述。\n * 触发器：触发用例执行的一个事件。\n * 前置条件：用例执行前系统状态的约束条件。\n * 基本事件流（典型过程）：用例的常规活动序列，包括参与者发起的动作与系统执行的响应活动。\n * 扩展事件流（替代过程）：记录如果典型过程出现异常或变化时的用例行为，即典型过程以外的其他活动步骤。\n * 结论：描述用例何时结束。\n * 后置条件：用例执行后系统状态的约束条件。\n * 补充约束：用例实现时需要考虑的业务规则、实现约束等信息。\n\n# 2.5.2.前置条件与后置条件\n\n 1. 前置条件指的是用例执行前系统和参与者应处于的状态。前置条件是用例的入口限制，它便于我们在进行系统分析及设计的时候注意到，在何时何地才可以合法地触发这个事件。\n\n 2. 后置条件是用例执行完毕后系统处于的状态。后置条件是对用例执行完毕后系统状况的总结，用来确保用户理解用例执行完毕后的结果，并非其他用例的触发器。\n\n 3. 前置条件与后置条件分别是用例在开始和结束时的必要条件。\n\n# 2.5.3.事件流\n\n事件流是对用例在使用场景下的交互动作的抽象，应该包括用例何时以及怎样开始和结束，用例何时与参与者交互，该行为的基本流和可选择的流。\n\n * 基本事件流：描述的是用例中最核心的事件流，是用例大部分时间所进行的场景。\n * 扩展事件流：描述的是用例处理过程中的一些分支或异常情况。\n\n# 2.5.4.补充约束\n\n补充约束用来描述用例在系统功能之外的内容，例如非功能需求、业务规则等等。\n\n数据需求：与该用例相关的一些数据项的说明。\n\n业务规则：与业务相关的逻辑和操作规则。\n\n非功能性需求：例如性能、支持的并发量等。\n\n设计约束：是从多个角度对用例或系统的约定。\n\n\n# 3.类图\n\n\n# 3.1.类图简介\n\n类图的定义：是显示一组类、接口、协作以及它们之间关系的图。\n\n类图主要包含7种元素：类、接口、协作、依赖关系、泛化关系、实现关系、关联关系。\n\n类图：包、子系统，用来把模型元素聚集成更大的组块。\n\n类图：约束、注解\n\n\n\n\n# 3.2.类\n\n 1. 类是一组拥有相同的属性、操作、方法、关系和行为的对象地描述符。\n 2. 类定义了一组有着状态与行为的对象。类的状态由属性和关联来描述，个体行为由操作来描述，对象的生命周期则由附加给类的状态机来描述。\n 3. 在UML中，类表达成一个有三个分隔区的矩形。其中顶端显示类名，中间显示类的属性，尾端显示类的操作。\n\n\n\n# 3.2.1.类——属性\n\n可见性：描述了该属性在那些范围内可以被使用。\n\n类型：属性的数据类型，可以系统固有，也可以用户自定义。属性的类型决定了该属性的所有可能取值的集合。\n\n可见性   英文限定符       UML标准图示   ROSE图示   说明\n公有    public      +                  其他类可以访问\n私有    private     -                  只对本类可见，不能被其他类访问\n保护    protected   #                  对本类及其派生类可见\n\n# 3.2.2.类——操作\n\n可见性：同样描述该操作在那些范围内可以使用，与属性的可见性相同。\n\n参数列表：是一些按照顺序排列的属性定义了操作的输入。例如：oper(out arg1:int, arg2:double=3.2)\n\n返回类型即回送调用对象消息的类型。void关键字表示无返回值。\n\n特性是对操作性质的约束说明。\n\n# 3.2.3.类——职责\n\n职责是类的契约或责任。当创建一个类时，就声明了这个类的所有对象具有相同种类的状态和相同种类的行为。在较高的抽象层次上，这些相应的属性和操作正式要完成类的职责的特征。\n\n类的职责是自由形式的文本，在非正式的类图中，可以将职责列在类图操作下的另一分割栏中。\n\n\n# 3.3.接口\n\n 1. 接口是一个被命名的操作集合，用于描述类或组件的一个服务。\n 2. 接口不包含属性与方法实现，但可以有一些操作。接口的所有内容都是公有的。\n 3. 接口代表了一份契约，实现该接口的类元必须履行它。\n 4. 在UML中，接口由一个带名称的小圆圈表示；也可以表示为带有<<interface>>构造型的类\n\n\n\n\n# 3.4.类图中的关系\n\nUML中最常用的四种关系，即关联关系、泛化关系、依赖关系和实现关系。\n\n# 3.4.1.类图中的关系——关联关系\n\n 1. 关联的实例被称为链，每个链由一组有序或无序的对象组成。\n 2. 关联关系靠近被关联元素的部分称为关联端，关联的大部分描述都包含在一组关联端的列表里，每个端用来描述关联中类的对象的参与\n 3. 二元关联、自关联、N元关联。\n\n\n\n * 关联名称：放在关联路径的旁边，但远离关联端。\n\n * 角色：放在靠近关联端的部分，表示该关联端连接的类在这一关联关系中担任的角色。角色名上也可使用可见性修饰符号。\n\n * 多重性：放在靠近关联端的部分，表示在关联关系中源端的一个对象可以与目标类的多少个对象之间有关联。\n\n * 导航性：一个布尔值，用来说明运行时刻是否可能穿越一个关联。\n\n * 限定符：是二元关联上的属性组成的列表的插槽，其中的属性值用来从整个对象集合里选择一个唯一的关联对象或者关联对象的集合。\n\n * 约束：关联间的约束关系。\n\n\n\n> 示例：\n\n比如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；再例如公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司。（表示有关联，也可以表示多重性）\n\n\n\n派生关联：属于一种派生元素。它不增加语义信息，只是一种可以由两个或两个以上的基础关联推算出来的虚拟关联。\n\n\n\n两种特殊的关联关系：聚合关系与组合关系\n\n1.聚合关系：描述“整体-部分”的关联关系\n\n聚合关系没有改变整体与部分之间整个关联的导航含义，也与整体和部分的生命周期无关。（部分与整体相互独立）\n\n\n\n2.组合关系：描述“整体-部分”的关联关系\n\n组合关系中的部分要完全依赖于整体。\n\n\n\n关联与聚合的区别\n\n 1. 关联关系所涉及的两个对象是处在同一个层次上的。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。聚合关系涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。\n 2. 对于具有聚集关系（尤其是强聚集关系）的两个对象，整体对象会制约它的组成对象的生命周期。部分类的对象不能单独存在，它的生命周期依赖于整体类的对象的生命周期，当整体消失，部分也就随之消失。比如张三的电脑被偷了，那么电脑的所有组件也不存在了，除非张三事先把一些电脑的组件（比如硬盘和内存）拆了下来。\n\n\n\n聚合与组合的区别\n\n 1. 聚合关系：涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。\n 2. 组合关系：代表整体的对象负责代表部分对象的生命周期。公司不存在，部门也没有意义了。再例如：人和五脏六腑、四肢的关系。\n\n\n\n# 3.4.2.类图中的关系——泛化关系\n\n泛化关系定义为一个较普通的元素与一个较特殊的元素之间的类元关系。其中描述一般的元素称为父，描述特殊的元素称为子。（子类是父类的继承，则父类就是子类的泛化。）\n\n通过泛化对应的继承机制使子类共享父类的属性和操作，小了模型的规模，同时也防止了模型的更新所导致的定义不一致的意外。\n\n泛化关系的特征：\n\n 1. 传递性：一个类子类的子类同样继承了这个类的特性。在父方向上经过了一个或几个泛化的元素被称为祖先，在子方向上则被称为后代。\n 2. 反对称性：泛化关系不能成环，即一个类不可能是自己的祖先和自己的后代。\n\n泛化关系的两种情况：\n\n 1. 单继承：每个类之多能拥有一个父类。编程语言：C#、Java等\n 2. 多重继承：子类可以有多个父类并继承了所有父类的结构、行为和约束。编程语言：C++等\n\n\n\n\n\n# 3.4.3.类图中的关系——依赖关系\n\n依赖关系表示的是两个元素之间语义上的连接关系。对于两个元素X和Y，如果元素X的变化会引起对另一个元素Y的变化，则称元素Y依赖于X。其中，X被称为提供者，Y被称为客户。\n\n现实例子：\n\n比如说你要去拧螺丝，你是不是要借助(也就是依赖)螺丝刀(Screwdriver)来帮助你完成拧螺丝(screw)的工作。\n\n对于类图而言，主要有以下需要使用依赖的情况：\n\n 1. 客户类向提供者类发送消息。\n 2. 提供者类是客户类的属性类型。\n 3. 提供者类是客户类操作的参数类型。\n\n\n\n# 3.4.4.类图中的关系——实现关系\n\n实现关系用来表示规格说明与实现之间的关系。在类图中，实现关系主要用于接口与实现该接口的类之间。\n\n一个类可以实现多个接口，一个接口也可以被多个类实现。\n\n实现关系的两种表示法：\n\n * 当接口元素以带构造型的类的方式表示时，用虚线三角形箭头表示。\n * 当接口元素以小圆圈方式表示时，用实线表示。\n\n\n\n\n# 4.综合例子\n\n",normalizedContent:"# uml详解\n\n\n# 1.uml概述\n\n\n# 1.1.什么是uml\n\n统一建模语言（uml）是一种通用的可视化建模语言，可以用来描述、可视化、构造和文档化软件密集型系统的各种工件。\n\numl是独立于过程的，它适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具。\n\n> 注：uml不是一种程序设计语言，其描述的模型可以和各种编程语言相联系。\n\n\n# 1.2.uml的目标\n\n 1. 为建模者提供可用的、富有表达力的、可视化的建模语言，以开发和交换有意义的模型。\n 2. 提供可扩展性和特殊化机制以延伸核心概念。\n 3. 支持独立于编程语言和开发过程的规范。\n 4. 为理解建模语言提供正式的基础。\n 5. 推动面向对象建模工具市场的成长。\n 6. 支持更高级的开发概念。\n\n\n# 1.3.uml的应用范围\n\n\n\n\n# 1.4.uml的构造块\n\numl的构造块：事物、关系、图\n\n\n\n\n# 2.用例图\n\n\n# 2.1.用例图基本概念\n\n用例图是用来描述系统功能的技术，表示一个系统中用例与参与者及其关系的图，主要用于需求分析阶段。\n\n用例图的基本组成元素：参与者、用例、元素之间的关系。\n\n# 2.1.1.使用范围——需求分析\n\n 1. 捕获需求。描述功能需求、行为需求（系统要完成什么任务）\n 2. 分析需求。明确类和对象，建立之间的关系\n\n# 2.1.2.基本概念\n\n 1. 用例图是表示一个系统中用例与参与者关系之间的图。它描述了系统中相关的用户和系统对不同用户提供的功能和服务。 用例图相当于从用户的视角来描述和建模整个系统，分析系统的功能与行为。 用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图还可以包括注解和约束，也可以使用包将图中的元素组合成模块。\n\n 2. 用例图相当于从用户的视角来描述和建模整个系统，分析系统的功能与行为。\n\n 3. 用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图还可以包括注解和约束，也可以使用包将图中的元素组合成模块。\n\n# 2.1.3.用例图示例\n\n\n\n\n# 2.2.参与者\n\n# 2.2.1.参与者概念\n\n 1. 参与者是与系统主体交互的外部实体的类元，描述了一个或一组与系统产生交互的外部用户或外部事物。\n 2. 参与者位于系统边界之外，而不是系统的一部分。\n 3. 参与者是从现实世界中抽象出来的一种形式，却不一定确切对应的现实中的某个特定对象。\n\n参与者的表示：\n\n\n\n# 2.2.2.如何确认参与者\n\n通过对参与者进行关注和分析，我们可以把重点放在如何与系统交互这一问题上，便于进一步确定系统的边界。另外，参与者也决定了系统需求的完整性。\n\n确定参与者可以从以下几个角度来考虑：\n\n 1. 为系统提供输入的人或事物\n 2. 接收系统输出的人或事物\n 3. 需要接入的第三方系统或设备\n 4. 时间是否会触发某些事件\n 5. 负责支持或维护系统中信息的人\n\n# 2.2.3. 参与者分类\n\n主要业务参与者：主要从用例的执行中获得好处的关联人员。\n\n主要系统参与者：直接同系统交互以发起或触发业务或系统事件的关联人员。\n\n外部服务参与者：响应来自用例的请求的关联人员。\n\n外部接收参与者：从用例中接收某些价值或输出的非主要的关联人员。\n\n# 2.2.4.参与者的泛化关系\n\n当系统中的几个参与者既扮演自身的角色，同时也有更一般化的角色时，可以通过建立泛化关系来进行描述。\n\n与类相似，父参与者可以是抽象的，即不能创建一个父参与者的直接实例，这就要求属于抽象父参与者的外部对象一定能够属于其子参与者之一。\n\n\n\n\n# 2.3.用例\n\n# 2.3.1.用例的概念\n\n用例是类元提供的一个内聚的的功能单元，表明系统与一个或多个参与者之间信息交换的顺序，也表明了系统执行的动作。\n\n简单来说，用例就是某一个参与者在系统中做某件事从开始到结束的一系列活动的集合，以及结束时应该返回的可观测、有意义的结果，其中也包含可能的各种分支情况。\n\n用例与用例图被广泛使用于系统的需求建模阶段，并在系统的整个生命周期中被不断细化。\n\n用例表示如下：\n\n\n\n# 2.3.2.用例与参与者的关系\n\n一个用例可以隶属一个或多个参与者，一个参与者也可以参与一个或多个用例。用例与参与者之间存在关联关系。\n\n主参与者与次参与者：通常来说主参与者是用例的重要服务对象，而次参与者处于一种协作地位。\n\n\n\n# 2.3.4.用例的特征\n\n用例的特征保证用例能够正确地捕捉功能性需求，同时也是判断用例是否准确的依据。\n\n 1. 用例是动宾短语\n 2. 用例是相对独立的\n 3. 用例是由参与者启动的\n 4. 用例要有可观测的执行结果\n 5. 一个用例是一个单元\n\n\n# 2.4.用例之间的关系\n\n用例之间的关系有：泛化关系、依赖关系（包含、扩展）\n\n# 2.4.1.泛化关系\n\n与参与者的泛化关系相似，用例的泛化关系将特化的用例与一般化的用例联系起来。子用例继承了父用例的属性、操作和行为序列，并且可以增加属于自己的附加属性和操作。父用例同样可以定义为抽象用例。\n\n用例之间的泛化关系表示为一根实线三角箭头，箭头指向父用例一方。如下图：\n\n\n\n# 2.4.2.依赖关系——包含\n\n包含指的是一个用例（基用例）可以包含其他用例（包含用例）具有的行为，其中包含用例中定义的行为将被插入基用例定义的行为中。\n\n包含的两个基本约束：\n\n 1. 基用例可以看到包含用例，并需要依赖于包含用例的执行结果，但是它对包含用例的内部结构没有了解；\n 2. 基用例一定会要求包含用例执行。\n\n包含表示为一个虚线箭头附加上《include》的构造型，箭头从基用例指向包含用例。\n\n\n\n\n\n# 2.4.3.依赖关系——扩展\n\n扩展指的是一个用例（扩展用例）对另一个用例（基用例）行为的增强。\n\n扩展使用一个附加了《enxtend》构造型的虚线箭头表示，箭头指向基用例。\n\n注意：扩展与包含的箭头方向是相反的，这表明扩展取决于扩展用例而非基用例，扩展用例决定扩展的执行时机，基用例对此一无所知。\n\n\n\n\n\n扩展用例的使用包括四个部分：\n\n 1. 基用例：需要被扩展的用例，“注册”用例。\n 2. 扩展用例：提供所添加的行为序列的用例。\n 3. 扩展关系：使用虚线箭头表示，箭头指向基用例。\n 4. 扩展点：基用例中的一个或多个位置，表示在该位置会根据某条件来决定是否要中断基用例的执行从而执行扩展用例中的片段。\n\n# 2.4.4.包含、扩展的区别\n\n根本区别，包含是无条件执行，扩展是有条件执行。图的起点不同，终点也不同。\n\n特性                   include                      extend\n作用                   增强基用例的行为                     增强基用例的行为\n执行过程                 包含用例一定会执行                    扩展用例可能被执行\n对基用例的要求              在没有包含用例的情况下，基用例可以是也可以不是良构的   在没有扩展用例的情况下，基用例一定是良构的\n表示法                  箭头指向包含用例                     箭头指向基用例\n基用例对增强行为的可见性         基用例可以看到包含用例，并决定包含用例的执行       基用例对扩展用例一无所知\n基用例每执行一次，增强行为的执行次数   只执行一次                        取决于条件（0到多次）\n\n\n# 2.5.用例描述与文档\n\n# 2.5.1用例描述概述\n\n一个完整的用例模型应该不仅仅包括用例图部分，还要有完整的用例描述部分。\n\n一般的用例描述主要包括以下几部分内容：\n\n * 用例名称：描述用例的意图或实现的目标，一般为动词或动宾短语。\n * 用例编号：用例的唯一标识符，在其他位置可以使用该标识符来引用用例。\n * 参与者：描述用例的参与者，包括主要参与者和其他参与者。\n * 用例描述：对用例的一段简单的概括描述。\n * 触发器：触发用例执行的一个事件。\n * 前置条件：用例执行前系统状态的约束条件。\n * 基本事件流（典型过程）：用例的常规活动序列，包括参与者发起的动作与系统执行的响应活动。\n * 扩展事件流（替代过程）：记录如果典型过程出现异常或变化时的用例行为，即典型过程以外的其他活动步骤。\n * 结论：描述用例何时结束。\n * 后置条件：用例执行后系统状态的约束条件。\n * 补充约束：用例实现时需要考虑的业务规则、实现约束等信息。\n\n# 2.5.2.前置条件与后置条件\n\n 1. 前置条件指的是用例执行前系统和参与者应处于的状态。前置条件是用例的入口限制，它便于我们在进行系统分析及设计的时候注意到，在何时何地才可以合法地触发这个事件。\n\n 2. 后置条件是用例执行完毕后系统处于的状态。后置条件是对用例执行完毕后系统状况的总结，用来确保用户理解用例执行完毕后的结果，并非其他用例的触发器。\n\n 3. 前置条件与后置条件分别是用例在开始和结束时的必要条件。\n\n# 2.5.3.事件流\n\n事件流是对用例在使用场景下的交互动作的抽象，应该包括用例何时以及怎样开始和结束，用例何时与参与者交互，该行为的基本流和可选择的流。\n\n * 基本事件流：描述的是用例中最核心的事件流，是用例大部分时间所进行的场景。\n * 扩展事件流：描述的是用例处理过程中的一些分支或异常情况。\n\n# 2.5.4.补充约束\n\n补充约束用来描述用例在系统功能之外的内容，例如非功能需求、业务规则等等。\n\n数据需求：与该用例相关的一些数据项的说明。\n\n业务规则：与业务相关的逻辑和操作规则。\n\n非功能性需求：例如性能、支持的并发量等。\n\n设计约束：是从多个角度对用例或系统的约定。\n\n\n# 3.类图\n\n\n# 3.1.类图简介\n\n类图的定义：是显示一组类、接口、协作以及它们之间关系的图。\n\n类图主要包含7种元素：类、接口、协作、依赖关系、泛化关系、实现关系、关联关系。\n\n类图：包、子系统，用来把模型元素聚集成更大的组块。\n\n类图：约束、注解\n\n\n\n\n# 3.2.类\n\n 1. 类是一组拥有相同的属性、操作、方法、关系和行为的对象地描述符。\n 2. 类定义了一组有着状态与行为的对象。类的状态由属性和关联来描述，个体行为由操作来描述，对象的生命周期则由附加给类的状态机来描述。\n 3. 在uml中，类表达成一个有三个分隔区的矩形。其中顶端显示类名，中间显示类的属性，尾端显示类的操作。\n\n\n\n# 3.2.1.类——属性\n\n可见性：描述了该属性在那些范围内可以被使用。\n\n类型：属性的数据类型，可以系统固有，也可以用户自定义。属性的类型决定了该属性的所有可能取值的集合。\n\n可见性   英文限定符       uml标准图示   rose图示   说明\n公有    public      +                  其他类可以访问\n私有    private     -                  只对本类可见，不能被其他类访问\n保护    protected   #                  对本类及其派生类可见\n\n# 3.2.2.类——操作\n\n可见性：同样描述该操作在那些范围内可以使用，与属性的可见性相同。\n\n参数列表：是一些按照顺序排列的属性定义了操作的输入。例如：oper(out arg1:int, arg2:double=3.2)\n\n返回类型即回送调用对象消息的类型。void关键字表示无返回值。\n\n特性是对操作性质的约束说明。\n\n# 3.2.3.类——职责\n\n职责是类的契约或责任。当创建一个类时，就声明了这个类的所有对象具有相同种类的状态和相同种类的行为。在较高的抽象层次上，这些相应的属性和操作正式要完成类的职责的特征。\n\n类的职责是自由形式的文本，在非正式的类图中，可以将职责列在类图操作下的另一分割栏中。\n\n\n# 3.3.接口\n\n 1. 接口是一个被命名的操作集合，用于描述类或组件的一个服务。\n 2. 接口不包含属性与方法实现，但可以有一些操作。接口的所有内容都是公有的。\n 3. 接口代表了一份契约，实现该接口的类元必须履行它。\n 4. 在uml中，接口由一个带名称的小圆圈表示；也可以表示为带有<<interface>>构造型的类\n\n\n\n\n# 3.4.类图中的关系\n\numl中最常用的四种关系，即关联关系、泛化关系、依赖关系和实现关系。\n\n# 3.4.1.类图中的关系——关联关系\n\n 1. 关联的实例被称为链，每个链由一组有序或无序的对象组成。\n 2. 关联关系靠近被关联元素的部分称为关联端，关联的大部分描述都包含在一组关联端的列表里，每个端用来描述关联中类的对象的参与\n 3. 二元关联、自关联、n元关联。\n\n\n\n * 关联名称：放在关联路径的旁边，但远离关联端。\n\n * 角色：放在靠近关联端的部分，表示该关联端连接的类在这一关联关系中担任的角色。角色名上也可使用可见性修饰符号。\n\n * 多重性：放在靠近关联端的部分，表示在关联关系中源端的一个对象可以与目标类的多少个对象之间有关联。\n\n * 导航性：一个布尔值，用来说明运行时刻是否可能穿越一个关联。\n\n * 限定符：是二元关联上的属性组成的列表的插槽，其中的属性值用来从整个对象集合里选择一个唯一的关联对象或者关联对象的集合。\n\n * 约束：关联间的约束关系。\n\n\n\n> 示例：\n\n比如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；再例如公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司。（表示有关联，也可以表示多重性）\n\n\n\n派生关联：属于一种派生元素。它不增加语义信息，只是一种可以由两个或两个以上的基础关联推算出来的虚拟关联。\n\n\n\n两种特殊的关联关系：聚合关系与组合关系\n\n1.聚合关系：描述“整体-部分”的关联关系\n\n聚合关系没有改变整体与部分之间整个关联的导航含义，也与整体和部分的生命周期无关。（部分与整体相互独立）\n\n\n\n2.组合关系：描述“整体-部分”的关联关系\n\n组合关系中的部分要完全依赖于整体。\n\n\n\n关联与聚合的区别\n\n 1. 关联关系所涉及的两个对象是处在同一个层次上的。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。聚合关系涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。\n 2. 对于具有聚集关系（尤其是强聚集关系）的两个对象，整体对象会制约它的组成对象的生命周期。部分类的对象不能单独存在，它的生命周期依赖于整体类的对象的生命周期，当整体消失，部分也就随之消失。比如张三的电脑被偷了，那么电脑的所有组件也不存在了，除非张三事先把一些电脑的组件（比如硬盘和内存）拆了下来。\n\n\n\n聚合与组合的区别\n\n 1. 聚合关系：涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。\n 2. 组合关系：代表整体的对象负责代表部分对象的生命周期。公司不存在，部门也没有意义了。再例如：人和五脏六腑、四肢的关系。\n\n\n\n# 3.4.2.类图中的关系——泛化关系\n\n泛化关系定义为一个较普通的元素与一个较特殊的元素之间的类元关系。其中描述一般的元素称为父，描述特殊的元素称为子。（子类是父类的继承，则父类就是子类的泛化。）\n\n通过泛化对应的继承机制使子类共享父类的属性和操作，小了模型的规模，同时也防止了模型的更新所导致的定义不一致的意外。\n\n泛化关系的特征：\n\n 1. 传递性：一个类子类的子类同样继承了这个类的特性。在父方向上经过了一个或几个泛化的元素被称为祖先，在子方向上则被称为后代。\n 2. 反对称性：泛化关系不能成环，即一个类不可能是自己的祖先和自己的后代。\n\n泛化关系的两种情况：\n\n 1. 单继承：每个类之多能拥有一个父类。编程语言：c#、java等\n 2. 多重继承：子类可以有多个父类并继承了所有父类的结构、行为和约束。编程语言：c++等\n\n\n\n\n\n# 3.4.3.类图中的关系——依赖关系\n\n依赖关系表示的是两个元素之间语义上的连接关系。对于两个元素x和y，如果元素x的变化会引起对另一个元素y的变化，则称元素y依赖于x。其中，x被称为提供者，y被称为客户。\n\n现实例子：\n\n比如说你要去拧螺丝，你是不是要借助(也就是依赖)螺丝刀(screwdriver)来帮助你完成拧螺丝(screw)的工作。\n\n对于类图而言，主要有以下需要使用依赖的情况：\n\n 1. 客户类向提供者类发送消息。\n 2. 提供者类是客户类的属性类型。\n 3. 提供者类是客户类操作的参数类型。\n\n\n\n# 3.4.4.类图中的关系——实现关系\n\n实现关系用来表示规格说明与实现之间的关系。在类图中，实现关系主要用于接口与实现该接口的类之间。\n\n一个类可以实现多个接口，一个接口也可以被多个类实现。\n\n实现关系的两种表示法：\n\n * 当接口元素以带构造型的类的方式表示时，用虚线三角形箭头表示。\n * 当接口元素以小圆圈方式表示时，用实线表示。\n\n\n\n\n# 4.综合例子\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"UML概述",frontmatter:{title:"UML概述",date:"2022-12-18T23:55:40.000Z",permalink:"/pages/f43aaa/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/10.UML/01.UML%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/10.UML/01.UML概述.md",key:"v-1283332c",path:"/pages/f43aaa/",headers:[{level:2,title:"UML概述",slug:"uml概述",normalizedTitle:"uml概述",charIndex:2},{level:3,title:"1.UML简介",slug:"_1-uml简介",normalizedTitle:"1.uml简介",charIndex:12},{level:3,title:"2.UML模型图的构成",slug:"_2-uml模型图的构成",normalizedTitle:"2.uml模型图的构成",charIndex:258},{level:4,title:"2.1 事物",slug:"_2-1-事物",normalizedTitle:"2.1 事物",charIndex:273},{level:4,title:"2.2 关系",slug:"_2-2-关系",normalizedTitle:"2.2 关系",charIndex:776},{level:4,title:"2.3 图",slug:"_2-3-图",normalizedTitle:"2.3 图",charIndex:1043},{level:3,title:"3. UML语法描述",slug:"_3-uml语法描述",normalizedTitle:"3. uml语法描述",charIndex:2164}],headersStr:"UML概述 1.UML简介 2.UML模型图的构成 2.1 事物 2.2 关系 2.3 图 3. UML语法描述",content:"# UML概述\n\n\n# 1.UML简介\n\nUML (Unified Modeling Language)为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。\n\nUML的定义包括UML语义和UML表示法两个部分。\n\n * UML语义:UML对语义的描述使开发者能在语义上取得一致认识，消除了因人而异的表达方法所造成的影响；\n * UML表示法:UML表示法定义UML符号的表示法，为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准\n\n\n# 2.UML模型图的构成\n\n# 2.1 事物\n\n事物[Things] (4种)：UML模型中最基本的构成元素，是具有代表性的成分的抽象\n\n 1. 构件事物：UML模型的静态部分，描述概念或物理元素\n\n * 类：具有相同属性相同操作相同关系相同语义的对象的描述\n\n * 接口：描述元素的外部可见行为，即服务集合的定义说明\n\n * 协作：描述了一组事物间的相互作用的集合\n\n * 用例：代表一个系统或系统的一部分行为，是一组动作序列的集合\n\n * 构件：系统中物理存在，可替换的部件\n\n * 节点：运行时存在的物理元素\n\n * > 另外，参与者、信号应用、文档库、页表等都是上述基本事物的变体\n\n 2. 行为事物：UML模型图的动态部分，描述跨越空间和时间的行为\n\n * 交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列、链接\n * 状态机：描述事物或交互在生命周期内响应事件所经历的状态序列\n\n3.分组事物：UML模型图的组织部分，描述事物的组织结构\n\n * 包:把元素组织成组的机制\n   \n   4.注释事物：UML模型的解释部分，用来对模型中的元素进行说明、解释\n\n * 注解:对元素进行约束或解释的简单符号\n\n# 2.2 关系\n\n关系[Relationships]：关系把事物紧密联系在一起\n\n 1. 依赖[depedency] 是两个事物之间的语义关系，其中一个事物(独立事物)发生变化，会影响到 另一个事物(依赖事物)的语义\n 2. 关联[association] 是一种结构关系，它指明一个事物的对象与另一个事物的对象间的联系\n 3. 泛化[generalization] 是一种特殊/一般的关系。也可以看作是常说的继承关系\n 4. 实现[realization] 是类元之间的语义关系，其中的一个类元指定了由另一个类元保证执行的契约\n\n# 2.3 图\n\n图[Diagrams]：图是事物和关系的可视化表示\n\n1. 用例图[Use Case Diagram]:\n\n用例图是从用户角度描述系统功能， 是用户所能观察到的系统功能的模型图，用例是系统中的一个功能单元\n\n2.类图[Class Diagram]:\n\n * 类图描述系统中类的静态结构。不仅定义系统中的类，表示类之间的联系如关联、依赖、聚合等，也包括类的内部结构(类的属性和操作);\n * 类图是以类为中心类组织的，类图中的其他元素或属于某个类或与类相关联\n\n3.对象图[Object Diagram]:\n\n对象图是类图的实例，几乎使用与类图完全相同的标识。他们的不同点在于对象图显示类的多个对象实例，而不是实际的类\n\n\n\n4.顺序图[Sequence Diagram]:\n\n * 顺序图显示对象之间的动态合作关系,他强调对象之间消息发送的顺序，同时显示对象之间的交互;\n * 顺序图的一个用途是用来表示用例中的行为顺序。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件\n\n5.协作图[Collaboration Diagram]:\n\n * 协作图描述对象间的协作关系，协作图跟顺序图相似，显示对象间的动态合作关系。除显示信息交换外，协作图还显示对象以及他们之间的关系\n * 协作图的一个用途是表示一个类操作的实现\n\n6.状态图[State Chart Diagram]:\n\n状态图是一个类对象所可能经历的所有历程的模型图。状态图由对象的各个状态和连接这些状态的转换组成\n\n\n\n7.活动图[Activity Diagram]:\n\n * 活动图是状态图的一个变体，用来描述执行算法的工作流程中涉及的活动\n * 活动图描述了一组顺序的或并发的活动\n\n8.构件图[Component Diagram]:\n\n构件图描述系统的构件模型以及各构件之间的依赖关系，以便通过这些依赖关系来估计对系统构件的修改给系统可能带来的影响\n\n\n\n9.部署图[Deployment Diagram]:\n\n部署视图描述位于节点实例上的运行构件实例的安排。节点是一组运行资源，如计算机、设备或存储器。这个视图允许评估分配结果和资源分配\n\n\n\n（四）各UML图的关系\n\n5类UML图的分类法：\n\n 1. 用例图：对系统提供提供功能的描述\n 2. 静态图：描述系统的静态结构，包括 类图 和 对象图\n 3. 行为图：描述系统的动态行为和组成系统的对象间的交互关系，包括 状态图 和 活动图\n 4. 交互图：描述对象间的交互关系，包括 顺序图 和 协作图\n 5. 实现图：提供关于系统实现方面的信息，包括 构件图 和 部署图\n\n\n# 3. UML语法描述\n\n",normalizedContent:"# uml概述\n\n\n# 1.uml简介\n\numl (unified modeling language)为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。\n\numl的定义包括uml语义和uml表示法两个部分。\n\n * uml语义:uml对语义的描述使开发者能在语义上取得一致认识，消除了因人而异的表达方法所造成的影响；\n * uml表示法:uml表示法定义uml符号的表示法，为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准\n\n\n# 2.uml模型图的构成\n\n# 2.1 事物\n\n事物[things] (4种)：uml模型中最基本的构成元素，是具有代表性的成分的抽象\n\n 1. 构件事物：uml模型的静态部分，描述概念或物理元素\n\n * 类：具有相同属性相同操作相同关系相同语义的对象的描述\n\n * 接口：描述元素的外部可见行为，即服务集合的定义说明\n\n * 协作：描述了一组事物间的相互作用的集合\n\n * 用例：代表一个系统或系统的一部分行为，是一组动作序列的集合\n\n * 构件：系统中物理存在，可替换的部件\n\n * 节点：运行时存在的物理元素\n\n * > 另外，参与者、信号应用、文档库、页表等都是上述基本事物的变体\n\n 2. 行为事物：uml模型图的动态部分，描述跨越空间和时间的行为\n\n * 交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列、链接\n * 状态机：描述事物或交互在生命周期内响应事件所经历的状态序列\n\n3.分组事物：uml模型图的组织部分，描述事物的组织结构\n\n * 包:把元素组织成组的机制\n   \n   4.注释事物：uml模型的解释部分，用来对模型中的元素进行说明、解释\n\n * 注解:对元素进行约束或解释的简单符号\n\n# 2.2 关系\n\n关系[relationships]：关系把事物紧密联系在一起\n\n 1. 依赖[depedency] 是两个事物之间的语义关系，其中一个事物(独立事物)发生变化，会影响到 另一个事物(依赖事物)的语义\n 2. 关联[association] 是一种结构关系，它指明一个事物的对象与另一个事物的对象间的联系\n 3. 泛化[generalization] 是一种特殊/一般的关系。也可以看作是常说的继承关系\n 4. 实现[realization] 是类元之间的语义关系，其中的一个类元指定了由另一个类元保证执行的契约\n\n# 2.3 图\n\n图[diagrams]：图是事物和关系的可视化表示\n\n1. 用例图[use case diagram]:\n\n用例图是从用户角度描述系统功能， 是用户所能观察到的系统功能的模型图，用例是系统中的一个功能单元\n\n2.类图[class diagram]:\n\n * 类图描述系统中类的静态结构。不仅定义系统中的类，表示类之间的联系如关联、依赖、聚合等，也包括类的内部结构(类的属性和操作);\n * 类图是以类为中心类组织的，类图中的其他元素或属于某个类或与类相关联\n\n3.对象图[object diagram]:\n\n对象图是类图的实例，几乎使用与类图完全相同的标识。他们的不同点在于对象图显示类的多个对象实例，而不是实际的类\n\n\n\n4.顺序图[sequence diagram]:\n\n * 顺序图显示对象之间的动态合作关系,他强调对象之间消息发送的顺序，同时显示对象之间的交互;\n * 顺序图的一个用途是用来表示用例中的行为顺序。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件\n\n5.协作图[collaboration diagram]:\n\n * 协作图描述对象间的协作关系，协作图跟顺序图相似，显示对象间的动态合作关系。除显示信息交换外，协作图还显示对象以及他们之间的关系\n * 协作图的一个用途是表示一个类操作的实现\n\n6.状态图[state chart diagram]:\n\n状态图是一个类对象所可能经历的所有历程的模型图。状态图由对象的各个状态和连接这些状态的转换组成\n\n\n\n7.活动图[activity diagram]:\n\n * 活动图是状态图的一个变体，用来描述执行算法的工作流程中涉及的活动\n * 活动图描述了一组顺序的或并发的活动\n\n8.构件图[component diagram]:\n\n构件图描述系统的构件模型以及各构件之间的依赖关系，以便通过这些依赖关系来估计对系统构件的修改给系统可能带来的影响\n\n\n\n9.部署图[deployment diagram]:\n\n部署视图描述位于节点实例上的运行构件实例的安排。节点是一组运行资源，如计算机、设备或存储器。这个视图允许评估分配结果和资源分配\n\n\n\n（四）各uml图的关系\n\n5类uml图的分类法：\n\n 1. 用例图：对系统提供提供功能的描述\n 2. 静态图：描述系统的静态结构，包括 类图 和 对象图\n 3. 行为图：描述系统的动态行为和组成系统的对象间的交互关系，包括 状态图 和 活动图\n 4. 交互图：描述对象间的交互关系，包括 顺序图 和 协作图\n 5. 实现图：提供关于系统实现方面的信息，包括 构件图 和 部署图\n\n\n# 3. uml语法描述\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"14种UML图",frontmatter:{title:"14种UML图",date:"2022-12-18T23:56:06.000Z",permalink:"/pages/9bf5f0/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/10.UML/03.14%E7%A7%8DUML%E5%9B%BE.html",relativePath:"01.指南/10.UML/03.14种UML图.md",key:"v-2f070f9c",path:"/pages/9bf5f0/",headers:[{level:3,title:"UML图有哪些？",slug:"uml图有哪些",normalizedTitle:"uml图有哪些？",charIndex:14},{level:3,title:"UML图概览",slug:"uml图概览",normalizedTitle:"uml图概览",charIndex:139},{level:3,title:"什么是类图？",slug:"什么是类图",normalizedTitle:"什么是类图？",charIndex:152},{level:4,title:"泛化（Generalization）",slug:"泛化-generalization",normalizedTitle:"泛化（generalization）",charIndex:251},{level:4,title:"实现（Realization）",slug:"实现-realization",normalizedTitle:"实现（realization）",charIndex:337},{level:4,title:"关联（Association）",slug:"关联-association",normalizedTitle:"关联（association）",charIndex:423},{level:4,title:"聚合（Aggregation）",slug:"聚合-aggregation",normalizedTitle:"聚合（aggregation）",charIndex:553},{level:4,title:"组合（Composition）",slug:"组合-composition",normalizedTitle:"组合（composition）",charIndex:701},{level:4,title:"依赖（Dependency）",slug:"依赖-dependency",normalizedTitle:"依赖（dependency）",charIndex:958},{level:2,title:"什么是组件图？",slug:"什么是组件图",normalizedTitle:"什么是组件图？",charIndex:1045},{level:2,title:"什么是部署图？",slug:"什么是部署图",normalizedTitle:"什么是部署图？",charIndex:1191},{level:2,title:"什么是对象图？",slug:"什么是对象图",normalizedTitle:"什么是对象图？",charIndex:1283},{level:2,title:"什么是包图？",slug:"什么是包图",normalizedTitle:"什么是包图？",charIndex:1420},{level:2,title:"什么是组合结构图？",slug:"什么是组合结构图",normalizedTitle:"什么是组合结构图？",charIndex:1677},{level:2,title:"什么是轮廓图？",slug:"什么是轮廓图",normalizedTitle:"什么是轮廓图？",charIndex:1819},{level:2,title:"什么是用例图？",slug:"什么是用例图",normalizedTitle:"什么是用例图？",charIndex:1998},{level:2,title:"什么是活动图？",slug:"什么是活动图",normalizedTitle:"什么是活动图？",charIndex:2210},{level:2,title:"什么是状态机图？",slug:"什么是状态机图",normalizedTitle:"什么是状态机图？",charIndex:2305},{level:2,title:"什么是序列图？",slug:"什么是序列图",normalizedTitle:"什么是序列图？",charIndex:2439},{level:2,title:"什么是通讯图？",slug:"什么是通讯图",normalizedTitle:"什么是通讯图？",charIndex:2603},{level:2,title:"什么是交互概览图？",slug:"什么是交互概览图",normalizedTitle:"什么是交互概览图？",charIndex:2740},{level:2,title:"什么是时序图？",slug:"什么是时序图",normalizedTitle:"什么是时序图？",charIndex:2859}],headersStr:"UML图有哪些？ UML图概览 什么是类图？ 泛化（Generalization） 实现（Realization） 关联（Association） 聚合（Aggregation） 组合（Composition） 依赖（Dependency） 什么是组件图？ 什么是部署图？ 什么是对象图？ 什么是包图？ 什么是组合结构图？ 什么是轮廓图？ 什么是用例图？ 什么是活动图？ 什么是状态机图？ 什么是序列图？ 什么是通讯图？ 什么是交互概览图？ 什么是时序图？",content:'# 14种UML图\n\n\n# UML图有哪些？\n\n * UML图分为结构图和行为图。\n * 结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。\n * 行为图又分活动图、用例图、状态机图和交互图。\n * 交互图又分为序列图、时序图、通讯图、交互概览图。\n\n\n\n\n# UML图概览\n\n\n\n\n# 什么是类图？\n\n * 【概念】 类图是一切面向对象方法的核心建模工具。类图描述了系统中对象的类型以及它们之间存在的各种静态关系。\n * 【目的】用来表示类、接口以及它们之间的静态结构和关系。\n\n# 泛化（Generalization）\n\n * 【泛化关系】是一种继承关系，表示子类继承父类的所有特征和行为。\n * 【箭头指向】带三角箭头的实线，箭头指向父类。\n\n\n\n# 实现（Realization）\n\n * 【实现关系】是一种类与接口的关系，表示类是接口所有特征和行为的实现。\n * 【箭头指向】带三角箭头的虚线，箭头指向接口。\n\n\n\n# 关联（Association）\n\n * 【关联关系】是一种拥有关系，它使得一个类知道另一个类的属性和方法。\n * 【代码体现】成员变量\n * 【箭头指向】带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。\n\n\n\n# 聚合（Aggregation）\n\n * 【聚合关系】是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。\n * 【代码体现】成员变量\n * 【箭头指向】带空心菱形的实线，空心菱形指向整体。\n\n\n\n# 组合（Composition）\n\n * 【组合关系】是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。\n * 【代码体现】成员变量\n * 【箭头指向】带实心菱形和普通箭头的实线，实心菱形指向整体。\n\n\n\n鸟是整体，翅膀是部分。鸟死了，翅膀也就不能飞了。所以是组合。我们再看一下，下面的一组经典的聚合组合关系的例子。\n\n\n\n一个公司拥有多个部门，公司和部门之间是组合关系，公司破产了，部门就不复存在了。部门和员工是聚合关系，部门被裁掉，员工就换下家了。\n\n# 依赖（Dependency）\n\n * 【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。\n * 【箭头指向】带普通箭头的虚线，普通箭头指向被使用者。\n\n\n\n\n# 什么是组件图？\n\n * 【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。\n * 【目的】用来展示各个组件之间的依赖关系。\n\n\n\n订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。\n\n\n# 什么是部署图？\n\n * 【概念】描述了系统内部的软件如何分布在不同的节点上。\n * 【目的】用来表示软件和硬件的映射关系。\n\n\n\n图中简单的表示，不同机器上面部署的不同软件。\n\n\n# 什么是对象图？\n\n * 【概念】对象图是类图的一个实例，是系统在某个时间点的详细状态的快照。\n * 【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。\n\n\n\n图中就是描述的，某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng。\n\n\n# 什么是包图？\n\n * 【概念】描绘了系统在包层面上的结构设计。\n * 【目的】用来表示包和包之间的依赖关系。\n\n\n\n * 《Use》关系表示使用依赖，Web Shopping依赖Payment\n * 《Merge》关系表示合并，Web Shopping合并了Shopping Cart就拥有了Shopping Cart的功能\n * 《Access》关系表示私有引入，比如代码中的指定包名类名\n * 《Import》关系表示公共引入，比如Java中的import之后，就可以直接使用import包中的类了。\n\n\n# 什么是组合结构图？\n\n * 【概念】描述了一个"组合结构"的内部结构，以及他们之间的关系。这个"组合结构"可以是系统的一部分，或者一个整体。\n * 【目的】用来表示系统中逻辑上的"组合结构"。\n\n\n\n图中描述了Car是由车轴连接着的两个前面轮子、两个后面轮子，和引擎组合的。\n\n\n# 什么是轮廓图？\n\n * 【概念】轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制UML模型。\n * 【目的】用于在特定领域中构建UML模型。\n\n\n\n图中我们定义了一个简易的EJB的概要图。Bean是从Component扩展来的。Entity Bean和Session Bean继承了Bean。EJB拥有Remote和Home接口，和JAR包。\n\n\n# 什么是用例图？\n\n * 【概念】用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。\n * 【目的】用来描述整个系统的功能。\n\n\n\n用例图中包含以下三种关系：\n\n * 包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。\n * 扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能\n * 泛化关系，子用例继承父用例所有结构、行为和关系。\n\n\n# 什么是活动图？\n\n * 【概念】描述了具体业务用例的实现流程。\n * 【目的】用来表示用例实现的工作流程。\n\n\n\n图中简单描述了，从开始到登录到查看订单列表，或者登录失败直接结束。\n\n\n# 什么是状态机图？\n\n * 【概念】状态机图对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n * 【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。\n\n\n\n图中描述了，门在其生命周期内所经历的状态。\n\n\n# 什么是序列图？\n\n * 【概念】序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。\n * 【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。\n\n\n\n图中展示的是支付宝条码支付场景的序列图。其中，loop是循环，alt是选择，序列图的其他关系这里就不介绍了。\n\n\n# 什么是通讯图？\n\n * 【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系而不是时间顺序。\n * 【目的】用来显示不同对象的关系。\n\n\n\n图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。\n\n\n# 什么是交互概览图？\n\n * 【概念】交互概览图与活动图类似，但是它的节点是交互图。\n * 【目的】提供了控制流的概述。\n\n\n\n图中表示一个调度系统的交互概览图，跟活动图很像。其中sd的框代表具体的交互流程，ref框代表使用交互。\n\n\n# 什么是时序图？\n\n * 【概念】时序图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n * 【目的】用来表示元素状态或者值随时间的变化而变化的视图。\n\n\n\n图中展示了老年痴呆病人随着时间的变化病情的变化。',normalizedContent:'# 14种uml图\n\n\n# uml图有哪些？\n\n * uml图分为结构图和行为图。\n * 结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。\n * 行为图又分活动图、用例图、状态机图和交互图。\n * 交互图又分为序列图、时序图、通讯图、交互概览图。\n\n\n\n\n# uml图概览\n\n\n\n\n# 什么是类图？\n\n * 【概念】 类图是一切面向对象方法的核心建模工具。类图描述了系统中对象的类型以及它们之间存在的各种静态关系。\n * 【目的】用来表示类、接口以及它们之间的静态结构和关系。\n\n# 泛化（generalization）\n\n * 【泛化关系】是一种继承关系，表示子类继承父类的所有特征和行为。\n * 【箭头指向】带三角箭头的实线，箭头指向父类。\n\n\n\n# 实现（realization）\n\n * 【实现关系】是一种类与接口的关系，表示类是接口所有特征和行为的实现。\n * 【箭头指向】带三角箭头的虚线，箭头指向接口。\n\n\n\n# 关联（association）\n\n * 【关联关系】是一种拥有关系，它使得一个类知道另一个类的属性和方法。\n * 【代码体现】成员变量\n * 【箭头指向】带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。\n\n\n\n# 聚合（aggregation）\n\n * 【聚合关系】是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。\n * 【代码体现】成员变量\n * 【箭头指向】带空心菱形的实线，空心菱形指向整体。\n\n\n\n# 组合（composition）\n\n * 【组合关系】是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。\n * 【代码体现】成员变量\n * 【箭头指向】带实心菱形和普通箭头的实线，实心菱形指向整体。\n\n\n\n鸟是整体，翅膀是部分。鸟死了，翅膀也就不能飞了。所以是组合。我们再看一下，下面的一组经典的聚合组合关系的例子。\n\n\n\n一个公司拥有多个部门，公司和部门之间是组合关系，公司破产了，部门就不复存在了。部门和员工是聚合关系，部门被裁掉，员工就换下家了。\n\n# 依赖（dependency）\n\n * 【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。\n * 【箭头指向】带普通箭头的虚线，普通箭头指向被使用者。\n\n\n\n\n# 什么是组件图？\n\n * 【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。\n * 【目的】用来展示各个组件之间的依赖关系。\n\n\n\n订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。\n\n\n# 什么是部署图？\n\n * 【概念】描述了系统内部的软件如何分布在不同的节点上。\n * 【目的】用来表示软件和硬件的映射关系。\n\n\n\n图中简单的表示，不同机器上面部署的不同软件。\n\n\n# 什么是对象图？\n\n * 【概念】对象图是类图的一个实例，是系统在某个时间点的详细状态的快照。\n * 【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。\n\n\n\n图中就是描述的，某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng。\n\n\n# 什么是包图？\n\n * 【概念】描绘了系统在包层面上的结构设计。\n * 【目的】用来表示包和包之间的依赖关系。\n\n\n\n * 《use》关系表示使用依赖，web shopping依赖payment\n * 《merge》关系表示合并，web shopping合并了shopping cart就拥有了shopping cart的功能\n * 《access》关系表示私有引入，比如代码中的指定包名类名\n * 《import》关系表示公共引入，比如java中的import之后，就可以直接使用import包中的类了。\n\n\n# 什么是组合结构图？\n\n * 【概念】描述了一个"组合结构"的内部结构，以及他们之间的关系。这个"组合结构"可以是系统的一部分，或者一个整体。\n * 【目的】用来表示系统中逻辑上的"组合结构"。\n\n\n\n图中描述了car是由车轴连接着的两个前面轮子、两个后面轮子，和引擎组合的。\n\n\n# 什么是轮廓图？\n\n * 【概念】轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制uml模型。\n * 【目的】用于在特定领域中构建uml模型。\n\n\n\n图中我们定义了一个简易的ejb的概要图。bean是从component扩展来的。entity bean和session bean继承了bean。ejb拥有remote和home接口，和jar包。\n\n\n# 什么是用例图？\n\n * 【概念】用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。\n * 【目的】用来描述整个系统的功能。\n\n\n\n用例图中包含以下三种关系：\n\n * 包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。\n * 扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能\n * 泛化关系，子用例继承父用例所有结构、行为和关系。\n\n\n# 什么是活动图？\n\n * 【概念】描述了具体业务用例的实现流程。\n * 【目的】用来表示用例实现的工作流程。\n\n\n\n图中简单描述了，从开始到登录到查看订单列表，或者登录失败直接结束。\n\n\n# 什么是状态机图？\n\n * 【概念】状态机图对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n * 【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。\n\n\n\n图中描述了，门在其生命周期内所经历的状态。\n\n\n# 什么是序列图？\n\n * 【概念】序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。\n * 【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。\n\n\n\n图中展示的是支付宝条码支付场景的序列图。其中，loop是循环，alt是选择，序列图的其他关系这里就不介绍了。\n\n\n# 什么是通讯图？\n\n * 【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系而不是时间顺序。\n * 【目的】用来显示不同对象的关系。\n\n\n\n图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。\n\n\n# 什么是交互概览图？\n\n * 【概念】交互概览图与活动图类似，但是它的节点是交互图。\n * 【目的】提供了控制流的概述。\n\n\n\n图中表示一个调度系统的交互概览图，跟活动图很像。其中sd的框代表具体的交互流程，ref框代表使用交互。\n\n\n# 什么是时序图？\n\n * 【概念】时序图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n * 【目的】用来表示元素状态或者值随时间的变化而变化的视图。\n\n\n\n图中展示了老年痴呆病人随着时间的变化病情的变化。',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据流图详解",frontmatter:{title:"数据流图详解",date:"2022-12-19T19:54:35.000Z",permalink:"/pages/fb9639/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/11.%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/01.%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E8%AF%A6%E8%A7%A3.html",relativePath:"01.指南/11.数据流图/01.数据流图详解.md",key:"v-90759344",path:"/pages/fb9639/",headers:[{level:2,title:"1.数据流图详解",slug:"_1-数据流图详解",normalizedTitle:"1.数据流图详解",charIndex:2},{level:3,title:"1.1 数据流图的概念",slug:"_1-1-数据流图的概念",normalizedTitle:"1.1 数据流图的概念",charIndex:15},{level:3,title:"1.2 数据流图的原理",slug:"_1-2-数据流图的原理",normalizedTitle:"1.2 数据流图的原理",charIndex:151},{level:3,title:"1.3 数据流图设计方法",slug:"_1-3-数据流图设计方法",normalizedTitle:"1.3 数据流图设计方法",charIndex:654},{level:3,title:"1.4 其他注意",slug:"_1-4-其他注意",normalizedTitle:"1.4 其他注意",charIndex:1590},{level:2,title:"2.数据流图的画法",slug:"_2-数据流图的画法",normalizedTitle:"2.数据流图的画法",charIndex:2413},{level:3,title:"2.1 数据流图的优点",slug:"_2-1-数据流图的优点",normalizedTitle:"2.1 数据流图的优点",charIndex:2427},{level:3,title:"2.2 数据流图的基本符号",slug:"_2-2-数据流图的基本符号",normalizedTitle:"2.2 数据流图的基本符号",charIndex:2745},{level:2,title:"3.示例：工厂订单报表",slug:"_3-示例-工厂订单报表",normalizedTitle:"3.示例：工厂订单报表",charIndex:3401},{level:3,title:"3.1 数据流图成分分析",slug:"_3-1-数据流图成分分析",normalizedTitle:"3.1 数据流图成分分析",charIndex:3583},{level:3,title:"3.2 开始画数据流图",slug:"_3-2-开始画数据流图",normalizedTitle:"3.2 开始画数据流图",charIndex:4159},{level:3,title:"3.3 顶层数据流图",slug:"_3-3-顶层数据流图",normalizedTitle:"3.3 顶层数据流图",charIndex:4329},{level:3,title:"3.4 第0层数据流图",slug:"_3-4-第0层数据流图",normalizedTitle:"3.4 第0层数据流图",charIndex:4473},{level:3,title:"3.5 第1层数据流图",slug:"_3-5-第1层数据流图",normalizedTitle:"3.5 第1层数据流图",charIndex:4850},{level:3,title:"3.6 补充: 数据流图命名规范",slug:"_3-6-补充-数据流图命名规范",normalizedTitle:"3.6 补充: 数据流图命名规范",charIndex:5416},{level:2,title:"4.练习",slug:"_4-练习",normalizedTitle:"4.练习",charIndex:6053},{level:3,title:"4.1 教务管理子系统",slug:"_4-1-教务管理子系统",normalizedTitle:"4.1 教务管理子系统",charIndex:6062},{level:3,title:"4.2 顶层数据流图",slug:"_4-2-顶层数据流图",normalizedTitle:"4.2 顶层数据流图",charIndex:6276},{level:3,title:"4.3 第0层数据流图",slug:"_4-3-第0层数据流图",normalizedTitle:"4.3 第0层数据流图",charIndex:6293},{level:3,title:"4.4 第1层数据流图",slug:"_4-4-第1层数据流图",normalizedTitle:"4.4 第1层数据流图",charIndex:6311}],headersStr:"1.数据流图详解 1.1 数据流图的概念 1.2 数据流图的原理 1.3 数据流图设计方法 1.4 其他注意 2.数据流图的画法 2.1 数据流图的优点 2.2 数据流图的基本符号 3.示例：工厂订单报表 3.1 数据流图成分分析 3.2 开始画数据流图 3.3 顶层数据流图 3.4 第0层数据流图 3.5 第1层数据流图 3.6 补充: 数据流图命名规范 4.练习 4.1 教务管理子系统 4.2 顶层数据流图 4.3 第0层数据流图 4.4 第1层数据流图",content:"# 1.数据流图详解\n\n\n# 1.1 数据流图的概念\n\n它是将提供给用户的业务流程图(“物理模型”)进行功能建模，转化成开发人员能够理解的一系列“逻辑模型”图，即以图形化的方法描绘数据在系统中的流动和处理的过程，这些图都应该用规范的DFD描述。\n\n1.上下文数据流图\n\n\n\n2.层数据流图\n\n\n\n\n# 1.2 数据流图的原理\n\nDFD设计过程就是将数据和处理进行逐层分解就形成了若干层次的DFD。DFD分为顶层图(只有一张)、0层图(也只有一张)、子图、子子图等等。\n\n包含主要元素：\n\n即在DFD中包括哪些主要元素，数据流、加工、数据存储、外部实体。\n\n 1. 数据流：用单箭头表示，如――>。是由一组固定成分的数据组成，表示数据的流向。数据流图中描述的是数据流，而不是控制流。除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义。\n 2. 加工：用圆或椭圆表示，如〇。描述了输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据。每个加工都有一个名字和编号。编号能反映该加工位于分层的数据流图的哪个层次和哪张图中，能够看出它是由哪个加工分解出来的子加工。\n 3. 数据存储：用双杠(带一边开口,一边闭合)表示, 又叫做文件，数据存储表示暂时存储的数据。每个数据存储都有一个名字。\n 4. 外部实体：用实心长方形表示，如███。外部实体是存在于软件系统之外的人员或组织，他指出数据所需要的发源地或系统所产生的数据的归属地。\n\n\n# 1.3 数据流图设计方法\n\n 1. 画顶层数据流图：\n    * 即画整个系统的输入输出(画系统也可以将各子系统分开画)。\n    * **把整个系统视为一个大的加工(也只能含一个加工)，**然后根据数据系统从哪些外部实体接收数据流，以及系统发送数据流到那些外部实体，就可以画出输入输出图。这张图称为顶层图。\n    * 顶层图的作用在于表明被开发系统的范围以及它和周围环境的数据交换关系。\n 2. 画0层数据流图:\n    * 即画系统的内部。\n    * **把顶层图的加工分解成若干个加工，并用数据流将这些加工连接起来，使得顶层图的输入数据经过若干加工处理后，变成顶层图的输出数据流。**这张图称为0层图。从一个加工画出一张数据流图的过程就是对加工的分解。\n    * **确定加工的方法：**在数据流的组成或值发生变化的地方应该画出一个加工，这个加工的功能就是实现这一变化，也可以根据系统的功能决定加工。\n    * **确定数据流的方法：**用户把若干数据当作一个单位来处理(这些数据一起到达、一起处理)时，可以把这些数据看成一个数据流。\n    * **关于数据存储：**对于一些以后某个时间要使用的数据，可以组织成为一个数据存储来表示。\n 3. 画加工的内部:\n    * 把每个加工看作一个小系统，把加工的输入输出数据流看成小系统的输入输出流。于是可以象画0层图一样画出每个小系统的加工的DFD图。\n 4. 画子加工的分解图:\n    * 对第三步分解出来的DFD图中的每个加工，重复第三步的分解过程，直到图中尚未分解的加工都是足够简单的(即不可再分解)。至此，得到了一套分层数据流图。\n 5. 对数据流图和加工编号:\n    * 对于一个软件系统，其数据流图可能有许多层，每一层又有许多张图。为了区分不同的加工和不同的DFD子图，应该对每张图进行编号，以便于管理。\n    * 顶层图只有一张，图中的加工也只有一个，所以不必为其编号。\n    * 0层图只有一张，图中的加工号分别是0.1、0.2、…，或者1， 2 。\n    * 子图就是父图中被分解的加工号。\n    * 子图中的加工号是由图号、圆点和序号组成，如：1.12，1.3 等等。\n\n\n# 1.4 其他注意\n\n * 命名。应适当的为数据流、加工、数据存储以及外部实体命名，名字应该反映该成分的实际含义，避免使用空洞的名字。\n * 画数据流图，不是画控制流。**数据流反映系统“做什么”，不反映“如何做”，**因此箭头上的数据流名称只能是名词或名词短语，整个图中不反映加工的执行顺序。\n * 一个加工的输出数据流，不应与输入数据流同名，即使他们的组成完全相同。\n * 允许一个加工有多条数据流流向另一个加工，也允许一个加工有两条相同的输出数据流流向不同的加工。\n * 编号。如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。子图及其所有的加工都应编号。\n * 保持父图与子图的平衡。**也就是说，父图中的某加工的输入输出流必须与他的所有子图的输入输出数据流在数量上和名字上相同。**值得注意的是，如果父图中的一个输入(输出)数据流对应于子图中的几个输入(输出)数据流，而子图中组成这些数据流的数据项的全体正好是父图中的这一个数据流，那么他们仍然算是平衡的。\n * 在自顶向下的分解过程中，若一个数据存储首次出现时，只与一个加工有关系，那么这个数据存储应作为这个加工的内部文件而不必画出。\n * 保持数据守恒，也就是，一个加工的所有输出数据流中的数据必须能从该加工的输入流中直接获得，或者通过该加工能产生的数据。\n * 每个加工必须既有输入数据流，又有输出数据流。\n * 在整套数据流图中，每个数据存储必须既有读的数据流，又有写的数据流。但是在某张子图中，可能只有读没有写，或者只有写没有读。\n * 局部数据存储。当某层数据流图中的数据存储不是父图中相应加工的外部接口，而只是本图中某些加工之间的数据接口，则称这些数据存储为局部数据存储。\n * 提高数据流图的易懂性。注意合理分解，要把一个加工分解成几个功能相对独立的子加工，这样可以减少加工之间输入、输出数据流的数目，增加数据流图的可理解性。\n\n\n# 2.数据流图的画法\n\n\n# 2.1 数据流图的优点\n\n数据流图的优点：\n\n 1. 在数据流图中没有任何具体的物理元素，它只是描绘信息在软件中流动和被处理的情况。\n 2. 因为数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，所以是分析员与用户之间极好的沟通工具。\n 3. 设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需考虑怎样具体地实现这些功能，因此，它也是今后进行软件设计很好的出发点。\n 4. 数据流图可以在任何抽象层次上被用来表示系统或软件。事实上，数据流图可以被分层次地画，层次越低（在数据流图中1层比0层的层次更等）表现出的信息流细节和功能细节也越多。数据流图既提供了功能建模机制、也提供了信息流建模机制。\n\n\n# 2.2 数据流图的基本符号\n\n\n\n数据流图有4种基本符号：\n\n * 正方形（或立方体）表示数据的源点或终点；\n * 圆角矩形（或圆形）代表变换数据的处理；\n * 开口矩形（或两条平行横线）代表数据存储；\n * 箭头表示数据流，即特定数据的流动方向。\n\n数据流说明：\n\n\n\n注意：\n\n * 处理并不一定是一个程序。一个处理框可以代表一系列程序、单个程序或者程序的一个模块；它甚至可以代表用穿孔机穿孔或目视检查数据正确性等人工处理过程。\n * 一个数据存储也并不等同于一个文件，它可以表示一个文件、文件的一部分、数据库的元素、记录的一部分等；数据可以存储在磁盘、磁带、磁鼓、主存、微缩胶片、穿孔卡片及其他任何介质上（包括人的记忆）。\n * 数据存储和数据流都是数据，仅仅所处的状态不同。数据存储是处于静止状态的数据，数据流是处于运动中的数据。\n * 通常在数据流图中忽略出错处理，也不包括诸如打开或关闭文件之类的内务处理，数据流图的基本要点是描绘“做什么”而不考虑“怎样做”。\n * 有时数据的源点和终点相同，这时如果只用一个符号代表数据的源点和终点，则将有两个箭头和这个符号相连（一个进一个出），可能其中一条箭头线相当长，这将降低数据流图的清晰度。另一种表示方法是再重复画一个同样的符号（正方形或立方体）表示数据的终点。有时数据存储也需要重复，以增加数据流图的清晰程度。为了避免可能引起的误解，如果代表同一个事物的同样符号在图中出现在n个地方，则在这个符号的一个角上（比如左上角）画n−1条短斜线做标记。\n\n\n# 3.示例：工厂订单报表\n\n假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据:零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的CRT终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。\n\n\n# 3.1 数据流图成分分析\n\n数据流图有4种成分：源点和终点、处理、数据存储和数据流。画出上述定货系统的数据流图可采用以下步骤。\n\n 1. 首先考虑数据的源点和终点，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的终端把事务报告给订货系统”，所以采购员是数据终点，而仓库管理员是数据源点。\n 2. 接下来考虑处理。再一次阅读问题描述，“采购部需要报表”，显然他们还没有这种报表，因此必须有一个用于产生报表的处理。事务的后果是改变零件库存量，而任何改变数据的操作都是处理，因此，对事务进行的加工是另一个处理。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。\n 3. 最后考虑数据流和数据存储。系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配：每当有一个事务发生时立即处理它，然而每天只产生一次订货报表，因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储（存储着订货报表的数据，每当订货报表的数据有更新时，可以立即获取最新的订货报表的数据，这样就可以实现每当有一个事务发生时立即处理它）。\n\n下表列出了上面分析的结果，其中加星号标记的是在问题描述中隐含的成分。\n\n\n\n\n# 3.2 开始画数据流图\n\n一旦把数据流图的4种成分分离出来后，就可以着手画数据流图了。但是要注意，数据流图是系统的逻辑模型，而任何计算机系统实质上都是信息处理系统，也就是说计算机系统本质上都是把输入数据变换成输出数据。因此，任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能。\n\n\n# 3.3 顶层数据流图\n\n对于上述的定货系统可以画出下图所示的顶层数据流图（突出表明了数据的源点和终点）。\n\n\n\n从顶层数据流图这样非常高的抽象层次开始画数据流图是一个好办法。在这个高层次的数据流图上是否列出了所有给定的数据源点 / 终点是一目了然的，因此它是很有价值的沟通工具。\n\n\n# 3.4 第0层数据流图\n\n顶层数据流图太抽象了，从这张图上所能了解到的信息非常有限。下一步应该把基本系统模型细化，描绘系统的主要功能。\n\n由于 “产生报表” 和 “处理事务” 是该系统必须完成的两个主要功能，它们将代替图顶层数据流图中的“订货系统”。此外，细化后的数据流图中还增加了两个数据存储：处理事务需要“库存清单”数据；产生报表和处理事务在不同时间，因此需要存储“定货信息”。除了2.1节（2.1 数据流图有4种成分分析）的表中列出的两个数据流之外还有另外两个数据流，它们与数据存储相同。这是因为从一个数据存储中取出来的或放进去的数据通常和原来存储的数据相同，也就是说，数据存储和数据流只不过是同样数据的两种不同形式（事务 <–> 库存清单，订货信息 <–> 订货报表）。\n\n> 给处理和数据存储都加了编号，这样做的目的是便于引用和追踪。\n\n\n# 3.5 第1层数据流图\n\n接下来应该对功能级数据流图中描绘的系统主要功能进一步细化。考虑通过系统的逻辑数据流，当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。因此，把“处理事务”这个功能分解为下述3个步骤：“接收事务”、“更新库存清单”和“处理订货”，这在逻辑上是合理的。\n\n\n\n我们为什么不进一步分解“产生报表”这个功能呢？因为订货报表中需要的数据在存储的订货信息中全都有，产生报表只不过是按一定顺序排列这些信息，再按一定格式打印出来。然而这些考虑纯属具体实现的细节，不应该在数据流图中表现。同样道理，对“接收事务”或“更新库存清单”等功能也没有必要进一步细化。总之，当进一步分解将涉及如何具体地实现一个功能时，就不应该再分解了。\n\n> 在对数据流图分层细化时必须保持信息连续性，即当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。\n\n还应该注意在数据流图中对处理进行编号的方法。处理1.1，1.2和1.3是更高层次的数据流图中处理1的组成元素。如果处理2被进一步分解，它的组成元素的编号将是2.1， 2.2……如果把处理1.1进一步分解，则将得到编号为1.1.1，1.1.2……的处理，以此类推。\n\n\n# 3.6 补充: 数据流图命名规范\n\n数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。 因此，给这些成分起名字时应该仔细推敲。\n\n数据源点/终点并不需要在开发目标系统的过程中设计和实现，它并不属于数据流图的核心内容，只不过是目标系统的外围环境部分（可能是人员、计算机外部设备或传感器装置）。通常，为数据源点 / 终点命名时采用它们在问题域中习惯使用的名字（如“采购员”、“仓库管理员”等）。\n\n> 数据流（或数据存储）命名：\n\n * 名字应代表整个数据流（或数据存储）的内容，而不是仅仅反映它的某些成分。\n * 不要使用空洞的、缺乏具体含义的名字（如“数据”、“信息”、“输入”之类）。\n * 如果在为某个数据流（或数据存储）起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。\n\n> 处理命名：\n\n * 通常先为数据流命名，然后再为与之相关联的处理命名。这样命名比较容易，而且体现了人类习惯的“由表及里”的思考过程。\n * 名字应该反映整个处理的功能，而不是它的一部分功能。\n * 名字最好由一个具体的及物动词加上一个具体的宾语组成。应该尽量避免使用“加工”、“处理”等空洞笼统的动词作为名字。\n * 通常名字中仅包括一个动词。如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。\n * 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。\n\n\n# 4.练习\n\n\n# 4.1 教务管理子系统\n\n教务管理是一项需求周密计划、严谨安排的工作，要依据教师、学生信息进行合理安排。\n\n> 教务管理子系统的需求描述：\n\n * 开学阶段，需要教师提交开课申请进行开课，学生根据老师的开课信息，选择课程，教务处生成学生课表、教师课表。\n * 期末阶段，需要根据开课情况对学生进行考试安排，对教师进行监考安排，以及学生考试成绩管理。\n * 学期结束，需要对学生成绩进行统计，计算绩点，排名，评定奖学金。\n\n\n# 4.2 顶层数据流图\n\n\n\n\n# 4.3 第0层数据流图\n\n\n\n\n# 4.4 第1层数据流图\n\n",normalizedContent:"# 1.数据流图详解\n\n\n# 1.1 数据流图的概念\n\n它是将提供给用户的业务流程图(“物理模型”)进行功能建模，转化成开发人员能够理解的一系列“逻辑模型”图，即以图形化的方法描绘数据在系统中的流动和处理的过程，这些图都应该用规范的dfd描述。\n\n1.上下文数据流图\n\n\n\n2.层数据流图\n\n\n\n\n# 1.2 数据流图的原理\n\ndfd设计过程就是将数据和处理进行逐层分解就形成了若干层次的dfd。dfd分为顶层图(只有一张)、0层图(也只有一张)、子图、子子图等等。\n\n包含主要元素：\n\n即在dfd中包括哪些主要元素，数据流、加工、数据存储、外部实体。\n\n 1. 数据流：用单箭头表示，如――>。是由一组固定成分的数据组成，表示数据的流向。数据流图中描述的是数据流，而不是控制流。除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义。\n 2. 加工：用圆或椭圆表示，如〇。描述了输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据。每个加工都有一个名字和编号。编号能反映该加工位于分层的数据流图的哪个层次和哪张图中，能够看出它是由哪个加工分解出来的子加工。\n 3. 数据存储：用双杠(带一边开口,一边闭合)表示, 又叫做文件，数据存储表示暂时存储的数据。每个数据存储都有一个名字。\n 4. 外部实体：用实心长方形表示，如███。外部实体是存在于软件系统之外的人员或组织，他指出数据所需要的发源地或系统所产生的数据的归属地。\n\n\n# 1.3 数据流图设计方法\n\n 1. 画顶层数据流图：\n    * 即画整个系统的输入输出(画系统也可以将各子系统分开画)。\n    * **把整个系统视为一个大的加工(也只能含一个加工)，**然后根据数据系统从哪些外部实体接收数据流，以及系统发送数据流到那些外部实体，就可以画出输入输出图。这张图称为顶层图。\n    * 顶层图的作用在于表明被开发系统的范围以及它和周围环境的数据交换关系。\n 2. 画0层数据流图:\n    * 即画系统的内部。\n    * **把顶层图的加工分解成若干个加工，并用数据流将这些加工连接起来，使得顶层图的输入数据经过若干加工处理后，变成顶层图的输出数据流。**这张图称为0层图。从一个加工画出一张数据流图的过程就是对加工的分解。\n    * **确定加工的方法：**在数据流的组成或值发生变化的地方应该画出一个加工，这个加工的功能就是实现这一变化，也可以根据系统的功能决定加工。\n    * **确定数据流的方法：**用户把若干数据当作一个单位来处理(这些数据一起到达、一起处理)时，可以把这些数据看成一个数据流。\n    * **关于数据存储：**对于一些以后某个时间要使用的数据，可以组织成为一个数据存储来表示。\n 3. 画加工的内部:\n    * 把每个加工看作一个小系统，把加工的输入输出数据流看成小系统的输入输出流。于是可以象画0层图一样画出每个小系统的加工的dfd图。\n 4. 画子加工的分解图:\n    * 对第三步分解出来的dfd图中的每个加工，重复第三步的分解过程，直到图中尚未分解的加工都是足够简单的(即不可再分解)。至此，得到了一套分层数据流图。\n 5. 对数据流图和加工编号:\n    * 对于一个软件系统，其数据流图可能有许多层，每一层又有许多张图。为了区分不同的加工和不同的dfd子图，应该对每张图进行编号，以便于管理。\n    * 顶层图只有一张，图中的加工也只有一个，所以不必为其编号。\n    * 0层图只有一张，图中的加工号分别是0.1、0.2、…，或者1， 2 。\n    * 子图就是父图中被分解的加工号。\n    * 子图中的加工号是由图号、圆点和序号组成，如：1.12，1.3 等等。\n\n\n# 1.4 其他注意\n\n * 命名。应适当的为数据流、加工、数据存储以及外部实体命名，名字应该反映该成分的实际含义，避免使用空洞的名字。\n * 画数据流图，不是画控制流。**数据流反映系统“做什么”，不反映“如何做”，**因此箭头上的数据流名称只能是名词或名词短语，整个图中不反映加工的执行顺序。\n * 一个加工的输出数据流，不应与输入数据流同名，即使他们的组成完全相同。\n * 允许一个加工有多条数据流流向另一个加工，也允许一个加工有两条相同的输出数据流流向不同的加工。\n * 编号。如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。子图及其所有的加工都应编号。\n * 保持父图与子图的平衡。**也就是说，父图中的某加工的输入输出流必须与他的所有子图的输入输出数据流在数量上和名字上相同。**值得注意的是，如果父图中的一个输入(输出)数据流对应于子图中的几个输入(输出)数据流，而子图中组成这些数据流的数据项的全体正好是父图中的这一个数据流，那么他们仍然算是平衡的。\n * 在自顶向下的分解过程中，若一个数据存储首次出现时，只与一个加工有关系，那么这个数据存储应作为这个加工的内部文件而不必画出。\n * 保持数据守恒，也就是，一个加工的所有输出数据流中的数据必须能从该加工的输入流中直接获得，或者通过该加工能产生的数据。\n * 每个加工必须既有输入数据流，又有输出数据流。\n * 在整套数据流图中，每个数据存储必须既有读的数据流，又有写的数据流。但是在某张子图中，可能只有读没有写，或者只有写没有读。\n * 局部数据存储。当某层数据流图中的数据存储不是父图中相应加工的外部接口，而只是本图中某些加工之间的数据接口，则称这些数据存储为局部数据存储。\n * 提高数据流图的易懂性。注意合理分解，要把一个加工分解成几个功能相对独立的子加工，这样可以减少加工之间输入、输出数据流的数目，增加数据流图的可理解性。\n\n\n# 2.数据流图的画法\n\n\n# 2.1 数据流图的优点\n\n数据流图的优点：\n\n 1. 在数据流图中没有任何具体的物理元素，它只是描绘信息在软件中流动和被处理的情况。\n 2. 因为数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，所以是分析员与用户之间极好的沟通工具。\n 3. 设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需考虑怎样具体地实现这些功能，因此，它也是今后进行软件设计很好的出发点。\n 4. 数据流图可以在任何抽象层次上被用来表示系统或软件。事实上，数据流图可以被分层次地画，层次越低（在数据流图中1层比0层的层次更等）表现出的信息流细节和功能细节也越多。数据流图既提供了功能建模机制、也提供了信息流建模机制。\n\n\n# 2.2 数据流图的基本符号\n\n\n\n数据流图有4种基本符号：\n\n * 正方形（或立方体）表示数据的源点或终点；\n * 圆角矩形（或圆形）代表变换数据的处理；\n * 开口矩形（或两条平行横线）代表数据存储；\n * 箭头表示数据流，即特定数据的流动方向。\n\n数据流说明：\n\n\n\n注意：\n\n * 处理并不一定是一个程序。一个处理框可以代表一系列程序、单个程序或者程序的一个模块；它甚至可以代表用穿孔机穿孔或目视检查数据正确性等人工处理过程。\n * 一个数据存储也并不等同于一个文件，它可以表示一个文件、文件的一部分、数据库的元素、记录的一部分等；数据可以存储在磁盘、磁带、磁鼓、主存、微缩胶片、穿孔卡片及其他任何介质上（包括人的记忆）。\n * 数据存储和数据流都是数据，仅仅所处的状态不同。数据存储是处于静止状态的数据，数据流是处于运动中的数据。\n * 通常在数据流图中忽略出错处理，也不包括诸如打开或关闭文件之类的内务处理，数据流图的基本要点是描绘“做什么”而不考虑“怎样做”。\n * 有时数据的源点和终点相同，这时如果只用一个符号代表数据的源点和终点，则将有两个箭头和这个符号相连（一个进一个出），可能其中一条箭头线相当长，这将降低数据流图的清晰度。另一种表示方法是再重复画一个同样的符号（正方形或立方体）表示数据的终点。有时数据存储也需要重复，以增加数据流图的清晰程度。为了避免可能引起的误解，如果代表同一个事物的同样符号在图中出现在n个地方，则在这个符号的一个角上（比如左上角）画n−1条短斜线做标记。\n\n\n# 3.示例：工厂订单报表\n\n假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据:零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的crt终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。\n\n\n# 3.1 数据流图成分分析\n\n数据流图有4种成分：源点和终点、处理、数据存储和数据流。画出上述定货系统的数据流图可采用以下步骤。\n\n 1. 首先考虑数据的源点和终点，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的终端把事务报告给订货系统”，所以采购员是数据终点，而仓库管理员是数据源点。\n 2. 接下来考虑处理。再一次阅读问题描述，“采购部需要报表”，显然他们还没有这种报表，因此必须有一个用于产生报表的处理。事务的后果是改变零件库存量，而任何改变数据的操作都是处理，因此，对事务进行的加工是另一个处理。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。\n 3. 最后考虑数据流和数据存储。系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配：每当有一个事务发生时立即处理它，然而每天只产生一次订货报表，因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储（存储着订货报表的数据，每当订货报表的数据有更新时，可以立即获取最新的订货报表的数据，这样就可以实现每当有一个事务发生时立即处理它）。\n\n下表列出了上面分析的结果，其中加星号标记的是在问题描述中隐含的成分。\n\n\n\n\n# 3.2 开始画数据流图\n\n一旦把数据流图的4种成分分离出来后，就可以着手画数据流图了。但是要注意，数据流图是系统的逻辑模型，而任何计算机系统实质上都是信息处理系统，也就是说计算机系统本质上都是把输入数据变换成输出数据。因此，任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能。\n\n\n# 3.3 顶层数据流图\n\n对于上述的定货系统可以画出下图所示的顶层数据流图（突出表明了数据的源点和终点）。\n\n\n\n从顶层数据流图这样非常高的抽象层次开始画数据流图是一个好办法。在这个高层次的数据流图上是否列出了所有给定的数据源点 / 终点是一目了然的，因此它是很有价值的沟通工具。\n\n\n# 3.4 第0层数据流图\n\n顶层数据流图太抽象了，从这张图上所能了解到的信息非常有限。下一步应该把基本系统模型细化，描绘系统的主要功能。\n\n由于 “产生报表” 和 “处理事务” 是该系统必须完成的两个主要功能，它们将代替图顶层数据流图中的“订货系统”。此外，细化后的数据流图中还增加了两个数据存储：处理事务需要“库存清单”数据；产生报表和处理事务在不同时间，因此需要存储“定货信息”。除了2.1节（2.1 数据流图有4种成分分析）的表中列出的两个数据流之外还有另外两个数据流，它们与数据存储相同。这是因为从一个数据存储中取出来的或放进去的数据通常和原来存储的数据相同，也就是说，数据存储和数据流只不过是同样数据的两种不同形式（事务 <–> 库存清单，订货信息 <–> 订货报表）。\n\n> 给处理和数据存储都加了编号，这样做的目的是便于引用和追踪。\n\n\n# 3.5 第1层数据流图\n\n接下来应该对功能级数据流图中描绘的系统主要功能进一步细化。考虑通过系统的逻辑数据流，当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。因此，把“处理事务”这个功能分解为下述3个步骤：“接收事务”、“更新库存清单”和“处理订货”，这在逻辑上是合理的。\n\n\n\n我们为什么不进一步分解“产生报表”这个功能呢？因为订货报表中需要的数据在存储的订货信息中全都有，产生报表只不过是按一定顺序排列这些信息，再按一定格式打印出来。然而这些考虑纯属具体实现的细节，不应该在数据流图中表现。同样道理，对“接收事务”或“更新库存清单”等功能也没有必要进一步细化。总之，当进一步分解将涉及如何具体地实现一个功能时，就不应该再分解了。\n\n> 在对数据流图分层细化时必须保持信息连续性，即当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。\n\n还应该注意在数据流图中对处理进行编号的方法。处理1.1，1.2和1.3是更高层次的数据流图中处理1的组成元素。如果处理2被进一步分解，它的组成元素的编号将是2.1， 2.2……如果把处理1.1进一步分解，则将得到编号为1.1.1，1.1.2……的处理，以此类推。\n\n\n# 3.6 补充: 数据流图命名规范\n\n数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。 因此，给这些成分起名字时应该仔细推敲。\n\n数据源点/终点并不需要在开发目标系统的过程中设计和实现，它并不属于数据流图的核心内容，只不过是目标系统的外围环境部分（可能是人员、计算机外部设备或传感器装置）。通常，为数据源点 / 终点命名时采用它们在问题域中习惯使用的名字（如“采购员”、“仓库管理员”等）。\n\n> 数据流（或数据存储）命名：\n\n * 名字应代表整个数据流（或数据存储）的内容，而不是仅仅反映它的某些成分。\n * 不要使用空洞的、缺乏具体含义的名字（如“数据”、“信息”、“输入”之类）。\n * 如果在为某个数据流（或数据存储）起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。\n\n> 处理命名：\n\n * 通常先为数据流命名，然后再为与之相关联的处理命名。这样命名比较容易，而且体现了人类习惯的“由表及里”的思考过程。\n * 名字应该反映整个处理的功能，而不是它的一部分功能。\n * 名字最好由一个具体的及物动词加上一个具体的宾语组成。应该尽量避免使用“加工”、“处理”等空洞笼统的动词作为名字。\n * 通常名字中仅包括一个动词。如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。\n * 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。\n\n\n# 4.练习\n\n\n# 4.1 教务管理子系统\n\n教务管理是一项需求周密计划、严谨安排的工作，要依据教师、学生信息进行合理安排。\n\n> 教务管理子系统的需求描述：\n\n * 开学阶段，需要教师提交开课申请进行开课，学生根据老师的开课信息，选择课程，教务处生成学生课表、教师课表。\n * 期末阶段，需要根据开课情况对学生进行考试安排，对教师进行监考安排，以及学生考试成绩管理。\n * 学期结束，需要对学生成绩进行统计，计算绩点，排名，评定奖学金。\n\n\n# 4.2 顶层数据流图\n\n\n\n\n# 4.3 第0层数据流图\n\n\n\n\n# 4.4 第1层数据流图\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据库设计",frontmatter:{title:"数据库设计",date:"2022-12-19T21:18:20.000Z",permalink:"/pages/91b2e7/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/12.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.html",relativePath:"01.指南/12.数据库设计/01.数据库设计.md",key:"v-74942003",path:"/pages/91b2e7/",headers:[{level:2,title:"数据库设计",slug:"数据库设计",normalizedTitle:"数据库设计",charIndex:2},{level:3,title:"1.数据库设计概述",slug:"_1-数据库设计概述",normalizedTitle:"1.数据库设计概述",charIndex:12},{level:4,title:"1.1 设计概述",slug:"_1-1-设计概述",normalizedTitle:"1.1 设计概述",charIndex:25},{level:4,title:"1.2 数据库设计的特点",slug:"_1-2-数据库设计的特点",normalizedTitle:"1.2 数据库设计的特点",charIndex:105},{level:4,title:"1.3 数据库设计方法",slug:"_1-3-数据库设计方法",normalizedTitle:"1.3 数据库设计方法",charIndex:217},{level:4,title:"1.4 数据库设计的基本步骤",slug:"_1-4-数据库设计的基本步骤",normalizedTitle:"1.4 数据库设计的基本步骤",charIndex:431},{level:3,title:"2.需求分析-步骤一",slug:"_2-需求分析-步骤一",normalizedTitle:"2.需求分析-步骤一",charIndex:701},{level:3,title:"3.概念结构设计-步骤二",slug:"_3-概念结构设计-步骤二",normalizedTitle:"3.概念结构设计-步骤二",charIndex:1210},{level:3,title:"4.逻辑结构设计-步骤三",slug:"_4-逻辑结构设计-步骤三",normalizedTitle:"4.逻辑结构设计-步骤三",charIndex:1696},{level:4,title:"4.1 两实体之间的1:1联系",slug:"_4-1-两实体之间的1-1联系",normalizedTitle:"4.1 两实体之间的1:1联系",charIndex:1968},{level:4,title:"4.2 两实体间的1:m联系",slug:"_4-2-两实体间的1-m联系",normalizedTitle:"4.2 两实体间的1:m联系",charIndex:2232},{level:4,title:"4.3 同一实体间的1:m联系",slug:"_4-3-同一实体间的1-m联系",normalizedTitle:"4.3 同一实体间的1:m联系",charIndex:2355},{level:4,title:"4.4 两实体间的弱实体联系",slug:"_4-4-两实体间的弱实体联系",normalizedTitle:"4.4 两实体间的弱实体联系",charIndex:2461},{level:4,title:"4.5 超类和子类的转换",slug:"_4-5-超类和子类的转换",normalizedTitle:"4.5 超类和子类的转换",charIndex:2693},{level:4,title:"4.6 两实体间的m:n联系",slug:"_4-6-两实体间的m-n联系",normalizedTitle:"4.6 两实体间的m:n联系",charIndex:3165},{level:4,title:"4.7 同一实体间的m:n联系",slug:"_4-7-同一实体间的m-n联系",normalizedTitle:"4.7 同一实体间的m:n联系",charIndex:3307},{level:4,title:"4.8 两个以上实体间的m:n联系",slug:"_4-8-两个以上实体间的m-n联系",normalizedTitle:"4.8 两个以上实体间的m:n联系",charIndex:3464},{level:4,title:"4.9 关系模式优化",slug:"_4-9-关系模式优化",normalizedTitle:"4.9 关系模式优化",charIndex:3642},{level:4,title:"4.10 设计用户子模式",slug:"_4-10-设计用户子模式",normalizedTitle:"4.10 设计用户子模式",charIndex:3890},{level:3,title:"5.物理结构设计-步骤四",slug:"_5-物理结构设计-步骤四",normalizedTitle:"5.物理结构设计-步骤四",charIndex:4064},{level:3,title:"6.数据库实施-步骤五",slug:"_6-数据库实施-步骤五",normalizedTitle:"6.数据库实施-步骤五",charIndex:4538},{level:3,title:"7.数据库运行维护-步骤六",slug:"_7-数据库运行维护-步骤六",normalizedTitle:"7.数据库运行维护-步骤六",charIndex:4905}],headersStr:"数据库设计 1.数据库设计概述 1.1 设计概述 1.2 数据库设计的特点 1.3 数据库设计方法 1.4 数据库设计的基本步骤 2.需求分析-步骤一 3.概念结构设计-步骤二 4.逻辑结构设计-步骤三 4.1 两实体之间的1:1联系 4.2 两实体间的1:m联系 4.3 同一实体间的1:m联系 4.4 两实体间的弱实体联系 4.5 超类和子类的转换 4.6 两实体间的m:n联系 4.7 同一实体间的m:n联系 4.8 两个以上实体间的m:n联系 4.9 关系模式优化 4.10 设计用户子模式 5.物理结构设计-步骤四 6.数据库实施-步骤五 7.数据库运行维护-步骤六",content:"# 数据库设计\n\n\n# 1.数据库设计概述\n\n# 1.1 设计概述\n\n数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求。\n\n# 1.2 数据库设计的特点\n\n数据库设计是一项涉及多学科的综合性技术，又是一项庞大的工程项目，具有如下特点：\n\n 1. 数据库建设是硬件、软件和干件（技术和管理的界面）的结合\n 2. 数据库设计应该和应用系统设计相结合\n\n# 1.3 数据库设计方法\n\n常用的数据库设计方法如下：\n\n * 新奥尔良方法：将数据库设计分为若干阶段和步骤\n * 基于E-R模型的设计方法：概念设计阶段广泛采用\n * 基于3NF的设计方法：逻辑阶段可采用的有效方法\n * ODL（Object Definition Language）方法：面向对象的数据库设计方法\n * 计算机辅助设计：ORACLE Designer 2000、SYBASE PowerDesigner\n\n# 1.4 数据库设计的基本步骤\n\n数据库设计分为6个阶段：\n\n 1. 需求分析：准确了解与分析用户需求（包括数据与处理）\n 2. 概念结构设计：对用户需求进行综合、归纳与抽象，形成一个独立与具体DBMS的概念模型\n 3. 逻辑结构设计：将概念结构转换为某个DMBS所支持的数据模型，并对其进行优化\n 4. 物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）\n 5. 数据库实施：建立数据库，编制与调试应用程序，组织数据入库，并进行试运行\n 6. 数据库运行和维护：对数据库系统进行评论、调整与修改\n\n\n# 2.需求分析-步骤一\n\n需求分析是整个数据库设计过程中最重要的步骤之一，是后继各阶段的基础。在需求分析阶段，从多方面对整个组织进行调查，收集和分析各项应用对信息和处理两方面的需求。\n\n 1. 收集资料\n    \n    收集资料是数据库设计人员和用户共同完成的任务。确定企业组织的目标，从这些目标导出对数据库的总体要求。通过调研，确定由计算机完成的功能。\n\n 2. 分析整理\n    \n    分析的过程是对所收集到的数据进行抽象的过程，产生求解的模型。\n\n 3. 数据流图\n    \n    采用数据流图来描述系统的功能。数据流图可以形象地描述事务处理与所需数据的关联，便于用结构化系统方法，自顶向下，逐层分解，步步细化。\n\n 4. 数据字典\n    \n    对数据流图中的数据流和加工等进一步定义，从而完整地反映系统需求。\n    \n    数据字典的用途：进行详细的数据收集和数据分析所获得的主要结果。\n    \n    数据字典的内容：数据项、数据结构、数据流、数据存储、处理过程\n\n 5. 用户确认\n    \n    需求分析得到的数据流图和数据字典要返回给用户，通过反复完善，最终取得用户的认可\n\n\n# 3.概念结构设计-步骤二\n\n概念设计阶段的目标是产生整体数据库概念结构，即概念模式。概念模式是整个组织各个用户关心的信息结构。描述概念结构的有力工具是 E-R模型\n\n 1. 实体型\n    \n     用矩形表示，矩形框内写明实体名\n    \n\n 2. 属性\n    \n     用椭圆形表示，并用无向边将其与相应的实体连接起来\n    \n\n 3. 联系\n    \n     用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时这无向边旁标上联系的类型（1：1、1：n或m:n）\n    \n\n\n\n建立E-R模型步骤：\n\n 1. 设计局部E-R模型\n    \n    * 确定局部结构范围\n    * 定义实体\n    * 联系定义\n    * 属性分配\n\n 2. 设计全局E-R模型\n    \n    * 确定公共实体类型\n    \n    * 局部E-R模型的合并\n    \n    * 消除冲突\n\n 3. 全局E-R模型的优化\n    \n    * 实体类型的合并\n    \n    * 冗余属性的消除\n    \n    * 冗余联系的消除\n\n\n# 4.逻辑结构设计-步骤三\n\n逻辑结构设计就是把上述概念模型转换成为某个具体的数据库管理系统所支持的数据模型\n\nE-R模型向关系模式的转换\n\n> E-R模型向关系模式的转换转换原则：\n> \n>  1. 每一个实体类型转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码\n> \n>  2. 联系的转换\n>     \n>     一般1:1,1:m联系不产生新的关系模式，而是将一方实体的码加入多方实体对应的关系模式中，联系的属性也一并加入m:n联系要产生一个新的关系模式，改关系模式由联系涉及实体的码加上联系的属性（若有）组成\n\n# 4.1 两实体之间的1:1联系\n\n一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端实体对应的关系模式合并，则需要这该关系模式的属性中加入另一个关系模式的码和联系本身的属性。可将任一方实体的主码纳入另一方实体对应的关系中，若有联系的属性也一并纳入。\n\n例如：\n\n\n\n关系模式：\n\n * 工厂（厂号，厂名，地点）\n * 厂长（姓名，性别，年龄，厂号，任期）\n\n# 4.2 两实体间的1:m联系\n\n可将“1”方实体的主码纳入“m”方实体对应的关系中作为外码，同时把联系的属性也一并纳入“m”方对应的关系中\n\n\n\n关系模式：\n\n * 仓库（仓库号，地点，面积）\n * 商品（货号，品名，价格，仓库号，数量）\n\n# 4.3 同一实体间的1:m联系\n\n可在这个实体所对应的关系中多设一个属性，作为域该实体相联系的另一个实体的主码。\n\n\n\n关系模式：\n\n * 职工（工号，姓名，年龄，性别，职称，工资，领导者工号，民意测验）\n\n# 4.4 两实体间的弱实体联系\n\n可将被依赖实体的主码纳入弱实体中，作为弱实体的主码或主码中的一部分\n\n在现实世界中，常常有某些实体对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体的存在为前提。通常把前者称为弱实体。\n\n在E-R图中，用双线框表示弱实体，用指向弱实体的箭头表明依赖联系。\n\n例如，如图所示的E-R图可转换为如下关系模式：\n\n\n\n关系模式：\n\n * 职工（工号，姓名，年龄，性别，职称）\n * 亲属（工号，亲戚姓名，亲戚关系）\n\n# 4.5 超类和子类的转换\n\n概括定义了类型之间的一种子集联系。\n\n例如：学生是一个实体型，本科生、研究生也是实体型。本科生、研究生均是学生的子集。把学生称为超类，本科生、研究生称为学生的子类。\n\n在E-R图中，用双竖边的矩形框表示子类，用直线加小圆圈表示超类-子类联系。子类继承超类上定义的全部属性，其本身还可包含其他属性。\n\n例如，如图所示的E-R图中各个实体的属性为：\n\n * 职员：职工号，姓名，性别，年龄，参加工作时间\n * 飞行员：飞行小时，健康检查，飞机型号\n * 机械师：学历，级别，专业职称\n * 管理员：职务，职称\n\n\n\n改E-R图转换为关系模式为：\n\n * 职员（职工号，姓名，性别，年龄，参加工作时间）\n * 飞行员（职工号，飞行小时，健康检查，飞机型号）\n * 机械师（职工号，学历，级别，专业职称）\n * 管理员（职工号，职务，职称）\n\n为了查询方便，可这超类实体中增加一个指示器属性，根据指示器的值直接查询子类实体表。所以，职员关系又可以为：\n\n * 职员（职工号，姓名，性别，年龄，参加工作时间，职员类型）\n\n# 4.6 两实体间的m:n联系\n\n必须对“联系”单独建立一个关系，该关系中至少包含被它所联系的双方实体的“主码”，如果联系用属性，也要纳入这个关系中。\n\n\n\n关系模式：\n\n * 学生（学号，姓名，性别，年龄）\n * 课程（课程号，课程名，学时）\n * 选修（学号，课程号，成绩）\n\n# 4.7 同一实体间的m:n联系\n\n必须为这个“联系”单独建立一个关系，该关系中至少包含被它所联系的双方实体的“主码”，如果联系用属性，也要纳入这个关系中，由于这个“联系”只涉及一个实体，所以加入的实体的主码不能同名\n\n\n\n关系模式：\n\n * 零部件（代号，名称，价格）\n * 组装（代号，组装件代号，数量）\n\n# 4.8 两个以上实体间的m:n联系\n\n必须为这个“联系”单独建立一个关系，该关系中至少包含被它所联系的各个实体的“主码”，若是联系有属性，也要纳入这个关系中\n\n\n\n关系模式：\n\n * 供应商（供应商号，供应商名，地址）\n * 零件（零件号，零件名，重量）\n * 项目（项目编号，项目名称，开工日期）\n * 供应（供应商号，项目编号，零件号，零件数）\n\n# 4.9 关系模式优化\n\n最核心的就是要遵循数据库设计的NF范式\n\n应用关系规范化理论对上述产生的关系模式进行优化，具体步骤如下：\n\n 1. 确定每个关系模式内部各个属性之间的数据依赖以及不同关系模式属性之间的数据依赖\n 2. 对各个关系模式之间的数据依赖进行最小化处理，消除冗余的联系\n 3. 确定各关系模式的范式等级\n 4. 按照需求分析阶段得到的处理要求，确定要对哪些模式进行合并或分解\n 5. 为了提高数据操作的效率和存储空间的利用率，对上述产生的关系模式进行适当的修改、调整和重构\n\n# 4.10 设计用户子模式\n\n全局关系模型设计完成后，还应根据局部应用的需求，结合具体DBMS的特点，设计用户的子模式\n\n设计子模式时应注意考虑用户的习惯和方便性，主要包括：\n\n 1. 使用更符合用户习惯的别名\n 2. 可以为不同级别的用户定义不同的视图，以保证系统的安全性\n 3. 可将经常使用的复杂的查询定义为视图，简化用户对系统的使用\n\n\n# 5.物理结构设计-步骤四\n\n数据库的物理设计是指对一个给定的逻辑数据库模型选取一个最适合应用环境的物理结构的过程。物理设计通常分为两步：\n\n第一步 确定数据库的物理结构\n\n 1. 确定数据的存取方法、索引方法的选择、聚簇方法的选择\n 2. 确定数据的存储结构\n\n> 确定数据的存放位置 基本原则：根据应用情况将易变部分与稳定部分分开存放、存取频率较高部分与存取频率较低部分分开存放\n\n * 确定系统配置\n * DBMS产品一般都提供了一些存储分配参数\n * 同时使用数据库的用户数\n * 同时打开的数据库对象数\n * 内存分配参数\n * 使用的缓冲区长度、个数\n * 存储分配参数\n\n第二步 物理结构进行评价\n\n> 对时间效率、空间效率、维护开销和各种用户要求进行权衡，从多种设计方案中选择一个较优的方案。\n\n * 评价方法（完全依赖于所选用的DBMS）\n * 定量估算各种方案\n * 存储空间\n * 存取时间\n * 维护代价\n * 对估算结果进行权衡、比较，选择出一个较优的合理的物理结构\n * 如果该结构不符合用户需求，则需要修改设计\n\n\n# 6.数据库实施-步骤五\n\n实施阶段的工作主要有：\n\n 1. 建立数据库结构\n\n 2. 数据载入\n    \n    数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。\n\n 3. 应用程序的编码和调试\n\n 4. 数据库试运行\n    \n    * 功能测试\n      \n      实际运行数据库应用程序，执行对数据库的各种操作，测试应用程序的功能是否满足设计要求如果不满足，对应用程序部分则要修改、调整，直到达到设计要求。\n    \n    * 性能测试\n      \n      测量系统的性能指标，分析是否达到设计目标。\n      \n      如果测试的结果与设计目标不符，则要返回物理设计阶段，重新调整物理结构，修改系统参数，某些情况下甚至要返回逻辑设计阶段，修改逻辑结构。\n\n\n# 7.数据库运行维护-步骤六\n\n数据库系统投入正式运行后，对数据库经常性的维护工作主要由DBA完成，包括：\n\n 1. 数据库的转储和恢复\n    \n    * 这数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生。\n    \n    * 系统的操作人员对新系统还不熟悉，误操作也不可避免因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏。\n\n 2. 数据库的安全性、完整性控制\n\n 3. 数据库性能的监督、分析和改造\n\n 4. 数据库的重组与重构\n    \n    * 重组的目标：提高系统性能\n    \n    * 重组的工作：按原设计要求、重新安排存储位置、回收垃圾、减少指针链、数据库的重组不会改变原设计的数据逻辑结构和物理结构\n    \n    * 数据库重构：根据新环境调整数据库的模式和内模式、增加新的数据项、改变数据项的类型、改变数据库的容量、增加或删除索引修改完整性约束条件",normalizedContent:"# 数据库设计\n\n\n# 1.数据库设计概述\n\n# 1.1 设计概述\n\n数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求。\n\n# 1.2 数据库设计的特点\n\n数据库设计是一项涉及多学科的综合性技术，又是一项庞大的工程项目，具有如下特点：\n\n 1. 数据库建设是硬件、软件和干件（技术和管理的界面）的结合\n 2. 数据库设计应该和应用系统设计相结合\n\n# 1.3 数据库设计方法\n\n常用的数据库设计方法如下：\n\n * 新奥尔良方法：将数据库设计分为若干阶段和步骤\n * 基于e-r模型的设计方法：概念设计阶段广泛采用\n * 基于3nf的设计方法：逻辑阶段可采用的有效方法\n * odl（object definition language）方法：面向对象的数据库设计方法\n * 计算机辅助设计：oracle designer 2000、sybase powerdesigner\n\n# 1.4 数据库设计的基本步骤\n\n数据库设计分为6个阶段：\n\n 1. 需求分析：准确了解与分析用户需求（包括数据与处理）\n 2. 概念结构设计：对用户需求进行综合、归纳与抽象，形成一个独立与具体dbms的概念模型\n 3. 逻辑结构设计：将概念结构转换为某个dmbs所支持的数据模型，并对其进行优化\n 4. 物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）\n 5. 数据库实施：建立数据库，编制与调试应用程序，组织数据入库，并进行试运行\n 6. 数据库运行和维护：对数据库系统进行评论、调整与修改\n\n\n# 2.需求分析-步骤一\n\n需求分析是整个数据库设计过程中最重要的步骤之一，是后继各阶段的基础。在需求分析阶段，从多方面对整个组织进行调查，收集和分析各项应用对信息和处理两方面的需求。\n\n 1. 收集资料\n    \n    收集资料是数据库设计人员和用户共同完成的任务。确定企业组织的目标，从这些目标导出对数据库的总体要求。通过调研，确定由计算机完成的功能。\n\n 2. 分析整理\n    \n    分析的过程是对所收集到的数据进行抽象的过程，产生求解的模型。\n\n 3. 数据流图\n    \n    采用数据流图来描述系统的功能。数据流图可以形象地描述事务处理与所需数据的关联，便于用结构化系统方法，自顶向下，逐层分解，步步细化。\n\n 4. 数据字典\n    \n    对数据流图中的数据流和加工等进一步定义，从而完整地反映系统需求。\n    \n    数据字典的用途：进行详细的数据收集和数据分析所获得的主要结果。\n    \n    数据字典的内容：数据项、数据结构、数据流、数据存储、处理过程\n\n 5. 用户确认\n    \n    需求分析得到的数据流图和数据字典要返回给用户，通过反复完善，最终取得用户的认可\n\n\n# 3.概念结构设计-步骤二\n\n概念设计阶段的目标是产生整体数据库概念结构，即概念模式。概念模式是整个组织各个用户关心的信息结构。描述概念结构的有力工具是 e-r模型\n\n 1. 实体型\n    \n     用矩形表示，矩形框内写明实体名\n    \n\n 2. 属性\n    \n     用椭圆形表示，并用无向边将其与相应的实体连接起来\n    \n\n 3. 联系\n    \n     用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时这无向边旁标上联系的类型（1：1、1：n或m:n）\n    \n\n\n\n建立e-r模型步骤：\n\n 1. 设计局部e-r模型\n    \n    * 确定局部结构范围\n    * 定义实体\n    * 联系定义\n    * 属性分配\n\n 2. 设计全局e-r模型\n    \n    * 确定公共实体类型\n    \n    * 局部e-r模型的合并\n    \n    * 消除冲突\n\n 3. 全局e-r模型的优化\n    \n    * 实体类型的合并\n    \n    * 冗余属性的消除\n    \n    * 冗余联系的消除\n\n\n# 4.逻辑结构设计-步骤三\n\n逻辑结构设计就是把上述概念模型转换成为某个具体的数据库管理系统所支持的数据模型\n\ne-r模型向关系模式的转换\n\n> e-r模型向关系模式的转换转换原则：\n> \n>  1. 每一个实体类型转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码\n> \n>  2. 联系的转换\n>     \n>     一般1:1,1:m联系不产生新的关系模式，而是将一方实体的码加入多方实体对应的关系模式中，联系的属性也一并加入m:n联系要产生一个新的关系模式，改关系模式由联系涉及实体的码加上联系的属性（若有）组成\n\n# 4.1 两实体之间的1:1联系\n\n一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端实体对应的关系模式合并，则需要这该关系模式的属性中加入另一个关系模式的码和联系本身的属性。可将任一方实体的主码纳入另一方实体对应的关系中，若有联系的属性也一并纳入。\n\n例如：\n\n\n\n关系模式：\n\n * 工厂（厂号，厂名，地点）\n * 厂长（姓名，性别，年龄，厂号，任期）\n\n# 4.2 两实体间的1:m联系\n\n可将“1”方实体的主码纳入“m”方实体对应的关系中作为外码，同时把联系的属性也一并纳入“m”方对应的关系中\n\n\n\n关系模式：\n\n * 仓库（仓库号，地点，面积）\n * 商品（货号，品名，价格，仓库号，数量）\n\n# 4.3 同一实体间的1:m联系\n\n可在这个实体所对应的关系中多设一个属性，作为域该实体相联系的另一个实体的主码。\n\n\n\n关系模式：\n\n * 职工（工号，姓名，年龄，性别，职称，工资，领导者工号，民意测验）\n\n# 4.4 两实体间的弱实体联系\n\n可将被依赖实体的主码纳入弱实体中，作为弱实体的主码或主码中的一部分\n\n在现实世界中，常常有某些实体对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体的存在为前提。通常把前者称为弱实体。\n\n在e-r图中，用双线框表示弱实体，用指向弱实体的箭头表明依赖联系。\n\n例如，如图所示的e-r图可转换为如下关系模式：\n\n\n\n关系模式：\n\n * 职工（工号，姓名，年龄，性别，职称）\n * 亲属（工号，亲戚姓名，亲戚关系）\n\n# 4.5 超类和子类的转换\n\n概括定义了类型之间的一种子集联系。\n\n例如：学生是一个实体型，本科生、研究生也是实体型。本科生、研究生均是学生的子集。把学生称为超类，本科生、研究生称为学生的子类。\n\n在e-r图中，用双竖边的矩形框表示子类，用直线加小圆圈表示超类-子类联系。子类继承超类上定义的全部属性，其本身还可包含其他属性。\n\n例如，如图所示的e-r图中各个实体的属性为：\n\n * 职员：职工号，姓名，性别，年龄，参加工作时间\n * 飞行员：飞行小时，健康检查，飞机型号\n * 机械师：学历，级别，专业职称\n * 管理员：职务，职称\n\n\n\n改e-r图转换为关系模式为：\n\n * 职员（职工号，姓名，性别，年龄，参加工作时间）\n * 飞行员（职工号，飞行小时，健康检查，飞机型号）\n * 机械师（职工号，学历，级别，专业职称）\n * 管理员（职工号，职务，职称）\n\n为了查询方便，可这超类实体中增加一个指示器属性，根据指示器的值直接查询子类实体表。所以，职员关系又可以为：\n\n * 职员（职工号，姓名，性别，年龄，参加工作时间，职员类型）\n\n# 4.6 两实体间的m:n联系\n\n必须对“联系”单独建立一个关系，该关系中至少包含被它所联系的双方实体的“主码”，如果联系用属性，也要纳入这个关系中。\n\n\n\n关系模式：\n\n * 学生（学号，姓名，性别，年龄）\n * 课程（课程号，课程名，学时）\n * 选修（学号，课程号，成绩）\n\n# 4.7 同一实体间的m:n联系\n\n必须为这个“联系”单独建立一个关系，该关系中至少包含被它所联系的双方实体的“主码”，如果联系用属性，也要纳入这个关系中，由于这个“联系”只涉及一个实体，所以加入的实体的主码不能同名\n\n\n\n关系模式：\n\n * 零部件（代号，名称，价格）\n * 组装（代号，组装件代号，数量）\n\n# 4.8 两个以上实体间的m:n联系\n\n必须为这个“联系”单独建立一个关系，该关系中至少包含被它所联系的各个实体的“主码”，若是联系有属性，也要纳入这个关系中\n\n\n\n关系模式：\n\n * 供应商（供应商号，供应商名，地址）\n * 零件（零件号，零件名，重量）\n * 项目（项目编号，项目名称，开工日期）\n * 供应（供应商号，项目编号，零件号，零件数）\n\n# 4.9 关系模式优化\n\n最核心的就是要遵循数据库设计的nf范式\n\n应用关系规范化理论对上述产生的关系模式进行优化，具体步骤如下：\n\n 1. 确定每个关系模式内部各个属性之间的数据依赖以及不同关系模式属性之间的数据依赖\n 2. 对各个关系模式之间的数据依赖进行最小化处理，消除冗余的联系\n 3. 确定各关系模式的范式等级\n 4. 按照需求分析阶段得到的处理要求，确定要对哪些模式进行合并或分解\n 5. 为了提高数据操作的效率和存储空间的利用率，对上述产生的关系模式进行适当的修改、调整和重构\n\n# 4.10 设计用户子模式\n\n全局关系模型设计完成后，还应根据局部应用的需求，结合具体dbms的特点，设计用户的子模式\n\n设计子模式时应注意考虑用户的习惯和方便性，主要包括：\n\n 1. 使用更符合用户习惯的别名\n 2. 可以为不同级别的用户定义不同的视图，以保证系统的安全性\n 3. 可将经常使用的复杂的查询定义为视图，简化用户对系统的使用\n\n\n# 5.物理结构设计-步骤四\n\n数据库的物理设计是指对一个给定的逻辑数据库模型选取一个最适合应用环境的物理结构的过程。物理设计通常分为两步：\n\n第一步 确定数据库的物理结构\n\n 1. 确定数据的存取方法、索引方法的选择、聚簇方法的选择\n 2. 确定数据的存储结构\n\n> 确定数据的存放位置 基本原则：根据应用情况将易变部分与稳定部分分开存放、存取频率较高部分与存取频率较低部分分开存放\n\n * 确定系统配置\n * dbms产品一般都提供了一些存储分配参数\n * 同时使用数据库的用户数\n * 同时打开的数据库对象数\n * 内存分配参数\n * 使用的缓冲区长度、个数\n * 存储分配参数\n\n第二步 物理结构进行评价\n\n> 对时间效率、空间效率、维护开销和各种用户要求进行权衡，从多种设计方案中选择一个较优的方案。\n\n * 评价方法（完全依赖于所选用的dbms）\n * 定量估算各种方案\n * 存储空间\n * 存取时间\n * 维护代价\n * 对估算结果进行权衡、比较，选择出一个较优的合理的物理结构\n * 如果该结构不符合用户需求，则需要修改设计\n\n\n# 6.数据库实施-步骤五\n\n实施阶段的工作主要有：\n\n 1. 建立数据库结构\n\n 2. 数据载入\n    \n    数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。\n\n 3. 应用程序的编码和调试\n\n 4. 数据库试运行\n    \n    * 功能测试\n      \n      实际运行数据库应用程序，执行对数据库的各种操作，测试应用程序的功能是否满足设计要求如果不满足，对应用程序部分则要修改、调整，直到达到设计要求。\n    \n    * 性能测试\n      \n      测量系统的性能指标，分析是否达到设计目标。\n      \n      如果测试的结果与设计目标不符，则要返回物理设计阶段，重新调整物理结构，修改系统参数，某些情况下甚至要返回逻辑设计阶段，修改逻辑结构。\n\n\n# 7.数据库运行维护-步骤六\n\n数据库系统投入正式运行后，对数据库经常性的维护工作主要由dba完成，包括：\n\n 1. 数据库的转储和恢复\n    \n    * 这数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生。\n    \n    * 系统的操作人员对新系统还不熟悉，误操作也不可避免因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏。\n\n 2. 数据库的安全性、完整性控制\n\n 3. 数据库性能的监督、分析和改造\n\n 4. 数据库的重组与重构\n    \n    * 重组的目标：提高系统性能\n    \n    * 重组的工作：按原设计要求、重新安排存储位置、回收垃圾、减少指针链、数据库的重组不会改变原设计的数据逻辑结构和物理结构\n    \n    * 数据库重构：根据新环境调整数据库的模式和内模式、增加新的数据项、改变数据项的类型、改变数据库的容量、增加或删除索引修改完整性约束条件",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据流设计答题技巧",frontmatter:{title:"数据流设计答题技巧",date:"2022-12-19T21:36:15.000Z",permalink:"/pages/1575d1/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/12.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/03.%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AE%BE%E8%AE%A1%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7.html",relativePath:"01.指南/12.数据库设计/03.数据流设计答题技巧.md",key:"v-7e0c0407",path:"/pages/1575d1/",headers:[{level:2,title:"数据库设计答题技巧",slug:"数据库设计答题技巧",normalizedTitle:"数据库设计答题技巧",charIndex:2},{level:2,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:16},{level:2,title:"答案",slug:"答案",normalizedTitle:"答案",charIndex:795},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:9},{level:3,title:"1.数据库设计过程",slug:"_1-数据库设计过程",normalizedTitle:"1.数据库设计过程",charIndex:1010},{level:3,title:"2.ER图转关系模式",slug:"_2-er图转关系模式",normalizedTitle:"2.er图转关系模式",charIndex:1124},{level:3,title:"3.答题技巧",slug:"_3-答题技巧",normalizedTitle:"3.答题技巧",charIndex:1245}],headersStr:"数据库设计答题技巧 题目 答案 技巧 1.数据库设计过程 2.ER图转关系模式 3.答题技巧",content:"# 数据库设计答题技巧\n\n\n# 题目\n\n试题二（共 15 分）\n\n阅读下列说明，回答问题 1 至问题 4，将解答填入答题纸的对应栏内。\n\n【说明】\n\n某汽车维修公司为了便于管理车辆的维修情况，拟开发一套汽车维修管理系统，请根据 下述需求描述完成该系统的数据库设计。\n\n【需求分析结果】\n\n（1）客户信息包括：客户号、客户名、客户性质、折扣率、联系人、联系电话。客户 性质有个人或单位。客户号唯一标识客户关系中的每一个元组。\n\n（2）车辆信息包括：车牌号、车型、颜色和车辆类别。一个客户至少有一辆车，一辆 车只属于一个客户。\n\n（3）员工信息包括：员工号、员工名、岗位、电话、家庭住址。其中，员工号唯一标 识员工关系中的每一个元组。岗位有业务员、维修工、主管。业务员根据车辆的故障情况填 写维修单。\n\n（4）部门信息包括：部门号、名称、主管和电话。其中，部门号唯一确定部门关系的 每一个元组。每个部门只有一名主管，但每个部门有多名员工，每名员工只属于一个部门。\n\n（5）维修单信息包括：维修单号、车牌号、维修内容、工时。其中，维修单号唯一标 识维修单关系中的每一个元组。一个维修工可以接多张维修单，但一张维修单只对应一个维 修工。\n\n\n\n\n\n【问题 1】（6 分）\n\n根据问题描述，补充 3 个联系，完善图 2-1 的实体联系图。联系名可以用联系 1、联系 2 和联系 3 代替，联系的类型为 1:1、1:n 和 m:n（或 1:1、1:*和*:*）\n\n【问题 2】（4 分）\n\n根据题意，将关系模式中的空（a）〜（d）的属性补充完整，并填入答题纸对应的位置 上。\n\n【问题 3】（2 分）\n\n分别给出车辆关系和维修单关系的主键和外键。\n\n【问题 4】（3 分）\n\n如果一张维修单涉及多项维修内容，需要多个维修工来处理，那么哪个联系类型会发生 何种变化？你认为应该如何解决这一问题？\n\n\n# 答案\n\n问题1 (6分)\n\n联系1:客户和车辆，1:1\n联系2:部门和员工，1:n\n联系3:维修工和维修单，1:n\n\n\n问题2 (4分)\n\na:客户性质 \nb:客户号\nc:部门号\nd:车牌号，员工号\n\n\n问题3 (2分)\n\n车辆关系的主键:(车辆号，客户号)外键:客户号\n维修单关系的主键:维修单号外键:车牌号，员工号\n\n\n问题4 (3分)\n\n维修工和维修单之间的联系类型会发生变化，从1:n变成m:n。\n\n\n\n# 技巧\n\n\n# 1.数据库设计过程\n\n数据库设计需要掌握如下几种:\n\n 1. 需求分析：数据流图、数据字典、需求说明；\n 2. 概念结构设计：ER模型；\n 3. 逻辑结构设计：关系模式；\n 4. 物理设计：DBMS特性、硬件、OS特性\n\n\n# 2.ER图转关系模式\n\n能理清一对一、一对多、多对多的关系\n\n出题方式\n\n 1. 补充实体联系图，主要是填充联系（1：1，1：n，n：m）\n\n 2. 补充关系模型中空缺的属性；\n\n 3. 指出部分实体的主键和外键；\n\n 4. 简答题\n\n\n# 3.答题技巧\n\n（1）联系和联系判断 根据题干找出关键信息，判断实体联系的比值。\n\n（2）关系模式属性判断 根据题干找出缺失的属性，或根据ER图转换为关系模式时属性的增加。\n\n（3）简答题联系规范化理论进行作答。",normalizedContent:"# 数据库设计答题技巧\n\n\n# 题目\n\n试题二（共 15 分）\n\n阅读下列说明，回答问题 1 至问题 4，将解答填入答题纸的对应栏内。\n\n【说明】\n\n某汽车维修公司为了便于管理车辆的维修情况，拟开发一套汽车维修管理系统，请根据 下述需求描述完成该系统的数据库设计。\n\n【需求分析结果】\n\n（1）客户信息包括：客户号、客户名、客户性质、折扣率、联系人、联系电话。客户 性质有个人或单位。客户号唯一标识客户关系中的每一个元组。\n\n（2）车辆信息包括：车牌号、车型、颜色和车辆类别。一个客户至少有一辆车，一辆 车只属于一个客户。\n\n（3）员工信息包括：员工号、员工名、岗位、电话、家庭住址。其中，员工号唯一标 识员工关系中的每一个元组。岗位有业务员、维修工、主管。业务员根据车辆的故障情况填 写维修单。\n\n（4）部门信息包括：部门号、名称、主管和电话。其中，部门号唯一确定部门关系的 每一个元组。每个部门只有一名主管，但每个部门有多名员工，每名员工只属于一个部门。\n\n（5）维修单信息包括：维修单号、车牌号、维修内容、工时。其中，维修单号唯一标 识维修单关系中的每一个元组。一个维修工可以接多张维修单，但一张维修单只对应一个维 修工。\n\n\n\n\n\n【问题 1】（6 分）\n\n根据问题描述，补充 3 个联系，完善图 2-1 的实体联系图。联系名可以用联系 1、联系 2 和联系 3 代替，联系的类型为 1:1、1:n 和 m:n（或 1:1、1:*和*:*）\n\n【问题 2】（4 分）\n\n根据题意，将关系模式中的空（a）〜（d）的属性补充完整，并填入答题纸对应的位置 上。\n\n【问题 3】（2 分）\n\n分别给出车辆关系和维修单关系的主键和外键。\n\n【问题 4】（3 分）\n\n如果一张维修单涉及多项维修内容，需要多个维修工来处理，那么哪个联系类型会发生 何种变化？你认为应该如何解决这一问题？\n\n\n# 答案\n\n问题1 (6分)\n\n联系1:客户和车辆，1:1\n联系2:部门和员工，1:n\n联系3:维修工和维修单，1:n\n\n\n问题2 (4分)\n\na:客户性质 \nb:客户号\nc:部门号\nd:车牌号，员工号\n\n\n问题3 (2分)\n\n车辆关系的主键:(车辆号，客户号)外键:客户号\n维修单关系的主键:维修单号外键:车牌号，员工号\n\n\n问题4 (3分)\n\n维修工和维修单之间的联系类型会发生变化，从1:n变成m:n。\n\n\n\n# 技巧\n\n\n# 1.数据库设计过程\n\n数据库设计需要掌握如下几种:\n\n 1. 需求分析：数据流图、数据字典、需求说明；\n 2. 概念结构设计：er模型；\n 3. 逻辑结构设计：关系模式；\n 4. 物理设计：dbms特性、硬件、os特性\n\n\n# 2.er图转关系模式\n\n能理清一对一、一对多、多对多的关系\n\n出题方式\n\n 1. 补充实体联系图，主要是填充联系（1：1，1：n，n：m）\n\n 2. 补充关系模型中空缺的属性；\n\n 3. 指出部分实体的主键和外键；\n\n 4. 简答题\n\n\n# 3.答题技巧\n\n（1）联系和联系判断 根据题干找出关键信息，判断实体联系的比值。\n\n（2）关系模式属性判断 根据题干找出缺失的属性，或根据er图转换为关系模式时属性的增加。\n\n（3）简答题联系规范化理论进行作答。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"Java设计模式笔记",frontmatter:{title:"Java设计模式笔记",date:"2022-12-19T18:43:22.000Z",permalink:"/pages/55dfda/",categories:["Java设计模式"],tags:["Java设计模式"]},regularPath:"/01.%E6%8C%87%E5%8D%97/13.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%BE%E8%A7%A3.html",relativePath:"01.指南/13.Java设计模式/01.Java设计模式图解.md",key:"v-4455e40b",path:"/pages/55dfda/",headers:[{level:2,title:"1. 创建型设计模式",slug:"_1-创建型设计模式",normalizedTitle:"1. 创建型设计模式",charIndex:17},{level:3,title:"1.2 工厂模式",slug:"_1-2-工厂模式",normalizedTitle:"1.2 工厂模式",charIndex:32},{level:3,title:"1.3 抽象工厂模式",slug:"_1-3-抽象工厂模式",normalizedTitle:"1.3 抽象工厂模式",charIndex:163},{level:3,title:"1.4 生成器模式",slug:"_1-4-生成器模式",normalizedTitle:"1.4 生成器模式",charIndex:412},{level:3,title:"1.5 原型模式",slug:"_1-5-原型模式",normalizedTitle:"1.5 原型模式",charIndex:646},{level:3,title:"1.6 单例模式",slug:"_1-6-单例模式",normalizedTitle:"1.6 单例模式",charIndex:908},{level:2,title:"2. 结构型设计模式",slug:"_2-结构型设计模式",normalizedTitle:"2. 结构型设计模式",charIndex:1101},{level:3,title:"2.1 适配器模式",slug:"_2-1-适配器模式",normalizedTitle:"2.1 适配器模式",charIndex:1116},{level:3,title:"2.2 桥接模式",slug:"_2-2-桥接模式",normalizedTitle:"2.2 桥接模式",charIndex:1489},{level:3,title:"2.3 组合模式",slug:"_2-3-组合模式",normalizedTitle:"2.3 组合模式",charIndex:1899},{level:3,title:"2.4 装饰器模式",slug:"_2-4-装饰器模式",normalizedTitle:"2.4 装饰器模式",charIndex:2018},{level:3,title:"2.5 外观模式",slug:"_2-5-外观模式",normalizedTitle:"2.5 外观模式",charIndex:2359},{level:3,title:"2.6 享元模式",slug:"_2-6-享元模式",normalizedTitle:"2.6 享元模式",charIndex:2864},{level:3,title:"2.7 代理模式",slug:"_2-7-代理模式",normalizedTitle:"2.7 代理模式",charIndex:3102},{level:2,title:"3. 行为型设计模式",slug:"_3-行为型设计模式",normalizedTitle:"3. 行为型设计模式",charIndex:3588},{level:3,title:"3.1 责任链模式",slug:"_3-1-责任链模式",normalizedTitle:"3.1 责任链模式",charIndex:3603},{level:3,title:"3.2 命令模式",slug:"_3-2-命令模式",normalizedTitle:"3.2 命令模式",charIndex:3934},{level:3,title:"3.3 解释器模式",slug:"_3-3-解释器模式",normalizedTitle:"3.3 解释器模式",charIndex:4740},{level:3,title:"3.4 迭代器模式",slug:"_3-4-迭代器模式",normalizedTitle:"3.4 迭代器模式",charIndex:5118},{level:3,title:"3.5 中介模式",slug:"_3-5-中介模式",normalizedTitle:"3.5 中介模式",charIndex:5309},{level:3,title:"3.6 备忘录模式",slug:"_3-6-备忘录模式",normalizedTitle:"3.6 备忘录模式",charIndex:5577},{level:3,title:"3.7 观察者模式",slug:"_3-7-观察者模式",normalizedTitle:"3.7 观察者模式",charIndex:5865},{level:3,title:"3.8 状态模式",slug:"_3-8-状态模式",normalizedTitle:"3.8 状态模式",charIndex:6301},{level:3,title:"3.9 策略模式",slug:"_3-9-策略模式",normalizedTitle:"3.9 策略模式",charIndex:6640},{level:3,title:"3.10 访问者模式",slug:"_3-10-访问者模式",normalizedTitle:"3.10 访问者模式",charIndex:7083},{level:3,title:"3.11 模板方法",slug:"_3-11-模板方法",normalizedTitle:"3.11 模板方法",charIndex:7502}],headersStr:"1. 创建型设计模式 1.2 工厂模式 1.3 抽象工厂模式 1.4 生成器模式 1.5 原型模式 1.6 单例模式 2. 结构型设计模式 2.1 适配器模式 2.2 桥接模式 2.3 组合模式 2.4 装饰器模式 2.5 外观模式 2.6 享元模式 2.7 代理模式 3. 行为型设计模式 3.1 责任链模式 3.2 命令模式 3.3 解释器模式 3.4 迭代器模式 3.5 中介模式 3.6 备忘录模式 3.7 观察者模式 3.8 状态模式 3.9 策略模式 3.10 访问者模式 3.11 模板方法",content:"# Java设计模式笔记\n\n\n# 1. 创建型设计模式\n\n\n# 1.2 工厂模式\n\n工厂模式(Factory Method)\n\n\n\n意图： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。\n\n应用场景： 当一个类希望由它的子类来指定它所创建的对象的时候\n\n\n# 1.3 抽象工厂模式\n\n抽象工厂模式(Abstract Factory)\n\n\n\n意图： 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。\n\n应用场景：\n\n 1. 提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类\n 2. 当一个系统应该独立于它的产品创建、构成和表示时\n 3. 当要强调一系列相关的产品对象的设计以便进行联合使用时\n 4. 一个系统要由多个产品系列中的一个来配置时\n 5. 为图形用户界面（GUI）组件定义不同平台的并行类层次结构\n\n\n# 1.4 生成器模式\n\n生成器模式（建造者模式）(Builder)\n\n\n\n意图： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n应用场景：\n\n 1. 当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时\n 2. 当构造过程必须允许被构造的对象有不同的表示时\n 3. 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示\n 4. 适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示\n\n\n# 1.5 原型模式\n\n原型模式（Prototype）\n\n\n\n意图： 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。\n\n应用场景：\n\n 1. 当一个系统应该独立于它的产品创建、构成和表示时。\n 2. 一个类的实例只能有几个不同状态组合中的一种\n 3. 当要实例化的类是在运行时刻指定时，例如，通过动态装载。\n 4. 为了避免创建一个与产品类层次平行的工厂类层次时。\n 5. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。\n\n\n# 1.6 单例模式\n\n单例模式（Singleton）\n\n\n\n意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n应用场景\n\n 1. 它能够保证一个类只产生唯一的一个实例\n 2. 一个类仅有一个实例\n 3. 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。\n 4. 当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。\n\n\n# 2. 结构型设计模式\n\n\n# 2.1 适配器模式\n\n适配器模式（Adapter）\n\n\n\n意图： 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n题目选项描述\n\n 1. 将一个对象加以包装以给客户提供其希望的另外一个接口\n 2. 想使用一个已经存在的类，而其接口不符合要美\n 3. 使所有接口不兼容类可以一起工作\n 4. 将一个类的接口转换成客户希望的另一个接口\n\n应用场景：\n\n 1. 想使用一个已经存在的类，而它的接口不符合要求。\n 2. 创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类)协同工作。\n 3. (仅适用于对象Adapter)想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n\n# 2.2 桥接模式\n\n桥接模式(Bridge)\n\n\n\n意图： 将抽象部分与其实现部分分离，使它们都可以独立地变化。\n\n题目选项描述\n\n 1. 类的抽象和其实现之间不希望有一个固定的绑定关系\n 2. 不希望在抽象和它的实现部分之间有一个固定的绑定关系\n\n应用场景：\n\n 1. 不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是B为，在程序运行时刻实现部分应可以被选择或者切换。\n 2. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge模式传得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n 3. 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。\n 4. (C++)想对客户完全隐藏抽象的实现部分。\n 5. 有许多类要生成的类层次结构。\n 6. 想在多个对象间共享实现（可能使用引用计数)，但同时要求客户并不知道这一点。\n\n\n# 2.3 组合模式\n\n组合模式（Composite）\n\n\n\n意图： 将对象组合成树型结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。\n\n应用场景：\n\n表示对象的部分-整体层次结构\n\n\n# 2.4 装饰器模式\n\n装饰器模式（Decorator）\n\n\n\n意图： 动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更加灵活。\n\n题目选项描述\n\n 1. 将一个对象加以包装以提供一些额外的行为\n 2. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责\n 3. 动态地给一个对象添加一些额外的职责\n\n应用场景：\n\n 1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n 2. 处理那些可以撤销的职责。\n 3. 当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。\n\n\n# 2.5 外观模式\n\n外观模式(Facade)\n\n\n\n**意图：**为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n题目选项描述\n\n 1. 将一系列对象加以包装以简化其接口\n 2. 需要为一个复杂子系统提供一个简单接口\n\n应用场景：\n\n 1. 要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制,但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。\n 2. 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。\n 3. 当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系。\n\n\n# 2.6 享元模式\n\n享元模式（Flyweight）\n\n\n\n**意图：**运用共亨技术有效地支持大量细粒度的对象。\n\n题目选项描述\n\n因使用大量的对象而造成很大的存储开销时，进行对象共享,以减少对象数量从而达到较少的内存占用并提升性能。\n\n应用场景：\n\n 1. 一个应用程序使用了大量的对象。\n 2. 完全由于使用大量的对象，造成很大的存储开销。\n 3. 对象的大多数状态都可变为外部状态。\n 4. 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n\n\n# 2.7 代理模式\n\n代理模式(Proxy)\n\n\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n题目选项描述\n\n 1. 将一个对象加以包装以控制对这个对象的访问\n 2. 在需要比较通用和复杂的对象指针代替简单的指针时\n 3. 为其他对象提供一种代理以控制对这个对象的访问\n\n应用场景：\n\n 1. Proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候,常见情况有:\n 2. 远程代理(Remote Proxy)为一个对象在不同地址空间提供局部代表。\n 3. 虚代理(Virtual Proxy）根据需要创建开销很大的对象。\n 4. 保护代理(Protection Proxy)控制对原始对象的访问，用于对象应该有不同的访问权限的时候。\n 5. 智能引用(Smart Reference)取代了简单的指针，它在访问对象时执行一些附加操作。典型用途包括:对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放;当第一次引用一个持久对象时，将它装入内存;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。\n\n\n# 3. 行为型设计模式\n\n\n# 3.1 责任链模式\n\n责任链模式（Chain of Responsibility）\n\n\n\n**意图：**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n题目选项描述\n\n 1. 有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理\n 2. 一个客户需要使用一组相关对象\n 3. 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求\n\n应用场景：\n\n 1. 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。\n 2. 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。\n 3. 可处理一个请求的对象集合应被动态指定。\n\n\n# 3.2 命令模式\n\n命令模式（Command）\n\n\n\n**意图：**将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作。\n\n题目选项描述\n\n 1. 抽象出执行的动作以参数化某对象\n 2. 将请求封装为对象从而可以使用不同的请求对客户进行参数化\n 3. 在不同的时刻指定、排列和执行请求\n\n应用场景：\n\n 1. 抽象出待执行的动作以参数化某对象(。Command模式是过程语言中的回调(Callback机制的一个面向对象的替代品。\n 2. 在不同的时刻指定、排列和执行请求一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程并在那儿实现该请求。\n 3. 支持取消操作Command的Execute操作可在实施操作前将状态存储起来，在取消探作时这个状态用来消除该操作的影响。Command接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。\n 4. 4、支持修改日志这样当系统崩溃时，这些修改可以被重做一遍。在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。\n 5. 用构建在原语操作上的高层操作构造一个系统)这样一种结构在支持事务(Transaction）的信息系统中很常见。Command模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。\n\n\n# 3.3 解释器模式\n\n解释器模式（Interpreter）\n\n\n\n意图： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n题目选项描述\n\n有一个语言需要解释执行，并且可将句子表示为一个抽象语法树\n\n应用场景：\n\n 1. Interpreter模式适用于当有一个语言需要解释执行,并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好:\n 2. 该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。\n 3. 效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。\n\n\n# 3.4 迭代器模式\n\n迭代器模式（Iterator）\n\n\n\n**意图：**提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。\n\n题目选项描述\n\n访问一个聚合对象的内容而无须暴露它的内部表示\n\n应用场景：\n\n 1. 访问一个聚合对象的内容而无须暴露它的内部表示。\n 2. 支持对聚合对象的多种遍历。\n 3. 为遍历不同的聚合结构提供一个统一的接口。\n\n\n# 3.5 中介模式\n\n中介模式（终结者模式）(Mediator)\n\n\n\n**意图：**用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n题目选项描述\n\n1、一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象\n\n2、一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。\n\n3、减少多个对象或类之间的通信复杂性\n\n应用场景：\n\n一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。\n\n\n# 3.6 备忘录模式\n\n备忘录模式（Memento）\n\n\n\n**意图：**在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。\n\n题目选项描述\n\n 1. 将对象的状态恢复到先前的状态\n 2. 在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存\n 3. 必须保存一个对象在某一个时刻的(部分）状态\n\n应用场景：\n\n 1. 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。\n 2. 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。\n\n\n# 3.7 观察者模式\n\n观察者模式（Observer）\n\n\n\n**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n题目选项描述\n\n 1. 当一个对象必须通知其它对象，而它又不能假定其它对象是谁时\n 2. 在发布-订阅(Publish-Subscribe）消息模型中，订阅者订阅一个主题后，当该主题有新消息到达时，所有订阅者都会收到通知\n 3. 使所要交互的对象尽量松耦合\n 4. 当一个对象状态改变时所有依赖它的对象得到通知并自动更新\n 5. 一个对象的改变需要改变其它对象\n\n应用场景：\n\n 1. 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。\n 2. 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。\n 3. 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。\n\n\n# 3.8 状态模式\n\n状态模式（State）\n\n\n\n**意图：**允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n题目选项描述\n\n 1. 一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为\n 2. 一个对象在其内部状态改变时改变其行为\n\n应用场景：\n\n 1. 一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。\n 2. 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。\n\n\n# 3.9 策略模式\n\n策略模式（Strategy）\n\n\n\n**意图：**定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。\n\n题目选项描述\n\n 1. 需要使用一个算法地不同变体\n 2. 许多相关的类仅仅是行为有异\n 3. 在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动\n\n应用场景：\n\n 1. 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置-个类的方法。\n 2. 需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。\n 3. 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。\n 4. 一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。\n\n\n# 3.10 访问者模式\n\n访问者模式（Visitor）\n\n\n\n**意图：**表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n题目选项描述\n\n需要对一个对象结构中的对象进行很多不同的并且不相关的操作\n\n应用场景：\n\n 1. 一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。\n 2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。\n 3. 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。\n\n\n# 3.11 模板方法\n\n模板方法模式（Template Method）\n\n\n\n**意图：**定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n应用场景：\n\n 1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n 2. 各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。\n 3. 控制子类扩展。模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展)，这就只允许在这些点进行扩展。",normalizedContent:"# java设计模式笔记\n\n\n# 1. 创建型设计模式\n\n\n# 1.2 工厂模式\n\n工厂模式(factory method)\n\n\n\n意图： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。factory method使一个类的实例化延迟到其子类。\n\n应用场景： 当一个类希望由它的子类来指定它所创建的对象的时候\n\n\n# 1.3 抽象工厂模式\n\n抽象工厂模式(abstract factory)\n\n\n\n意图： 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。\n\n应用场景：\n\n 1. 提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类\n 2. 当一个系统应该独立于它的产品创建、构成和表示时\n 3. 当要强调一系列相关的产品对象的设计以便进行联合使用时\n 4. 一个系统要由多个产品系列中的一个来配置时\n 5. 为图形用户界面（gui）组件定义不同平台的并行类层次结构\n\n\n# 1.4 生成器模式\n\n生成器模式（建造者模式）(builder)\n\n\n\n意图： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n应用场景：\n\n 1. 当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时\n 2. 当构造过程必须允许被构造的对象有不同的表示时\n 3. 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示\n 4. 适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示\n\n\n# 1.5 原型模式\n\n原型模式（prototype）\n\n\n\n意图： 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。\n\n应用场景：\n\n 1. 当一个系统应该独立于它的产品创建、构成和表示时。\n 2. 一个类的实例只能有几个不同状态组合中的一种\n 3. 当要实例化的类是在运行时刻指定时，例如，通过动态装载。\n 4. 为了避免创建一个与产品类层次平行的工厂类层次时。\n 5. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。\n\n\n# 1.6 单例模式\n\n单例模式（singleton）\n\n\n\n意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n应用场景\n\n 1. 它能够保证一个类只产生唯一的一个实例\n 2. 一个类仅有一个实例\n 3. 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。\n 4. 当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。\n\n\n# 2. 结构型设计模式\n\n\n# 2.1 适配器模式\n\n适配器模式（adapter）\n\n\n\n意图： 将一个类的接口转换成客户希望的另外一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n题目选项描述\n\n 1. 将一个对象加以包装以给客户提供其希望的另外一个接口\n 2. 想使用一个已经存在的类，而其接口不符合要美\n 3. 使所有接口不兼容类可以一起工作\n 4. 将一个类的接口转换成客户希望的另一个接口\n\n应用场景：\n\n 1. 想使用一个已经存在的类，而它的接口不符合要求。\n 2. 创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类)协同工作。\n 3. (仅适用于对象adapter)想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n\n# 2.2 桥接模式\n\n桥接模式(bridge)\n\n\n\n意图： 将抽象部分与其实现部分分离，使它们都可以独立地变化。\n\n题目选项描述\n\n 1. 类的抽象和其实现之间不希望有一个固定的绑定关系\n 2. 不希望在抽象和它的实现部分之间有一个固定的绑定关系\n\n应用场景：\n\n 1. 不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是b为，在程序运行时刻实现部分应可以被选择或者切换。\n 2. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 bridge模式传得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n 3. 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。\n 4. (c++)想对客户完全隐藏抽象的实现部分。\n 5. 有许多类要生成的类层次结构。\n 6. 想在多个对象间共享实现（可能使用引用计数)，但同时要求客户并不知道这一点。\n\n\n# 2.3 组合模式\n\n组合模式（composite）\n\n\n\n意图： 将对象组合成树型结构以表示“部分-整体”的层次结构。composite使得用户对单个对象和组合对象的使用具有一致性。\n\n应用场景：\n\n表示对象的部分-整体层次结构\n\n\n# 2.4 装饰器模式\n\n装饰器模式（decorator）\n\n\n\n意图： 动态地给一个对象添加一些额外的职责。就增加功能而言，decorator模式比生成子类更加灵活。\n\n题目选项描述\n\n 1. 将一个对象加以包装以提供一些额外的行为\n 2. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责\n 3. 动态地给一个对象添加一些额外的职责\n\n应用场景：\n\n 1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n 2. 处理那些可以撤销的职责。\n 3. 当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。\n\n\n# 2.5 外观模式\n\n外观模式(facade)\n\n\n\n**意图：**为子系统中的一组接口提供一个一致的界面，facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n题目选项描述\n\n 1. 将一系列对象加以包装以简化其接口\n 2. 需要为一个复杂子系统提供一个简单接口\n\n应用场景：\n\n 1. 要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制,但也给那些不需要定制子系统的用户带来一些使用上的困难。facade可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。\n 2. 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。\n 3. 当需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过facade进行通信，从而简化了它们之间的依赖关系。\n\n\n# 2.6 享元模式\n\n享元模式（flyweight）\n\n\n\n**意图：**运用共亨技术有效地支持大量细粒度的对象。\n\n题目选项描述\n\n因使用大量的对象而造成很大的存储开销时，进行对象共享,以减少对象数量从而达到较少的内存占用并提升性能。\n\n应用场景：\n\n 1. 一个应用程序使用了大量的对象。\n 2. 完全由于使用大量的对象，造成很大的存储开销。\n 3. 对象的大多数状态都可变为外部状态。\n 4. 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n\n\n# 2.7 代理模式\n\n代理模式(proxy)\n\n\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n题目选项描述\n\n 1. 将一个对象加以包装以控制对这个对象的访问\n 2. 在需要比较通用和复杂的对象指针代替简单的指针时\n 3. 为其他对象提供一种代理以控制对这个对象的访问\n\n应用场景：\n\n 1. proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候,常见情况有:\n 2. 远程代理(remote proxy)为一个对象在不同地址空间提供局部代表。\n 3. 虚代理(virtual proxy）根据需要创建开销很大的对象。\n 4. 保护代理(protection proxy)控制对原始对象的访问，用于对象应该有不同的访问权限的时候。\n 5. 智能引用(smart reference)取代了简单的指针，它在访问对象时执行一些附加操作。典型用途包括:对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放;当第一次引用一个持久对象时，将它装入内存;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。\n\n\n# 3. 行为型设计模式\n\n\n# 3.1 责任链模式\n\n责任链模式（chain of responsibility）\n\n\n\n**意图：**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n题目选项描述\n\n 1. 有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理\n 2. 一个客户需要使用一组相关对象\n 3. 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求\n\n应用场景：\n\n 1. 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。\n 2. 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。\n 3. 可处理一个请求的对象集合应被动态指定。\n\n\n# 3.2 命令模式\n\n命令模式（command）\n\n\n\n**意图：**将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作。\n\n题目选项描述\n\n 1. 抽象出执行的动作以参数化某对象\n 2. 将请求封装为对象从而可以使用不同的请求对客户进行参数化\n 3. 在不同的时刻指定、排列和执行请求\n\n应用场景：\n\n 1. 抽象出待执行的动作以参数化某对象(。command模式是过程语言中的回调(callback机制的一个面向对象的替代品。\n 2. 在不同的时刻指定、排列和执行请求一个command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程并在那儿实现该请求。\n 3. 支持取消操作command的execute操作可在实施操作前将状态存储起来，在取消探作时这个状态用来消除该操作的影响。command接口必须添加一个unexecute操作，该操作取消上一次execute 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用unexecute和execute来实现重数不限的“取消和“重做”。\n 4. 4、支持修改日志这样当系统崩溃时，这些修改可以被重做一遍。在 command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用execute操作重新执行它们。\n 5. 用构建在原语操作上的高层操作构造一个系统)这样一种结构在支持事务(transaction）的信息系统中很常见。command模式提供了对事务进行建模的方法。command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。\n\n\n# 3.3 解释器模式\n\n解释器模式（interpreter）\n\n\n\n意图： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n题目选项描述\n\n有一个语言需要解释执行，并且可将句子表示为一个抽象语法树\n\n应用场景：\n\n 1. interpreter模式适用于当有一个语言需要解释执行,并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好:\n 2. 该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。\n 3. 效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。\n\n\n# 3.4 迭代器模式\n\n迭代器模式（iterator）\n\n\n\n**意图：**提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。\n\n题目选项描述\n\n访问一个聚合对象的内容而无须暴露它的内部表示\n\n应用场景：\n\n 1. 访问一个聚合对象的内容而无须暴露它的内部表示。\n 2. 支持对聚合对象的多种遍历。\n 3. 为遍历不同的聚合结构提供一个统一的接口。\n\n\n# 3.5 中介模式\n\n中介模式（终结者模式）(mediator)\n\n\n\n**意图：**用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n题目选项描述\n\n1、一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象\n\n2、一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。\n\n3、减少多个对象或类之间的通信复杂性\n\n应用场景：\n\n一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。\n\n\n# 3.6 备忘录模式\n\n备忘录模式（memento）\n\n\n\n**意图：**在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。\n\n题目选项描述\n\n 1. 将对象的状态恢复到先前的状态\n 2. 在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存\n 3. 必须保存一个对象在某一个时刻的(部分）状态\n\n应用场景：\n\n 1. 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。\n 2. 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。\n\n\n# 3.7 观察者模式\n\n观察者模式（observer）\n\n\n\n**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n题目选项描述\n\n 1. 当一个对象必须通知其它对象，而它又不能假定其它对象是谁时\n 2. 在发布-订阅(publish-subscribe）消息模型中，订阅者订阅一个主题后，当该主题有新消息到达时，所有订阅者都会收到通知\n 3. 使所要交互的对象尽量松耦合\n 4. 当一个对象状态改变时所有依赖它的对象得到通知并自动更新\n 5. 一个对象的改变需要改变其它对象\n\n应用场景：\n\n 1. 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。\n 2. 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。\n 3. 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。\n\n\n# 3.8 状态模式\n\n状态模式（state）\n\n\n\n**意图：**允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n题目选项描述\n\n 1. 一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为\n 2. 一个对象在其内部状态改变时改变其行为\n\n应用场景：\n\n 1. 一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。\n 2. 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。state模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。\n\n\n# 3.9 策略模式\n\n策略模式（strategy）\n\n\n\n**意图：**定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。\n\n题目选项描述\n\n 1. 需要使用一个算法地不同变体\n 2. 许多相关的类仅仅是行为有异\n 3. 在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动\n\n应用场景：\n\n 1. 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置-个类的方法。\n 2. 需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。\n 3. 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。\n 4. 一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的strategy类中，以代替这些条件语句。\n\n\n# 3.10 访问者模式\n\n访问者模式（visitor）\n\n\n\n**意图：**表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n题目选项描述\n\n需要对一个对象结构中的对象进行很多不同的并且不相关的操作\n\n应用场景：\n\n 1. 一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。\n 2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用visitor模式让每个应用仅包含需要用到的操作。\n 3. 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。\n\n\n# 3.11 模板方法\n\n模板方法模式（template method）\n\n\n\n**意图：**定义一个操作中的算法骨架，而将一些步骤延迟到子类中。template method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n应用场景：\n\n 1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n 2. 各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。\n 3. 控制子类扩展。模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展)，这就只允许在这些点进行扩展。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"Java设计模式下午题目",frontmatter:{title:"Java设计模式下午题目",date:"2022-12-19T18:53:56.000Z",permalink:"/pages/5aa53b/",categories:["Java设计模式"],tags:["Java设计模式"]},regularPath:"/01.%E6%8C%87%E5%8D%97/13.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8D%88%E9%A2%98%E7%9B%AE.html",relativePath:"01.指南/13.Java设计模式/02.Java设计模式下午题目.md",key:"v-fb50d35c",path:"/pages/5aa53b/",headers:[{level:2,title:"1.【2013年试题六】设计模式",slug:"_1-【2013年试题六】设计模式",normalizedTitle:"1.【2013年试题六】设计模式",charIndex:18},{level:2,title:"2.【2014年试题六】设计模式",slug:"_2-【2014年试题六】设计模式",normalizedTitle:"2.【2014年试题六】设计模式",charIndex:2027},{level:2,title:"3.【2015年试题六】设计模式",slug:"_3-【2015年试题六】设计模式",normalizedTitle:"3.【2015年试题六】设计模式",charIndex:4483},{level:2,title:"4.【2016年试题六】设计模式",slug:"_4-【2016年试题六】设计模式",normalizedTitle:"4.【2016年试题六】设计模式",charIndex:6444},{level:2,title:"5.【2017年试题六】设计模式",slug:"_5-【2017年试题六】设计模式",normalizedTitle:"5.【2017年试题六】设计模式",charIndex:8287},{level:2,title:"6.【2018年试题六】设计模式",slug:"_6-【2018年试题六】设计模式",normalizedTitle:"6.【2018年试题六】设计模式",charIndex:9760},{level:2,title:"7.【2019年试题六】设计模式",slug:"_7-【2019年试题六】设计模式",normalizedTitle:"7.【2019年试题六】设计模式",charIndex:12078},{level:2,title:"8.【2021年试题六】设计模式",slug:"_8-【2021年试题六】设计模式",normalizedTitle:"8.【2021年试题六】设计模式",charIndex:13997},{level:2,title:"9.【2022年试题六】设计模式",slug:"_9-【2022年试题六】设计模式",normalizedTitle:"9.【2022年试题六】设计模式",charIndex:16191}],headersStr:"1.【2013年试题六】设计模式 2.【2014年试题六】设计模式 3.【2015年试题六】设计模式 4.【2016年试题六】设计模式 5.【2017年试题六】设计模式 6.【2018年试题六】设计模式 7.【2019年试题六】设计模式 8.【2021年试题六】设计模式 9.【2022年试题六】设计模式",content:'# Java设计模式下午题\n\n\n# 1.【2013年试题六】设计模式\n\n欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。以绘制直线和圆形为 例，对应的绘图程序如表 6-1 所示。\n\n\n\n(1) interface Drawing{\n   (2) void drawLine(double x1,double y1,double x2,double y2);\n   (3) void drawCircle(double x,double y,double r);\n}\n\nclass DP1{\n    static public void draw_a_line(double x1,double y1,double y,double r) { // 代码省略 }\n    static public void draw_a_circle(double x,double y,double r) { // 代码省略 }\n}\n\nclass DP2{\n    static public void drawline(double x1,double y1,double x2,double y2) { // 代码省略 }\n    static public void drawcircle(double x,double y,double r) { // 代码省略 }\n}\n\nclass V1Drawing implements Drawing{\n    public void drawLine(double x1,double y1,double x2,double y2) { // 代码省略 }\n    public void drawCircle(double x, double y, double r) { \n        (4) DP1.draw_a_circle(x,y,r);\n    }\n}\n\nclass V2Drawing implements Drawing {\n    public void drawLine(double x1, double y1, double x2, double y2) { /* 代码省略 */ }\n    public void drawCircle(double x, double y, double r) { \n        (5) DP2.drawcircle(x,y,r);\n    }\n}\n\nabstract class Shape {\n    private Drawing _dp;\n    (6) abstract public void draw();\n    Shape(Drawing dp) { _dp = dp; }\n    public void drawLine(double x1, double y1, double x2 ,double y2)\n    { _dp.drawLine(x1, y1, x2, y2); }\n    public void drawCircle (double x, double y, double r)\n    { _dp.drawCircle(x, y, r); }\n}\n\nclass Rectangle extends Shape {\n    private double _x1, _x2, _y1, _y2;\n    public Rectangle(Drawing dp, double x1, double y1, double x2, double y2) { /* 代码省略 */ }\n    public void draw() { /* 代码省略 */ }\n}\n\nclass Circle extends Shape {\n    private double _x, _y, _r;\n    public Circle(Drawing dp, double x, double y, double r) { /* 代码省略 */ }\n    public void draw() { drawCircle(_x, _y, _r); }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) interface\n(2) void drawLine(double x1,double y1,double x2,double y2);\n(3) void drawCircle(double x,double y,double r);\n(4) DP1.draw_a_circle(x,y,r);\n(5) DP2.drawcircle(x,y,r);\n(6) abstract public void draw();\n\n\n\n# 2.【2014年试题六】设计模式\n\n本题目使用的是命令模式（Command）\n\n某灯具厂商欲生产一个灯具遥控器，该遥控器具有 7 个可编程的插槽，每个插槽都有开 关按钮，对应着一个不同的灯。利用该遥控器能够统一控制房间中该厂商所有品牌灯具的开 关，现采用 Command（命令）模式实现该遥控器的软件部分。Command 模式的类图如图 6-1 所示。\n\n\n\nclass Light {\n    public Light() {}\n    public Light(String name) { /* 代码省略 */ }\n    public void on() { /* 代码省略 */ } // 开灯\n    public void off() { /* 代码省略 */ } // 关灯\n// 其余代码省略\n}\n\n(1) interface Command {\n    public void execute();\n}\n\nclass LightOnCommand implements Command { // 开灯命令\n    Light light;\n    public LightOnCommand(Light light) { this.light = light; }\n    public void execute() { \n        (2) light.on(); \n    }\n}\n\nclass LightOffCommand implements Command { // 关灯命令\n    Light light;\n    public LightOffCommand(Light light) { this.light = light; }\n    public void execute() { \n        (3) light.off();\n    }\n}\n\nclass RemoteControl { // 遥控器\n    Command[] onCommands = new Command[7];\n    Command[] offCommands = new Command[7];\n\n    public RemoteControl() { /* 代码省略 */ }\n\n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        (4) onCommands[slot] = onCommand;\n        (5) offCommands[slot]= offCommand;\n    }\n\n    public void onButtonWasPushed(int slot) {\n        (6) onCommands[slot].execute();\n    }\n\n    public void offButtonWasPushed(int slot) {\n        (7) offCommands[slot].execute();\n    }\n}\n\nclass RemoteLoader {\n    public static void main(String[] args) {\n        RemoteControl remoteControl = new RemoteControl();\n        Light livingRoomLight = new Light("Living Room");\n        Light kitchenLight = new Light("kitchen");\n        LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight);\n        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n        remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);\n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) interface Command\n(2) light.on(); \n(3) light.off();\n(4) onCommands[slot] = onCommand;\n(5) offCommands[slot]= offCommand;\n(6) onCommands[slot].execute();\n(7) offCommands[slot].execute();\n\n\n\n# 3.【2015年试题六】设计模式\n\n某大型购物中心欲开发一套收银软件，要求其能够支持购物中心在不同时期推出的各种 促销活动，如打折、返利（例如，满 300 返 100）等等。现采用策略（Strategy）模式实现 该要求，得到如图 6-1 所示的类图。\n\n\n\nimport java.util.*;\n\nenum TYPE { NORMAL, CASH_DISCOUNT, CASH_RETURN};\ninterface CashSuper {\n    public (1) double acceptCash(double money);\n}\n\nclass CashNormal implements CashSuper { // 正常收费子类\n    public double acceptCash(double money) {\n        return money;\n    }\n}\n\nclass CashDiscount implements CashSuper {\n    private double moneyDiscount; // 折扣率\n    public CashDiscount(double moneyDiscount) {\n        this moneyDiscount = moneyDiscount;\n    }\n    public double acceptCash(double money) {\n        return money* moneyDiscount;\n    }\n}\nclass CashReturn implements CashSuper { // 满额返利\n    private double moneyCondition;\n    private double moneyReturn;\n\n    public CashReturn(double moneyCondition, double moneyReturn) {\n        this.moneyCondition = moneyCondition; // 满额数额\n        this.moneyReturn = moneyReturn; // 返利数额\n    }\n\n    public double acceptCash(double money) {\n        double result = money;\n        if (money >= moneyCondition)\n            result = money - Math.floor(money / moneyCondition) * moneyReturn;\n        return result;\n    }\n}\n\nclass CashContext {\n    private CashSuper cs;\n    private TYPE t;\n\n    public CashContext(TYPE t) {\n        switch (t) {\n            case NORMAL: // 正常收费\n                (2) cs = new CashNormal;\n                break;\n            case CASH_DISCOUNT: // 打 8 折\n                (3) cs = new CashDiscount;\n                break;\n            case CASH_RETURN: // 满 300 返 100\n                (4) cs = new CashReturn;\n                break;\n        }\n    }\n\n    public double GetResult(double money) {\n        (5) return cs.acceptCash(money);\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n本题使用策略模式（Strategy）\n\n\n\n参考答案：\n\n(1) double acceptCash(double money)\n(2) cs = new CashNormal;\n(3) cs = new CashDiscount;\n(4) cs = new CashReturn;\n(5) return cs.acceptCash(money);\n\n\n\n# 4.【2016年试题六】设计模式\n\n本题使用的是装饰器模式（Decorator）\n\n某发票（lnvoice）由抬头（Head）部分、正文部分和脚注（Foot）部分构成。现采用 装饰（Decorator）模式实现打印发票的功能，得到如图 6-1 所示的类图。\n\n\n\nclass invoice {\n    public void printInvoice() {\n        System.out.println("This is the content of the invoice!");\n    }\n}\n\nclass Decorator extends Invoice {\n    protected Invoice ticket;\n    public Decorator(Invoice t) {\n        ticket = t;\n    }\n    public void printInvoice() {\n        if (ticket != null)\n            (1) ticket.printInvoice();\n    }\n}\nclass HeadDecorator extends Decorator {\n    public HeadDecorator(Invoice t) {\n        super(t);\n    }\n    public void printInvoice () {\n        System.out.println("This is the header of the invoice!");\n        (2) super.printInvoice();\n    }\n}\nclass FootDecorator extends Decorator {\n    public FootDecorator(Invoice t) {\n        super(t);\n    }\n\n    public void printInvoice() {\n        (3) super.printInvoice();\n        System.out.println("This is the footnote of the invoice!");\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Invoice t = new Invoice();\n        Invoice ticket;\n        ticket = (4) new HeadDecorator(new FootDecorator(t));\n        ticket.printInvoice();\n        System.out.println("--------------------");\n        ticket = (5) new HeadDecorator(new FootDecorator(null));\n        ticket.printInvoice();\n    }\n}\n\n程序的输出结果为：\n        This is the header of the invoice!\n        This is the content of the invoice!\n        This is the footnote of the invoice!\n        --------------------\n        This is the header of the invoice!\n        This is the footnote of the invoice!\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) ticket.printInvoice();\n(2) super.printInvoice();\n(3) super.printInvoice();\n(4) new HeadDecorator(new FootDecorator(t));\n(5) new HeadDecorator(new FootDecorator(null));\n\n\n\n# 5.【2017年试题六】设计模式\n\n本题使用的模式是桥接模式（Bridge）\n\n某图像预览程序要求能够查看 BMP、JPEG 和 GIF 三种格式的文件，且能够在 Windows 和 Linux 两种操作系统上运行。程序需具有较好的扩展性以支持新的文件格式和操作系统。 为满足上述需求并减少所需生成的子类数目，现采用桥接（Bridge）模式进行设计，得到如 图 6-1 所示的类图。\n\n\n\nimport java.util.*;\n\nclass Matrix { // 各种格式的文件最终都被转化为像素矩阵\n// 此处代码省略\n}\nabstract class Implementor {\n    public (1) abstract void doPaint(Matrix m); // 显示像素矩阵 m\n}\n\nclass WinImp extends Implementor {\n    public void doPaint(Matrix m) { // 调用 Windows 系统的绘制函数绘制像素矩阵\n        // 此处代码省略\n    }\n}\nclass LinuxImp extends Implementor {\n    public void doPaint(Matrix m) { // 调用 Linux 系统的绘制函数绘制像素矩阵\n        // 此处代码省略\n    }\n}\nabstract class Image {\n    public void setImp(Implementor imp) { this.imp = imp; }\n    public abstract void parseFile(String fileName);\n    protected Implementor imp;\n}\nclass BMPImage extends Image {\n// 此处代码省略\n}\nclass GIFImage extends Image {\n    public void parseFile(String fileName) {\n// 此处解析 BMP 文件并获得一个像素矩阵对象 m\n        (2) imp.doPaint(m); // 显示像素矩阵 m\n    }\n\n}\n\nclass JPEGImage extends Image {\n// 此处代码省略\n}\nclass Main {\n    public static void main(String[] args) {\n// 在 Linux 操作系统上查看 demo.gif 图像文件\n        Image image = (3) new GIFImage();\n        Implementor imageImp = (4) new LinuxImp();\n        (5) image.setImp(imageImp);\n        Image.parseFile("demo.gif");\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) abstract void doPaint(Matrix m);\n(2) imp.doPaint(m); \n(3) new GIFImage();\n(4) new LinuxImp();\n(5) image.setImp(imageImp);\n\n\n\n# 6.【2018年试题六】设计模式\n\n本题使用的是状态模式（State）\n\n某航空公司的会员积分系统将其会员划分为：普卡(Basic)、银卡(Silver)和金卡(Gold) 三个等级。非会员(NonMember)可以申请成为普卡会员。会员的等级根据其一年内累积的 里程数进行调整。描述会员等级调整的状态图如图 6-1 所示。现采用状态(State)模式实现 上述场景，得到如图 6-2 所示的类图。\n\n\n\nimport com.example.day09.CFrequentFlyer;\n\nimport java.util.*;\nabstract class CState {\n    public int flyMiles; // 里程数\n    public (1) abstract double travel(int miles,CFrequentFlyer context); // 根据累积里程数调整会员等级\n}\nclass CNoCustomer extends CState { // 非会员\n    public double travel(int miles, CFrequentFlyer context) {\n        System.out.println("Your travel will not account for points");\n        return miles; // 不累积里程数\n    }\n}\nclass CBasic extends CState { // 普卡会员\n    public double travel(int miles, CFrequentFlyer context) {\n        if (context.flyMiles >= 25000 && context.flyMiles < 50000)\n            (2) context.setState(new CSilver());\n        if (context.flyMiles >= 50000)\n            (3) context.setState(new CGold());\n        return miles;\n    }\n}\n\nclass CGold extends CState { // 金卡会员\n    public double travel(int miles, CFrequentFlyer context) {\n        if (context.flyMiles >= 25000 && context.flyMiles < 50000)\n            (4) context.setState(new CSilver()); \n        if (context.flyMiles < 25000);\n            (5) context.setState(new CGold()); \n            return miles + 0.5 * miles; // 累积里程数\n    }\n}\nclass CSilver extends CState { // 银卡会员\n    public double travel(int miles, CFrequentFlyer context) {\n        if (context.flyMiles <= 25000)\n            context.setState(new CBasic());\n        if (context.flyMiles >= 50000)\n            context.setState(new CGold());\n        return (miles + 0.25 * miles); // 累积里程数\n    }\n}\n\nclass CFrequentFlyer {\n    CState state;\n    double flyMiles;\n\n    public CFrequentFlyer() {\n        state = new CNoCustomer();\n        flyMiles = 0;\n        setState(state);\n    }\n\n    public void setState(CState state) {\n        this.state = state;\n    }\n\n    public void travel(int miles) {\n        double bonusMiles = state.travel(miles, this);\n        flyMiles = flyMiles + bonusMiles;\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n\n\n参考答案：\n\n(1) abstract double travel(int miles,CFrequentFlyer context);\n(2) context.setState(new CSilver());\n(3) context.setState(new CGold());\n(4) context.setState(new CSilver()); \n(5) context.setState(new CGold()); \n\n\n\n# 7.【2019年试题六】设计模式\n\n本题使用的是观察者模式（Observer）\n\n某文件管理系统中定义了类 OfficeDoc 和 DocExplorer。当类 OfficeDoc 发生变化时， 类 DocExplorer 的所有对象都要更新其自身的状态。现采用观察者（Observer）设计模式来 实现该需求，所设计的类图如图 6-1 所示。\n\n\n\nimport java.util.*;\n\ninterface Observer {\n    public (1)void update();\n}\ninterface Subject {\n    public void Attach(Observer obs);\n\n    public void Detach(Observer obs);\n\n    public void Notify();\n\n    public void setStatus(int status);\n\n    public int getStatus();\n}\n\nclass OfficeDoc implements Subject {\nprivate List<(2) Observer>myObs;\n    private String mySubjectName;\n    private int m_status;\n\n    public OfficeDoc(String name) {\n        mySubjectName = name;\n        this.myObs = new ArrayList<Observer>();\n        m_status = 0;\n    }\n\n    public void Attach(Observer obs) {\n        this.myObs.add(obs);\n    }\n\n    public void Detach(Observer obs) {\n        this.myObs.remove(obs);\n    }\n\n    public void Notify() {\n        for (Observer obs : this.myObs) {\n            (3) obs.update();\n        }\n    }\n\n    public void setStatus(int status) {\n        m_status = status;\n        System.out.println("SetStatus subject[" + mySubjectName +\n                "]status:" + status);\n    }\n\n    public int getStatus() {\n        return m_status;\n    }\n}\n\nclass DocExplorer implements Observer {\n    private String myObsName;\n    public DocExplorer(String name, (4) Subject sub) {\n        myObsName = name;\n        sub. (5) Attach(this);\n    }\n    public void update() {\n        System.out.println("update observer[" + myObsName + "]");\n    }\n}\nclass ObserverTest {\n    public static void main(String[] args) {\n        Subject subjectA = new OfficeDoc("subject A");\n        Observer observerA = new DocExplorer("observer A", subjectA);\n        subjectA.setStatus(1);\n        subjectA.Notify();\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1)void update();\n(2) Observer\n(3) obs.update();\n(4) Subject\n(5) Attach(this);\n\n\n\n# 8.【2021年试题六】设计模式\n\n本题是使用享元（FlyWeight）模式\n\n享元（FlyWeight）模式主要用于减少创建对象的数量，以降低内存占用，提高性能。 先要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空 间，采用享元模式实现该程序，得到如图 6-1 所示的类图。\n\n\n\nimport java.util.*;\nenum PieceColor { BLACK, WHITE } // 棋子颜色\nclass PiecePos { // 棋子位置\n    private int x;\n    private int y;\n\n    public PiecePos(int a, int b) {\n        x = a;\n        y = b;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n}\n\nabstract class Piece { // 棋子定义\n    protected PieceColor m_color; // 颜色\n    protected PiecePos m_pos; // 位置\n    public Piece(PieceColor color, PiecePos pos) {\n        m_color = color;\n        m_pos = pos;\n    }\n \t(1) public abstract void draw();\n}\nclass BlackPiece extends Piece {\n    public BlackPiece(PieceColor color, PiecePos pos) {\n        super(color, pos);\n    }\n    public void draw() { System.out.println("draw a blackpiece"); }\n}\nclass WhitePiece extends Piece {\n    public WhitePiece(PieceColor color, PiecePos pos) {\n        super(color, pos);\n    }\n\n    public void draw() {\n        System.out.println("white a blackpiece");\n    }\n}\n\nclass PieceBoard { // 棋盘上已有的棋子\nprivate static final ArrayList<(2) Piece>m_arrayPiece =new ArrayList\n    private String m_blackName; // 黑方名称\n    private String m_whiteName; // 白方名称\n\n    public PieceBoard(String black, String white) {\n        m_blackName = black;\n        m_whiteName = white;\n    }\n\n    // 一步棋，在棋盘上放一颗棋子\n    public void SetPiece(PieceColor color, PiecePos pos) {\n        (3) Piece piece = null;\n        if (color == PieceColor.BLACK) { // 放黑子\n            piece = new BlackPiece(color, pos); // 获取一颗黑子\n            System.out.println(m_blackName + "在位置(" + pos.getX() + ","\n                    + pos.getY() + ")");\n            (4) piece.draw();\n        } else { // 放白子\n            piece = new WhitePiece(color, pos); // 获取一颗白子\n            System.out.println(m_whiteName + "在位置(" + pos.getX() + ","\n                    + pos.getY() + ")");\n            (5) piece.draw();\n        }\n        m_arrayPiece.add(piece);\n    }\n}\n\n\n----------------------------------------\n\n参考答案：\n\n(1) public abstract void draw();\n(2) Piece\n(3) Piece piece = null;\n(4) piece.draw();\n(5) piece.draw();\n\n\n\n# 9.【2022年试题六】设计模式\n\n本题使用的是备忘录模式（Memento）\n\n在软件系统中，通常都会给用户提供取消、不确定或者错误操作的选择，允许将系统 恢复到原先的状态。现使用备忘录（Memento）模式实现该要求，得到如图 6-1 所示 的类图。Memento 包含了要被恢复的状态。Originator 创建并在 Memento 中存储状 态。Caretaker 负责从 Memento 中恢复状态。\n\n\n\nimport java.util.*;\nclass Memento {\n    private String state;\n    public Memento（String state）{this.state=state;}\n    public String getState（）{return state;}\n}\nclass Originator {\n    private String state;\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    public String getState() {\n        retum state;\n    }\n\n    public Memento saveStateToMemento(){\n        return （1）new Memento(state);\n    }\n\n    public void getStateFromMemento(Memento Memento) {\n        state =（2）Memento.getState();\n\t}\n}\n\nclass CareTaker｛\n    private List<Memento> mementoList = new ArrayList<Memento>();\n    public（3）void add(Memento state)\n    {\n        mementoList.add(state);\n    }\n\n    public （4）careTaker.add(originator.saveState ToMemento())\n\n    {\n        return memensoList.get(index);\n    }\n}\n\nclass MementoPaneDems{\n    public static void main(String[] args) {\n        Originator originator = new Originator();\n        CareTaker careTaker = new careTaker();\n        originator.setState("State #1");\n        originator.setState("State #2");\n        careTaker.add( （5）careTaker.add(originator.saveState ToMemento()));\n        originator.setState("State #3");\n        careTaker.add( （6）careTaker.add(originator.saveState ToMemento()));\n        originator.setState("State #4");\n        System.out.println("Current State" + originator.getState());\n        originator.getStateFromMemento(careTaker.get(0));\n        System.out.println("Frist saved State" + originator.getState());\n        originator.getStateFromMemento(careTaker.get(1));\n        System.out.println("Second saved State" + originator.getState());\n    }\n}\n\n\n----------------------------------------\n\n参考答案：\n\n1. new Memento(state)\n2. Memento.getState()\n3. void add(Memento state)\n4. Memento get(int index)\n5. careTaker.add(originator.saveState ToMemento())\n6. careTaker.add(originator.saveState ToMemento())\n',normalizedContent:'# java设计模式下午题\n\n\n# 1.【2013年试题六】设计模式\n\n欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。以绘制直线和圆形为 例，对应的绘图程序如表 6-1 所示。\n\n\n\n(1) interface drawing{\n   (2) void drawline(double x1,double y1,double x2,double y2);\n   (3) void drawcircle(double x,double y,double r);\n}\n\nclass dp1{\n    static public void draw_a_line(double x1,double y1,double y,double r) { // 代码省略 }\n    static public void draw_a_circle(double x,double y,double r) { // 代码省略 }\n}\n\nclass dp2{\n    static public void drawline(double x1,double y1,double x2,double y2) { // 代码省略 }\n    static public void drawcircle(double x,double y,double r) { // 代码省略 }\n}\n\nclass v1drawing implements drawing{\n    public void drawline(double x1,double y1,double x2,double y2) { // 代码省略 }\n    public void drawcircle(double x, double y, double r) { \n        (4) dp1.draw_a_circle(x,y,r);\n    }\n}\n\nclass v2drawing implements drawing {\n    public void drawline(double x1, double y1, double x2, double y2) { /* 代码省略 */ }\n    public void drawcircle(double x, double y, double r) { \n        (5) dp2.drawcircle(x,y,r);\n    }\n}\n\nabstract class shape {\n    private drawing _dp;\n    (6) abstract public void draw();\n    shape(drawing dp) { _dp = dp; }\n    public void drawline(double x1, double y1, double x2 ,double y2)\n    { _dp.drawline(x1, y1, x2, y2); }\n    public void drawcircle (double x, double y, double r)\n    { _dp.drawcircle(x, y, r); }\n}\n\nclass rectangle extends shape {\n    private double _x1, _x2, _y1, _y2;\n    public rectangle(drawing dp, double x1, double y1, double x2, double y2) { /* 代码省略 */ }\n    public void draw() { /* 代码省略 */ }\n}\n\nclass circle extends shape {\n    private double _x, _y, _r;\n    public circle(drawing dp, double x, double y, double r) { /* 代码省略 */ }\n    public void draw() { drawcircle(_x, _y, _r); }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) interface\n(2) void drawline(double x1,double y1,double x2,double y2);\n(3) void drawcircle(double x,double y,double r);\n(4) dp1.draw_a_circle(x,y,r);\n(5) dp2.drawcircle(x,y,r);\n(6) abstract public void draw();\n\n\n\n# 2.【2014年试题六】设计模式\n\n本题目使用的是命令模式（command）\n\n某灯具厂商欲生产一个灯具遥控器，该遥控器具有 7 个可编程的插槽，每个插槽都有开 关按钮，对应着一个不同的灯。利用该遥控器能够统一控制房间中该厂商所有品牌灯具的开 关，现采用 command（命令）模式实现该遥控器的软件部分。command 模式的类图如图 6-1 所示。\n\n\n\nclass light {\n    public light() {}\n    public light(string name) { /* 代码省略 */ }\n    public void on() { /* 代码省略 */ } // 开灯\n    public void off() { /* 代码省略 */ } // 关灯\n// 其余代码省略\n}\n\n(1) interface command {\n    public void execute();\n}\n\nclass lightoncommand implements command { // 开灯命令\n    light light;\n    public lightoncommand(light light) { this.light = light; }\n    public void execute() { \n        (2) light.on(); \n    }\n}\n\nclass lightoffcommand implements command { // 关灯命令\n    light light;\n    public lightoffcommand(light light) { this.light = light; }\n    public void execute() { \n        (3) light.off();\n    }\n}\n\nclass remotecontrol { // 遥控器\n    command[] oncommands = new command[7];\n    command[] offcommands = new command[7];\n\n    public remotecontrol() { /* 代码省略 */ }\n\n    public void setcommand(int slot, command oncommand, command offcommand) {\n        (4) oncommands[slot] = oncommand;\n        (5) offcommands[slot]= offcommand;\n    }\n\n    public void onbuttonwaspushed(int slot) {\n        (6) oncommands[slot].execute();\n    }\n\n    public void offbuttonwaspushed(int slot) {\n        (7) offcommands[slot].execute();\n    }\n}\n\nclass remoteloader {\n    public static void main(string[] args) {\n        remotecontrol remotecontrol = new remotecontrol();\n        light livingroomlight = new light("living room");\n        light kitchenlight = new light("kitchen");\n        lightoncommand livingroomlighton = new lightoncommand(livingroomlight);\n        lightoffcommand livingroomlightoff = new lightoffcommand(livingroomlight);\n        lightoncommand kitchenlighton = new lightoncommand(kitchenlight);\n        lightoffcommand kitchenlightoff = new lightoffcommand(kitchenlight);\n        remotecontrol.setcommand(0, livingroomlighton, livingroomlightoff);\n        remotecontrol.setcommand(1, kitchenlighton, kitchenlightoff);\n        remotecontrol.onbuttonwaspushed(0);\n        remotecontrol.offbuttonwaspushed(0);\n        remotecontrol.onbuttonwaspushed(1);\n        remotecontrol.offbuttonwaspushed(1);\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) interface command\n(2) light.on(); \n(3) light.off();\n(4) oncommands[slot] = oncommand;\n(5) offcommands[slot]= offcommand;\n(6) oncommands[slot].execute();\n(7) offcommands[slot].execute();\n\n\n\n# 3.【2015年试题六】设计模式\n\n某大型购物中心欲开发一套收银软件，要求其能够支持购物中心在不同时期推出的各种 促销活动，如打折、返利（例如，满 300 返 100）等等。现采用策略（strategy）模式实现 该要求，得到如图 6-1 所示的类图。\n\n\n\nimport java.util.*;\n\nenum type { normal, cash_discount, cash_return};\ninterface cashsuper {\n    public (1) double acceptcash(double money);\n}\n\nclass cashnormal implements cashsuper { // 正常收费子类\n    public double acceptcash(double money) {\n        return money;\n    }\n}\n\nclass cashdiscount implements cashsuper {\n    private double moneydiscount; // 折扣率\n    public cashdiscount(double moneydiscount) {\n        this moneydiscount = moneydiscount;\n    }\n    public double acceptcash(double money) {\n        return money* moneydiscount;\n    }\n}\nclass cashreturn implements cashsuper { // 满额返利\n    private double moneycondition;\n    private double moneyreturn;\n\n    public cashreturn(double moneycondition, double moneyreturn) {\n        this.moneycondition = moneycondition; // 满额数额\n        this.moneyreturn = moneyreturn; // 返利数额\n    }\n\n    public double acceptcash(double money) {\n        double result = money;\n        if (money >= moneycondition)\n            result = money - math.floor(money / moneycondition) * moneyreturn;\n        return result;\n    }\n}\n\nclass cashcontext {\n    private cashsuper cs;\n    private type t;\n\n    public cashcontext(type t) {\n        switch (t) {\n            case normal: // 正常收费\n                (2) cs = new cashnormal;\n                break;\n            case cash_discount: // 打 8 折\n                (3) cs = new cashdiscount;\n                break;\n            case cash_return: // 满 300 返 100\n                (4) cs = new cashreturn;\n                break;\n        }\n    }\n\n    public double getresult(double money) {\n        (5) return cs.acceptcash(money);\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n本题使用策略模式（strategy）\n\n\n\n参考答案：\n\n(1) double acceptcash(double money)\n(2) cs = new cashnormal;\n(3) cs = new cashdiscount;\n(4) cs = new cashreturn;\n(5) return cs.acceptcash(money);\n\n\n\n# 4.【2016年试题六】设计模式\n\n本题使用的是装饰器模式（decorator）\n\n某发票（lnvoice）由抬头（head）部分、正文部分和脚注（foot）部分构成。现采用 装饰（decorator）模式实现打印发票的功能，得到如图 6-1 所示的类图。\n\n\n\nclass invoice {\n    public void printinvoice() {\n        system.out.println("this is the content of the invoice!");\n    }\n}\n\nclass decorator extends invoice {\n    protected invoice ticket;\n    public decorator(invoice t) {\n        ticket = t;\n    }\n    public void printinvoice() {\n        if (ticket != null)\n            (1) ticket.printinvoice();\n    }\n}\nclass headdecorator extends decorator {\n    public headdecorator(invoice t) {\n        super(t);\n    }\n    public void printinvoice () {\n        system.out.println("this is the header of the invoice!");\n        (2) super.printinvoice();\n    }\n}\nclass footdecorator extends decorator {\n    public footdecorator(invoice t) {\n        super(t);\n    }\n\n    public void printinvoice() {\n        (3) super.printinvoice();\n        system.out.println("this is the footnote of the invoice!");\n    }\n}\n\nclass test {\n    public static void main(string[] args) {\n        invoice t = new invoice();\n        invoice ticket;\n        ticket = (4) new headdecorator(new footdecorator(t));\n        ticket.printinvoice();\n        system.out.println("--------------------");\n        ticket = (5) new headdecorator(new footdecorator(null));\n        ticket.printinvoice();\n    }\n}\n\n程序的输出结果为：\n        this is the header of the invoice!\n        this is the content of the invoice!\n        this is the footnote of the invoice!\n        --------------------\n        this is the header of the invoice!\n        this is the footnote of the invoice!\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) ticket.printinvoice();\n(2) super.printinvoice();\n(3) super.printinvoice();\n(4) new headdecorator(new footdecorator(t));\n(5) new headdecorator(new footdecorator(null));\n\n\n\n# 5.【2017年试题六】设计模式\n\n本题使用的模式是桥接模式（bridge）\n\n某图像预览程序要求能够查看 bmp、jpeg 和 gif 三种格式的文件，且能够在 windows 和 linux 两种操作系统上运行。程序需具有较好的扩展性以支持新的文件格式和操作系统。 为满足上述需求并减少所需生成的子类数目，现采用桥接（bridge）模式进行设计，得到如 图 6-1 所示的类图。\n\n\n\nimport java.util.*;\n\nclass matrix { // 各种格式的文件最终都被转化为像素矩阵\n// 此处代码省略\n}\nabstract class implementor {\n    public (1) abstract void dopaint(matrix m); // 显示像素矩阵 m\n}\n\nclass winimp extends implementor {\n    public void dopaint(matrix m) { // 调用 windows 系统的绘制函数绘制像素矩阵\n        // 此处代码省略\n    }\n}\nclass linuximp extends implementor {\n    public void dopaint(matrix m) { // 调用 linux 系统的绘制函数绘制像素矩阵\n        // 此处代码省略\n    }\n}\nabstract class image {\n    public void setimp(implementor imp) { this.imp = imp; }\n    public abstract void parsefile(string filename);\n    protected implementor imp;\n}\nclass bmpimage extends image {\n// 此处代码省略\n}\nclass gifimage extends image {\n    public void parsefile(string filename) {\n// 此处解析 bmp 文件并获得一个像素矩阵对象 m\n        (2) imp.dopaint(m); // 显示像素矩阵 m\n    }\n\n}\n\nclass jpegimage extends image {\n// 此处代码省略\n}\nclass main {\n    public static void main(string[] args) {\n// 在 linux 操作系统上查看 demo.gif 图像文件\n        image image = (3) new gifimage();\n        implementor imageimp = (4) new linuximp();\n        (5) image.setimp(imageimp);\n        image.parsefile("demo.gif");\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1) abstract void dopaint(matrix m);\n(2) imp.dopaint(m); \n(3) new gifimage();\n(4) new linuximp();\n(5) image.setimp(imageimp);\n\n\n\n# 6.【2018年试题六】设计模式\n\n本题使用的是状态模式（state）\n\n某航空公司的会员积分系统将其会员划分为：普卡(basic)、银卡(silver)和金卡(gold) 三个等级。非会员(nonmember)可以申请成为普卡会员。会员的等级根据其一年内累积的 里程数进行调整。描述会员等级调整的状态图如图 6-1 所示。现采用状态(state)模式实现 上述场景，得到如图 6-2 所示的类图。\n\n\n\nimport com.example.day09.cfrequentflyer;\n\nimport java.util.*;\nabstract class cstate {\n    public int flymiles; // 里程数\n    public (1) abstract double travel(int miles,cfrequentflyer context); // 根据累积里程数调整会员等级\n}\nclass cnocustomer extends cstate { // 非会员\n    public double travel(int miles, cfrequentflyer context) {\n        system.out.println("your travel will not account for points");\n        return miles; // 不累积里程数\n    }\n}\nclass cbasic extends cstate { // 普卡会员\n    public double travel(int miles, cfrequentflyer context) {\n        if (context.flymiles >= 25000 && context.flymiles < 50000)\n            (2) context.setstate(new csilver());\n        if (context.flymiles >= 50000)\n            (3) context.setstate(new cgold());\n        return miles;\n    }\n}\n\nclass cgold extends cstate { // 金卡会员\n    public double travel(int miles, cfrequentflyer context) {\n        if (context.flymiles >= 25000 && context.flymiles < 50000)\n            (4) context.setstate(new csilver()); \n        if (context.flymiles < 25000);\n            (5) context.setstate(new cgold()); \n            return miles + 0.5 * miles; // 累积里程数\n    }\n}\nclass csilver extends cstate { // 银卡会员\n    public double travel(int miles, cfrequentflyer context) {\n        if (context.flymiles <= 25000)\n            context.setstate(new cbasic());\n        if (context.flymiles >= 50000)\n            context.setstate(new cgold());\n        return (miles + 0.25 * miles); // 累积里程数\n    }\n}\n\nclass cfrequentflyer {\n    cstate state;\n    double flymiles;\n\n    public cfrequentflyer() {\n        state = new cnocustomer();\n        flymiles = 0;\n        setstate(state);\n    }\n\n    public void setstate(cstate state) {\n        this.state = state;\n    }\n\n    public void travel(int miles) {\n        double bonusmiles = state.travel(miles, this);\n        flymiles = flymiles + bonusmiles;\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n\n\n参考答案：\n\n(1) abstract double travel(int miles,cfrequentflyer context);\n(2) context.setstate(new csilver());\n(3) context.setstate(new cgold());\n(4) context.setstate(new csilver()); \n(5) context.setstate(new cgold()); \n\n\n\n# 7.【2019年试题六】设计模式\n\n本题使用的是观察者模式（observer）\n\n某文件管理系统中定义了类 officedoc 和 docexplorer。当类 officedoc 发生变化时， 类 docexplorer 的所有对象都要更新其自身的状态。现采用观察者（observer）设计模式来 实现该需求，所设计的类图如图 6-1 所示。\n\n\n\nimport java.util.*;\n\ninterface observer {\n    public (1)void update();\n}\ninterface subject {\n    public void attach(observer obs);\n\n    public void detach(observer obs);\n\n    public void notify();\n\n    public void setstatus(int status);\n\n    public int getstatus();\n}\n\nclass officedoc implements subject {\nprivate list<(2) observer>myobs;\n    private string mysubjectname;\n    private int m_status;\n\n    public officedoc(string name) {\n        mysubjectname = name;\n        this.myobs = new arraylist<observer>();\n        m_status = 0;\n    }\n\n    public void attach(observer obs) {\n        this.myobs.add(obs);\n    }\n\n    public void detach(observer obs) {\n        this.myobs.remove(obs);\n    }\n\n    public void notify() {\n        for (observer obs : this.myobs) {\n            (3) obs.update();\n        }\n    }\n\n    public void setstatus(int status) {\n        m_status = status;\n        system.out.println("setstatus subject[" + mysubjectname +\n                "]status:" + status);\n    }\n\n    public int getstatus() {\n        return m_status;\n    }\n}\n\nclass docexplorer implements observer {\n    private string myobsname;\n    public docexplorer(string name, (4) subject sub) {\n        myobsname = name;\n        sub. (5) attach(this);\n    }\n    public void update() {\n        system.out.println("update observer[" + myobsname + "]");\n    }\n}\nclass observertest {\n    public static void main(string[] args) {\n        subject subjecta = new officedoc("subject a");\n        observer observera = new docexplorer("observer a", subjecta);\n        subjecta.setstatus(1);\n        subjecta.notify();\n    }\n}\n\n\n----------------------------------------\n\n解题思路：\n\n\n\n参考答案：\n\n(1)void update();\n(2) observer\n(3) obs.update();\n(4) subject\n(5) attach(this);\n\n\n\n# 8.【2021年试题六】设计模式\n\n本题是使用享元（flyweight）模式\n\n享元（flyweight）模式主要用于减少创建对象的数量，以降低内存占用，提高性能。 先要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空 间，采用享元模式实现该程序，得到如图 6-1 所示的类图。\n\n\n\nimport java.util.*;\nenum piececolor { black, white } // 棋子颜色\nclass piecepos { // 棋子位置\n    private int x;\n    private int y;\n\n    public piecepos(int a, int b) {\n        x = a;\n        y = b;\n    }\n\n    public int getx() {\n        return x;\n    }\n\n    public int gety() {\n        return y;\n    }\n\n}\n\nabstract class piece { // 棋子定义\n    protected piececolor m_color; // 颜色\n    protected piecepos m_pos; // 位置\n    public piece(piececolor color, piecepos pos) {\n        m_color = color;\n        m_pos = pos;\n    }\n \t(1) public abstract void draw();\n}\nclass blackpiece extends piece {\n    public blackpiece(piececolor color, piecepos pos) {\n        super(color, pos);\n    }\n    public void draw() { system.out.println("draw a blackpiece"); }\n}\nclass whitepiece extends piece {\n    public whitepiece(piececolor color, piecepos pos) {\n        super(color, pos);\n    }\n\n    public void draw() {\n        system.out.println("white a blackpiece");\n    }\n}\n\nclass pieceboard { // 棋盘上已有的棋子\nprivate static final arraylist<(2) piece>m_arraypiece =new arraylist\n    private string m_blackname; // 黑方名称\n    private string m_whitename; // 白方名称\n\n    public pieceboard(string black, string white) {\n        m_blackname = black;\n        m_whitename = white;\n    }\n\n    // 一步棋，在棋盘上放一颗棋子\n    public void setpiece(piececolor color, piecepos pos) {\n        (3) piece piece = null;\n        if (color == piececolor.black) { // 放黑子\n            piece = new blackpiece(color, pos); // 获取一颗黑子\n            system.out.println(m_blackname + "在位置(" + pos.getx() + ","\n                    + pos.gety() + ")");\n            (4) piece.draw();\n        } else { // 放白子\n            piece = new whitepiece(color, pos); // 获取一颗白子\n            system.out.println(m_whitename + "在位置(" + pos.getx() + ","\n                    + pos.gety() + ")");\n            (5) piece.draw();\n        }\n        m_arraypiece.add(piece);\n    }\n}\n\n\n----------------------------------------\n\n参考答案：\n\n(1) public abstract void draw();\n(2) piece\n(3) piece piece = null;\n(4) piece.draw();\n(5) piece.draw();\n\n\n\n# 9.【2022年试题六】设计模式\n\n本题使用的是备忘录模式（memento）\n\n在软件系统中，通常都会给用户提供取消、不确定或者错误操作的选择，允许将系统 恢复到原先的状态。现使用备忘录（memento）模式实现该要求，得到如图 6-1 所示 的类图。memento 包含了要被恢复的状态。originator 创建并在 memento 中存储状 态。caretaker 负责从 memento 中恢复状态。\n\n\n\nimport java.util.*;\nclass memento {\n    private string state;\n    public memento（string state）{this.state=state;}\n    public string getstate（）{return state;}\n}\nclass originator {\n    private string state;\n    public void setstate(string state) {\n        this.state = state;\n    }\n\n    public string getstate() {\n        retum state;\n    }\n\n    public memento savestatetomemento(){\n        return （1）new memento(state);\n    }\n\n    public void getstatefrommemento(memento memento) {\n        state =（2）memento.getstate();\n\t}\n}\n\nclass caretaker｛\n    private list<memento> mementolist = new arraylist<memento>();\n    public（3）void add(memento state)\n    {\n        mementolist.add(state);\n    }\n\n    public （4）caretaker.add(originator.savestate tomemento())\n\n    {\n        return memensolist.get(index);\n    }\n}\n\nclass mementopanedems{\n    public static void main(string[] args) {\n        originator originator = new originator();\n        caretaker caretaker = new caretaker();\n        originator.setstate("state #1");\n        originator.setstate("state #2");\n        caretaker.add( （5）caretaker.add(originator.savestate tomemento()));\n        originator.setstate("state #3");\n        caretaker.add( （6）caretaker.add(originator.savestate tomemento()));\n        originator.setstate("state #4");\n        system.out.println("current state" + originator.getstate());\n        originator.getstatefrommemento(caretaker.get(0));\n        system.out.println("frist saved state" + originator.getstate());\n        originator.getstatefrommemento(caretaker.get(1));\n        system.out.println("second saved state" + originator.getstate());\n    }\n}\n\n\n----------------------------------------\n\n参考答案：\n\n1. new memento(state)\n2. memento.getstate()\n3. void add(memento state)\n4. memento get(int index)\n5. caretaker.add(originator.savestate tomemento())\n6. caretaker.add(originator.savestate tomemento())\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据流图答题技巧",frontmatter:{title:"数据流图答题技巧",date:"2022-12-19T21:06:24.000Z",permalink:"/pages/70e421/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/01.%E6%8C%87%E5%8D%97/11.%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/02.%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7.html",relativePath:"01.指南/11.数据流图/02.数据流图答题技巧.md",key:"v-c40dde22",path:"/pages/70e421/",headers:[{level:2,title:"数据流图答题技巧",slug:"数据流图答题技巧",normalizedTitle:"数据流图答题技巧",charIndex:2},{level:2,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:17},{level:2,title:"答案",slug:"答案",normalizedTitle:"答案",charIndex:739},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:8},{level:3,title:"1.填空技巧",slug:"_1-填空技巧",normalizedTitle:"1.填空技巧",charIndex:961},{level:3,title:"2.加工技巧",slug:"_2-加工技巧",normalizedTitle:"2.加工技巧",charIndex:1445},{level:3,title:"3.数据流平衡技巧",slug:"_3-数据流平衡技巧",normalizedTitle:"3.数据流平衡技巧",charIndex:1543}],headersStr:"数据流图答题技巧 题目 答案 技巧 1.填空技巧 2.加工技巧 3.数据流平衡技巧",content:"# 数据流图答题技巧\n\n\n\n\n# 题目\n\n试题一（共 15 分）\n\n阅读下列说明和数据流图，回答问题 1 至问题 4，将解答填入答题纸的对应栏内。\n\n【说明】\n\n某现代农业种植基地为进一步提升农作物种植过程的智能化，欲开发智慧农业平台，集 管理和销售于一体，该平台的主要功能有:\n\n（1）信息维护。农业专家对农作物、环境等监测数据的监控处理规则进行维护。\n\n（2）数据采集。获取传感器上传的农作物长势、土壤墒情、气候等连续监测数据，解 析后将监测信息进行数据处理、可视化和存储等操作。\n\n（3）数据处理。对实时监测信息根据监控处理规则进行监测分析，将分析结果进行可 视化并进行存储、远程控制，对历史监测信息进行综合统计和预测，将预测信息进行可视化 和存储。\n\n（4）远程控制。根据监控处理规则对分析结果进行判定，依据判定结果自动对控制器 进行远程控制。平台也可以根据农业人员提供的控制信息对控制器进行远程控制。\n\n（5）可视化。实时向农业人员展示监测信息：实时给农业专家展示统计分析结果和预 测信息或根据农业专家请求进行展示。 现采用结构化方法对智慧农业平台进行分析与设计，获得如图 1-1 所示的上下文数据 流图和图 1-2 所示的 0 层数据流图。\n\n\n\n\n\n【问题 1】（4 分）\n\n使用说明中的词语，给出图 1-1 中的实体 E1〜E4 的名称。\n\n【问题 2】（4 分）\n\n使用说明中的词语，给出图 1-2 中的数据存储 D1〜D4 的名称。\n\n【问题 3】（4 分）\n\n根据说明和图中术语，补充图 1-2 中缺失的数据流及其起点和终点。\n\n【问题 4】（3 分）\n\n根据说明，“数据处理”可以分解为哪些子加工？进一步进行分解时，需要注意哪三种 常见的错误？\n\n\n# 答案\n\n问题1（4分）\n\nE1:传感器;\nE2:农业专家;\nE3:农业人员;\nE4:控制器\n\n\n问题2 （4分）\n\nD1:监控处理规则文件 \nD2:监测信息表 \nD3:分析结果文件 \nD4:预测信息表\n\n\n问题3 （4分）\n\n起点D1，终点P4，规则起点E2，终点P5，请求\n起点D3,终点P5，分析结果\n起点D4，终点P5，预测信息\n\n\n问题4 （3分）\n\n数据处理加工分为数据分析，可视化与存储;\n黑洞、奇迹、灰洞\n\n\n\n# 技巧\n\n\n# 1.填空技巧\n\n补充实体实体可能是：\n\n * 人物角色：如客户、管理员、主管、经理、老师、学生组织机构：如银行、供应商、募捐机构\n * 组织机构：如银行、供应商、 募捐机构\n * 外部系统：如银行系统、工资系统、后台数据库（当要开发的是中间件时）\n\n> 补充： 主要找一些题目描述中的名称\n\n 1. 补充存储 特征：文件、表、库、清单、 档案\n 2. 补充加工名 加工是用于处理数据流的，所以要补充加工名，可以把该加工涉及到的数据流，在说明中标识出来，再在数据流名称所在的句子中，找动词+名词的结构，分析是否可作为加工。 如：生成报告，发出通知，批改作业，记录分数，当然这只是普遍情况，也有例外，如物流跟踪、用户管理。\n 3. 补充数据流 数据平衡原则： 顶层图与 0 层图对比，是否有顶层图有，但 0 层图无的数据流，或反之。检查图中每个加工，是否存在只有入没有出，或只有出没有入，或根据输入的数据无法产生对应的输出的情况。 按题目说明与图进行匹配： 说明中的每一句话，都能与图中有对应关系，当把说明中的实体与数据流标识出来之后，容易缩小对应范围，找出纰漏\n\n\n# 2.加工技巧\n\n数据流图常见的 3 种错误：\n\n * 加工只有输入没有输出，称之为“黑洞”；\n * 加工只有输出没有输入，称之为“奇迹”；\n * 加工中输入不足以产生输出，称之为“灰洞”\n\n\n# 3.数据流平衡技巧\n\n父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（输出）数据流对应子图中的几个输入（输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的数据流！\n\n * 父图与子图之间的平衡原则\n * 子图内平衡原则",normalizedContent:"# 数据流图答题技巧\n\n\n\n\n# 题目\n\n试题一（共 15 分）\n\n阅读下列说明和数据流图，回答问题 1 至问题 4，将解答填入答题纸的对应栏内。\n\n【说明】\n\n某现代农业种植基地为进一步提升农作物种植过程的智能化，欲开发智慧农业平台，集 管理和销售于一体，该平台的主要功能有:\n\n（1）信息维护。农业专家对农作物、环境等监测数据的监控处理规则进行维护。\n\n（2）数据采集。获取传感器上传的农作物长势、土壤墒情、气候等连续监测数据，解 析后将监测信息进行数据处理、可视化和存储等操作。\n\n（3）数据处理。对实时监测信息根据监控处理规则进行监测分析，将分析结果进行可 视化并进行存储、远程控制，对历史监测信息进行综合统计和预测，将预测信息进行可视化 和存储。\n\n（4）远程控制。根据监控处理规则对分析结果进行判定，依据判定结果自动对控制器 进行远程控制。平台也可以根据农业人员提供的控制信息对控制器进行远程控制。\n\n（5）可视化。实时向农业人员展示监测信息：实时给农业专家展示统计分析结果和预 测信息或根据农业专家请求进行展示。 现采用结构化方法对智慧农业平台进行分析与设计，获得如图 1-1 所示的上下文数据 流图和图 1-2 所示的 0 层数据流图。\n\n\n\n\n\n【问题 1】（4 分）\n\n使用说明中的词语，给出图 1-1 中的实体 e1〜e4 的名称。\n\n【问题 2】（4 分）\n\n使用说明中的词语，给出图 1-2 中的数据存储 d1〜d4 的名称。\n\n【问题 3】（4 分）\n\n根据说明和图中术语，补充图 1-2 中缺失的数据流及其起点和终点。\n\n【问题 4】（3 分）\n\n根据说明，“数据处理”可以分解为哪些子加工？进一步进行分解时，需要注意哪三种 常见的错误？\n\n\n# 答案\n\n问题1（4分）\n\ne1:传感器;\ne2:农业专家;\ne3:农业人员;\ne4:控制器\n\n\n问题2 （4分）\n\nd1:监控处理规则文件 \nd2:监测信息表 \nd3:分析结果文件 \nd4:预测信息表\n\n\n问题3 （4分）\n\n起点d1，终点p4，规则起点e2，终点p5，请求\n起点d3,终点p5，分析结果\n起点d4，终点p5，预测信息\n\n\n问题4 （3分）\n\n数据处理加工分为数据分析，可视化与存储;\n黑洞、奇迹、灰洞\n\n\n\n# 技巧\n\n\n# 1.填空技巧\n\n补充实体实体可能是：\n\n * 人物角色：如客户、管理员、主管、经理、老师、学生组织机构：如银行、供应商、募捐机构\n * 组织机构：如银行、供应商、 募捐机构\n * 外部系统：如银行系统、工资系统、后台数据库（当要开发的是中间件时）\n\n> 补充： 主要找一些题目描述中的名称\n\n 1. 补充存储 特征：文件、表、库、清单、 档案\n 2. 补充加工名 加工是用于处理数据流的，所以要补充加工名，可以把该加工涉及到的数据流，在说明中标识出来，再在数据流名称所在的句子中，找动词+名词的结构，分析是否可作为加工。 如：生成报告，发出通知，批改作业，记录分数，当然这只是普遍情况，也有例外，如物流跟踪、用户管理。\n 3. 补充数据流 数据平衡原则： 顶层图与 0 层图对比，是否有顶层图有，但 0 层图无的数据流，或反之。检查图中每个加工，是否存在只有入没有出，或只有出没有入，或根据输入的数据无法产生对应的输出的情况。 按题目说明与图进行匹配： 说明中的每一句话，都能与图中有对应关系，当把说明中的实体与数据流标识出来之后，容易缩小对应范围，找出纰漏\n\n\n# 2.加工技巧\n\n数据流图常见的 3 种错误：\n\n * 加工只有输入没有输出，称之为“黑洞”；\n * 加工只有输出没有输入，称之为“奇迹”；\n * 加工中输入不足以产生输出，称之为“灰洞”\n\n\n# 3.数据流平衡技巧\n\n父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（输出）数据流对应子图中的几个输入（输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的数据流！\n\n * 父图与子图之间的平衡原则\n * 子图内平衡原则",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"计算机结构思维导图",frontmatter:{title:"计算机结构思维导图",date:"2022-12-17T23:26:41.000Z",permalink:"/pages/fb6ad7/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/01.计算机结构思维导图.md",key:"v-3bf4c9cb",path:"/pages/fb6ad7/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"思维导图学习导航",frontmatter:{title:"思维导图学习导航",date:"2022-12-17T23:33:04.000Z",permalink:"/pages/64d804/"},regularPath:"/02.%E9%85%8D%E7%BD%AE/01.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/01.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html",relativePath:"02.配置/01.思维导图/01.思维导图学习导航.md",key:"v-359c0910",path:"/pages/64d804/",headers:[{level:2,title:"思维导图的学习方法",slug:"思维导图的学习方法",normalizedTitle:"思维导图的学习方法",charIndex:2},{level:3,title:"思维导图软件推荐",slug:"思维导图软件推荐",normalizedTitle:"思维导图软件推荐",charIndex:241}],headersStr:"思维导图的学习方法 思维导图软件推荐",content:"# 思维导图的学习方法\n\n阅读是一种长时间的成长奠基，或许阅读过相关的书籍，相似的导图，那么在你的大脑里已有了相关内容，将这本书的框架归类进自己的知识系统中，经过长时间的积累，会发现知识不再单纯从一本书中获得，而是读过相关类型的知识再次整合，思想碰撞进行了一次梳理，在这个过程里，整体的逻辑梳理后，这本书的价值就更好的提升自己。\n\n整个过程看起来似乎有些麻烦，只是一种不习惯，消化一本书，尝试的用思维导图实践，相信你会喜欢上这种做读书笔记的方式，这就是思维导图的魅力所在！\n\n\n# 思维导图软件推荐\n\n * XMind官方网站: https://xmind.cn/\n * ProcessOn官方网站: https://www.processon.com/\n * GitMind官方网站: https://gitmind.cn/\n * 幕布官方网站: https://mubu.com/",normalizedContent:"# 思维导图的学习方法\n\n阅读是一种长时间的成长奠基，或许阅读过相关的书籍，相似的导图，那么在你的大脑里已有了相关内容，将这本书的框架归类进自己的知识系统中，经过长时间的积累，会发现知识不再单纯从一本书中获得，而是读过相关类型的知识再次整合，思想碰撞进行了一次梳理，在这个过程里，整体的逻辑梳理后，这本书的价值就更好的提升自己。\n\n整个过程看起来似乎有些麻烦，只是一种不习惯，消化一本书，尝试的用思维导图实践，相信你会喜欢上这种做读书笔记的方式，这就是思维导图的魅力所在！\n\n\n# 思维导图软件推荐\n\n * xmind官方网站: https://xmind.cn/\n * processon官方网站: https://www.processon.com/\n * gitmind官方网站: https://gitmind.cn/\n * 幕布官方网站: https://mubu.com/",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"程序设计语言思维导图",frontmatter:{title:"程序设计语言思维导图",date:"2022-12-17T23:26:47.000Z",permalink:"/pages/ac51c5/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/02.%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/02.程序设计语言思维导图.md",key:"v-f34049fe",path:"/pages/ac51c5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"面向对象思维导图",frontmatter:{title:"面向对象思维导图",date:"2022-12-18T16:36:18.000Z",permalink:"/pages/0c2de5/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/04.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/04.面向对象思维导图.md",key:"v-41672a42",path:"/pages/0c2de5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"知识产权思维导图",frontmatter:{title:"知识产权思维导图",date:"2022-12-17T23:26:54.000Z",permalink:"/pages/57d5f6/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/03.%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/03.知识产权思维导图.md",key:"v-7bd90c00",path:"/pages/57d5f6/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"数据结构思维导图",frontmatter:{title:"数据结构思维导图",date:"2022-12-18T17:02:47.000Z",permalink:"/pages/47a2c3/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/06.数据结构思维导图.md",key:"v-5bf6b476",path:"/pages/47a2c3/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"排序算法思维导图",frontmatter:{title:"排序算法思维导图",date:"2022-12-18T17:17:02.000Z",permalink:"/pages/99cb22/",categories:["软件设计师"],tags:["软件设计师"]},regularPath:"/02.%E9%85%8D%E7%BD%AE/02.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%8D%E4%B9%A0/07.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"02.配置/02.思维导图复习/07.排序算法思维导图.md",key:"v-0fa0e03a",path:"/pages/99cb22/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"软件设计师复习大纲",frontmatter:{title:"软件设计师复习大纲",date:"2022-09-06T03:29:32.000Z",categories:["软件设计师","计算机系统与网络"],tags:["软件设计师"],permalink:"/pages/0751c5/"},regularPath:"/02.%E9%85%8D%E7%BD%AE/03.%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/01.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2.html",relativePath:"02.配置/03.复习笔记/01.软件设计师复习大纲.md",key:"v-0a2e96d0",path:"/pages/0751c5/",headers:[{level:2,title:"一、计算机系统基础知识",slug:"一、计算机系统基础知识",normalizedTitle:"一、计算机系统基础知识",charIndex:16},{level:2,title:"二、操作系统知识",slug:"二、操作系统知识",normalizedTitle:"二、操作系统知识",charIndex:1406},{level:2,title:"三、网络基础知识",slug:"三、网络基础知识",normalizedTitle:"三、网络基础知识",charIndex:3088},{level:2,title:"四、数据库技术基础",slug:"四、数据库技术基础",normalizedTitle:"四、数据库技术基础",charIndex:5488},{level:2,title:"五、程序语言基础知识",slug:"五、程序语言基础知识",normalizedTitle:"五、程序语言基础知识",charIndex:7340},{level:2,title:"六、系统开发和运行知识",slug:"六、系统开发和运行知识",normalizedTitle:"六、系统开发和运行知识",charIndex:7772},{level:2,title:"七、标准化和软件知识产权基础",slug:"七、标准化和软件知识产权基础",normalizedTitle:"七、标准化和软件知识产权基础",charIndex:11377},{level:2,title:"八、软件系统分析与设计",slug:"八、软件系统分析与设计",normalizedTitle:"八、软件系统分析与设计",charIndex:12363},{level:2,title:"九、多媒体基础知识",slug:"九、多媒体基础知识",normalizedTitle:"九、多媒体基础知识",charIndex:13057}],headersStr:"一、计算机系统基础知识 二、操作系统知识 三、网络基础知识 四、数据库技术基础 五、程序语言基础知识 六、系统开发和运行知识 七、标准化和软件知识产权基础 八、软件系统分析与设计 九、多媒体基础知识",content:"# 软件设计师复习大纲\n\n\n# 一、计算机系统基础知识\n\n1.CPU的功能： 程序控制、操作控制、时间控制、数据处理。\n\n2.计算机系统组成示意图：\n\n\n\n3.数据表示： 原码、反码、补码、移码。（0为正，1为负）\n\n4.移码： 如果机器字长为 N，偏移量为 2^N-1，则[X]移=2^N-1+[X]补(X 为纯整数)。[X]移=1+X（X 为纯小数）。\n\n5.IEEE754： 符号位（1 位,0 正 1 负）+阶码（8 位,+127）+尾数（23 位,小数点在最高位之 后，随后省略最高位）。\n\n6.浮点数加减： 0 操作数检查，对阶操作(小阶变大阶)，尾数加减(阶码用双符号位，尾数用 单符号位)，结果规格化，舍入处理(判定溢出)。\n\n7.常用校验码： 奇偶校验码（只能检错）、海明码（纠错加检错）、循环冗余校验码（CRC）。\n\n8.计算机体系结构分类： 单处理系统，并行处理与多处理系统，分布式处理系统。\n\n9.指令集的发展:CISC（复杂指令集计算机）： 增强原有指令的功能，用更为复杂的新指令取 而代之；RISC（精简指令集计算机）：减少指令总数简化指令功能，优化编译降低复杂度。\n\n10.指令控制方式： 顺序方式，重叠方式，流水方式。\n\n11.RISC 中的流水线技术： 超流水线技术，超标量技术，超长指令字技术。\n\n12.并发性的解决： 阵列处理机，并行处理机，多处理机。\n\n13.主存与 cache 地址映射方式： 全相联映射-将主存一个块的地址与内容一起存入 cache 中，拷贝灵活但是比较器电路难设计实现；直接映射-一个主存块只能拷贝到 cache 的特定行上 去，硬件简单成本低但是容易冲突效率下降；组相联映射-主存块放到哪个组是固定的，但 是放到哪一行是灵活的，折中办法广泛采用。\n\n14.虚拟存储器： 页式：页表硬件小，查表速度快但不利于存储保护；段式：界限分明便于 程序的模块化设计，易于编译修改和保护，但主存利用率低，产生大量碎片，查表速度慢； 段页式：折中办法，广泛采用，但地址变换速度比较慢。\n\n15.计算机与外设数据交换： 无条件传送，查询方式传送，中断方式传送，直接存储器存取 方式（DMA）：CPU 仅在过程开始和结束时有处理，过程中 DMA 占用系统总线传送数据。\n\n16.多中断处理办法： 多中断信号线法，中断软件查询法，菊花链法，总线仲裁法，中断向 量表法。\n\n17.总线分类： 内部总线：芯片的互连，系统总线：CPU，内存，接口等的连接；外部总线： 数据交换。\n\n18.信息安全 5 要素： 机密性，完整性，可用性，可控性，可审查性。\n\n19.加密技术： 对称加密（私人密钥加密）：数据加密标准（DES）+三重 DES+RC-5+国际数 据加密算法（IDEA）+高级加密标准（AES）；非对称加密（公开密钥加密，比如 RSA 算法）： 加密模型+认证模型。\n\n20.PKI： 一种遵循既定标准的密钥管理平台，能够为所有网络应用提供加密和数字签名等密 码服务及所必需的密钥和证书管理体系，必须具有权威认证机构、数字证书库、密钥备份和 恢复系统、证书作废系统、应用接口。\n\n21.计算机可靠性： 可靠性：串联系统 R=R1*R2，并联系统R=1-（1-R1）（1-R2）；平均无故 障时间：串联系统 K=K1+K2，并联系统K=1/K*(1+1/2)。\n\n\n# 二、操作系统知识\n\n1.操作系统的作用： 通过资源管理提高计算机系统的效率；改善人机界面，向用户提供友好的工作环境。\n\n2.操作系统的特征： 并发性、共享性、虚拟性和不确定性\n\n3.操作系统的功能： 处理机管理、文件管理、存储管理、设备管理、作业管理\n\n4.操作系统的类型： 批处理操作系统（单道、多道）、分时操作系统（UNIX，多路性、独立性、交互性、及时性）、实时操作系统（快速的相应时间、有限的交互能力、高可靠性）、网络操作系统、分布式操作系统、微机操作系统（Windows，Linux）、嵌入式操作系统\n\n5.程序并发执行的特点： 失去了程序的封闭性，程序和机器的执行程序的活动不再一一对应，并发程序间的相互制约性\n\n**6.进程的组成： ** 程序、数据、进程控制块（PCB）\n\n7.进程的状态： 新建、就绪、运行、阻塞、终止\n\n**8.原语（若干条机器指令组成）的特点： ** 执行时不能被分割，要么都做要么都不做\n\n9.进程的同步： 进程间完成一项任务时直接发生相互作用的关系\n\n10 进程的互斥： 系统中各进程互斥使用临界资源\n\n11.信号量的意义： 若 S>=0 表示某资源的可用数；若 S<0 则其绝对值表示阻塞队列中等待该资源的进程数\n\n12.PV 操作（低级通讯方式）： P 操作申请一个资源，V 操作释放一个资源\n\n13.高级通讯方式： 共享存储模式，消息传递模式，管道通信\n\n14.管城： 由一些共享数据、一组能为并发进程所执行的作用在共享数据上的操作的集合、初始代码以及存取权组成，一种同步机制\n\n15.进程调度（可剥夺+不可剥夺）算法： 先来先服务算法：主要用于宏观调度；时间片轮转：微观调度，分时间片占用 CPU；优先级调度：根据优先级（静态+动态）；多级反馈调度：分多个优先级队列前三中调度的综合，先执行新进程。\n\n16.产生死锁的原因： 竞争资源及进程推进顺序算法\n\n17.产生死锁的四个必要条件： 互斥条件，请求保持条件，不可剥夺条件，环路条件\n\n18.死锁的处理： 预防；避免（银行家算法：先计算，如果分配资源后系统进入不安全状态则不予分配）；检测（系统定时运行死锁检测程序）；解除（资源剥夺法+撤销进程法）\n\n19.安全状态： 系统能按某种顺序来为每个进程分配其所需资源，使每个进程都能顺序完成\n\n20.线程： 是进程中的一个实体，是被系统独立分配和调度的基本单位，基本上不拥有资源\n\n21.存储器管理： 分配和回收主存空间、提高主存利用率、扩充主存、有效保护主存信息\n\n22.存储器的的层次结构： 寄存器、快速缓存（cache）、主存、外存\n\n23.地址重定位： 将逻辑地址转变成物理地址的过程，分静态和动态（程序运行时完成转换）\n\n24.虚拟存储页面置换算法： 最佳置换（以后最久不会被使用），先进先出置换，最近最少未使用，最近未用\n\n25.设备管理的目标： 提高设备的利用率，为用户提供方便统一的界面\n\n26.磁盘调度（使平均寻道时间最少）算法： 先来先服务，最短寻道时间优先，扫描算法，单向扫描调度\n\n27.文件： 具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合\n\n28.文件系统： 操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构\n\n29.存储管理方案示意图\n\n\n\n30.文件系统的安全： 一类涉及到技术、管理、法律、道德和政治等问题；另一类涉及操作系统的安全机制\n\n31.文件系统的可靠性： 转储和恢复，日志文件，文件系统的一致性\n\n32.作业： 系统为完成一个用户的计算任务（或一次事物处理）所做的工作总和\n\n33.作业状态： 提交，后备，执行，完成\n\n34.作业调度算法： 先来先服务，短作业优先，响应比高优先，优先级调度，均衡调度\n\n35.网络操作系统： 集中模式，客户端/服务器模式，对等模式\n\n36.嵌入式操作系统： 微型化，可定制，实时性，可靠性，易移植性\n\n37.shell 变量： 用户定义变量，系统定义变量，shell 定义变量\n\n\n# 三、网络基础知识\n\n1.计算机网络（计算机技术+通信技术）的发展： 具有通信功能的单机系统->具有通信功能的多机系统->以共享资源为目的的计算机网络->以局域网及因特网为支撑环境的分布式计算机系统\n\n2.计算机网络的功能： 数据通信，资源共享，负载均衡，高可靠性\n\n3.计算机网络的分类： 局域网（LAN：10m~1000m），城域网（MAN：10km），广域网（WAN：100km 以上）\n\n4.网络拓扑结构： 总线型，星型，环型，树型，分布式（无严格的布线规定和形状，各节点有多条线路相连）\n\n5.OSI 七层参考模型： 物理层（物理地传送比特流），数据链路层（负责两相邻节点间无差错传送以帧为单位的数据），网络层（提供端到端的交换网络数据传送功能），传输层（提供可靠的数据传输服务），会话层（提供会话管理服务），表示层（提供格式化的表示和转换数据服务），应用层（提供网络与用户应用软件之间的接口服务）\n\n6.网络互连设备： 中继器（物理层上实现局域网网段互连，用于扩展局域网网段长度），集线器（特殊的多路中继器，有信号方法功能并便于网络维护）；网桥（工作与数据链路层，用于连接两个局域网网段），交换机（按每一个包中的 MAC 地址相对简单地决策信息转发）；路由器（网络层异构互连，连接多个逻辑上分开的网络），网关（在两个不同类型协议的网络系统之间进行通信）\n\n7.网络传输介质： 有线介质（双绞线，同轴电缆：直接传输数字信号，光纤：传输光信号、需信号转换）；无线介质（微波：利用无线电波传输，红外线：传输红外光信号，激光：传激光信号，卫星通信：传输电磁波信号）\n\n8.局域网组成部件： 服务器（文件服务器、打印服务器、通信服务器），客户端（用户与网络应用接口设备），网络设备（网卡，收发器，中继器，集中器，网桥，路由器等），通信介质（数据的传输媒体），网络软件（底层协议软件、网络操作系统等）\n\n9.协议： 规定通信时的数据格式、数据传送时序以及相应的控制信息和应答信号等内容\n\n10.网络的标准： 电信标准，国际标准（IEEE 标准等），Internet 标准（自发标准非政府干预）\n\n11.决定局域网特性的主要技术： 用以传输数据的传输介质，用以连接各种设备的拓扑结构，用以共享资源的介质访问控制方法\n\n12.局域网协议： LAN 模型（物理层，数据链路层：逻辑链路控制子层、介质访问控制）；以太网（CSMA/CD 技术：边发送边接收、时刻侦听信道）；令牌环网（适用于环型网络结构的分布式介质访问控制：广播发送令牌、目标站进行处理）；FDDI（类似令牌环网协议、光纤作为传输介质）\n\n13.广域网协议： 点对点协议（PPP：主要用于拨号上网，建立点对点连接发送数据），数字用户线（xDSL：不对称数字用户线 ADSL，甚高速数字用户线 VDSL），数字专线（电信数字数据网固定专线，电信铺设），帧中继（在用户网络接口之间提供用户信息流的双向传送，并保持顺序不变），异步传输模式（ATM：面向分组的快速分组交换模式，使用异步时分复用技术），X.25 协议（在本地数据终端设备和远程数据终端设备之间提供一个全双工、同步的透明信道）\n\n14.TCP/IP 协议簇特性： 逻辑编址，路由选择，域名解析，错误检测和流量控制\n\n15.TCP/IP 模型\n\n\n\n16.Internet 地址格式： 域名格式，IP 地址格式\n\n17.解决 IP 地址短缺问题： 长期（使用 Ipv6），短期（使用网络地址翻译技术 NAT：在子网内部使用局部地址，外部使用少量的全局地址，通过路由器进行内部地址和外部地址的转换）\n\n18.Ipv6： 40 个字节的首部长度，16 个字节的 IP 地址长度\n\n19.服务端口： 公共端口（0~1023）注册登记端口（1024~65535）\n\n20.Internet 高层协议： 域名服务（UDP 端口，53，通过 DNS 服务器将域名变换为 IP 地址）；远程登录服务（TCP 端口，23，将用户计算机与远程主机连接起来）；电子邮件服务（TCP端口，25：SMTP and 110：POP3，发送：SMTP，接收：SMTP+POP3）；WWW 服务（TCP端口，80，基于客户端/服务器模式的信息发送技术和超文本技术的综合）；文件传输服务（TCP 端口，20：数据连接 and 21：控制连接）\n\n21.网络安全的威胁： 计算机存储着国家、机构、组织的秘密信息或个人的隐私成为某类人攻击的目标；软件规模的膨胀容易使系统存在缺陷；信息传输的安全性存在隐患；网络协议本身的漏洞也会引发安全问题\n\n22.网络安全： 运行系统安全，信息系统的安全，信息传播的安全，信息内容的安全\n\n23.信息系统的需求： 保密性，完整性，可用性，可控性，可核查性\n\n24.网络的安全威胁： 物理威胁，网络攻击，身份鉴别，编程威胁，系统漏洞\n\n25.网络的信息安全： 信息的存储安全（用户的标识与验证，用户存取权限限制，系统安全监控，计算机病毒防治，数据的加密，计算机网络安全）；信息的传输安全（链路加密，节点加密，端到端加密）\n\n26.防火墙： 建立在内外网络边界的过滤封锁机制，防止不良数据包进出被保护的内部网络\n\n27.防火墙的分类： 包过滤型（直接转发报文，对用户透明），应用代理网关型（通过服务器建立连接），状态检测型（建立状态连接表，跟踪检测每一个会话状态）\n\n28.典型防火墙的体系结构： 包过滤路由器（在网络层对进出内部网络所有信息进行分析限 制），双宿主主机（代理服务器软件在双宿主主机上运行，每一个接口连接不同网段），被屏 蔽主机（由过滤路由器和应用网管组成，包过滤+代理服务，内网和外网双重保障），被屏 蔽子网（由两个包过滤路由器和一个应用网关组成，最安全的防火墙系统）\n\n\n# 四、数据库技术基础\n\n1.数据库系统： 数据库，硬件，软件，人员\n\n2.DBMS（数据库管理系统）的功能： 数据定义，数据库操作，数据库运行管理，数据组织、存储和管理，数据库的建立和维护，与其他软件系统的通信功能等\n\n3.DBMS 的特征： 数据结构化且统一管理，有较高的数据独立性，数据控制功能（数据库的安全性保护、数据的完整性、并发控制、故障恢复）\n\n4.DBMS 分类： 关系数据库系统（实体间的联系用关系表示），面向对象的数据库系统（以对象形式对数据建模），对象关系数据库系统（在关系数据模型基础上提供处理新的数据类型操作的能力）\n\n5 数据库系统体系结构： 集中式（数据、数据管理、数据库功能等都集中在一起），分布式（物理上分布+逻辑上分布），C/S 模式（客户端负责数据表示服务、服务器负责数据库服务），并行结构（多个 CPU 物理上连在一起处理）\n\n6.数据库的三级模式： 概念模式（数据库中全部数据的逻辑结构和特征的描述、只涉及型的描述而不涉及具体的值），外模式（用户与数据库系统的接口、用户用到那部分数据的描述），内模式（数据物理结构和存储方式的描述、数据在数据库内部的表示方式）\n\n7.数据库的两级映像： 模式/内模式映像（实现概念模式与内模式的转换），外模式/模式映像（实现外模式与概念模式的转换）\n\n8.数据的独立性： 物理独立性（数据库的内模式改变时数据的逻辑结构不变），逻辑独立性（用户的应用程序与数据库的逻辑结构相互独立）\n\n9.数据模型： 概念数据模型（E-R 模型等），基本数据模型（层次模型：用树型结构表示数据间的联系、网状模型：用网络结构表示数据间的联系、关系模型：用表格结构表示实体间的联系、面向对象模型：对象标识+封装+对象的属性+类和类层次+继承）\n\n10.数据模型三要素： 数据结构，数据操作，数据的约束条件\n\n11.E-R 图： 实体（矩形），联系（菱形），属性（椭圆形）\n\n12.完整性约束： 实体完整性，参照完整性，用户自定义完整性\n\n13.关系代数运算： 并，交，差，笛卡尔积，投影，选择，连接，除\n\n14.SQL 语言的特点： 综合统一，高度非过程化，面向集合的操作方式，两种使用方式（自含式、嵌入式），语言简洁易学易用\n\n15.SQL 语言的组成： 数据定义语言，交互式数据操纵语言，事务控制，嵌入式 SQL 和动态SQL，完整性，权限管理\n\n16.SQL 数据定义： 创建（create），修改（alter），删除（drop）：表（table），视图（view[as select]），索引（index[on]）\n\n17.SQL 数据查询： select...from...where...group by...having...order by...\n\n**18.插入数据： ** insert into...values...\n\n**19.修改数据： ** update...set...=...where...\n\n20.删除数据： delete from...where...\n\n21.授权： grant...on...to...(with grant option)\n\n22.回收权限： revoke...on...from...\n\n23.函数依赖： 反映属性间的联系（X→Y）；完全函数依赖：（学生 ID，所修课程 ID）→成绩；部分函数依赖 ：（学生 ID，所修课程 ID）→学生姓名；平凡函数依赖：X→Y 且 Y 包含于 X；非平凡函数依赖：X→Y 且 Y 不包含于 X；传递函数依赖：X→Y，Y→Z\n\n24.规范化： 1NF： 每个分量都不可再分；2NF：消除非主属性对码的部分函数依赖；3NF：消除非主属性对码的传递函数依赖\n\n25.模式分解标准： 无损连接，保持函数依赖\n\n26.事务的 ACID 性质： 原子性，一致性，隔离性，持久性\n\n27.事务管理： 事务开始（begin transaction），事务提交（commit），事务回滚（rollback）\n\n28.数据库故障： 事务内部故障，系统故障，介质故障，计算机病毒\n\n29.数据备份方法： 静态转储和动态转储，海量转储和增量转储，日志文件\n\n30.数据恢复步骤： 反向扫描文件日志，对事物的更新操作执行逆操作，继续反向扫描和更新，直到事务的开始标志\n\n31.并发控制的技术： 封锁（写锁、读锁）\n\n32.数据不一致性： 丢失修改，不可重复读，读脏数据\n\n\n# 五、程序语言基础知识\n\n1.编程语言之间的翻译形式： 汇编，解释，编译。\n\n2.程序设计语言的定义： 语法，语义，语用。\n\n3.程序语言的分类： 命令式程序设计语言：FORTRAN，PASCAL，C 语言；面向对象的程序设计语言（C++，JAVA，smaltalk）；函数式程序设计语言（LISP）；逻辑型程序设计语言（PROLOG）。\n\n4.程序语言的基本成分： 数据，运算，控制，传输。\n\n5.汇编语言源程序： 指令语句，伪指令语句，宏指令语句。\n\n6.汇编程序： 将汇编语言所编写的源程序翻译成机器指令程序。\n\n7.编译过程： 源程序---词法分析---语法分析---语义分析---中间代码生成---代码优化---目标代码生成---目标代码。（另全过程有符号表管理和出错处理）\n\n8.解释程序： 分析部分：词法分析、语法分析、语义分析->中间代码；解释部分：解释执行中间代码。\n\n9.编译与解释方式的比较： 前者效率高；后者更具有灵活性和可移植性。\n\n\n# 六、系统开发和运行知识\n\n1.软件工程： 指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件工程的问题。其目的是提高软件生产率，提高软件质量，降低软件成本\n\n2.软件生存周期： 可行性分析与项目开发计划、需求分析、概要设计、详细设计、编码、测试、维护\n\n3.软件生存周期模型： 瀑布模型（按顺序阶段性开发），演化模型（先构造一个初始版本再不断改进），螺旋模型（制定计划、风险分析、实施工程、用户评估），喷泉模型(重视用户需求，允许各步骤交叉进行)\n\n4.软件开发方法： 结构化方法（面向数据流，自顶向下逐层分解），jackson 方法（面向数据结构），原型化方法（开发一个对用户透明的框架，然后根据用户需求壮大），面向对象开发方法\n\n5.需求分析： 确定软件系统的综合要求，分析软件系统的数据要求，导出系统的逻辑模型，修正项目开发计划，可开发一个原型系统\n\n6.数据域的属性： 数据流，数据内容，数据结构\n\n7.需求工程： 需求开发（需求捕获、需求分析、编写规格说明书、需求验证），需求管理（定义需求基线、处理需求变更、需求跟踪）\n\n8.软件开发项目管理： 成本估算（自顶向下估算方法、自底向上估算方法、差别估算方法），风险分析（风险识别、风险预测、风险评估），进度管理（Gantt 图、PERT 图），人员管理（主程序员组、无主程序员组、层次式程序员组）\n\n**9.软件配置管理的目标：**标识变更，控制变更，确保变更正确地实现，报告有关变更\n\n10.基线： 软件生存期中各开发阶段的一个特定点，相当于断点，便于检查和肯定阶段成果\n\n11.软件开发工具： 需求分析工具，设计工具，编码与排错工具，测试工具\n\n12.软件维护工具： 版本控制工具，文档分析工具，开发信息库工具，逆向工程工具，再工程工具\n\n13.软件管理和软件支持工具： 项目管理工具，配置管理工具，软件评价工具\n\n14.软件过程评估的意义： 改进软件过程，降低软件风险\n\n15.软件能力过程成熟度： 初始级，可重复级，已定义级，已管理级，优化级\n\n**16.统一过程：**起始阶段， 精化阶段，构建阶段，移交阶段，产生阶段\n\n17.敏捷开发： 极限编程（计划游戏、小型发布、隐喻、简单设计、测试先行、重构、结对编程、持续集成），水晶法（不同的项目需要不同的策略、约定和方法论），并列征求法（多个小组并行递增实现产品），自适应软件开发\n\n18.软件质量特性： 功能性，可靠性，易使用性，效率，可维护性，可移植性\n\n19.软件质量保证： 应用技术方法，进行正式的技术评审，测试软件，标准的实施，控制变更，度量，记录保存和报告\n\n20.软件复杂性： 规模，难度，结构，智能度\n\n21.软件质量： 设计质量（设计的规格说明书符合用户的要求），程序质量（程序按照设计规格说明所规定的情况正确执行）\n\n22.设计质量评审内容： 是否合乎用户要求，可靠性，保密措施实现情况，操作特性实施情况，性能实现情况，是否具有可修改性可扩充性、可互换性、可移植性、可测试性、复用性\n\n23.程序质量评审内容： 功能结构，功能的通用性，模块的层次，模块结构，处理过程的结构\n\n24.软件实现容错的主要手段就是冗余\n\n25.冗余： 结构冗余，信息冗余，时间冗余，冗余附加调用\n\n26.系统分析： 对当前系统进行详细调查，收集数据；建立当前系统的逻辑模型；分析现状，提出意见和新目标；建立新系统的逻辑模型；编写系统方案说明书\n\n27.结构化分析方法（自顶向下逐层分解）： 数据流图，数据字典，小说明，补充材料\n\n28.数据流图（DFD：描述系统的分解）： 数据流，加工，数据存储，外部实体\n\n29.DFD 信息流的类型： 变换流（输入、变换、输出），事务流（输入到事务中心、选择执行）\n\n30.数据字典（DD：对图中各成分进行说明）： 数据流条目，数据存储条目，数据项条目，加工条目\n\n31.加工逻辑描述方法： 结构化语言，判定表，判定树\n\n32.系统分析报告作用： 描述目标系统的逻辑模型，作为用户与开发人员之间的协议或合同， 作为目标系统验收和评价的依据\n\n33.系统分析报告内容： 组织情况概述，现行系统概述，系统逻辑模型，新系统在各个业务 处理环节拟采用的管理方法、算法或模型，与新系统相配套的管理制度和运行体制的建立， 系统设计与实施的初步计划，用户领导审批意见\n\n34.系统设计： 概要设计（设计软件系统总体结构、数据结构及数据库设计、编写概要设计 文档、评审），详细设计（分模块进行详细的算法设计、对模块内的数据结构进行设计、对数据库进行物理设计、其他设计、编写详细设计说明书、评审）\n\n35.系统设计基本原理： 抽象，模块化，信息隐蔽，模块独立（耦合：模块之间联系的紧密程度；内聚：模块内部各元素之间联系的紧密程度）\n\n36.系统结构设计原则： 分解-协调，自顶向下，信息隐蔽、抽象，一致性，明确性，模块间耦合尽可能小、内聚尽可能高，模块的扇入、扇出系数要合理，模块的规划适当\n\n37.子系统划分的原则： 要具有相对独立性，之间的数据依赖性要尽可能小，结果应使数据冗余较小，应考虑今后管理发展的需要，应便于系统分阶段实现，应考虑各类资源的利用\n\n38.模块（组成系统的基本单位）四要素： 输入和输出，处理功能，内部数据，程序代码\n\n39.模块结构图： 模块，调用，数据，控制，转接\n\n40.变换分析（从变换流型的 DFD 导出程序结构图）： 确定输入流和输出流、分离出变换中心，第一级分解，第二级分解，事务分析\n\n41.面向数据结构的设计方法（jackson 方法）： 分析确定输入输出数据的逻辑结构，找出输入与输出数据结构有对应关系的数据单元，从描述数据结构的 jackson 图导出描述程序结构的 jackson 图，列出所有操作并分配到程序结构图上，用伪码表示程序\n\n42.Jackson 图： 表达数据元素间的逻辑关系（顺序，选择，重复）或程序结构（顺序，选择，重复）\n\n43.系统详细设计： 代码设计（唯一性、合理性、可扩充性、简单性、适用性、规范性、系统性），输入设计（确定输入数据内容、输入方式设计、输入格式设计、校对方式设计），输出设计（确定输出内容、选择输出设备与介质、确定输出格式），处理过程设计（程序流程图、盒图：NS 图、形式语言、决策树、决策表），用户界面设计（菜单方式、会话管理方式、提示方式与权限管理），安全控制设计（环境性因素、数据处理因素）\n\n44.系统实施的任务： 按总体设计方案购置和安装计算机网络系统，软件准备，培训，数据准备，投入转换和试运行\n\n45.系统实施的步骤： 按总体设计方案购置和安装计算机网络系统，建立数据库系统，程序设计，收集有关数据并进行录入工作和系统测试，人员培训、系统转换和试运行\n\n46.程序设计方法： 结构化方法（模块内部程序各部分要自顶向下地结构化划分、各程序部分应按功能组合、各程序部分的联系尽量使用调用子程序方式而不是 GOTO 方式），原型方法（将带有普遍性的功能模块集中、开发完成通用模块、生成程序模块原型），面向对象的方法（一个简单直接的映射过程）\n\n47.程序模块图\n\n\n\n48.测试： 以最少的人力和时间发现潜在的各种错误和缺陷\n\n49.测试过程： 制定测试计划，编制测试大纲，设计生成测试用例，实施测试，生成测试报告\n\n50.软件测试： 单元测试（模块接口、局部数据结构、重要的执行路径、出错处理、边界条件），集成测试（把模块按系统设计说明书的要求组合起来进行测试），确认测试（有效性测 试、软件配置审查、验收测试），系统测试（恢复测试、安全性测试、压力测试、性能测试、 可靠性及可用性和可维护性测试、安装测试）\n\n51.测试方法： 静态测试（人工检测、计算机辅助静态分析），动态测试（白盒测试：逻辑覆 盖、循环覆盖、基本路径测试；黑盒测试： 等价类划分、边值分析、错误猜测、因果图）\n\n52.调试（改正测试时发现的错误）： 试探法，回溯法，对分查找法，归纳法，演绎法\n\n53.系统文档： 软件开发过程中的文档，硬件采购和网络设计中的文档，系统建设过程中的 各种来往文件、会议纪要、会议单据等，程序资料和培训教程等\n\n54.系统转换（新系统试运行成功后与旧系统相互转换）： 直接转换，并行转换，分段转换\n\n55.系统可维护性的评价指标： 可理解性，可测试性，可修改性\n\n56.系统维护： 硬件维护，软件维护（正确性维护、适应性维护、完善性维护、预防性维护）， 数据维护\n\n57.系统维护的步骤： 提出维护或修改要求，领导审查并做出答复，领导分配任务、维护人 员执行修改，验收维护成果并登记修改信息\n\n58.系统评价： 立项评价，中期评价，结项评价\n\n\n# 七、标准化和软件知识产权基础\n\n1.标准： 对重复性事务和概念所做的统一规定\n\n2.标准化对象： 标准化的具体对象（需要指定标准的具体事务）；标准化的总体对象（各种 具体对象的全体所构成的整体）\n\n3.标准化活动过程： 标准的制定，标准的实施，标准的更新\n\n4.标准的分类： 根据适用范围（国际标准，国家标准，区域标准，行业标准，企业标准，项 目规范）；根据标准的性质（技术标准，管理标准，工作标准）；根据标准化的对象和作用（基 础标准，产品标准，方法标准，安全标准，卫生标准，环境保护标准，服务标准）；根据法 律的约束性（强制性标准，推荐性标准）\n\n5.信息技术标准化： 信息编码标准化（如 ASCII 码）；汉字编码标准化（如 gb2312）；软件 工程标准化(基础标准，开发标准，文档标准，管理标准)\n\n6.权威国际标准化组织： 国际标准化组织（ISO）；国际电工委员会（IEC）\n\n7.知识产权： 人们基于自己的智力活动创造的成果和经营管理活动中的经验、知识而依法享 有的权利\n\n8.知识产权的分类： 工业产权（专利、实用新型、工业品外观设计、商标、服务标记、厂商名称、产地标记、原产品名称、制止不正当竞争等）；著作权（版权）\n\n9.知识产权的特点： 无形性，双重性，确认性，独占性，地域性，时间性\n\n10.计算机软件著作权受保护条件： 独立创作，可被感知，逻辑合理\n\n11.计算机软件著作权的权利： 人身权（发表权，署名权）；著作财产权（使用权，复制权，修改权，发行权，翻译权，注释权，信息网络传播权，出租权，使用许可权，获得报酬权，转让权）\n\n12.软件经济权利的许可使用： 独占许可使用，独家许可使用，普通许可使用，法定许可使用，强制许可使用\n\n13.软件著作权： 谁开发，谁享有\n\n14.计算机软件著作权特点： 技术性，依赖性，多样性，运行性\n\n15.软件著作权侵权的法律责任： 民事责任，行政责任，刑事责任\n\n16.商业秘密： 部位公众所知的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息；包括经营秘密和技术秘密\n\n16.商业秘密的构成条件： 未公开性，实用性，保密性\n\n17.授予专利权的条件： 新颖性，创造性，实用性\n\n18.软件企业应建立的合同规范： 劳动合同关系，软件开发合同，软件许可使用（或转让）合同\n\n\n# 八、软件系统分析与设计\n\n1.软件设计师应用性技术内容： 结构化分析与设计；数据库分析与设计；面向对象分析与设计；算法分析与设计；面向过程的程序设计与实现；面向对象的程序设计与实现\n\n2.结构化分析与设计： 确定系统边界，画出系统环境图；自顶向下，画出各层数据流图；定义数据字典；定义加工说明；将图、字典以及加工组成分析模型\n\n3.数据库分析与设计： 数据库规划；需求描述与分析；数据库与应用程序设计；数据库系统实现；测试阶段；运行维护\n\n4.数据库设计的方法： 用户需求分析（调查机构情况，熟悉业务活动，明确用户需求，确定系统边界，分析系统功能，分析系统数据，编写分析报告）；概念设计（数据建模，E-R 方法）；逻辑设计（数据模式设计：层次模型、网状模型、关系模型）；物理设计（确定数据分布，确定数据的存储结构，确定数据的访问方式）\n\n5.面向对象分析与设计的步骤： 建模系统功能（确定参与者，确定需求用例，构造用例模型，记录需求用例描述）；定义领域模型（定义概念、属性和重要的关联）；定义交互、行为和状态（确定并分类用例设计类，确定类属性、行为和责任）；定义设计类图（会议，用户，会议主题，稿件，审阅意见）\n\n6.算法设计过程： 理解问题；确定相关因素（包括问题的输入与输出、用何种数据结构、用什么样的算法设计策略）；设计算法；证明算法的正确性；分析算法的效率；实现算法7.算法问题类型：查找问题；排序问题；图问题；组合问题（最优化问题）；几何问题（点、线、面、体）\n\n8.面向过程的程序设计与实现的核心： C 语言->指针\n\n9.面向对象的程序设计与实现的核心： 设计模式\n\n\n# 九、多媒体基础知识\n\n1.媒体： 感觉媒体（使人产生感觉的媒体），表示媒体（传输感觉媒体的中介媒体），表现媒体（进行信息输入和输出的媒体），存储媒体（用于存储表示媒体的物理介质），传输媒体（传输表示媒体的物理介质）\n\n2.多媒体的特性： 多样性，集成性，交互性，非线性，实时性，信息使用的方便性，信息结构的动态性\n\n3.虚拟现实： 运用计算机对现实世界进行全面仿真，创建与现实社会类似的环境，通过多种传感设备使用户“投入到该环境中”，实现用户与该环境直接进行自然交互\n\n4.虚拟现实技术的特征： 多感知（听觉感知、力觉感知、触觉感知、运动感知、味觉感知、嗅觉感知），沉浸（用户感受到的模拟环境的真实程度），交互（用户对模拟环境内物体的可操作程度和从环境得到反馈的自然程度）\n\n5.虚拟现实的分类： 桌面虚拟现实，完全沉浸的虚拟现实，增强现实性的虚拟现实，分布式虚拟现实\n\n6.声音感觉的三个指标： 音量，音调，音色\n\n7.声音信号的数字化： 采样，量化，编码\n\n8.数字语音的数据压缩方法： 波形编码，参数编码，混合编码\n\n9.声音合成： 语音合成（发音参数合成、声道模型参数合成、波形编辑合成），音乐合成\n\n10.MIDI（乐器数字接口）： 数字音乐的国际标准\n\n11.色彩三要素： 亮度，色调，色饱和度\n\n12.彩色空间： RGB，CMY，YUV 等\n\n13.图形数据表示形式： 矢量图形（用数学的方式描述图像），位图图像（用像素点来描述的图）\n\n14.图像的属性： 分辨率，图像深度，真彩色和伪彩色\n\n15.图像的数据量： 图像的总像素*图像深度/8\n\n16.数据压缩： 有损压缩（压缩过程中损失一定信息），无损压缩（行程长度编码，增量调制编码，霍夫曼编码）\n\n17.多媒体数据压缩编码标准： JPEG，MPEG，H.261\n\n18.动画（本质是运动）： 实时动画（用各种算法来实现运动物体的运动控制），矢量动画（由矢量图衍生出的动画形式），二维动画（对传统动画的一个改进），三维动画（根据三维数据模型）\n\n19.彩色电视制式： NTSC 制，PAL 制，SECAM 制\n\n20.数字视频标准： 采样频率，分辨率，数据量\n\n21.超文本（将文本中遇到的一些相关内容通过链接组织在一起）三要素： 节点，链，网络\n\n22.超媒体： 用超文本方式组织和处理多媒体信息\n\n23.流媒体： 在网络中使用流式传输技术的连续时基载体。信息经过压缩之后放到专用流服务器上，让浏览者一边下载一边观看或收听\n\n24.多媒体计算机硬件系统： 音频卡，视频卡，光盘驱动器，扫描仪，光学字符阅读器，触摸屏，数字化仪，操纵杆，绘图仪、投影仪和激光视盘播放器\n\n25.多媒体计算机软件系统： 多媒体操作系统，多媒体应用软件的开发工具，多媒体应用软 件",normalizedContent:"# 软件设计师复习大纲\n\n\n# 一、计算机系统基础知识\n\n1.cpu的功能： 程序控制、操作控制、时间控制、数据处理。\n\n2.计算机系统组成示意图：\n\n\n\n3.数据表示： 原码、反码、补码、移码。（0为正，1为负）\n\n4.移码： 如果机器字长为 n，偏移量为 2^n-1，则[x]移=2^n-1+[x]补(x 为纯整数)。[x]移=1+x（x 为纯小数）。\n\n5.ieee754： 符号位（1 位,0 正 1 负）+阶码（8 位,+127）+尾数（23 位,小数点在最高位之 后，随后省略最高位）。\n\n6.浮点数加减： 0 操作数检查，对阶操作(小阶变大阶)，尾数加减(阶码用双符号位，尾数用 单符号位)，结果规格化，舍入处理(判定溢出)。\n\n7.常用校验码： 奇偶校验码（只能检错）、海明码（纠错加检错）、循环冗余校验码（crc）。\n\n8.计算机体系结构分类： 单处理系统，并行处理与多处理系统，分布式处理系统。\n\n9.指令集的发展:cisc（复杂指令集计算机）： 增强原有指令的功能，用更为复杂的新指令取 而代之；risc（精简指令集计算机）：减少指令总数简化指令功能，优化编译降低复杂度。\n\n10.指令控制方式： 顺序方式，重叠方式，流水方式。\n\n11.risc 中的流水线技术： 超流水线技术，超标量技术，超长指令字技术。\n\n12.并发性的解决： 阵列处理机，并行处理机，多处理机。\n\n13.主存与 cache 地址映射方式： 全相联映射-将主存一个块的地址与内容一起存入 cache 中，拷贝灵活但是比较器电路难设计实现；直接映射-一个主存块只能拷贝到 cache 的特定行上 去，硬件简单成本低但是容易冲突效率下降；组相联映射-主存块放到哪个组是固定的，但 是放到哪一行是灵活的，折中办法广泛采用。\n\n14.虚拟存储器： 页式：页表硬件小，查表速度快但不利于存储保护；段式：界限分明便于 程序的模块化设计，易于编译修改和保护，但主存利用率低，产生大量碎片，查表速度慢； 段页式：折中办法，广泛采用，但地址变换速度比较慢。\n\n15.计算机与外设数据交换： 无条件传送，查询方式传送，中断方式传送，直接存储器存取 方式（dma）：cpu 仅在过程开始和结束时有处理，过程中 dma 占用系统总线传送数据。\n\n16.多中断处理办法： 多中断信号线法，中断软件查询法，菊花链法，总线仲裁法，中断向 量表法。\n\n17.总线分类： 内部总线：芯片的互连，系统总线：cpu，内存，接口等的连接；外部总线： 数据交换。\n\n18.信息安全 5 要素： 机密性，完整性，可用性，可控性，可审查性。\n\n19.加密技术： 对称加密（私人密钥加密）：数据加密标准（des）+三重 des+rc-5+国际数 据加密算法（idea）+高级加密标准（aes）；非对称加密（公开密钥加密，比如 rsa 算法）： 加密模型+认证模型。\n\n20.pki： 一种遵循既定标准的密钥管理平台，能够为所有网络应用提供加密和数字签名等密 码服务及所必需的密钥和证书管理体系，必须具有权威认证机构、数字证书库、密钥备份和 恢复系统、证书作废系统、应用接口。\n\n21.计算机可靠性： 可靠性：串联系统 r=r1*r2，并联系统r=1-（1-r1）（1-r2）；平均无故 障时间：串联系统 k=k1+k2，并联系统k=1/k*(1+1/2)。\n\n\n# 二、操作系统知识\n\n1.操作系统的作用： 通过资源管理提高计算机系统的效率；改善人机界面，向用户提供友好的工作环境。\n\n2.操作系统的特征： 并发性、共享性、虚拟性和不确定性\n\n3.操作系统的功能： 处理机管理、文件管理、存储管理、设备管理、作业管理\n\n4.操作系统的类型： 批处理操作系统（单道、多道）、分时操作系统（unix，多路性、独立性、交互性、及时性）、实时操作系统（快速的相应时间、有限的交互能力、高可靠性）、网络操作系统、分布式操作系统、微机操作系统（windows，linux）、嵌入式操作系统\n\n5.程序并发执行的特点： 失去了程序的封闭性，程序和机器的执行程序的活动不再一一对应，并发程序间的相互制约性\n\n**6.进程的组成： ** 程序、数据、进程控制块（pcb）\n\n7.进程的状态： 新建、就绪、运行、阻塞、终止\n\n**8.原语（若干条机器指令组成）的特点： ** 执行时不能被分割，要么都做要么都不做\n\n9.进程的同步： 进程间完成一项任务时直接发生相互作用的关系\n\n10 进程的互斥： 系统中各进程互斥使用临界资源\n\n11.信号量的意义： 若 s>=0 表示某资源的可用数；若 s<0 则其绝对值表示阻塞队列中等待该资源的进程数\n\n12.pv 操作（低级通讯方式）： p 操作申请一个资源，v 操作释放一个资源\n\n13.高级通讯方式： 共享存储模式，消息传递模式，管道通信\n\n14.管城： 由一些共享数据、一组能为并发进程所执行的作用在共享数据上的操作的集合、初始代码以及存取权组成，一种同步机制\n\n15.进程调度（可剥夺+不可剥夺）算法： 先来先服务算法：主要用于宏观调度；时间片轮转：微观调度，分时间片占用 cpu；优先级调度：根据优先级（静态+动态）；多级反馈调度：分多个优先级队列前三中调度的综合，先执行新进程。\n\n16.产生死锁的原因： 竞争资源及进程推进顺序算法\n\n17.产生死锁的四个必要条件： 互斥条件，请求保持条件，不可剥夺条件，环路条件\n\n18.死锁的处理： 预防；避免（银行家算法：先计算，如果分配资源后系统进入不安全状态则不予分配）；检测（系统定时运行死锁检测程序）；解除（资源剥夺法+撤销进程法）\n\n19.安全状态： 系统能按某种顺序来为每个进程分配其所需资源，使每个进程都能顺序完成\n\n20.线程： 是进程中的一个实体，是被系统独立分配和调度的基本单位，基本上不拥有资源\n\n21.存储器管理： 分配和回收主存空间、提高主存利用率、扩充主存、有效保护主存信息\n\n22.存储器的的层次结构： 寄存器、快速缓存（cache）、主存、外存\n\n23.地址重定位： 将逻辑地址转变成物理地址的过程，分静态和动态（程序运行时完成转换）\n\n24.虚拟存储页面置换算法： 最佳置换（以后最久不会被使用），先进先出置换，最近最少未使用，最近未用\n\n25.设备管理的目标： 提高设备的利用率，为用户提供方便统一的界面\n\n26.磁盘调度（使平均寻道时间最少）算法： 先来先服务，最短寻道时间优先，扫描算法，单向扫描调度\n\n27.文件： 具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合\n\n28.文件系统： 操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构\n\n29.存储管理方案示意图\n\n\n\n30.文件系统的安全： 一类涉及到技术、管理、法律、道德和政治等问题；另一类涉及操作系统的安全机制\n\n31.文件系统的可靠性： 转储和恢复，日志文件，文件系统的一致性\n\n32.作业： 系统为完成一个用户的计算任务（或一次事物处理）所做的工作总和\n\n33.作业状态： 提交，后备，执行，完成\n\n34.作业调度算法： 先来先服务，短作业优先，响应比高优先，优先级调度，均衡调度\n\n35.网络操作系统： 集中模式，客户端/服务器模式，对等模式\n\n36.嵌入式操作系统： 微型化，可定制，实时性，可靠性，易移植性\n\n37.shell 变量： 用户定义变量，系统定义变量，shell 定义变量\n\n\n# 三、网络基础知识\n\n1.计算机网络（计算机技术+通信技术）的发展： 具有通信功能的单机系统->具有通信功能的多机系统->以共享资源为目的的计算机网络->以局域网及因特网为支撑环境的分布式计算机系统\n\n2.计算机网络的功能： 数据通信，资源共享，负载均衡，高可靠性\n\n3.计算机网络的分类： 局域网（lan：10m~1000m），城域网（man：10km），广域网（wan：100km 以上）\n\n4.网络拓扑结构： 总线型，星型，环型，树型，分布式（无严格的布线规定和形状，各节点有多条线路相连）\n\n5.osi 七层参考模型： 物理层（物理地传送比特流），数据链路层（负责两相邻节点间无差错传送以帧为单位的数据），网络层（提供端到端的交换网络数据传送功能），传输层（提供可靠的数据传输服务），会话层（提供会话管理服务），表示层（提供格式化的表示和转换数据服务），应用层（提供网络与用户应用软件之间的接口服务）\n\n6.网络互连设备： 中继器（物理层上实现局域网网段互连，用于扩展局域网网段长度），集线器（特殊的多路中继器，有信号方法功能并便于网络维护）；网桥（工作与数据链路层，用于连接两个局域网网段），交换机（按每一个包中的 mac 地址相对简单地决策信息转发）；路由器（网络层异构互连，连接多个逻辑上分开的网络），网关（在两个不同类型协议的网络系统之间进行通信）\n\n7.网络传输介质： 有线介质（双绞线，同轴电缆：直接传输数字信号，光纤：传输光信号、需信号转换）；无线介质（微波：利用无线电波传输，红外线：传输红外光信号，激光：传激光信号，卫星通信：传输电磁波信号）\n\n8.局域网组成部件： 服务器（文件服务器、打印服务器、通信服务器），客户端（用户与网络应用接口设备），网络设备（网卡，收发器，中继器，集中器，网桥，路由器等），通信介质（数据的传输媒体），网络软件（底层协议软件、网络操作系统等）\n\n9.协议： 规定通信时的数据格式、数据传送时序以及相应的控制信息和应答信号等内容\n\n10.网络的标准： 电信标准，国际标准（ieee 标准等），internet 标准（自发标准非政府干预）\n\n11.决定局域网特性的主要技术： 用以传输数据的传输介质，用以连接各种设备的拓扑结构，用以共享资源的介质访问控制方法\n\n12.局域网协议： lan 模型（物理层，数据链路层：逻辑链路控制子层、介质访问控制）；以太网（csma/cd 技术：边发送边接收、时刻侦听信道）；令牌环网（适用于环型网络结构的分布式介质访问控制：广播发送令牌、目标站进行处理）；fddi（类似令牌环网协议、光纤作为传输介质）\n\n13.广域网协议： 点对点协议（ppp：主要用于拨号上网，建立点对点连接发送数据），数字用户线（xdsl：不对称数字用户线 adsl，甚高速数字用户线 vdsl），数字专线（电信数字数据网固定专线，电信铺设），帧中继（在用户网络接口之间提供用户信息流的双向传送，并保持顺序不变），异步传输模式（atm：面向分组的快速分组交换模式，使用异步时分复用技术），x.25 协议（在本地数据终端设备和远程数据终端设备之间提供一个全双工、同步的透明信道）\n\n14.tcp/ip 协议簇特性： 逻辑编址，路由选择，域名解析，错误检测和流量控制\n\n15.tcp/ip 模型\n\n\n\n16.internet 地址格式： 域名格式，ip 地址格式\n\n17.解决 ip 地址短缺问题： 长期（使用 ipv6），短期（使用网络地址翻译技术 nat：在子网内部使用局部地址，外部使用少量的全局地址，通过路由器进行内部地址和外部地址的转换）\n\n18.ipv6： 40 个字节的首部长度，16 个字节的 ip 地址长度\n\n19.服务端口： 公共端口（0~1023）注册登记端口（1024~65535）\n\n20.internet 高层协议： 域名服务（udp 端口，53，通过 dns 服务器将域名变换为 ip 地址）；远程登录服务（tcp 端口，23，将用户计算机与远程主机连接起来）；电子邮件服务（tcp端口，25：smtp and 110：pop3，发送：smtp，接收：smtp+pop3）；www 服务（tcp端口，80，基于客户端/服务器模式的信息发送技术和超文本技术的综合）；文件传输服务（tcp 端口，20：数据连接 and 21：控制连接）\n\n21.网络安全的威胁： 计算机存储着国家、机构、组织的秘密信息或个人的隐私成为某类人攻击的目标；软件规模的膨胀容易使系统存在缺陷；信息传输的安全性存在隐患；网络协议本身的漏洞也会引发安全问题\n\n22.网络安全： 运行系统安全，信息系统的安全，信息传播的安全，信息内容的安全\n\n23.信息系统的需求： 保密性，完整性，可用性，可控性，可核查性\n\n24.网络的安全威胁： 物理威胁，网络攻击，身份鉴别，编程威胁，系统漏洞\n\n25.网络的信息安全： 信息的存储安全（用户的标识与验证，用户存取权限限制，系统安全监控，计算机病毒防治，数据的加密，计算机网络安全）；信息的传输安全（链路加密，节点加密，端到端加密）\n\n26.防火墙： 建立在内外网络边界的过滤封锁机制，防止不良数据包进出被保护的内部网络\n\n27.防火墙的分类： 包过滤型（直接转发报文，对用户透明），应用代理网关型（通过服务器建立连接），状态检测型（建立状态连接表，跟踪检测每一个会话状态）\n\n28.典型防火墙的体系结构： 包过滤路由器（在网络层对进出内部网络所有信息进行分析限 制），双宿主主机（代理服务器软件在双宿主主机上运行，每一个接口连接不同网段），被屏 蔽主机（由过滤路由器和应用网管组成，包过滤+代理服务，内网和外网双重保障），被屏 蔽子网（由两个包过滤路由器和一个应用网关组成，最安全的防火墙系统）\n\n\n# 四、数据库技术基础\n\n1.数据库系统： 数据库，硬件，软件，人员\n\n2.dbms（数据库管理系统）的功能： 数据定义，数据库操作，数据库运行管理，数据组织、存储和管理，数据库的建立和维护，与其他软件系统的通信功能等\n\n3.dbms 的特征： 数据结构化且统一管理，有较高的数据独立性，数据控制功能（数据库的安全性保护、数据的完整性、并发控制、故障恢复）\n\n4.dbms 分类： 关系数据库系统（实体间的联系用关系表示），面向对象的数据库系统（以对象形式对数据建模），对象关系数据库系统（在关系数据模型基础上提供处理新的数据类型操作的能力）\n\n5 数据库系统体系结构： 集中式（数据、数据管理、数据库功能等都集中在一起），分布式（物理上分布+逻辑上分布），c/s 模式（客户端负责数据表示服务、服务器负责数据库服务），并行结构（多个 cpu 物理上连在一起处理）\n\n6.数据库的三级模式： 概念模式（数据库中全部数据的逻辑结构和特征的描述、只涉及型的描述而不涉及具体的值），外模式（用户与数据库系统的接口、用户用到那部分数据的描述），内模式（数据物理结构和存储方式的描述、数据在数据库内部的表示方式）\n\n7.数据库的两级映像： 模式/内模式映像（实现概念模式与内模式的转换），外模式/模式映像（实现外模式与概念模式的转换）\n\n8.数据的独立性： 物理独立性（数据库的内模式改变时数据的逻辑结构不变），逻辑独立性（用户的应用程序与数据库的逻辑结构相互独立）\n\n9.数据模型： 概念数据模型（e-r 模型等），基本数据模型（层次模型：用树型结构表示数据间的联系、网状模型：用网络结构表示数据间的联系、关系模型：用表格结构表示实体间的联系、面向对象模型：对象标识+封装+对象的属性+类和类层次+继承）\n\n10.数据模型三要素： 数据结构，数据操作，数据的约束条件\n\n11.e-r 图： 实体（矩形），联系（菱形），属性（椭圆形）\n\n12.完整性约束： 实体完整性，参照完整性，用户自定义完整性\n\n13.关系代数运算： 并，交，差，笛卡尔积，投影，选择，连接，除\n\n14.sql 语言的特点： 综合统一，高度非过程化，面向集合的操作方式，两种使用方式（自含式、嵌入式），语言简洁易学易用\n\n15.sql 语言的组成： 数据定义语言，交互式数据操纵语言，事务控制，嵌入式 sql 和动态sql，完整性，权限管理\n\n16.sql 数据定义： 创建（create），修改（alter），删除（drop）：表（table），视图（view[as select]），索引（index[on]）\n\n17.sql 数据查询： select...from...where...group by...having...order by...\n\n**18.插入数据： ** insert into...values...\n\n**19.修改数据： ** update...set...=...where...\n\n20.删除数据： delete from...where...\n\n21.授权： grant...on...to...(with grant option)\n\n22.回收权限： revoke...on...from...\n\n23.函数依赖： 反映属性间的联系（x→y）；完全函数依赖：（学生 id，所修课程 id）→成绩；部分函数依赖 ：（学生 id，所修课程 id）→学生姓名；平凡函数依赖：x→y 且 y 包含于 x；非平凡函数依赖：x→y 且 y 不包含于 x；传递函数依赖：x→y，y→z\n\n24.规范化： 1nf： 每个分量都不可再分；2nf：消除非主属性对码的部分函数依赖；3nf：消除非主属性对码的传递函数依赖\n\n25.模式分解标准： 无损连接，保持函数依赖\n\n26.事务的 acid 性质： 原子性，一致性，隔离性，持久性\n\n27.事务管理： 事务开始（begin transaction），事务提交（commit），事务回滚（rollback）\n\n28.数据库故障： 事务内部故障，系统故障，介质故障，计算机病毒\n\n29.数据备份方法： 静态转储和动态转储，海量转储和增量转储，日志文件\n\n30.数据恢复步骤： 反向扫描文件日志，对事物的更新操作执行逆操作，继续反向扫描和更新，直到事务的开始标志\n\n31.并发控制的技术： 封锁（写锁、读锁）\n\n32.数据不一致性： 丢失修改，不可重复读，读脏数据\n\n\n# 五、程序语言基础知识\n\n1.编程语言之间的翻译形式： 汇编，解释，编译。\n\n2.程序设计语言的定义： 语法，语义，语用。\n\n3.程序语言的分类： 命令式程序设计语言：fortran，pascal，c 语言；面向对象的程序设计语言（c++，java，smaltalk）；函数式程序设计语言（lisp）；逻辑型程序设计语言（prolog）。\n\n4.程序语言的基本成分： 数据，运算，控制，传输。\n\n5.汇编语言源程序： 指令语句，伪指令语句，宏指令语句。\n\n6.汇编程序： 将汇编语言所编写的源程序翻译成机器指令程序。\n\n7.编译过程： 源程序---词法分析---语法分析---语义分析---中间代码生成---代码优化---目标代码生成---目标代码。（另全过程有符号表管理和出错处理）\n\n8.解释程序： 分析部分：词法分析、语法分析、语义分析->中间代码；解释部分：解释执行中间代码。\n\n9.编译与解释方式的比较： 前者效率高；后者更具有灵活性和可移植性。\n\n\n# 六、系统开发和运行知识\n\n1.软件工程： 指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件工程的问题。其目的是提高软件生产率，提高软件质量，降低软件成本\n\n2.软件生存周期： 可行性分析与项目开发计划、需求分析、概要设计、详细设计、编码、测试、维护\n\n3.软件生存周期模型： 瀑布模型（按顺序阶段性开发），演化模型（先构造一个初始版本再不断改进），螺旋模型（制定计划、风险分析、实施工程、用户评估），喷泉模型(重视用户需求，允许各步骤交叉进行)\n\n4.软件开发方法： 结构化方法（面向数据流，自顶向下逐层分解），jackson 方法（面向数据结构），原型化方法（开发一个对用户透明的框架，然后根据用户需求壮大），面向对象开发方法\n\n5.需求分析： 确定软件系统的综合要求，分析软件系统的数据要求，导出系统的逻辑模型，修正项目开发计划，可开发一个原型系统\n\n6.数据域的属性： 数据流，数据内容，数据结构\n\n7.需求工程： 需求开发（需求捕获、需求分析、编写规格说明书、需求验证），需求管理（定义需求基线、处理需求变更、需求跟踪）\n\n8.软件开发项目管理： 成本估算（自顶向下估算方法、自底向上估算方法、差别估算方法），风险分析（风险识别、风险预测、风险评估），进度管理（gantt 图、pert 图），人员管理（主程序员组、无主程序员组、层次式程序员组）\n\n**9.软件配置管理的目标：**标识变更，控制变更，确保变更正确地实现，报告有关变更\n\n10.基线： 软件生存期中各开发阶段的一个特定点，相当于断点，便于检查和肯定阶段成果\n\n11.软件开发工具： 需求分析工具，设计工具，编码与排错工具，测试工具\n\n12.软件维护工具： 版本控制工具，文档分析工具，开发信息库工具，逆向工程工具，再工程工具\n\n13.软件管理和软件支持工具： 项目管理工具，配置管理工具，软件评价工具\n\n14.软件过程评估的意义： 改进软件过程，降低软件风险\n\n15.软件能力过程成熟度： 初始级，可重复级，已定义级，已管理级，优化级\n\n**16.统一过程：**起始阶段， 精化阶段，构建阶段，移交阶段，产生阶段\n\n17.敏捷开发： 极限编程（计划游戏、小型发布、隐喻、简单设计、测试先行、重构、结对编程、持续集成），水晶法（不同的项目需要不同的策略、约定和方法论），并列征求法（多个小组并行递增实现产品），自适应软件开发\n\n18.软件质量特性： 功能性，可靠性，易使用性，效率，可维护性，可移植性\n\n19.软件质量保证： 应用技术方法，进行正式的技术评审，测试软件，标准的实施，控制变更，度量，记录保存和报告\n\n20.软件复杂性： 规模，难度，结构，智能度\n\n21.软件质量： 设计质量（设计的规格说明书符合用户的要求），程序质量（程序按照设计规格说明所规定的情况正确执行）\n\n22.设计质量评审内容： 是否合乎用户要求，可靠性，保密措施实现情况，操作特性实施情况，性能实现情况，是否具有可修改性可扩充性、可互换性、可移植性、可测试性、复用性\n\n23.程序质量评审内容： 功能结构，功能的通用性，模块的层次，模块结构，处理过程的结构\n\n24.软件实现容错的主要手段就是冗余\n\n25.冗余： 结构冗余，信息冗余，时间冗余，冗余附加调用\n\n26.系统分析： 对当前系统进行详细调查，收集数据；建立当前系统的逻辑模型；分析现状，提出意见和新目标；建立新系统的逻辑模型；编写系统方案说明书\n\n27.结构化分析方法（自顶向下逐层分解）： 数据流图，数据字典，小说明，补充材料\n\n28.数据流图（dfd：描述系统的分解）： 数据流，加工，数据存储，外部实体\n\n29.dfd 信息流的类型： 变换流（输入、变换、输出），事务流（输入到事务中心、选择执行）\n\n30.数据字典（dd：对图中各成分进行说明）： 数据流条目，数据存储条目，数据项条目，加工条目\n\n31.加工逻辑描述方法： 结构化语言，判定表，判定树\n\n32.系统分析报告作用： 描述目标系统的逻辑模型，作为用户与开发人员之间的协议或合同， 作为目标系统验收和评价的依据\n\n33.系统分析报告内容： 组织情况概述，现行系统概述，系统逻辑模型，新系统在各个业务 处理环节拟采用的管理方法、算法或模型，与新系统相配套的管理制度和运行体制的建立， 系统设计与实施的初步计划，用户领导审批意见\n\n34.系统设计： 概要设计（设计软件系统总体结构、数据结构及数据库设计、编写概要设计 文档、评审），详细设计（分模块进行详细的算法设计、对模块内的数据结构进行设计、对数据库进行物理设计、其他设计、编写详细设计说明书、评审）\n\n35.系统设计基本原理： 抽象，模块化，信息隐蔽，模块独立（耦合：模块之间联系的紧密程度；内聚：模块内部各元素之间联系的紧密程度）\n\n36.系统结构设计原则： 分解-协调，自顶向下，信息隐蔽、抽象，一致性，明确性，模块间耦合尽可能小、内聚尽可能高，模块的扇入、扇出系数要合理，模块的规划适当\n\n37.子系统划分的原则： 要具有相对独立性，之间的数据依赖性要尽可能小，结果应使数据冗余较小，应考虑今后管理发展的需要，应便于系统分阶段实现，应考虑各类资源的利用\n\n38.模块（组成系统的基本单位）四要素： 输入和输出，处理功能，内部数据，程序代码\n\n39.模块结构图： 模块，调用，数据，控制，转接\n\n40.变换分析（从变换流型的 dfd 导出程序结构图）： 确定输入流和输出流、分离出变换中心，第一级分解，第二级分解，事务分析\n\n41.面向数据结构的设计方法（jackson 方法）： 分析确定输入输出数据的逻辑结构，找出输入与输出数据结构有对应关系的数据单元，从描述数据结构的 jackson 图导出描述程序结构的 jackson 图，列出所有操作并分配到程序结构图上，用伪码表示程序\n\n42.jackson 图： 表达数据元素间的逻辑关系（顺序，选择，重复）或程序结构（顺序，选择，重复）\n\n43.系统详细设计： 代码设计（唯一性、合理性、可扩充性、简单性、适用性、规范性、系统性），输入设计（确定输入数据内容、输入方式设计、输入格式设计、校对方式设计），输出设计（确定输出内容、选择输出设备与介质、确定输出格式），处理过程设计（程序流程图、盒图：ns 图、形式语言、决策树、决策表），用户界面设计（菜单方式、会话管理方式、提示方式与权限管理），安全控制设计（环境性因素、数据处理因素）\n\n44.系统实施的任务： 按总体设计方案购置和安装计算机网络系统，软件准备，培训，数据准备，投入转换和试运行\n\n45.系统实施的步骤： 按总体设计方案购置和安装计算机网络系统，建立数据库系统，程序设计，收集有关数据并进行录入工作和系统测试，人员培训、系统转换和试运行\n\n46.程序设计方法： 结构化方法（模块内部程序各部分要自顶向下地结构化划分、各程序部分应按功能组合、各程序部分的联系尽量使用调用子程序方式而不是 goto 方式），原型方法（将带有普遍性的功能模块集中、开发完成通用模块、生成程序模块原型），面向对象的方法（一个简单直接的映射过程）\n\n47.程序模块图\n\n\n\n48.测试： 以最少的人力和时间发现潜在的各种错误和缺陷\n\n49.测试过程： 制定测试计划，编制测试大纲，设计生成测试用例，实施测试，生成测试报告\n\n50.软件测试： 单元测试（模块接口、局部数据结构、重要的执行路径、出错处理、边界条件），集成测试（把模块按系统设计说明书的要求组合起来进行测试），确认测试（有效性测 试、软件配置审查、验收测试），系统测试（恢复测试、安全性测试、压力测试、性能测试、 可靠性及可用性和可维护性测试、安装测试）\n\n51.测试方法： 静态测试（人工检测、计算机辅助静态分析），动态测试（白盒测试：逻辑覆 盖、循环覆盖、基本路径测试；黑盒测试： 等价类划分、边值分析、错误猜测、因果图）\n\n52.调试（改正测试时发现的错误）： 试探法，回溯法，对分查找法，归纳法，演绎法\n\n53.系统文档： 软件开发过程中的文档，硬件采购和网络设计中的文档，系统建设过程中的 各种来往文件、会议纪要、会议单据等，程序资料和培训教程等\n\n54.系统转换（新系统试运行成功后与旧系统相互转换）： 直接转换，并行转换，分段转换\n\n55.系统可维护性的评价指标： 可理解性，可测试性，可修改性\n\n56.系统维护： 硬件维护，软件维护（正确性维护、适应性维护、完善性维护、预防性维护）， 数据维护\n\n57.系统维护的步骤： 提出维护或修改要求，领导审查并做出答复，领导分配任务、维护人 员执行修改，验收维护成果并登记修改信息\n\n58.系统评价： 立项评价，中期评价，结项评价\n\n\n# 七、标准化和软件知识产权基础\n\n1.标准： 对重复性事务和概念所做的统一规定\n\n2.标准化对象： 标准化的具体对象（需要指定标准的具体事务）；标准化的总体对象（各种 具体对象的全体所构成的整体）\n\n3.标准化活动过程： 标准的制定，标准的实施，标准的更新\n\n4.标准的分类： 根据适用范围（国际标准，国家标准，区域标准，行业标准，企业标准，项 目规范）；根据标准的性质（技术标准，管理标准，工作标准）；根据标准化的对象和作用（基 础标准，产品标准，方法标准，安全标准，卫生标准，环境保护标准，服务标准）；根据法 律的约束性（强制性标准，推荐性标准）\n\n5.信息技术标准化： 信息编码标准化（如 ascii 码）；汉字编码标准化（如 gb2312）；软件 工程标准化(基础标准，开发标准，文档标准，管理标准)\n\n6.权威国际标准化组织： 国际标准化组织（iso）；国际电工委员会（iec）\n\n7.知识产权： 人们基于自己的智力活动创造的成果和经营管理活动中的经验、知识而依法享 有的权利\n\n8.知识产权的分类： 工业产权（专利、实用新型、工业品外观设计、商标、服务标记、厂商名称、产地标记、原产品名称、制止不正当竞争等）；著作权（版权）\n\n9.知识产权的特点： 无形性，双重性，确认性，独占性，地域性，时间性\n\n10.计算机软件著作权受保护条件： 独立创作，可被感知，逻辑合理\n\n11.计算机软件著作权的权利： 人身权（发表权，署名权）；著作财产权（使用权，复制权，修改权，发行权，翻译权，注释权，信息网络传播权，出租权，使用许可权，获得报酬权，转让权）\n\n12.软件经济权利的许可使用： 独占许可使用，独家许可使用，普通许可使用，法定许可使用，强制许可使用\n\n13.软件著作权： 谁开发，谁享有\n\n14.计算机软件著作权特点： 技术性，依赖性，多样性，运行性\n\n15.软件著作权侵权的法律责任： 民事责任，行政责任，刑事责任\n\n16.商业秘密： 部位公众所知的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息；包括经营秘密和技术秘密\n\n16.商业秘密的构成条件： 未公开性，实用性，保密性\n\n17.授予专利权的条件： 新颖性，创造性，实用性\n\n18.软件企业应建立的合同规范： 劳动合同关系，软件开发合同，软件许可使用（或转让）合同\n\n\n# 八、软件系统分析与设计\n\n1.软件设计师应用性技术内容： 结构化分析与设计；数据库分析与设计；面向对象分析与设计；算法分析与设计；面向过程的程序设计与实现；面向对象的程序设计与实现\n\n2.结构化分析与设计： 确定系统边界，画出系统环境图；自顶向下，画出各层数据流图；定义数据字典；定义加工说明；将图、字典以及加工组成分析模型\n\n3.数据库分析与设计： 数据库规划；需求描述与分析；数据库与应用程序设计；数据库系统实现；测试阶段；运行维护\n\n4.数据库设计的方法： 用户需求分析（调查机构情况，熟悉业务活动，明确用户需求，确定系统边界，分析系统功能，分析系统数据，编写分析报告）；概念设计（数据建模，e-r 方法）；逻辑设计（数据模式设计：层次模型、网状模型、关系模型）；物理设计（确定数据分布，确定数据的存储结构，确定数据的访问方式）\n\n5.面向对象分析与设计的步骤： 建模系统功能（确定参与者，确定需求用例，构造用例模型，记录需求用例描述）；定义领域模型（定义概念、属性和重要的关联）；定义交互、行为和状态（确定并分类用例设计类，确定类属性、行为和责任）；定义设计类图（会议，用户，会议主题，稿件，审阅意见）\n\n6.算法设计过程： 理解问题；确定相关因素（包括问题的输入与输出、用何种数据结构、用什么样的算法设计策略）；设计算法；证明算法的正确性；分析算法的效率；实现算法7.算法问题类型：查找问题；排序问题；图问题；组合问题（最优化问题）；几何问题（点、线、面、体）\n\n8.面向过程的程序设计与实现的核心： c 语言->指针\n\n9.面向对象的程序设计与实现的核心： 设计模式\n\n\n# 九、多媒体基础知识\n\n1.媒体： 感觉媒体（使人产生感觉的媒体），表示媒体（传输感觉媒体的中介媒体），表现媒体（进行信息输入和输出的媒体），存储媒体（用于存储表示媒体的物理介质），传输媒体（传输表示媒体的物理介质）\n\n2.多媒体的特性： 多样性，集成性，交互性，非线性，实时性，信息使用的方便性，信息结构的动态性\n\n3.虚拟现实： 运用计算机对现实世界进行全面仿真，创建与现实社会类似的环境，通过多种传感设备使用户“投入到该环境中”，实现用户与该环境直接进行自然交互\n\n4.虚拟现实技术的特征： 多感知（听觉感知、力觉感知、触觉感知、运动感知、味觉感知、嗅觉感知），沉浸（用户感受到的模拟环境的真实程度），交互（用户对模拟环境内物体的可操作程度和从环境得到反馈的自然程度）\n\n5.虚拟现实的分类： 桌面虚拟现实，完全沉浸的虚拟现实，增强现实性的虚拟现实，分布式虚拟现实\n\n6.声音感觉的三个指标： 音量，音调，音色\n\n7.声音信号的数字化： 采样，量化，编码\n\n8.数字语音的数据压缩方法： 波形编码，参数编码，混合编码\n\n9.声音合成： 语音合成（发音参数合成、声道模型参数合成、波形编辑合成），音乐合成\n\n10.midi（乐器数字接口）： 数字音乐的国际标准\n\n11.色彩三要素： 亮度，色调，色饱和度\n\n12.彩色空间： rgb，cmy，yuv 等\n\n13.图形数据表示形式： 矢量图形（用数学的方式描述图像），位图图像（用像素点来描述的图）\n\n14.图像的属性： 分辨率，图像深度，真彩色和伪彩色\n\n15.图像的数据量： 图像的总像素*图像深度/8\n\n16.数据压缩： 有损压缩（压缩过程中损失一定信息），无损压缩（行程长度编码，增量调制编码，霍夫曼编码）\n\n17.多媒体数据压缩编码标准： jpeg，mpeg，h.261\n\n18.动画（本质是运动）： 实时动画（用各种算法来实现运动物体的运动控制），矢量动画（由矢量图衍生出的动画形式），二维动画（对传统动画的一个改进），三维动画（根据三维数据模型）\n\n19.彩色电视制式： ntsc 制，pal 制，secam 制\n\n20.数字视频标准： 采样频率，分辨率，数据量\n\n21.超文本（将文本中遇到的一些相关内容通过链接组织在一起）三要素： 节点，链，网络\n\n22.超媒体： 用超文本方式组织和处理多媒体信息\n\n23.流媒体： 在网络中使用流式传输技术的连续时基载体。信息经过压缩之后放到专用流服务器上，让浏览者一边下载一边观看或收听\n\n24.多媒体计算机硬件系统： 音频卡，视频卡，光盘驱动器，扫描仪，光学字符阅读器，触摸屏，数字化仪，操纵杆，绘图仪、投影仪和激光视盘播放器\n\n25.多媒体计算机软件系统： 多媒体操作系统，多媒体应用软件的开发工具，多媒体应用软 件",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"资源",frontmatter:{title:"资源",date:"2020-05-12T15:10:15.000Z",permalink:"/pages/db78e2",article:!1},regularPath:"/03.%E8%B5%84%E6%BA%90/01.%E8%B5%84%E6%BA%90.html",relativePath:"03.资源/01.资源.md",key:"v-6c624ce1",path:"/pages/db78e2/",headers:[{level:2,title:"插件推荐",slug:"插件推荐",normalizedTitle:"插件推荐",charIndex:2},{level:3,title:"更多插件...",slug:"更多插件",normalizedTitle:"更多插件...",charIndex:465},{level:2,title:"社区优秀解决方案",slug:"社区优秀解决方案",normalizedTitle:"社区优秀解决方案",charIndex:521},{level:3,title:"1. 站点信息模块",slug:"_1-站点信息模块",normalizedTitle:"1. 站点信息模块",charIndex:534},{level:3,title:"2. 私密文章功能",slug:"_2-私密文章功能",normalizedTitle:"2. 私密文章功能",charIndex:594},{level:3,title:"3. 首页大图模块",slug:"_3-首页大图模块",normalizedTitle:"3. 首页大图模块",charIndex:645},{level:2,title:"图标&配图",slug:"图标-配图",normalizedTitle:"图标&amp;配图",charIndex:null},{level:3,title:"静态图标",slug:"静态图标",normalizedTitle:"静态图标",charIndex:737},{level:3,title:"萌系图标",slug:"萌系图标",normalizedTitle:"萌系图标",charIndex:792},{level:3,title:"动态图标",slug:"动态图标",normalizedTitle:"动态图标",charIndex:830},{level:3,title:"插画",slug:"插画",normalizedTitle:"插画",charIndex:858},{level:3,title:"配图",slug:"配图",normalizedTitle:"配图",charIndex:683},{level:3,title:"Logo",slug:"logo",normalizedTitle:"logo",charIndex:905},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:931},{level:2,title:"共享资源",slug:"共享资源",normalizedTitle:"共享资源",charIndex:1028}],headersStr:"插件推荐 更多插件... 社区优秀解决方案 1. 站点信息模块 2. 私密文章功能 3. 首页大图模块 图标&配图 静态图标 萌系图标 动态图标 插画 配图 Logo Emoji表情 共享资源",content:'# 插件推荐\n\n * vuepress-plugin-fulltext-search 全文搜索\n\n * vuepress-plugin-thirdparty-search 可以添加第三方搜索链接的搜索框\n\n * vuepress-plugin-one-click-copy 代码块一键复制\n\n * vuepress-plugin-comment 评论区\n\n * vuepress-plugin-vssue 评论区（单页）\n\n * vuepress-plugin-vssue-global 评论区（全局）\n\n * vuepress-plugin-smplayer 播放器\n\n * vuepress-plugin-flowchart 流程图\n\n * vuepress-plugin-mathjax 数学公式\n\n * vuepress-plugin-tabs 选项卡\n\n * vuepress-plugin-element-ui Element UI\n\n * 花里胡哨的插件 鼠标点击特效、背景彩带、音乐播放器等花里胡哨的插件\n\n\n# 更多插件...\n\nAwesome VuePress\n\n在npm中搜索"vuepress–plugin"\n\n\n# 社区优秀解决方案\n\n\n# 1. 站点信息模块\n\n在首页添加站点信息模块，效果：\n\n\n\n在文章页添加文章字数、阅读时间、浏览量，效果：\n\n\n\n\n# 2. 私密文章功能\n\n当大家想要「云端备份」文章到博客时，又不希望别人看到，该功能能满足你。\n\n\n# 3. 首页大图模块\n\n喜欢首页大图模式的朋友可以参考此教程。\n\n\n# 图标&配图\n\n说明：以下图标非主题内置，你可以选择喜欢的图标右键保存或到图标库下载。更多图标：阿里图标库\n\n\n# 静态图标\n\n编程   服务器   机器学习   计算机网络   面向对象   软件开发   数据结构\n\n\n# 萌系图标\n\n * 猫咪系列\n   \n * 数码宝贝\n * 水果系列\n\n\n# 动态图标\n\n猫1   猫2   猫3   猫4\n\n\n# 插画\n\n免费插画\n2D/3D/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# Logo\n\nlogo生成1\nlogo生成2\n\n\n# Emoji表情\n\nEmoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nWindows系统下按Win + .\nMac系统下按Control + Command + 空格\n\n\n# 共享资源\n\n如果您有不错的资源，欢迎在 资源分享区 留言。',normalizedContent:'# 插件推荐\n\n * vuepress-plugin-fulltext-search 全文搜索\n\n * vuepress-plugin-thirdparty-search 可以添加第三方搜索链接的搜索框\n\n * vuepress-plugin-one-click-copy 代码块一键复制\n\n * vuepress-plugin-comment 评论区\n\n * vuepress-plugin-vssue 评论区（单页）\n\n * vuepress-plugin-vssue-global 评论区（全局）\n\n * vuepress-plugin-smplayer 播放器\n\n * vuepress-plugin-flowchart 流程图\n\n * vuepress-plugin-mathjax 数学公式\n\n * vuepress-plugin-tabs 选项卡\n\n * vuepress-plugin-element-ui element ui\n\n * 花里胡哨的插件 鼠标点击特效、背景彩带、音乐播放器等花里胡哨的插件\n\n\n# 更多插件...\n\nawesome vuepress\n\n在npm中搜索"vuepress–plugin"\n\n\n# 社区优秀解决方案\n\n\n# 1. 站点信息模块\n\n在首页添加站点信息模块，效果：\n\n\n\n在文章页添加文章字数、阅读时间、浏览量，效果：\n\n\n\n\n# 2. 私密文章功能\n\n当大家想要「云端备份」文章到博客时，又不希望别人看到，该功能能满足你。\n\n\n# 3. 首页大图模块\n\n喜欢首页大图模式的朋友可以参考此教程。\n\n\n# 图标&配图\n\n说明：以下图标非主题内置，你可以选择喜欢的图标右键保存或到图标库下载。更多图标：阿里图标库\n\n\n# 静态图标\n\n编程   服务器   机器学习   计算机网络   面向对象   软件开发   数据结构\n\n\n# 萌系图标\n\n * 猫咪系列\n   \n * 数码宝贝\n * 水果系列\n\n\n# 动态图标\n\n猫1   猫2   猫3   猫4\n\n\n# 插画\n\n免费插画\n2d/3d/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# logo\n\nlogo生成1\nlogo生成2\n\n\n# emoji表情\n\nemoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nwindows系统下按win + .\nmac系统下按control + command + 空格\n\n\n# 共享资源\n\n如果您有不错的资源，欢迎在 资源分享区 留言。',charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"问答",frontmatter:{title:"问答",date:"2020-05-25T12:01:52.000Z",permalink:"/pages/9cc27d",article:!1},regularPath:"/04.%E9%97%AE%E7%AD%94/01.%E9%97%AE%E7%AD%94.html",relativePath:"04.问答/01.问答.md",key:"v-218f15ef",path:"/pages/9cc27d/",headers:[{level:2,title:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？",slug:"我是一个小白-想使用这个主题搭建博客-知识库-需要做哪些工作",normalizedTitle:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？",charIndex:2},{level:2,title:"clone 项目后需要修改哪些地方？",slug:"clone-项目后需要修改哪些地方",normalizedTitle:"clone 项目后需要修改哪些地方？",charIndex:220},{level:2,title:"可减少项目冗余的地方有哪些？",slug:"可减少项目冗余的地方有哪些",normalizedTitle:"可减少项目冗余的地方有哪些？",charIndex:371},{level:2,title:"我可以不使用永久链接吗？",slug:"我可以不使用永久链接吗",normalizedTitle:"我可以不使用永久链接吗？",charIndex:533},{level:2,title:"是否支持国际化？",slug:"是否支持国际化",normalizedTitle:"是否支持国际化？",charIndex:756},{level:2,title:"打包后在本地预览怎么没有样式？",slug:"打包后在本地预览怎么没有样式",normalizedTitle:"打包后在本地预览怎么没有样式？",charIndex:834},{level:2,title:"在build时出现错误，但是在dev时是正常的",slug:"在build时出现错误-但是在dev时是正常的",normalizedTitle:"在build时出现错误，但是在dev时是正常的",charIndex:974}],headersStr:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？ clone 项目后需要修改哪些地方？ 可减少项目冗余的地方有哪些？ 我可以不使用永久链接吗？ 是否支持国际化？ 打包后在本地预览怎么没有样式？ 在build时出现错误，但是在dev时是正常的",content:"# 我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？\n\n答：使用这个主题前需要你掌握下面这些知识：\n\n * 掌握 markdown、yaml 语法\n * 会使用终端（命令行），会使用 git\n * 会阅读文档、搜索文档\n * 会VuePress的基本使用和默认主题的基本配置\n\n以上知识都掌握之后，再查看本文档。你也可以运行我的主题项目，一边看代码，一边查看文档。主题项目内写了比较多的注释代码，方便你的学习和使用。\n\n\n# clone 项目后需要修改哪些地方？\n\n答：大致的修改流程是这样的：\n\n 1. 首先让项目正常的跑起来\n 2. 根据需求构建和替换 docs/<结构化目录> 的目录及内容\n 3. 根据需求修改 config.js 配置\n 4. 修改 首页配置\n 5. 修改 主题颜色和样式（如果你想修改的话）\n\n\n# 可减少项目冗余的地方有哪些？\n\n答：在完成项目的搭建之后，对于没有使用到的一些文件和代码，可以看情况删减，可删减的地方有:\n\n * 卸载config.js中未使用的插件依赖包\n * 参照 目录结构，删除未使用到的 可选 文件\n * 删除.vusepress目录内未使用到的 可选 文件\n * 删除各文件内的注释代码\n\n\n# 我可以不使用永久链接吗？\n\n答：不可以。当你没有在front matter指定永久链接时，主题会自动生成永久链接到front matter，你可以修改永久链接的值。 使用永久链接是出于以下几点考虑:\n\n 1. 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n 2. 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n 3. 主题中的目录页需要通过永久链接来访问文章。\n\n\n# 是否支持国际化？\n\n答：暂不支持。目前的国际化方案，只能是使用不同项目来处理，比如：一个项目是中文，一个项目是英文，在导航中添加中英文站点的链接。\n\n\n# 打包后在本地预览怎么没有样式？\n\n答：因vuepress打包后的CSS、JS等资源链接采用绝对路径引入，在本地预览时的引入链接是不正确的，部署到服务器即可正常引入和预览。如果你确实需要本地预览，可以使用vuepress-plugin-serve插件，使用方法看相应文档。\n\n\n# 在build时出现错误，但是在dev时是正常的\n\n答：这种情况多半是因为你在created或beforeCreate生命周期调用了浏览器API的原因导致，详情查看：浏览器的 API 访问限制",normalizedContent:"# 我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？\n\n答：使用这个主题前需要你掌握下面这些知识：\n\n * 掌握 markdown、yaml 语法\n * 会使用终端（命令行），会使用 git\n * 会阅读文档、搜索文档\n * 会vuepress的基本使用和默认主题的基本配置\n\n以上知识都掌握之后，再查看本文档。你也可以运行我的主题项目，一边看代码，一边查看文档。主题项目内写了比较多的注释代码，方便你的学习和使用。\n\n\n# clone 项目后需要修改哪些地方？\n\n答：大致的修改流程是这样的：\n\n 1. 首先让项目正常的跑起来\n 2. 根据需求构建和替换 docs/<结构化目录> 的目录及内容\n 3. 根据需求修改 config.js 配置\n 4. 修改 首页配置\n 5. 修改 主题颜色和样式（如果你想修改的话）\n\n\n# 可减少项目冗余的地方有哪些？\n\n答：在完成项目的搭建之后，对于没有使用到的一些文件和代码，可以看情况删减，可删减的地方有:\n\n * 卸载config.js中未使用的插件依赖包\n * 参照 目录结构，删除未使用到的 可选 文件\n * 删除.vusepress目录内未使用到的 可选 文件\n * 删除各文件内的注释代码\n\n\n# 我可以不使用永久链接吗？\n\n答：不可以。当你没有在front matter指定永久链接时，主题会自动生成永久链接到front matter，你可以修改永久链接的值。 使用永久链接是出于以下几点考虑:\n\n 1. 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n 2. 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n 3. 主题中的目录页需要通过永久链接来访问文章。\n\n\n# 是否支持国际化？\n\n答：暂不支持。目前的国际化方案，只能是使用不同项目来处理，比如：一个项目是中文，一个项目是英文，在导航中添加中英文站点的链接。\n\n\n# 打包后在本地预览怎么没有样式？\n\n答：因vuepress打包后的css、js等资源链接采用绝对路径引入，在本地预览时的引入链接是不正确的，部署到服务器即可正常引入和预览。如果你确实需要本地预览，可以使用vuepress-plugin-serve插件，使用方法看相应文档。\n\n\n# 在build时出现错误，但是在dev时是正常的\n\n答：这种情况多半是因为你在created或beforecreate生命周期调用了浏览器api的原因导致，详情查看：浏览器的 api 访问限制",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"支持这个项目",frontmatter:{title:"支持这个项目",date:"2020-05-12T15:09:57.000Z",permalink:"/pages/1b12ed",sidebar:!1,article:!1},regularPath:"/05.%E6%94%AF%E6%8C%81/01.%E6%94%AF%E6%8C%81.html",relativePath:"05.支持/01.支持.md",key:"v-5617b67f",path:"/pages/1b12ed/",headers:[{level:3,title:"用爱发电",slug:"用爱发电",normalizedTitle:"用爱发电",charIndex:2},{level:3,title:"成为赞助商",slug:"成为赞助商",normalizedTitle:"成为赞助商",charIndex:86},{level:2,title:"致谢",slug:"致谢",normalizedTitle:"致谢",charIndex:168}],headersStr:"用爱发电 成为赞助商 致谢",content:"# 用爱发电\n\n微信号 有问题扫码添加   本知识文档开源\n              \n              😶‍🌫️\n\n微信   支付宝\n     \n\n\n# 成为赞助商\n\n成为赞助商，即可将您的品牌LOGO及标语同时展示在：\n\n * GitHub仓库主页顶部\n * 官网首页顶部\n * 官网所有文档页左侧边栏顶部\n\n\n# 致谢\n\n感谢给予支持的朋友，您的支持是我前进的动力 🎉",normalizedContent:"# 用爱发电\n\n微信号 有问题扫码添加   本知识文档开源\n              \n              😶‍🌫️\n\n微信   支付宝\n     \n\n\n# 成为赞助商\n\n成为赞助商，即可将您的品牌logo及标语同时展示在：\n\n * github仓库主页顶部\n * 官网首页顶部\n * 官网所有文档页左侧边栏顶部\n\n\n# 致谢\n\n感谢给予支持的朋友，您的支持是我前进的动力 🎉",charsets:{cjk:!0},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-504fe09d",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/Archivement.png",heroText:"Stabilized",tagline:"软件设计师的复习文档",actionText:"Go ✨",actionLink:"/pages/8d7d6e/",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-0d6c806e",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/19, 22:18:59",lastUpdatedTimestamp:1671459539e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"指南",link:"/pages/f015b6/",items:[{text:"1.文档介绍",link:"/pages/8d7d6e/"},{text:"2.学习路线规划",link:"/pages/f015b6/"},{text:"3.计算机系统与网络",link:"/pages/0ca117/"},{text:"4.数据库",link:"/pages/454a1c/"},{text:"5.程序语言设计",link:"/pages/beda9a/"},{text:"6.面向对象设计",link:"/pages/f5abb7/"},{text:"7.数据结构与算法",link:"/pages/2bb75b/"},{text:"8.知识产权",link:"/pages/9e10e0/"},{text:"9.软件工程",link:"/pages/52aecc/"},{text:"10.UML",link:"/pages/f43aaa/"},{text:"11.数据流图",link:"/pages/fb9639/"},{text:"12.数据库设计",link:"/pages/91b2e7/"},{text:"13.Java设计模式",link:"/pages/55dfda/"}]},{text:"思维导图",link:"/pages/fb6ad7/",items:[{text:"思维导图复习导航",link:"/pages/64d804/"},{text:"计算机结构思维导图",link:"/pages/fb6ad7/"},{text:"复习大纲笔记",link:"/pages/0751c5/"}]},{text:"资源",link:"/pages/db78e2/"},{text:"💖支持",link:"/pages/1b12ed/"}],sidebarDepth:2,logo:"/img/deer.png",repo:"Kryust/exam",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.指南/":[{title:"开篇介绍",collapsable:!1,children:[["01.开篇介绍/01.文档介绍.md","文档系统介绍","/pages/8d7d6e"]]},{title:"学习路线规划",collapsable:!1,children:[["02.学习路线规划/01.学习路线规划.md","软考学习路线规划","/pages/f015b6/"]]},{title:"计算机系统与网络",collapsable:!1,children:[["03.计算机系统与网络/01.计算机组成与体系结构.md","计算机组成与体系结构","/pages/0ca117/"],["03.计算机系统与网络/02.操作系统基本原理.md","操作系统基本原理","/pages/1581f4/"],["03.计算机系统与网络/03.计算机网络.md","计算机网络","/pages/fd02ba/"],["03.计算机系统与网络/04.网络信息安全.md","网络信息安全","/pages/b49e95/"]]},{title:"数据库",collapsable:!1,children:[["04.数据库/01.数据库系统.md","数据库系统","/pages/454a1c/"],["04.数据库/02.MySQL概述.md","MySQL概述","/pages/b3d4fe/"],["04.数据库/03.MySQL安装.md","MySQL安装","/pages/4d8727/"],["04.数据库/04.MySQL的SQL详解.md","MySQL的SQL详解","/pages/972c8f/"],["04.数据库/05.MySQL的函数.md","MySQL的函数","/pages/7bb5a9/"],["04.数据库/06.MySQL的约束.md","MySQL的约束","/pages/c2207f/"],["04.数据库/07.MySQL多表查询.md","MySQL多表查询","/pages/7cdfba/"],["04.数据库/08.MySQL的事务.md","MySQL的事务","/pages/904c55/"],["04.数据库/09.MySQL索引.md","MySQL的存储引擎和索引","/pages/751d08/"]]},{title:"面向对象",collapsable:!1,children:[["05.面向对象/01.Java面向对象(上).md","Java面向对象(上)","/pages/f5abb7/"],["05.面向对象/02.Java面对对象(下).md","Java面对对象(下)","/pages/a5fd33/"],["05.面向对象/03.面向对象设计总结.md","面向对象设计总结","/pages/d7dcc5/"]]},{title:"数据结构",collapsable:!1,children:[["06.数据结构/01.数据结构基本概念.md","数据结构基本概念","/pages/2bb75b/"],["06.数据结构/02.线性表.md","线性表","/pages/a46aa1/"],["06.数据结构/03.堆栈.md","堆栈","/pages/6e4306/"],["06.数据结构/04.队列.md","队列","/pages/3e284b/"],["06.数据结构/05.树的定义.md","树的定义","/pages/925cd5/"],["06.数据结构/06.二叉树的遍历.md","二叉树的遍历","/pages/75c23c/"],["06.数据结构/07.二叉查找树.md","二叉查找树","/pages/a7d8d3/"],["06.数据结构/08.平衡平衡树.md","平衡二叉树","/pages/bf255e/"],["06.数据结构/09.堆.md","堆","/pages/830399/"],["06.数据结构/10.哈夫曼树.md","哈夫曼树","/pages/41b93a/"],["06.数据结构/11.图.md","图","/pages/9640b5/"]]},{title:"知识产权",collapsable:!1,children:[["07.知识产权/01.知识产权标准化.md","知识产权标准化","/pages/9e10e0/"]]},{title:"程序语言设计",collapsable:!1,children:[["08.程序语言设计/01.程序语言设计(上).md","程序语言设计(上)","/pages/beda9a/"],["08.程序语言设计/02.程序语言设计(下).md","程序设计语言(下)","/pages/76f52a/"]]},{title:"软件工程",collapsable:!1,children:[["09.软件工程/01.软件工程基础知识.md","软件工程基础知识","/pages/52aecc/"],["09.软件工程/02.软件工程题目.md","软件工程题目","/pages/4e3563/"]]},{title:"UML",collapsable:!1,children:[["10.UML/01.UML概述.md","UML概述","/pages/f43aaa/"],["10.UML/02.UML详解.md","UML详解","/pages/3cb6ac/"],["10.UML/03.14种UML图.md","14种UML图","/pages/9bf5f0/"]]},{title:"数据流图",collapsable:!1,children:[["11.数据流图/01.数据流图详解.md","数据流图详解","/pages/fb9639/"],["11.数据流图/02.数据流图答题技巧.md","数据流图答题技巧","/pages/70e421/"]]},{title:"数据库设计",collapsable:!1,children:[["12.数据库设计/01.数据库设计.md","数据库设计","/pages/91b2e7/"],["12.数据库设计/03.数据流设计答题技巧.md","数据流设计答题技巧","/pages/1575d1/"]]},{title:"Java设计模式",collapsable:!1,children:[["13.Java设计模式/01.Java设计模式图解.md","Java设计模式笔记","/pages/55dfda/"],["13.Java设计模式/02.Java设计模式下午题目.md","Java设计模式下午题目","/pages/5aa53b/"]]}],catalogue:{},"/02.配置/":[{title:"思维导图",collapsable:!1,children:[["01.思维导图/01.思维导图学习导航.md","思维导图学习导航","/pages/64d804/"]]},{title:"思维导图复习",collapsable:!1,children:[["02.思维导图复习/01.计算机结构思维导图.md","计算机结构思维导图","/pages/fb6ad7/"],["02.思维导图复习/02.程序设计语言思维导图.md","程序设计语言思维导图","/pages/ac51c5/"],["02.思维导图复习/03.知识产权思维导图.md","知识产权思维导图","/pages/57d5f6/"],["02.思维导图复习/04.面向对象思维导图.md","面向对象思维导图","/pages/0c2de5/"],["02.思维导图复习/06.数据结构思维导图.md","数据结构思维导图","/pages/47a2c3/"],["02.思维导图复习/07.排序算法思维导图.md","排序算法思维导图","/pages/99cb22/"]]},{title:"复习笔记",collapsable:!1,children:[["03.复习笔记/01.软件设计师复习大纲.md","软件设计师复习大纲","/pages/0751c5/"]]}],"/03.资源/":[["01.资源.md","资源","/pages/db78e2"]],"/04.问答/":[["01.问答.md","问答","/pages/9cc27d"]],"/05.支持/":[["01.支持.md","支持这个项目","/pages/1b12ed"]]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"ZYH",href:"https://github.com/Kryust"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:2756864799@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Kryust"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:"ZYH"},htmlModules:{pageT:'\n    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>\n    <style>\n      .page-wwads{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n      }\n      .page-wwads .wwads-img img{\n        width:80px!important;\n      }\n      .page-wwads .wwads-poweredby{\n        width: 40px;\n        position: absolute;\n        right: 25px;\n        bottom: 3px;\n      }\n      .wwads-content .wwads-text, .page-wwads .wwads-text{\n        height: 100%;\n        padding-top: 5px;\n        display: block;\n      }\n  </style>\n  '}}};var _l=t(92),xl=t(93),wl=t(11);var El={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(wl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(wl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(wl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(wl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(wl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};$t.component(_l.default),$t.component(xl.default);function kl(n){return n.toString().padStart(2,"0")}t(236);$t.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,368))),$t.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,92))),$t.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,93)));t(237);var Sl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{r||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${kl(n.getUTCMonth()+1)}-${kl(n.getUTCDate())} ${kl(n.getUTCHours())}:${kl(n.getUTCMinutes())}:${kl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(El)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Tl=[];class Il extends class{constructor(){this.store=new $t({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){$t.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Il.prototype,{getPageAsyncComponent:ro,getLayoutAsyncComponent:io,getAsyncComponent:so,getVueComponent:oo});var Ll={install(n){const e=new Il;n.$vuepress=e,n.prototype.$vuepress=e}};function Cl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Al={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return co("pageKey",e),$t.component(e)||$t.component(e,ro(e)),$t.component(e)?n(e):n("")}},Bl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Dl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ml=(t(238),t(239),Object(gl.a)(Dl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),zl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};$t.config.productionTip=!1,$t.use(Fs),$t.use(Ll),$t.mixin(function(n,e,t=$t){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),$t.component("Content",Al),$t.component("ContentSlotsDistributor",Bl),$t.component("OutboundLink",Ml),$t.component("ClientOnly",zl),$t.component("Layout",io("Layout")),$t.component("NotFound",io("NotFound")),$t.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"861f3b4"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Fs({base:e,mode:"history",fallback:!1,routes:vl,scrollBehavior:(n,e,t)=>t||(n.hash?!$t.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Cl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Cl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Cl(n,r)?a(r):Cl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Sl.filter(n=>"function"==typeof n).map(e=>e({Vue:$t,options:a,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new $t(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Tl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);