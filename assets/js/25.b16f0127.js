(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{340:function(t,a,s){"use strict";s.r(a);var n=s(6),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-堆栈的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-堆栈的基本概念"}},[t._v("#")]),t._v(" 1.堆栈的基本概念")]),t._v(" "),a("h3",{attrs:{id:"_1-1-什么是堆栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是堆栈"}},[t._v("#")]),t._v(" 1.1 什么是堆栈")]),t._v(" "),a("p",[t._v("同"),a("a",{attrs:{href:"http://c.biancheng.net/view/3334.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("顺序表"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"http://c.biancheng.net/view/3336.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("链表"),a("OutboundLink")],1),t._v('一样，栈也是用来存储逻辑关系为 "一对一" 数据的'),a("a",{attrs:{href:"http://c.biancheng.net/view/3333.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("线性存储结构"),a("OutboundLink")],1),t._v("，如图 1 所示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/1I0526392-0.gif",alt:"栈存储结构示意图"}})]),t._v(" "),a("p",[t._v('从图 1我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 "存" 和 "取" 的过程有特殊的要求：')]),t._v(" "),a("ol",[a("li",[t._v("栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；")]),t._v(" "),a("li",[t._v("在栈中，无论是存数据还是取数据，都必须遵循"),a("code",[t._v('"先进后出"')]),t._v('的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据"先进后出"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。')]),t._v(" "),a("li",[t._v('因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。')])]),t._v(" "),a("p",[t._v("通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/1I0523601-1.gif",alt:"栈顶和栈底"}})]),t._v(" "),a("h3",{attrs:{id:"_1-2-进栈和出栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-进栈和出栈"}},[t._v("#")]),t._v(" 1.2 进栈和出栈")]),t._v(" "),a("p",[t._v("基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：")]),t._v(" "),a("ul",[a("li",[t._v("向栈中添加元素，此过程被称为"),a("code",[t._v('"进栈"')]),t._v("（入栈或压栈）；")]),t._v(" "),a("li",[t._v("从栈中提取出指定元素，此过程被称为"),a("code",[t._v('"出栈"')]),t._v("（或弹栈）；")])]),t._v(" "),a("h3",{attrs:{id:"_1-3-栈的具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-栈的具体实现"}},[t._v("#")]),t._v(" 1.3 栈的具体实现")]),t._v(" "),a("p",[t._v('栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：')]),t._v(" "),a("ol",[a("li",[t._v("顺序栈：采用"),a("a",{attrs:{href:"http://c.biancheng.net/view/3334.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("顺序存储结构"),a("OutboundLink")],1),t._v("可以模拟栈存储数据的特点，从而实现栈存储结构；")]),t._v(" "),a("li",[t._v("链栈：采用"),a("a",{attrs:{href:"http://c.biancheng.net/view/3336.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("链式存储结构"),a("OutboundLink")],1),t._v("实现栈结构；")])]),t._v(" "),a("p",[t._v("两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，"),a("code",[t._v("顺序栈底层采用的是数组，链栈底层采用的是链表")]),t._v("。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。")]),t._v(" "),a("h3",{attrs:{id:"_1-4-栈堆的操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-栈堆的操作"}},[t._v("#")]),t._v(" 1.4 栈堆的操作")]),t._v(" "),a("p",[t._v("堆栈（Stack）："),a("code",[t._v("具有一定操作约束的线性表")])]),t._v(" "),a("ul",[a("li",[t._v("只在一端（栈顶，Top）做插入、删除")]),t._v(" "),a("li",[t._v("插入数据：入栈（Push）")]),t._v(" "),a("li",[t._v("删除数据：出栈（Pop）")]),t._v(" "),a("li",[t._v("后入先出：Last In First Out（LIFO）")])]),t._v(" "),a("h3",{attrs:{id:"_1-5-堆栈的抽象数据类型描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-堆栈的抽象数据类型描述"}},[t._v("#")]),t._v(" 1.5 堆栈的抽象数据类型描述")]),t._v(" "),a("p",[t._v("类型名称："),a("code",[t._v("堆栈（Stack）")])]),t._v(" "),a("p",[t._v("数据对象集：一个有 0 个或多个元素的有穷线性表")]),t._v(" "),a("p",[t._v("操作集：长度为 MaxSize 的堆栈 S ∈ Stack，堆栈元素 item ∈ ElementType")]),t._v(" "),a("p",[t._v("堆栈的基本操作主要有：")]),t._v(" "),a("ul",[a("li",[t._v("Stack CreateStack(int MaxSize)：生成空堆栈，其最大长度为 MaxSize")]),t._v(" "),a("li",[t._v("int IsFull(Stack S,int MaxSize)：判断堆栈 S 是否已满")]),t._v(" "),a("li",[t._v("void Push(Stack S,ElementType item)：将元素 item 压入堆栈")]),t._v(" "),a("li",[t._v("int IsEmpty(Stack S)：判断堆栈 S 是否为空")]),t._v(" "),a("li",[t._v("ElementType Pop(Stack S)：删除并返回栈顶元素")])]),t._v(" "),a("h2",{attrs:{id:"_2-顺序栈及基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-顺序栈及基本操作"}},[t._v("#")]),t._v(" 2.顺序栈及基本操作")]),t._v(" "),a("h3",{attrs:{id:"_2-1-顺序表存储数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-顺序表存储数据"}},[t._v("#")]),t._v(" 2.1 顺序表存储数据")]),t._v(" "),a("p",[t._v("如果你仔细观察顺序表（底层实现是数组）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。")]),t._v(" "),a("p",[t._v("例如，我们先使用顺序表（a 数组）存储 "),a("code",[t._v("{1,2,3,4}")]),t._v("，存储状态如图 1 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219140834366.png",alt:"image-20221219140834366"}})]),t._v(" "),a("p",[t._v("同样，使用栈存储结构存储 "),a("code",[t._v("{1,2,3,4}")]),t._v("，其存储状态如图 2 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219140844916.png",alt:"image-20221219140844916"}})]),t._v(" "),a("p",[t._v("通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("从数组下标为 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。\n")])])]),a("p",[t._v('了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有"先进后出"的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。')]),t._v(" "),a("p",[t._v('这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是"空栈"。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。')]),t._v(" "),a("h3",{attrs:{id:"_2-2-顺序栈元素-入栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-顺序栈元素-入栈"}},[t._v("#")]),t._v(' 2.2 顺序栈元素"入栈"')]),t._v(" "),a("p",[t._v("比如，还是模拟栈存储 "),a("code",[t._v("{1,2,3,4}")]),t._v(" 的过程。最初，栈是"),a("code",[t._v('"空栈"')]),t._v("，即数组是空的，top 值为初始值 -1，如图 3 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219141031198.png",alt:"image-20221219141031198"}})]),t._v(" "),a("p",[t._v("首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219141047627.png",alt:"image-20221219141047627"}})]),t._v(" "),a("p",[t._v("采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219141103201.png",alt:"image-20221219141103201"}})]),t._v(" "),a("p",[t._v("因此，C 语言实现代码为：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//元素elem进栈，a为数组，top值为当前栈的栈顶位置")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" elem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("elem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_2-3-顺序栈元素-出栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-顺序栈元素-出栈"}},[t._v("#")]),t._v(' 2.3 顺序栈元素"出栈"')]),t._v(" "),a("p",[t._v('其实，top 变量的设置对模拟数据的 "入栈" 操作没有实际的帮助，它是为实现数据的 '),a("code",[t._v('"出栈"')]),t._v(" 操作做准备的。")]),t._v(" "),a("p",[t._v("比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/1I2032W4-5.gif",alt:"数据元素出栈"}})]),t._v(" "),a("blockquote",[a("p",[t._v("注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。")])]),t._v(" "),a("p",[t._v("元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//数据元素出栈")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"空栈"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"弹栈元素：%d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    top"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" top"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v('代码中的 if 语句是为了防止用户做 "栈中已无数据却还要数据出栈" 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。')]),t._v(" "),a("h2",{attrs:{id:"_3-链栈及基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-链栈及基本操作"}},[t._v("#")]),t._v(" 3.链栈及基本操作")]),t._v(" "),a("p",[t._v("链"),a("a",{attrs:{href:"http://c.biancheng.net/view/3349.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("栈"),a("OutboundLink")],1),t._v("，即用"),a("a",{attrs:{href:"http://c.biancheng.net/view/3336.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("链表"),a("OutboundLink")],1),t._v("实现栈存储结构。")]),t._v(" "),a("p",[t._v("链栈的实现思路同顺序栈类似，顺序栈是将数"),a("a",{attrs:{href:"http://c.biancheng.net/view/3334.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("顺序表"),a("OutboundLink")],1),t._v("（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图 1 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219141309747.png",alt:"image-20221219141309747"}})]),t._v(" "),a("p",[t._v('将链表头部作为栈顶的一端，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。')]),t._v(" "),a("p",[t._v("链表的头部作为栈顶，意味着：")]),t._v(" "),a("ul",[a("li",[t._v('在实现数据"入栈"操作时，需要将数据从链表的头部插入；')]),t._v(" "),a("li",[t._v('在实现数据"出栈"操作时，需要删除链表头部的首元节点；')])]),t._v(" "),a("h3",{attrs:{id:"_3-1-链栈元素入栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-链栈元素入栈"}},[t._v("#")]),t._v(" 3.1 链栈元素入栈")]),t._v(" "),a("p",[t._v("例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/1I2551925-1.gif",alt:"链栈元素依次入栈过程示意图"}})]),t._v(" "),a("p",[t._v("C语言实现代码为：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//链表中的节点结构")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("lineStack")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("lineStack")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("lineStack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//stack为当前的链栈，a表示入栈元素")]),t._v("\nlineStack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lineStack "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建存储新元素的节点")]),t._v("\n    lineStack "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" line"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lineStack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lineStack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    line"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//新节点与头节点建立逻辑关系")]),t._v("\n    line"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//更新头指针的指向")]),t._v("\n    stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("line"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_3-2-链栈元素出栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-链栈元素出栈"}},[t._v("#")]),t._v(" 3.2 链栈元素出栈")]),t._v(" "),a("p",[t._v('例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据"先进后出"的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/1I2554T4-2.gif",alt:"链栈元素出栈示意图"}})]),t._v(" "),a("p",[t._v("因此，实现栈顶元素出链栈的 C 语言实现代码为：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//栈顶元素出链栈的实现函数")]),t._v("\nlineStack "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lineStack "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//声明一个新指针指向栈顶节点")]),t._v("\n        lineStack "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//更新头指针")]),t._v("\n        stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"出栈元素：%d "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"新栈顶元素：%d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"栈已空\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"栈内没有元素"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);