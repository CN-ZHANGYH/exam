(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{352:function(_,v,t){"use strict";t.r(v);var a=t(6),i=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"java设计模式笔记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java设计模式笔记"}},[_._v("#")]),_._v(" Java设计模式笔记")]),_._v(" "),v("h2",{attrs:{id:"_1-创建型设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建型设计模式"}},[_._v("#")]),_._v(" 1. 创建型设计模式")]),_._v(" "),v("h3",{attrs:{id:"_1-2-工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-工厂模式"}},[_._v("#")]),_._v(" 1.2 工厂模式")]),_._v(" "),v("p",[v("code",[_._v("工厂模式(Factory Method)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184028693.png",alt:"image-20221219184028693"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v(" 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")]),_._v(" 当一个类希望由它的子类来指定它所创建的对象的时候")]),_._v(" "),v("h3",{attrs:{id:"_1-3-抽象工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-抽象工厂模式"}},[_._v("#")]),_._v(" 1.3 抽象工厂模式")]),_._v(" "),v("p",[v("code",[_._v("抽象工厂模式(Abstract Factory)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184020801.png",alt:"image-20221219184020801"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类")]),_._v(" "),v("li",[_._v("当一个系统应该独立于它的产品创建、构成和表示时")]),_._v(" "),v("li",[_._v("当要强调一系列相关的产品对象的设计以便进行联合使用时")]),_._v(" "),v("li",[_._v("一个系统要由多个产品系列中的一个来配置时")]),_._v(" "),v("li",[_._v("为图形用户界面（GUI）组件定义不同平台的并行类层次结构")])]),_._v(" "),v("h3",{attrs:{id:"_1-4-生成器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-生成器模式"}},[_._v("#")]),_._v(" 1.4 生成器模式")]),_._v(" "),v("p",[v("code",[_._v("生成器模式（建造者模式）(Builder)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184036640.png",alt:"image-20221219184036640"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("   将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时")]),_._v(" "),v("li",[_._v("当构造过程必须允许被构造的对象有不同的表示时")]),_._v(" "),v("li",[_._v("将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示")]),_._v(" "),v("li",[_._v("适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示")])]),_._v(" "),v("h3",{attrs:{id:"_1-5-原型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-原型模式"}},[_._v("#")]),_._v(" 1.5 原型模式")]),_._v(" "),v("p",[v("code",[_._v("原型模式（Prototype）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184044959.png",alt:"image-20221219184044959"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("当一个系统应该独立于它的产品创建、构成和表示时。")]),_._v(" "),v("li",[_._v("一个类的实例只能有几个不同状态组合中的一种")]),_._v(" "),v("li",[_._v("当要实例化的类是在运行时刻指定时，例如，通过动态装载。")]),_._v(" "),v("li",[_._v("为了避免创建一个与产品类层次平行的工厂类层次时。")]),_._v(" "),v("li",[_._v("当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。")])]),_._v(" "),v("h3",{attrs:{id:"_1-6-单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-单例模式"}},[_._v("#")]),_._v(" 1.6 单例模式")]),_._v(" "),v("p",[v("code",[_._v("单例模式（Singleton）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184055250.png",alt:"image-20221219184055250"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  保证一个类仅有一个实例，并提供一个访问它的全局访问点。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景")])]),_._v(" "),v("ol",[v("li",[_._v("它能够保证一个类只产生唯一的一个实例")]),_._v(" "),v("li",[_._v("一个类仅有一个实例")]),_._v(" "),v("li",[_._v("当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。")]),_._v(" "),v("li",[_._v("当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。")])]),_._v(" "),v("h2",{attrs:{id:"_2-结构型设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-结构型设计模式"}},[_._v("#")]),_._v(" 2. 结构型设计模式")]),_._v(" "),v("h3",{attrs:{id:"_2-1-适配器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-适配器模式"}},[_._v("#")]),_._v(" 2.1 适配器模式")]),_._v(" "),v("p",[v("code",[_._v("适配器模式（Adapter）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184111300.png",alt:"image-20221219184111300"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("将一个对象加以包装以给客户提供其希望的另外一个接口")]),_._v(" "),v("li",[_._v("想使用一个已经存在的类，而其接口不符合要美")]),_._v(" "),v("li",[_._v("使所有接口不兼容类可以一起工作")]),_._v(" "),v("li",[_._v("将一个类的接口转换成客户希望的另一个接口")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("想使用一个已经存在的类，而它的接口不符合要求。")]),_._v(" "),v("li",[_._v("创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类)协同工作。")]),_._v(" "),v("li",[_._v("(仅适用于对象Adapter)想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-桥接模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-桥接模式"}},[_._v("#")]),_._v(" 2.2 桥接模式")]),_._v(" "),v("p",[v("code",[_._v("桥接模式(Bridge)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184120118.png",alt:"image-20221219184120118"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v(" 将抽象部分与其实现部分分离，使它们都可以独立地变化。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("类的抽象和其实现之间不希望有一个固定的绑定关系")]),_._v(" "),v("li",[_._v("不希望在抽象和它的实现部分之间有一个固定的绑定关系")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是B为，在程序运行时刻实现部分应可以被选择或者切换。")]),_._v(" "),v("li",[_._v("类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge模式传得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。")]),_._v(" "),v("li",[_._v("对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。")]),_._v(" "),v("li",[_._v("(C++)想对客户完全隐藏抽象的实现部分。")]),_._v(" "),v("li",[_._v("有许多类要生成的类层次结构。")]),_._v(" "),v("li",[_._v("想在多个对象间共享实现（可能使用引用计数)，但同时要求客户并不知道这一点。")])]),_._v(" "),v("h3",{attrs:{id:"_2-3-组合模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-组合模式"}},[_._v("#")]),_._v(" 2.3 组合模式")]),_._v(" "),v("p",[v("code",[_._v("组合模式（Composite）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184129556.png",alt:"image-20221219184129556"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  将对象组合成树型结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("p",[_._v("表示对象的部分-整体层次结构")]),_._v(" "),v("h3",{attrs:{id:"_2-4-装饰器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-装饰器模式"}},[_._v("#")]),_._v(" 2.4 装饰器模式")]),_._v(" "),v("p",[v("code",[_._v("装饰器模式（Decorator）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184158319.png",alt:"image-20221219184158319"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v("  动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更加灵活。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("将一个对象加以包装以提供一些额外的行为")]),_._v(" "),v("li",[_._v("在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责")]),_._v(" "),v("li",[_._v("动态地给一个对象添加一些额外的职责")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。")]),_._v(" "),v("li",[_._v("处理那些可以撤销的职责。")]),_._v(" "),v("li",[_._v("当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。")])]),_._v(" "),v("h3",{attrs:{id:"_2-5-外观模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-外观模式"}},[_._v("#")]),_._v(" 2.5 外观模式")]),_._v(" "),v("p",[v("code",[_._v("外观模式(Facade)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184141073.png",alt:"image-20221219184141073"}})]),_._v(" "),v("p",[_._v("**意图：**为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("将一系列对象加以包装以简化其接口")]),_._v(" "),v("li",[_._v("需要为一个复杂子系统提供一个简单接口")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制,但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。")]),_._v(" "),v("li",[_._v("客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。")]),_._v(" "),v("li",[_._v("当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系。")])]),_._v(" "),v("h3",{attrs:{id:"_2-6-享元模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-享元模式"}},[_._v("#")]),_._v(" 2.6 享元模式")]),_._v(" "),v("p",[v("code",[_._v("享元模式（Flyweight）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184149612.png",alt:"image-20221219184149612"}})]),_._v(" "),v("p",[_._v("**意图：**运用共亨技术有效地支持大量细粒度的对象。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("p",[_._v("因使用大量的对象而造成很大的存储开销时，进行对象共享,以减少对象数量从而达到较少的内存占用并提升性能。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("一个应用程序使用了大量的对象。")]),_._v(" "),v("li",[_._v("完全由于使用大量的对象，造成很大的存储开销。")]),_._v(" "),v("li",[_._v("对象的大多数状态都可变为外部状态。")]),_._v(" "),v("li",[_._v("如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。")])]),_._v(" "),v("h3",{attrs:{id:"_2-7-代理模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-代理模式"}},[_._v("#")]),_._v(" 2.7 代理模式")]),_._v(" "),v("p",[v("code",[_._v("代理模式(Proxy)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219184221415.png",alt:"image-20221219184221415"}})]),_._v(" "),v("p",[_._v("**意图：**为其他对象提供一种代理以控制对这个对象的访问。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("将一个对象加以包装以控制对这个对象的访问")]),_._v(" "),v("li",[_._v("在需要比较通用和复杂的对象指针代替简单的指针时")]),_._v(" "),v("li",[_._v("为其他对象提供一种代理以控制对这个对象的访问")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("Proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候,常见情况有:")]),_._v(" "),v("li",[_._v("远程代理(Remote Proxy)为一个对象在不同地址空间提供局部代表。")]),_._v(" "),v("li",[_._v("虚代理(Virtual Proxy）根据需要创建开销很大的对象。")]),_._v(" "),v("li",[_._v("保护代理(Protection Proxy)控制对原始对象的访问，用于对象应该有不同的访问权限的时候。")]),_._v(" "),v("li",[_._v("智能引用(Smart Reference)取代了简单的指针，它在访问对象时执行一些附加操作。典型用途包括:对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放;当第一次引用一个持久对象时，将它装入内存;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。")])]),_._v(" "),v("h2",{attrs:{id:"_3-行为型设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-行为型设计模式"}},[_._v("#")]),_._v(" 3. 行为型设计模式")]),_._v(" "),v("h3",{attrs:{id:"_3-1-责任链模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-责任链模式"}},[_._v("#")]),_._v(" 3.1 责任链模式")]),_._v(" "),v("p",[v("code",[_._v("责任链模式（Chain of Responsibility）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183750632.png",alt:"image-20221219183750632"}})]),_._v(" "),v("p",[_._v("**意图：**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理")]),_._v(" "),v("li",[_._v("一个客户需要使用一组相关对象")]),_._v(" "),v("li",[_._v("想在不明确指定接收者的情况下向多个对象中的一个提交一个请求")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。")]),_._v(" "),v("li",[_._v("想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。")]),_._v(" "),v("li",[_._v("可处理一个请求的对象集合应被动态指定。")])]),_._v(" "),v("h3",{attrs:{id:"_3-2-命令模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-命令模式"}},[_._v("#")]),_._v(" 3.2 命令模式")]),_._v(" "),v("p",[v("code",[_._v("命令模式（Command）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183804398.png",alt:"image-20221219183804398"}})]),_._v(" "),v("p",[_._v("**意图：**将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("抽象出执行的动作以参数化某对象")]),_._v(" "),v("li",[_._v("将请求封装为对象从而可以使用不同的请求对客户进行参数化")]),_._v(" "),v("li",[_._v("在不同的时刻指定、排列和执行请求")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("抽象出待执行的动作以参数化某对象(。Command模式是过程语言中的回调(Callback机制的一个面向对象的替代品。")]),_._v(" "),v("li",[_._v("在不同的时刻指定、排列和执行请求一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程并在那儿实现该请求。")]),_._v(" "),v("li",[_._v("支持取消操作Command的Execute操作可在实施操作前将状态存储起来，在取消探作时这个状态用来消除该操作的影响。Command接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。")]),_._v(" "),v("li",[_._v("4、支持修改日志这样当系统崩溃时，这些修改可以被重做一遍。在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。")]),_._v(" "),v("li",[_._v("用构建在原语操作上的高层操作构造一个系统)这样一种结构在支持事务(Transaction）的信息系统中很常见。Command模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。")])]),_._v(" "),v("h3",{attrs:{id:"_3-3-解释器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-解释器模式"}},[_._v("#")]),_._v(" 3.3 解释器模式")]),_._v(" "),v("p",[v("code",[_._v("解释器模式（Interpreter）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183933470.png",alt:"image-20221219183933470"}})]),_._v(" "),v("p",[v("strong",[_._v("意图：")]),_._v(" 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("p",[_._v("有一个语言需要解释执行，并且可将句子表示为一个抽象语法树")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("Interpreter模式适用于当有一个语言需要解释执行,并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好:")]),_._v(" "),v("li",[_._v("该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。")]),_._v(" "),v("li",[_._v("效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。")])]),_._v(" "),v("h3",{attrs:{id:"_3-4-迭代器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-迭代器模式"}},[_._v("#")]),_._v(" 3.4 迭代器模式")]),_._v(" "),v("p",[v("code",[_._v("迭代器模式（Iterator）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183947606.png",alt:"image-20221219183947606"}})]),_._v(" "),v("p",[_._v("**意图：**提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("p",[_._v("访问一个聚合对象的内容而无须暴露它的内部表示")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("访问一个聚合对象的内容而无须暴露它的内部表示。")]),_._v(" "),v("li",[_._v("支持对聚合对象的多种遍历。")]),_._v(" "),v("li",[_._v("为遍历不同的聚合结构提供一个统一的接口。")])]),_._v(" "),v("h3",{attrs:{id:"_3-5-中介模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-中介模式"}},[_._v("#")]),_._v(" 3.5 中介模式")]),_._v(" "),v("p",[v("code",[_._v("中介模式（终结者模式）(Mediator)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183919381.png",alt:"image-20221219183919381"}})]),_._v(" "),v("p",[_._v("**意图：**用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("p",[_._v("1、一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象")]),_._v(" "),v("p",[_._v("2、一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。")]),_._v(" "),v("p",[_._v("3、减少多个对象或类之间的通信复杂性")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("p",[_._v("一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。")]),_._v(" "),v("h3",{attrs:{id:"_3-6-备忘录模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-备忘录模式"}},[_._v("#")]),_._v(" 3.6 备忘录模式")]),_._v(" "),v("p",[v("code",[_._v("备忘录模式（Memento）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183912371.png",alt:"image-20221219183912371"}})]),_._v(" "),v("p",[_._v("**意图：**在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("将对象的状态恢复到先前的状态")]),_._v(" "),v("li",[_._v("在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存")]),_._v(" "),v("li",[_._v("必须保存一个对象在某一个时刻的(部分）状态")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。")]),_._v(" "),v("li",[_._v("如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。")])]),_._v(" "),v("h3",{attrs:{id:"_3-7-观察者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-观察者模式"}},[_._v("#")]),_._v(" 3.7 观察者模式")]),_._v(" "),v("p",[v("code",[_._v("观察者模式（Observer）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183905684.png",alt:"image-20221219183905684"}})]),_._v(" "),v("p",[_._v("**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("当一个对象必须通知其它对象，而它又不能假定其它对象是谁时")]),_._v(" "),v("li",[_._v("在发布-订阅(Publish-Subscribe）消息模型中，订阅者订阅一个主题后，当该主题有新消息到达时，所有订阅者都会收到通知")]),_._v(" "),v("li",[_._v("使所要交互的对象尽量松耦合")]),_._v(" "),v("li",[_._v("当一个对象状态改变时所有依赖它的对象得到通知并自动更新")]),_._v(" "),v("li",[_._v("一个对象的改变需要改变其它对象")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。")]),_._v(" "),v("li",[_._v("当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。")]),_._v(" "),v("li",[_._v("当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。")])]),_._v(" "),v("h3",{attrs:{id:"_3-8-状态模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-状态模式"}},[_._v("#")]),_._v(" 3.8 状态模式")]),_._v(" "),v("p",[v("code",[_._v("状态模式（State）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183855372.png",alt:"image-20221219183855372"}})]),_._v(" "),v("p",[_._v("**意图：**允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为")]),_._v(" "),v("li",[_._v("一个对象在其内部状态改变时改变其行为")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。")]),_._v(" "),v("li",[_._v("一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。")])]),_._v(" "),v("h3",{attrs:{id:"_3-9-策略模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-策略模式"}},[_._v("#")]),_._v(" 3.9 策略模式")]),_._v(" "),v("p",[v("code",[_._v("策略模式（Strategy）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183841883.png",alt:"image-20221219183841883"}})]),_._v(" "),v("p",[_._v("**意图：**定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("ol",[v("li",[_._v("需要使用一个算法地不同变体")]),_._v(" "),v("li",[_._v("许多相关的类仅仅是行为有异")]),_._v(" "),v("li",[_._v("在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动")])]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置-个类的方法。")]),_._v(" "),v("li",[_._v("需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。")]),_._v(" "),v("li",[_._v("算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。")]),_._v(" "),v("li",[_._v("一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。")])]),_._v(" "),v("h3",{attrs:{id:"_3-10-访问者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-10-访问者模式"}},[_._v("#")]),_._v(" 3.10 访问者模式")]),_._v(" "),v("p",[v("code",[_._v("访问者模式（Visitor）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183816713.png",alt:"image-20221219183816713"}})]),_._v(" "),v("p",[_._v("**意图：**表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。")]),_._v(" "),v("p",[v("strong",[_._v("题目选项描述")])]),_._v(" "),v("p",[_._v("需要对一个对象结构中的对象进行很多不同的并且不相关的操作")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。")]),_._v(" "),v("li",[_._v("需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。")]),_._v(" "),v("li",[_._v("定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。")])]),_._v(" "),v("h3",{attrs:{id:"_3-11-模板方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-11-模板方法"}},[_._v("#")]),_._v(" 3.11 模板方法")]),_._v(" "),v("p",[v("code",[_._v("模板方法模式（Template Method）")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/Kryust/image/main/img/image-20221219183832803.png",alt:"image-20221219183832803"}})]),_._v(" "),v("p",[_._v("**意图：**定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。")]),_._v(" "),v("p",[v("strong",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。")]),_._v(" "),v("li",[_._v("各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。")]),_._v(" "),v("li",[_._v("控制子类扩展。模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展)，这就只允许在这些点进行扩展。")])])])}),[],!1,null,null,null);v.default=i.exports}}]);